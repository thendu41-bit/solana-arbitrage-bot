import { createJupiterApiClient } from '@jup-ag/api';
import { Connection, Keypair, Transaction, TransactionInstruction, PublicKey } from '@solana/web3.js';
import { Kamino, Obligation, Reserve } from '@kamino-finance/klend-sdk';
import fs from 'fs';

const ENV = 'devnet';
const connection = new Connection(ENV === 'devnet' ? 'https://api.devnet.solana.com' : 'https://api.mainnet-beta.solana.com', 'confirmed');
const keypair = Keypair.fromSecretKey(Uint8Array.from(JSON.parse(fs.readFileSync(process.env.HOME + '/.config/solana/' + (ENV === 'devnet' ? 'new-devnet.json' : 'id.json'), 'utf8'))));
const jupiterApi = createJupiterApiClient();
const kamino = new Kamino(ENV, connection);
let obligation: Obligation;

async function initKamino() {
  try {
    const obligations = await kamino.getObligationsForUser(keypair.publicKey);
    obligation = obligations.length ? obligations[0] : await kamino.createObligation(keypair.publicKey);
    console.log('Kamino obligation ready:', obligation.publicKey.toBase58());
  } catch (error) {
    console.error('Kamino init failed:', error.message, error.stack);
  }
}

const SOL_MINT = new PublicKey('So11111111111111111111111111111111111111112');
const USDC_MINT = new PublicKey('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v');
const INPUT_AMOUNT_LAMPORTS = 5000000n; // 0.005 SOL for ~$3/hour
const MIN_PROFIT_MARGIN = 0.005; // 0.5%

async function checkArbitrageOpportunity() {
  try {
    console.log('Checking arbitrage opportunity...');
    const quote1 = await jupiterApi.quoteGet({ inputMint: SOL_MINT.toBase58(), outputMint: USDC_MINT.toBase58(), amount: Number(INPUT_AMOUNT_LAMPORTS), slippageBps: 50 });
    const quote2 = await jupiterApi.quoteGet({ inputMint: USDC_MINT.toBase58(), outputMint: SOL_MINT.toBase58(), amount: Number(quote1.outAmount), slippageBps: 50 });

    const finalOut = BigInt(quote2.outAmount);
    const profit = finalOut - INPUT_AMOUNT_LAMPORTS;
    const profitPercent = Number(profit) / Number(INPUT_AMOUNT_LAMPORTS);

    console.log(`Cycle Profit: ${profit} lamports (${(profitPercent * 100).toFixed(4)}%)`);

    if (profit > 0n && profitPercent > MIN_PROFIT_MARGIN) {
      console.log('Profitable opp found! Executing...');
      await executeTrade(quote1, quote2);
    } else {
      console.log('No profitable opportunity.');
    }
  } catch (error) {
    console.error('Arbitrage check failed:', error.message, error.stack);
  }
}

async function executeTrade(quote1, quote2) {
  try {
    const amountTokens = Number(INPUT_AMOUNT_LAMPORTS) / 1e9;
    const solReserve = (await kamino.getReserves()).find(r => r.tokenMint.equals(SOL_MINT));
    if (!solReserve) throw new Error('SOL reserve not found');

    const borrowIx = await kamino.buildBorrowInstruction(obligation.publicKey, solReserve.publicKey, amountTokens, keypair.publicKey);
    const repayIx = await kamino.buildRepayInstruction(obligation.publicKey, solReserve.publicKey, amountTokens + 0.0001, keypair.publicKey);

    const swap1 = await jupiterApi.swapInstructionsPost({ quoteResponse: quote1, userPublicKey: keypair.publicKey.toBase58(), wrapAndUnwrapSol: true });
    const swap2 = await jupiterApi.swapInstructionsPost({ quoteResponse: quote2, userPublicKey: keypair.publicKey.toBase58(), wrapAndUnwrapSol: true });

    const ixs = [
      ...borrowIx.instructions,
      ...swap1.computeBudgetInstructions.map(ix => new TransactionInstruction(ix)),
      ...swap1.setupInstructions.map(ix => new TransactionInstruction(ix)),
      new TransactionInstruction(swap1.swapInstruction),
      ...swap1.cleanupInstructions.map(ix => new TransactionInstruction(ix)),
      ...swap2.computeBudgetInstructions.map(ix => new TransactionInstruction(ix)),
      ...swap2.setupInstructions.map(ix => new TransactionInstruction(ix)),
      new TransactionInstruction(swap2.swapInstruction),
      ...swap2.cleanupInstructions.map(ix => new TransactionInstruction(ix)),
      ...repayIx.instructions,
    ];

    const tx = new Transaction();
    tx.add(...ixs);
    tx.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
    tx.feePayer = keypair.publicKey;
    tx.sign(keypair);

    const signature = await connection.sendTransaction(tx, [keypair]);
    console.log('Flash loan arbitrage executed:', signature);
  } catch (error) {
    console.error('Trade execution failed:', error.message, error.stack);
  }
}

async function main() {
  try {
    await initKamino();
    console.log('Main loop started');
    while (true) {
      await checkArbitrageOpportunity();
      await new Promise(resolve => setTimeout(resolve, 5000));
    }
  } catch (error) {
    console.error('Main error:', error);
  }
}

main();

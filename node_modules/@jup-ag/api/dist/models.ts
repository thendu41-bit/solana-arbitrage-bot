/* eslint-disable */
// tslint:disable
/**
 * Jupiter API v6
 * The core of [jup.ag](https://jup.ag). Easily get a quote and swap through Jupiter API.

### Rate Limit
We update our rate limit from time to time depending on the load of our servers. We recommend running your own instance of the API if you want to have high rate limit, here to learn how to run the [self-hosted API](https://station.jup.ag/docs/apis/self-hosted).

### API Wrapper
- Typescript [@jup-ag/api](https://github.com/jup-ag/jupiter-quote-api-node)

### Data types
- Public keys are base58 encoded strings
- raw data such as Vec<u8\> are base64 encoded strings

 *
 * OpenAPI spec version: 6.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator+.
 * https://github.com/karlvr/openapi-generator-plus
 * Do not edit the class manually.
 */

export namespace Api {
	export interface AccountMeta {
		pubkey: string;
		isSigner: boolean;
		isWritable: boolean;
	}

	export interface IndexedRouteMapResponse {
		/**
		 * @description <p>All the mints that are indexed to match in indexedRouteMap</p>
		 * @type {string[]}
		 * @memberof IndexedRouteMapResponse
		 */
		mintKeys: string[];
		/**
		 * @description <p>All the possible route and their corresponding output mints</p>
		 * @type {{ [name: string]: number[] }}
		 * @memberof IndexedRouteMapResponse
		 */
		indexedRouteMap: { [name: string]: number[] };
	}

	export interface Instruction {
		programId: string;
		accounts: Api.AccountMeta[];
		data: string;
	}

	export interface PlatformFee {
		amount?: string;
		/**
		 * @type {number}
		 * @memberof PlatformFee
		 */
		feeBps?: number;
	}

	export interface QuoteResponse {
		inputMint: string;
		inAmount: string;
		outputMint: string;
		outAmount: string;
		otherAmountThreshold: string;
		swapMode: Api.SwapMode;
		/**
		 * @type {number}
		 * @memberof QuoteResponse
		 */
		slippageBps: number;
		/**
		 * @type {number}
		 * @memberof QuoteResponse
		 */
		computedAutoSlippage?: number;
		platformFee?: Api.PlatformFee;
		priceImpactPct: string;
		routePlan: Api.RoutePlanStep[];
		/**
		 * @type {number}
		 * @memberof QuoteResponse
		 */
		contextSlot?: number;
		/**
		 * @type {number}
		 * @memberof QuoteResponse
		 */
		timeTaken?: number;
	}

	export interface RoutePlanStep {
		swapInfo: Api.SwapInfo;
		/**
		 * @type {number}
		 * @memberof RoutePlanStep
		 */
		percent: number;
	}

	export interface SwapInfo {
		ammKey: string;
		label?: string;
		inputMint: string;
		outputMint: string;
		inAmount: string;
		outAmount: string;
		feeAmount: string;
		feeMint: string;
	}

	export interface SwapInstructionsResponse {
		/**
		 * @description <p>If you are using <code>useTokenLedger = true</code>.</p>
		 * @type {Api.Instruction}
		 * @memberof SwapInstructionsResponse
		 */
		tokenLedgerInstruction?: Api.Instruction;
		/**
		 * @description <p>The necessary instructions to setup the compute budget.</p>
		 * @type {Api.Instruction[]}
		 * @memberof SwapInstructionsResponse
		 */
		computeBudgetInstructions: Api.Instruction[];
		/**
		 * @description <p>Setup missing ATA for the users.</p>
		 * @type {Api.Instruction[]}
		 * @memberof SwapInstructionsResponse
		 */
		setupInstructions: Api.Instruction[];
		/**
		 * @description <p>The actual swap instruction.</p>
		 * @type {Api.Instruction}
		 * @memberof SwapInstructionsResponse
		 */
		swapInstruction: Api.Instruction;
		/**
		 * @description <p>Unwrap the SOL if <code>wrapAndUnwrapSol = true</code>.</p>
		 * @type {Api.Instruction}
		 * @memberof SwapInstructionsResponse
		 */
		cleanupInstruction?: Api.Instruction;
		/**
		 * @description <p>The lookup table addresses that you can use if you are using versioned transaction.</p>
		 * @type {string[]}
		 * @memberof SwapInstructionsResponse
		 */
		addressLookupTableAddresses: string[];
	}

	export enum SwapMode {
		ExactIn = 'ExactIn',
		ExactOut = 'ExactOut'
	}

	export enum SwapModeParameterEnum {
		ExactIn = 'ExactIn',
		ExactOut = 'ExactOut'
	}

	export interface SwapRequest {
		/**
		 * @description <p>The user public key.</p>
		 * @type {string}
		 * @memberof SwapRequest
		 */
		userPublicKey: string;
		/**
		 * @description <p>Default is true. If true, will automatically wrap/unwrap SOL. If false, it will use wSOL token account.  Will be ignored if <code>destinationTokenAccount</code> is set because the <code>destinationTokenAccount</code> may belong to a different user that we have no authority to close.</p>
		 * @type {boolean}
		 * @memberof SwapRequest
		 */
		wrapAndUnwrapSol?: boolean;
		/**
		 * @description <p>Default is true. This enables the usage of shared program accountns. That means no intermediate token accounts or open orders accounts need to be created for the users. But it also means that the likelihood of hot accounts is higher.</p>
		 * @type {boolean}
		 * @memberof SwapRequest
		 */
		useSharedAccounts?: boolean;
		/**
		 * @description <p>Fee token account, same as the output token for ExactIn and as the input token for ExactOut, it is derived using the seeds = [&quot;referral_ata&quot;, referral_account, mint] and the <code>REFER4ZgmyYx9c6He5XfaTMiGfdLwRnkV4RPp9t9iF3</code> referral contract (only pass in if you set a feeBps and make sure that the feeAccount has been created).</p>
		 * @type {string}
		 * @memberof SwapRequest
		 */
		feeAccount?: string;
		/**
		 * @description <p>The compute unit price to prioritize the transaction, the additional fee will be <code>computeUnitLimit (1400000) * computeUnitPriceMicroLamports</code>. If <code>auto</code> is used, Jupiter will automatically set a priority fee and it will be capped at 5,000,000 lamports / 0.005 SOL.</p>
		 * @type {number | Api.SwapRequest.ComputeUnitPriceMicroLamports.EnumValueEnum}
		 * @memberof SwapRequest
		 */
		computeUnitPriceMicroLamports?: number | Api.SwapRequest.ComputeUnitPriceMicroLamports.EnumValueEnum;
		/**
		 * @description <p>Prioritization fee lamports paid for the transaction in addition to the signatures fee. Mutually exclusive with compute_unit_price_micro_lamports.</p>
		 * @type {Api.SwapRequest.PrioritizationFeeLamports.ObjectValue | Api.SwapRequest.PrioritizationFeeLamports.ObjectValue2 | Api.SwapRequest.PrioritizationFeeLamports.ObjectValue3 | Api.SwapRequest.PrioritizationFeeLamports.EnumValueEnum | number | Api.SwapRequest.PrioritizationFeeLamports.EnumValueEnum2}
		 * @memberof SwapRequest
		 */
		prioritizationFeeLamports?: Api.SwapRequest.PrioritizationFeeLamports.ObjectValue | Api.SwapRequest.PrioritizationFeeLamports.ObjectValue2 | Api.SwapRequest.PrioritizationFeeLamports.ObjectValue3 | Api.SwapRequest.PrioritizationFeeLamports.EnumValueEnum | number | Api.SwapRequest.PrioritizationFeeLamports.EnumValueEnum2;
		/**
		 * @description <p>Default is false. Request a legacy transaction rather than the default versioned transaction, needs to be paired with a quote using asLegacyTransaction otherwise the transaction might be too large.</p>
		 * @type {boolean}
		 * @memberof SwapRequest
		 */
		asLegacyTransaction?: boolean;
		/**
		 * @description <p>Default is false. This is useful when the instruction before the swap has a transfer that increases the input token amount. Then, the swap will just use the difference between the token ledger token amount and post token amount.</p>
		 * @type {boolean}
		 * @memberof SwapRequest
		 */
		useTokenLedger?: boolean;
		/**
		 * @description <p>Public key of the token account that will be used to receive the token out of the swap. If not provided, the user&#39;s ATA will be used. If provided, we assume that the token account is already initialized.</p>
		 * @type {string}
		 * @memberof SwapRequest
		 */
		destinationTokenAccount?: string;
		/**
		 * @description <p>When enabled, it will do a swap simulation to get the compute unit used and set it in ComputeBudget&#39;s compute unit limit. This will increase latency slightly since there will be one extra RPC call to simulate this. Default is <code>false</code>.</p>
		 * @type {boolean}
		 * @memberof SwapRequest
		 */
		dynamicComputeUnitLimit?: boolean;
		/**
		 * @description <p>When enabled, it will not do any rpc calls check on user&#39;s accounts. Enable it only when you already setup all the accounts needed for the trasaction, like wrapping or unwrapping sol, destination account is already created.</p>
		 * @type {boolean}
		 * @memberof SwapRequest
		 */
		skipUserAccountsRpcCalls?: boolean;
		/**
		 * @description <p>The program authority id [0;7], load balanced across the available set by default</p>
		 * @type {number}
		 * @memberof SwapRequest
		 */
		programAuthorityId?: number;
		/**
		 * @description <p>Default is false. Enabling it would reduce use an optimized way to open WSOL that reduce compute unit.</p>
		 * @type {boolean}
		 * @memberof SwapRequest
		 */
		allowOptimizedWrappedSolTokenAccount?: boolean;
		quoteResponse: Api.QuoteResponse;
	}
	
	/**
	 * @export
	 * @namespace SwapRequest
	 */
	export namespace SwapRequest {
		export type ComputeUnitPriceMicroLamports = number | Api.SwapRequest.ComputeUnitPriceMicroLamports.EnumValueEnum;
		
		/**
		 * @export
		 * @namespace ComputeUnitPriceMicroLamports
		 */
		export namespace ComputeUnitPriceMicroLamports {
			export enum EnumValueEnum {
				Auto = 'auto'
			}
		
		}
	
		export type PrioritizationFeeLamports = Api.SwapRequest.PrioritizationFeeLamports.ObjectValue | Api.SwapRequest.PrioritizationFeeLamports.ObjectValue2 | Api.SwapRequest.PrioritizationFeeLamports.ObjectValue3 | Api.SwapRequest.PrioritizationFeeLamports.EnumValueEnum | number | Api.SwapRequest.PrioritizationFeeLamports.EnumValueEnum2;
		
		/**
		 * @export
		 * @namespace PrioritizationFeeLamports
		 */
		export namespace PrioritizationFeeLamports {
			export interface ObjectValue {
				/**
				 * @description <p>Automatically set priority fee with a multiplier.</p>
				 * @type {number}
				 * @memberof ObjectValue
				 */
				autoMultiplier: number;
			}
		
			export interface ObjectValue2 {
				/**
				 * @description <p>Jito tip in lamports.</p>
				 * @type {number}
				 * @memberof ObjectValue2
				 */
				jitoTipLamports: number;
			}
		
			export interface ObjectValue3 {
				priorityLevelWithMaxLamports: Api.SwapRequest.PrioritizationFeeLamports.ObjectValue3.PriorityLevelWithMaxLamports;
			}
			
			/**
			 * @export
			 * @namespace ObjectValue3
			 */
			export namespace ObjectValue3 {
				export interface PriorityLevelWithMaxLamports {
					/**
					 * @description <p>Priority level for the transaction.</p>
					 * @type {Api.SwapRequest.PrioritizationFeeLamports.ObjectValue3.PriorityLevelWithMaxLamports.PriorityLevelEnum}
					 * @memberof PriorityLevelWithMaxLamports
					 */
					priorityLevel: Api.SwapRequest.PrioritizationFeeLamports.ObjectValue3.PriorityLevelWithMaxLamports.PriorityLevelEnum;
					/**
					 * @description <p>Maximum lamports to be used for prioritization.</p>
					 * @type {number}
					 * @memberof PriorityLevelWithMaxLamports
					 */
					maxLamports: number;
					/**
					 * @description <p>Whether to use global priority.</p>
					 * @type {boolean}
					 * @memberof PriorityLevelWithMaxLamports
					 */
					global?: boolean;
				}
				
				/**
				 * @export
				 * @namespace PriorityLevelWithMaxLamports
				 */
				export namespace PriorityLevelWithMaxLamports {
					/**
					 * <p>Priority level for the transaction.</p>
					 */
					export enum PriorityLevelEnum {
						Low = 'low',
						Medium = 'medium',
						High = 'high',
						VeryHigh = 'veryHigh',
						Max = 'max'
					}
				
				}
			
			}
		
			/**
			 * <p>Automatically set priority fee.</p>
			 */
			export enum EnumValueEnum {
				Auto = 'auto'
			}
		
			/**
			 * <p>Disable prioritization fee.</p>
			 */
			export enum EnumValueEnum2 {
				Disabled = 'disabled'
			}
		
		}
	
	}

	export interface SwapResponse {
		swapTransaction: string;
		/**
		 * @type {number}
		 * @memberof SwapResponse
		 */
		lastValidBlockHeight: number;
		/**
		 * @type {number}
		 * @memberof SwapResponse
		 */
		prioritizationFeeLamports?: number;
	}

}

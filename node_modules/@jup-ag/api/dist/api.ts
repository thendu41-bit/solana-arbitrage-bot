/* eslint-disable */
// tslint:disable
/**
 * Jupiter API v6
 * The core of [jup.ag](https://jup.ag). Easily get a quote and swap through Jupiter API.

### Rate Limit
We update our rate limit from time to time depending on the load of our servers. We recommend running your own instance of the API if you want to have high rate limit, here to learn how to run the [self-hosted API](https://station.jup.ag/docs/apis/self-hosted).

### API Wrapper
- Typescript [@jup-ag/api](https://github.com/jup-ag/jupiter-quote-api-node)

### Data types
- Public keys are base58 encoded strings
- raw data such as Vec<u8\> are base64 encoded strings

 *
 * OpenAPI spec version: 6.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator+.
 * https://github.com/karlvr/openapi-generator-plus
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import { BASE_PATH, COLLECTION_FORMATS, FetchAPI, FetchArgs, BaseAPI, RequiredError, defaultFetch } from "./runtime";
import { Api } from "./models";

export type FactoryFunction<T> = (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) => T;

/**
 * IndexedRouteMapApi - fetch parameter creator
 * @export
 */
export const IndexedRouteMapApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * <p>DEPRECATED, please use /tokens for tradable mints. Returns a hash map, input mint as key and an array of valid output mint as values, token mints are indexed to reduce the file size</p>
		 * @summary GET /indexed-route-map
		 * @param {boolean} [onlyDirectRoutes] <p>Default is false. Direct Routes limits Jupiter routing to single hop routes only.</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 * @deprecated
		 */
		getIndexedRouteMap(onlyDirectRoutes: boolean | undefined, options: RequestInit = {}): FetchArgs {
			let localVarPath = `/indexed-route-map`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			if (onlyDirectRoutes !== undefined) {
				localVarQueryParameter.append('onlyDirectRoutes', String(onlyDirectRoutes));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * IndexedRouteMapApi - functional programming interface
 * @export
 */
export const IndexedRouteMapApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * <p>DEPRECATED, please use /tokens for tradable mints. Returns a hash map, input mint as key and an array of valid output mint as values, token mints are indexed to reduce the file size</p>
		 * @summary GET /indexed-route-map
		 * @param {boolean} [onlyDirectRoutes] <p>Default is false. Direct Routes limits Jupiter routing to single hop routes only.</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 * @deprecated
		 */
		getIndexedRouteMap(onlyDirectRoutes: boolean | undefined, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.IndexedRouteMapResponse> {
			const localVarFetchArgs = IndexedRouteMapApiFetchParamCreator(configuration).getIndexedRouteMap(onlyDirectRoutes, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					throw response;
				});
			};
		},
	}
};

/**
 * IndexedRouteMapApi - factory interface
 * @export
 */
export const IndexedRouteMapApiFactory: FactoryFunction<IndexedRouteMapApi> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new IndexedRouteMapApi(configuration, basePath, fetch);
};

/**
 * IndexedRouteMapApi - object-oriented interface
 * @export
 * @class IndexedRouteMapApi
 * @extends {BaseAPI}
 */
export class IndexedRouteMapApi extends BaseAPI {
	/**
	 * <p>DEPRECATED, please use /tokens for tradable mints. Returns a hash map, input mint as key and an array of valid output mint as values, token mints are indexed to reduce the file size</p>
	 * @summary GET /indexed-route-map
	 * @param {boolean} [onlyDirectRoutes] <p>Default is false. Direct Routes limits Jupiter routing to single hop routes only.</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 * @deprecated
	 */
	public getIndexedRouteMap(onlyDirectRoutes: boolean | undefined, options?: RequestInit) {
		return IndexedRouteMapApiFp(this.configuration).getIndexedRouteMap(onlyDirectRoutes, options)(this.fetch, this.basePath);
	}

}
/**
 * ProgramIdToLabelApi - fetch parameter creator
 * @export
 */
export const ProgramIdToLabelApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * <p>Returns a hash, which key is the program id and value is the label. This is used to help map error from transaction by identifying the fault program id. With that, we can use the <code>excludeDexes</code> or <code>dexes</code> parameter.</p>
		 * @summary GET /program-id-to-label
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getProgramIdToLabel(options: RequestInit = {}): FetchArgs {
			let localVarPath = `/program-id-to-label`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * ProgramIdToLabelApi - functional programming interface
 * @export
 */
export const ProgramIdToLabelApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * <p>Returns a hash, which key is the program id and value is the label. This is used to help map error from transaction by identifying the fault program id. With that, we can use the <code>excludeDexes</code> or <code>dexes</code> parameter.</p>
		 * @summary GET /program-id-to-label
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getProgramIdToLabel(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<{ [name: string]: string }> {
			const localVarFetchArgs = ProgramIdToLabelApiFetchParamCreator(configuration).getProgramIdToLabel(options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					throw response;
				});
			};
		},
	}
};

/**
 * ProgramIdToLabelApi - factory interface
 * @export
 */
export const ProgramIdToLabelApiFactory: FactoryFunction<ProgramIdToLabelApi> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new ProgramIdToLabelApi(configuration, basePath, fetch);
};

/**
 * ProgramIdToLabelApi - object-oriented interface
 * @export
 * @class ProgramIdToLabelApi
 * @extends {BaseAPI}
 */
export class ProgramIdToLabelApi extends BaseAPI {
	/**
	 * <p>Returns a hash, which key is the program id and value is the label. This is used to help map error from transaction by identifying the fault program id. With that, we can use the <code>excludeDexes</code> or <code>dexes</code> parameter.</p>
	 * @summary GET /program-id-to-label
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getProgramIdToLabel(options?: RequestInit) {
		return ProgramIdToLabelApiFp(this.configuration).getProgramIdToLabel(options)(this.fetch, this.basePath);
	}

}
/**
 * QuoteApi - fetch parameter creator
 * @export
 */
export const QuoteApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * <p>Sends a GET request to the Jupiter API to get the best priced quote.</p>
		 * @summary GET /quote
		 * @param {string} inputMint <p>Input token mint address</p>
		 * @param {string} outputMint <p>Output token mint address</p>
		 * @param {number} amount <p>The amount to swap, have to factor in the token decimals.</p>
		 * @param {number} [slippageBps] <p>The slippage in basis points, 1 basis point is 0.01%. If the output token amount exceeds the slippage then the swap transaction will fail.</p>
		 * @param {boolean} [autoSlippage] <p>Automatically calculate the slippage based on pairs.</p>
		 * @param {number} [autoSlippageCollisionUsdValue] <p>Automatic slippage collision value.</p>
		 * @param {boolean} [computeAutoSlippage] <p>Compute auto slippage value without using it.</p>
		 * @param {number} [maxAutoSlippageBps] <p>Max slippage in basis points for auto slippage calculation. Default is 400.</p>
		 * @param {Api.SwapModeParameterEnum} [swapMode] <p>(ExactIn or ExactOut) Defaults to ExactIn. ExactOut is for supporting use cases where you need an exact token amount, like payments. In this case the slippage is on the input token.</p>
		 * @param {string[]} [dexes] <p>Default is that all DEXes are included. You can pass in the DEXes that you want to include only and separate them by <code>,</code>. You can check out the full list <a href="https://quote-api.jup.ag/v6/program-id-to-label">here</a>.</p>
		 * @param {string[]} [excludeDexes] <p>Default is that all DEXes are included. You can pass in the DEXes that you want to exclude and separate them by <code>,</code>. You can check out the full list <a href="https://quote-api.jup.ag/v6/program-id-to-label">here</a>.</p>
		 * @param {boolean} [restrictIntermediateTokens] <p>Restrict intermediate tokens to a top token set that has stable liquidity. This will help to ease potential high slippage error rate when swapping with minimal impact on pricing.</p>
		 * @param {boolean} [onlyDirectRoutes] <p>Default is false. Direct Routes limits Jupiter routing to single hop routes only.</p>
		 * @param {boolean} [asLegacyTransaction] <p>Default is false. Instead of using versioned transaction, this will use the legacy transaction.</p>
		 * @param {number} [platformFeeBps] <p>If you want to charge the user a fee, you can specify the fee in BPS. Fee % is taken out of the output token.</p>
		 * @param {number} [maxAccounts] <p>Rough estimate of the max accounts to be used for the quote, so that you can compose with your own accounts</p>
		 * @param {boolean} [minimizeSlippage] <p>Default is false. Miminize slippage attempts to find routes with lower slippage.</p>
		 * @param {boolean} [preferLiquidDexes] <p>Default is false. Enabling it would only consider markets with high liquidity to reduce slippage.</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getQuote(inputMint: string, outputMint: string, amount: number, slippageBps: number | undefined, autoSlippage: boolean | undefined, autoSlippageCollisionUsdValue: number | undefined, computeAutoSlippage: boolean | undefined, maxAutoSlippageBps: number | undefined, swapMode: Api.SwapModeParameterEnum | undefined, dexes: string[] | undefined, excludeDexes: string[] | undefined, restrictIntermediateTokens: boolean | undefined, onlyDirectRoutes: boolean | undefined, asLegacyTransaction: boolean | undefined, platformFeeBps: number | undefined, maxAccounts: number | undefined, minimizeSlippage: boolean | undefined, preferLiquidDexes: boolean | undefined, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'inputMint' is not null or undefined
			if (inputMint === null || inputMint === undefined) {
				throw new RequiredError('inputMint', 'Required parameter inputMint was null or undefined when calling getQuote.');
			}
			// verify required parameter 'outputMint' is not null or undefined
			if (outputMint === null || outputMint === undefined) {
				throw new RequiredError('outputMint', 'Required parameter outputMint was null or undefined when calling getQuote.');
			}
			// verify required parameter 'amount' is not null or undefined
			if (amount === null || amount === undefined) {
				throw new RequiredError('amount', 'Required parameter amount was null or undefined when calling getQuote.');
			}
			let localVarPath = `/quote`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			if (inputMint !== undefined) {
				localVarQueryParameter.append('inputMint', String(inputMint));
			}

			if (outputMint !== undefined) {
				localVarQueryParameter.append('outputMint', String(outputMint));
			}

			if (amount !== undefined) {
				localVarQueryParameter.append('amount', String(amount));
			}

			if (slippageBps !== undefined) {
				localVarQueryParameter.append('slippageBps', String(slippageBps));
			}

			if (autoSlippage !== undefined) {
				localVarQueryParameter.append('autoSlippage', String(autoSlippage));
			}

			if (autoSlippageCollisionUsdValue !== undefined) {
				localVarQueryParameter.append('autoSlippageCollisionUsdValue', String(autoSlippageCollisionUsdValue));
			}

			if (computeAutoSlippage !== undefined) {
				localVarQueryParameter.append('computeAutoSlippage', String(computeAutoSlippage));
			}

			if (maxAutoSlippageBps !== undefined) {
				localVarQueryParameter.append('maxAutoSlippageBps', String(maxAutoSlippageBps));
			}

			if (swapMode !== undefined) {
				localVarQueryParameter.append('swapMode', String(swapMode));
			}

			if (dexes !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of dexes) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('dexes', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (excludeDexes !== undefined) {
				/* array form exploded */
				for (const localVarArrayElement of excludeDexes) {
					if (localVarArrayElement !== undefined) {
						localVarQueryParameter.append('excludeDexes', localVarArrayElement !== null ? String(localVarArrayElement) : '');
					}
				}
			}

			if (restrictIntermediateTokens !== undefined) {
				localVarQueryParameter.append('restrictIntermediateTokens', String(restrictIntermediateTokens));
			}

			if (onlyDirectRoutes !== undefined) {
				localVarQueryParameter.append('onlyDirectRoutes', String(onlyDirectRoutes));
			}

			if (asLegacyTransaction !== undefined) {
				localVarQueryParameter.append('asLegacyTransaction', String(asLegacyTransaction));
			}

			if (platformFeeBps !== undefined) {
				localVarQueryParameter.append('platformFeeBps', String(platformFeeBps));
			}

			if (maxAccounts !== undefined) {
				localVarQueryParameter.append('maxAccounts', String(maxAccounts));
			}

			if (minimizeSlippage !== undefined) {
				localVarQueryParameter.append('minimizeSlippage', String(minimizeSlippage));
			}

			if (preferLiquidDexes !== undefined) {
				localVarQueryParameter.append('preferLiquidDexes', String(preferLiquidDexes));
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * QuoteApi - functional programming interface
 * @export
 */
export const QuoteApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * <p>Sends a GET request to the Jupiter API to get the best priced quote.</p>
		 * @summary GET /quote
		 * @param {string} inputMint <p>Input token mint address</p>
		 * @param {string} outputMint <p>Output token mint address</p>
		 * @param {number} amount <p>The amount to swap, have to factor in the token decimals.</p>
		 * @param {number} [slippageBps] <p>The slippage in basis points, 1 basis point is 0.01%. If the output token amount exceeds the slippage then the swap transaction will fail.</p>
		 * @param {boolean} [autoSlippage] <p>Automatically calculate the slippage based on pairs.</p>
		 * @param {number} [autoSlippageCollisionUsdValue] <p>Automatic slippage collision value.</p>
		 * @param {boolean} [computeAutoSlippage] <p>Compute auto slippage value without using it.</p>
		 * @param {number} [maxAutoSlippageBps] <p>Max slippage in basis points for auto slippage calculation. Default is 400.</p>
		 * @param {Api.SwapModeParameterEnum} [swapMode] <p>(ExactIn or ExactOut) Defaults to ExactIn. ExactOut is for supporting use cases where you need an exact token amount, like payments. In this case the slippage is on the input token.</p>
		 * @param {string[]} [dexes] <p>Default is that all DEXes are included. You can pass in the DEXes that you want to include only and separate them by <code>,</code>. You can check out the full list <a href="https://quote-api.jup.ag/v6/program-id-to-label">here</a>.</p>
		 * @param {string[]} [excludeDexes] <p>Default is that all DEXes are included. You can pass in the DEXes that you want to exclude and separate them by <code>,</code>. You can check out the full list <a href="https://quote-api.jup.ag/v6/program-id-to-label">here</a>.</p>
		 * @param {boolean} [restrictIntermediateTokens] <p>Restrict intermediate tokens to a top token set that has stable liquidity. This will help to ease potential high slippage error rate when swapping with minimal impact on pricing.</p>
		 * @param {boolean} [onlyDirectRoutes] <p>Default is false. Direct Routes limits Jupiter routing to single hop routes only.</p>
		 * @param {boolean} [asLegacyTransaction] <p>Default is false. Instead of using versioned transaction, this will use the legacy transaction.</p>
		 * @param {number} [platformFeeBps] <p>If you want to charge the user a fee, you can specify the fee in BPS. Fee % is taken out of the output token.</p>
		 * @param {number} [maxAccounts] <p>Rough estimate of the max accounts to be used for the quote, so that you can compose with your own accounts</p>
		 * @param {boolean} [minimizeSlippage] <p>Default is false. Miminize slippage attempts to find routes with lower slippage.</p>
		 * @param {boolean} [preferLiquidDexes] <p>Default is false. Enabling it would only consider markets with high liquidity to reduce slippage.</p>
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getQuote(inputMint: string, outputMint: string, amount: number, slippageBps: number | undefined, autoSlippage: boolean | undefined, autoSlippageCollisionUsdValue: number | undefined, computeAutoSlippage: boolean | undefined, maxAutoSlippageBps: number | undefined, swapMode: Api.SwapModeParameterEnum | undefined, dexes: string[] | undefined, excludeDexes: string[] | undefined, restrictIntermediateTokens: boolean | undefined, onlyDirectRoutes: boolean | undefined, asLegacyTransaction: boolean | undefined, platformFeeBps: number | undefined, maxAccounts: number | undefined, minimizeSlippage: boolean | undefined, preferLiquidDexes: boolean | undefined, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.QuoteResponse> {
			const localVarFetchArgs = QuoteApiFetchParamCreator(configuration).getQuote(inputMint, outputMint, amount, slippageBps, autoSlippage, autoSlippageCollisionUsdValue, computeAutoSlippage, maxAutoSlippageBps, swapMode, dexes, excludeDexes, restrictIntermediateTokens, onlyDirectRoutes, asLegacyTransaction, platformFeeBps, maxAccounts, minimizeSlippage, preferLiquidDexes, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					throw response;
				});
			};
		},
	}
};

/**
 * QuoteApi - factory interface
 * @export
 */
export const QuoteApiFactory: FactoryFunction<QuoteApi> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new QuoteApi(configuration, basePath, fetch);
};

/**
 * QuoteApi - object-oriented interface
 * @export
 * @class QuoteApi
 * @extends {BaseAPI}
 */
export class QuoteApi extends BaseAPI {
	/**
	 * <p>Sends a GET request to the Jupiter API to get the best priced quote.</p>
	 * @summary GET /quote
	 * @param {string} inputMint <p>Input token mint address</p>
	 * @param {string} outputMint <p>Output token mint address</p>
	 * @param {number} amount <p>The amount to swap, have to factor in the token decimals.</p>
	 * @param {number} [slippageBps] <p>The slippage in basis points, 1 basis point is 0.01%. If the output token amount exceeds the slippage then the swap transaction will fail.</p>
	 * @param {boolean} [autoSlippage] <p>Automatically calculate the slippage based on pairs.</p>
	 * @param {number} [autoSlippageCollisionUsdValue] <p>Automatic slippage collision value.</p>
	 * @param {boolean} [computeAutoSlippage] <p>Compute auto slippage value without using it.</p>
	 * @param {number} [maxAutoSlippageBps] <p>Max slippage in basis points for auto slippage calculation. Default is 400.</p>
	 * @param {Api.SwapModeParameterEnum} [swapMode] <p>(ExactIn or ExactOut) Defaults to ExactIn. ExactOut is for supporting use cases where you need an exact token amount, like payments. In this case the slippage is on the input token.</p>
	 * @param {string[]} [dexes] <p>Default is that all DEXes are included. You can pass in the DEXes that you want to include only and separate them by <code>,</code>. You can check out the full list <a href="https://quote-api.jup.ag/v6/program-id-to-label">here</a>.</p>
	 * @param {string[]} [excludeDexes] <p>Default is that all DEXes are included. You can pass in the DEXes that you want to exclude and separate them by <code>,</code>. You can check out the full list <a href="https://quote-api.jup.ag/v6/program-id-to-label">here</a>.</p>
	 * @param {boolean} [restrictIntermediateTokens] <p>Restrict intermediate tokens to a top token set that has stable liquidity. This will help to ease potential high slippage error rate when swapping with minimal impact on pricing.</p>
	 * @param {boolean} [onlyDirectRoutes] <p>Default is false. Direct Routes limits Jupiter routing to single hop routes only.</p>
	 * @param {boolean} [asLegacyTransaction] <p>Default is false. Instead of using versioned transaction, this will use the legacy transaction.</p>
	 * @param {number} [platformFeeBps] <p>If you want to charge the user a fee, you can specify the fee in BPS. Fee % is taken out of the output token.</p>
	 * @param {number} [maxAccounts] <p>Rough estimate of the max accounts to be used for the quote, so that you can compose with your own accounts</p>
	 * @param {boolean} [minimizeSlippage] <p>Default is false. Miminize slippage attempts to find routes with lower slippage.</p>
	 * @param {boolean} [preferLiquidDexes] <p>Default is false. Enabling it would only consider markets with high liquidity to reduce slippage.</p>
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getQuote(inputMint: string, outputMint: string, amount: number, slippageBps: number | undefined, autoSlippage: boolean | undefined, autoSlippageCollisionUsdValue: number | undefined, computeAutoSlippage: boolean | undefined, maxAutoSlippageBps: number | undefined, swapMode: Api.SwapModeParameterEnum | undefined, dexes: string[] | undefined, excludeDexes: string[] | undefined, restrictIntermediateTokens: boolean | undefined, onlyDirectRoutes: boolean | undefined, asLegacyTransaction: boolean | undefined, platformFeeBps: number | undefined, maxAccounts: number | undefined, minimizeSlippage: boolean | undefined, preferLiquidDexes: boolean | undefined, options?: RequestInit) {
		return QuoteApiFp(this.configuration).getQuote(inputMint, outputMint, amount, slippageBps, autoSlippage, autoSlippageCollisionUsdValue, computeAutoSlippage, maxAutoSlippageBps, swapMode, dexes, excludeDexes, restrictIntermediateTokens, onlyDirectRoutes, asLegacyTransaction, platformFeeBps, maxAccounts, minimizeSlippage, preferLiquidDexes, options)(this.fetch, this.basePath);
	}

}
/**
 * SwapApi - fetch parameter creator
 * @export
 */
export const SwapApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * <p>Returns a transaction that you can use from the quote you get from <code>/quote</code>.</p>
		 * @summary POST /swap
		 * @param {Api.SwapRequest} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postSwap(request: Api.SwapRequest, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling postSwap.');
			}
			let localVarPath = `/swap`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * SwapApi - functional programming interface
 * @export
 */
export const SwapApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * <p>Returns a transaction that you can use from the quote you get from <code>/quote</code>.</p>
		 * @summary POST /swap
		 * @param {Api.SwapRequest} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postSwap(request: Api.SwapRequest, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.SwapResponse> {
			const localVarFetchArgs = SwapApiFetchParamCreator(configuration).postSwap(request, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					throw response;
				});
			};
		},
	}
};

/**
 * SwapApi - factory interface
 * @export
 */
export const SwapApiFactory: FactoryFunction<SwapApi> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new SwapApi(configuration, basePath, fetch);
};

/**
 * SwapApi - object-oriented interface
 * @export
 * @class SwapApi
 * @extends {BaseAPI}
 */
export class SwapApi extends BaseAPI {
	/**
	 * <p>Returns a transaction that you can use from the quote you get from <code>/quote</code>.</p>
	 * @summary POST /swap
	 * @param {Api.SwapRequest} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public postSwap(request: Api.SwapRequest, options?: RequestInit) {
		return SwapApiFp(this.configuration).postSwap(request, options)(this.fetch, this.basePath);
	}

}
/**
 * SwapInstructionsApi - fetch parameter creator
 * @export
 */
export const SwapInstructionsApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * <p>Returns instructions that you can use from the quote you get from <code>/quote</code>.</p>
		 * @summary POST /swap-instructions
		 * @param {Api.SwapRequest} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postSwapInstructions(request: Api.SwapRequest, options: RequestInit = {}): FetchArgs {
			// verify required parameter 'request' is not null or undefined
			if (request === null || request === undefined) {
				throw new RequiredError('request', 'Required parameter request was null or undefined when calling postSwapInstructions.');
			}
			let localVarPath = `/swap-instructions`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'POST' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarHeaderParameter.set('Content-Type', 'application/json');

			localVarRequestOptions.headers = localVarHeaderParameter;
	
			if (request !== undefined) {
				localVarRequestOptions.body = JSON.stringify(request || {});
			}

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * SwapInstructionsApi - functional programming interface
 * @export
 */
export const SwapInstructionsApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * <p>Returns instructions that you can use from the quote you get from <code>/quote</code>.</p>
		 * @summary POST /swap-instructions
		 * @param {Api.SwapRequest} request
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postSwapInstructions(request: Api.SwapRequest, options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<Api.SwapInstructionsResponse> {
			const localVarFetchArgs = SwapInstructionsApiFetchParamCreator(configuration).postSwapInstructions(request, options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					throw response;
				});
			};
		},
	}
};

/**
 * SwapInstructionsApi - factory interface
 * @export
 */
export const SwapInstructionsApiFactory: FactoryFunction<SwapInstructionsApi> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new SwapInstructionsApi(configuration, basePath, fetch);
};

/**
 * SwapInstructionsApi - object-oriented interface
 * @export
 * @class SwapInstructionsApi
 * @extends {BaseAPI}
 */
export class SwapInstructionsApi extends BaseAPI {
	/**
	 * <p>Returns instructions that you can use from the quote you get from <code>/quote</code>.</p>
	 * @summary POST /swap-instructions
	 * @param {Api.SwapRequest} request
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public postSwapInstructions(request: Api.SwapRequest, options?: RequestInit) {
		return SwapInstructionsApiFp(this.configuration).postSwapInstructions(request, options)(this.fetch, this.basePath);
	}

}
/**
 * TokensApi - fetch parameter creator
 * @export
 */
export const TokensApiFetchParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 * <p>Returns a list of all the tradable mints</p>
		 * @summary GET /tokens
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getTokens(options: RequestInit = {}): FetchArgs {
			let localVarPath = `/tokens`;
			const localVarPathQueryStart = localVarPath.indexOf("?");
			const localVarRequestOptions: RequestInit = Object.assign({ method: 'GET' }, options);
			const localVarHeaderParameter: Headers = options.headers ? new Headers(options.headers) : new Headers();
			const localVarQueryParameter = new URLSearchParams(localVarPathQueryStart !== -1 ? localVarPath.substring(localVarPathQueryStart + 1) : "");
			if (localVarPathQueryStart !== -1) {
				localVarPath = localVarPath.substring(0, localVarPathQueryStart);
			}

			localVarRequestOptions.headers = localVarHeaderParameter;

			const localVarQueryParameterString = localVarQueryParameter.toString();
			if (localVarQueryParameterString) {
				localVarPath += "?" + localVarQueryParameterString;
			}
			return {
				url: localVarPath,
				options: localVarRequestOptions,
			};
		},
	}
};

/**
 * TokensApi - functional programming interface
 * @export
 */
export const TokensApiFp = function(configuration?: Configuration) {
	return {
		/**
		 * <p>Returns a list of all the tradable mints</p>
		 * @summary GET /tokens
		 * @param {RequestInit} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getTokens(options?: RequestInit): (fetch?: FetchAPI, basePath?: string) => Promise<string[]> {
			const localVarFetchArgs = TokensApiFetchParamCreator(configuration).getTokens(options);
			return (fetch: FetchAPI = defaultFetch, basePath: string = BASE_PATH) => {
				return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
					const contentType = response.headers.get('Content-Type');
					const mimeType = contentType ? contentType.replace(/;.*/, '') : undefined;
					
					if (response.status === 200) {
						if (mimeType === 'application/json') {
							return response.json() as any;
						}
						throw response;
					}
					throw response;
				});
			};
		},
	}
};

/**
 * TokensApi - factory interface
 * @export
 */
export const TokensApiFactory: FactoryFunction<TokensApi> = function (configuration?: Configuration, basePath?: string, fetch?: FetchAPI) {
	return new TokensApi(configuration, basePath, fetch);
};

/**
 * TokensApi - object-oriented interface
 * @export
 * @class TokensApi
 * @extends {BaseAPI}
 */
export class TokensApi extends BaseAPI {
	/**
	 * <p>Returns a list of all the tradable mints</p>
	 * @summary GET /tokens
	 * @param {RequestInit} [options] Override http request option.
	 * @throws {RequiredError}
	 */
	public getTokens(options?: RequestInit) {
		return TokensApiFp(this.configuration).getTokens(options)(this.fetch, this.basePath);
	}

}

/**
 * We sometimes represent dates as strings (in models) and as Dates (in parameters) so this
 * function converts them both to a string.
 */
function dateToString(value: Date | string | undefined): string | undefined {
	if (value instanceof Date) {
		return value.toISOString();
	} else if (typeof value === 'string') {
		return value;
	} else {
		return undefined;
	}
}

/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import YAML from "yaml";
import $protobuf from "protobufjs/minimal.js";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots.oracle_job || ($protobuf.roots.oracle_job = {});

export const oracle_job = $root.oracle_job = (() => {

    /**
     * Namespace oracle_job.
     * @exports oracle_job
     * @namespace
     */
    const oracle_job = {};

    oracle_job.OracleFeed = (function() {

        /**
         * Properties of an OracleFeed.
         * @memberof oracle_job
         * @interface IOracleFeed
         * @property {string|null} [name] OracleFeed name
         * @property {Array.<oracle_job.IOracleJob>|null} [jobs] A list of jobs to be performed by the oracle.
         * @property {number|null} [minOracleSamples] The number of oracles to sample before returning a result.
         * @property {number|null} [minJobResponses] The minimum number of jobs required to succeed in order to produce a result.
         * @property {number|Long|null} [maxJobRangePct] Maximum allowed percentage deviation between job responses.
         */

        /**
         * Constructs a new OracleFeed.
         * @memberof oracle_job
         * @classdesc Represents a complete feed schema to be performed by a Switchboard oracle.
         * @implements IOracleFeed
         * @constructor
         * @param {oracle_job.IOracleFeed=} [properties] Properties to set
         */
        function OracleFeed(properties) {
            this.jobs = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OracleFeed name.
         * @member {string} name
         * @memberof oracle_job.OracleFeed
         * @instance
         */
        OracleFeed.prototype.name = "";

        /**
         * A list of jobs to be performed by the oracle.
         * @member {Array.<oracle_job.IOracleJob>} jobs
         * @memberof oracle_job.OracleFeed
         * @instance
         */
        OracleFeed.prototype.jobs = $util.emptyArray;

        /**
         * The number of oracles to sample before returning a result.
         * @member {number} minOracleSamples
         * @memberof oracle_job.OracleFeed
         * @instance
         */
        OracleFeed.prototype.minOracleSamples = 0;

        /**
         * The minimum number of jobs required to succeed in order to produce a result.
         * @member {number} minJobResponses
         * @memberof oracle_job.OracleFeed
         * @instance
         */
        OracleFeed.prototype.minJobResponses = 0;

        /**
         * Maximum allowed percentage deviation between job responses.
         * @member {number|Long} maxJobRangePct
         * @memberof oracle_job.OracleFeed
         * @instance
         */
        OracleFeed.prototype.maxJobRangePct = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new OracleFeed instance using the specified properties.
         * @function create
         * @memberof oracle_job.OracleFeed
         * @static
         * @param {oracle_job.IOracleFeed=} [properties] Properties to set
         * @returns {oracle_job.OracleFeed} OracleFeed instance
         */
        OracleFeed.create = function create(properties) {
      return OracleFeed.fromObject(properties);
    };

        /**
         * Encodes the specified OracleFeed message. Does not implicitly {@link oracle_job.OracleFeed.verify|verify} messages.
         * @function encode
         * @memberof oracle_job.OracleFeed
         * @static
         * @param {oracle_job.IOracleFeed} message OracleFeed message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OracleFeed.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.jobs != null && message.jobs.length)
                for (let i = 0; i < message.jobs.length; ++i)
                    $root.oracle_job.OracleJob.encode(message.jobs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.minOracleSamples != null && Object.hasOwnProperty.call(message, "minOracleSamples"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.minOracleSamples);
            if (message.minJobResponses != null && Object.hasOwnProperty.call(message, "minJobResponses"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.minJobResponses);
            if (message.maxJobRangePct != null && Object.hasOwnProperty.call(message, "maxJobRangePct"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.maxJobRangePct);
            return writer;
        };

        /**
         * Encodes the specified OracleFeed message, length delimited. Does not implicitly {@link oracle_job.OracleFeed.verify|verify} messages.
         * @function encodeDelimited
         * @memberof oracle_job.OracleFeed
         * @static
         * @param {oracle_job.IOracleFeed} message OracleFeed message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OracleFeed.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OracleFeed message from the specified reader or buffer.
         * @function decode
         * @memberof oracle_job.OracleFeed
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {oracle_job.OracleFeed} OracleFeed
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OracleFeed.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleFeed();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        if (!(message.jobs && message.jobs.length))
                            message.jobs = [];
                        message.jobs.push($root.oracle_job.OracleJob.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        message.minOracleSamples = reader.uint32();
                        break;
                    }
                case 4: {
                        message.minJobResponses = reader.uint32();
                        break;
                    }
                case 5: {
                        message.maxJobRangePct = reader.uint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OracleFeed message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof oracle_job.OracleFeed
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {oracle_job.OracleFeed} OracleFeed
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OracleFeed.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OracleFeed message.
         * @function verify
         * @memberof oracle_job.OracleFeed
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OracleFeed.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.jobs != null && message.hasOwnProperty("jobs")) {
                if (!Array.isArray(message.jobs))
                    return "jobs: array expected";
                for (let i = 0; i < message.jobs.length; ++i) {
                    let error = $root.oracle_job.OracleJob.verify(message.jobs[i]);
                    if (error)
                        return "jobs." + error;
                }
            }
            if (message.minOracleSamples != null && message.hasOwnProperty("minOracleSamples"))
                if (!$util.isInteger(message.minOracleSamples))
                    return "minOracleSamples: integer expected";
            if (message.minJobResponses != null && message.hasOwnProperty("minJobResponses"))
                if (!$util.isInteger(message.minJobResponses))
                    return "minJobResponses: integer expected";
            if (message.maxJobRangePct != null && message.hasOwnProperty("maxJobRangePct"))
                if (!$util.isInteger(message.maxJobRangePct) && !(message.maxJobRangePct && $util.isInteger(message.maxJobRangePct.low) && $util.isInteger(message.maxJobRangePct.high)))
                    return "maxJobRangePct: integer|Long expected";
            return null;
        };

        /**
         * Creates an OracleFeed message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof oracle_job.OracleFeed
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {oracle_job.OracleFeed} OracleFeed
         */
        OracleFeed.fromObject = function fromObject(object) {
            if (object instanceof $root.oracle_job.OracleFeed)
                return object;
            let message = new $root.oracle_job.OracleFeed();
            if (object.name != null)
                message.name = String(object.name);
            if (object.jobs) {
                if (!Array.isArray(object.jobs))
                    throw TypeError(".oracle_job.OracleFeed.jobs: array expected");
                message.jobs = [];
                for (let i = 0; i < object.jobs.length; ++i) {
                    if (typeof object.jobs[i] !== "object")
                        throw TypeError(".oracle_job.OracleFeed.jobs: object expected");
                    message.jobs[i] = $root.oracle_job.OracleJob.fromObject(object.jobs[i]);
                }
            }
            if (object.minOracleSamples != null)
                message.minOracleSamples = object.minOracleSamples >>> 0;
            if (object.minJobResponses != null)
                message.minJobResponses = object.minJobResponses >>> 0;
            if (object.maxJobRangePct != null)
                if ($util.Long)
                    (message.maxJobRangePct = $util.Long.fromValue(object.maxJobRangePct)).unsigned = true;
                else if (typeof object.maxJobRangePct === "string")
                    message.maxJobRangePct = parseInt(object.maxJobRangePct, 10);
                else if (typeof object.maxJobRangePct === "number")
                    message.maxJobRangePct = object.maxJobRangePct;
                else if (typeof object.maxJobRangePct === "object")
                    message.maxJobRangePct = new $util.LongBits(object.maxJobRangePct.low >>> 0, object.maxJobRangePct.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from an OracleFeed message. Also converts values to other types if specified.
         * @function toObject
         * @memberof oracle_job.OracleFeed
         * @static
         * @param {oracle_job.OracleFeed} message OracleFeed
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OracleFeed.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.jobs = [];
            if (options.defaults) {
                object.name = "";
                object.minOracleSamples = 0;
                object.minJobResponses = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.maxJobRangePct = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.maxJobRangePct = options.longs === String ? "0" : 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.jobs && message.jobs.length) {
                object.jobs = [];
                for (let j = 0; j < message.jobs.length; ++j)
                    object.jobs[j] = $root.oracle_job.OracleJob.toObject(message.jobs[j], options);
            }
            if (message.minOracleSamples != null && message.hasOwnProperty("minOracleSamples"))
                object.minOracleSamples = message.minOracleSamples;
            if (message.minJobResponses != null && message.hasOwnProperty("minJobResponses"))
                object.minJobResponses = message.minJobResponses;
            if (message.maxJobRangePct != null && message.hasOwnProperty("maxJobRangePct"))
                if (typeof message.maxJobRangePct === "number")
                    object.maxJobRangePct = options.longs === String ? String(message.maxJobRangePct) : message.maxJobRangePct;
                else
                    object.maxJobRangePct = options.longs === String ? $util.Long.prototype.toString.call(message.maxJobRangePct) : options.longs === Number ? new $util.LongBits(message.maxJobRangePct.low >>> 0, message.maxJobRangePct.high >>> 0).toNumber(true) : message.maxJobRangePct;
            return object;
        };

        /**
         * Converts this OracleFeed to JSON.
         * @function toJSON
         * @memberof oracle_job.OracleFeed
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OracleFeed.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for OracleFeed
         * @function getTypeUrl
         * @memberof oracle_job.OracleFeed
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        OracleFeed.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/oracle_job.OracleFeed";
        };

        return OracleFeed;
    })();

    oracle_job.OracleJob = (function() {

        /**
         * Properties of an OracleJob.
         * @memberof oracle_job
         * @interface IOracleJob
         * @property {Array.<oracle_job.OracleJob.ITask>|null} [tasks] The chain of tasks to perform for this OracleJob.
         * @property {number|null} [weight] The weight to assign to this job's result when aggregating multiple job results. A higher
         * weight means this job's result will have more influence on the final aggregated value. This
         * value must be greater than or equal to 0.
         */

        /**
         * Constructs a new OracleJob.
         * @memberof oracle_job
         * @classdesc Represnts a list of tasks to be performed by a Switchboard oracle.
         * @implements IOracleJob
         * @constructor
         * @param {oracle_job.IOracleJob=} [properties] Properties to set
         */
        function OracleJob(properties) {
            this.tasks = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The chain of tasks to perform for this OracleJob.
         * @member {Array.<oracle_job.OracleJob.ITask>} tasks
         * @memberof oracle_job.OracleJob
         * @instance
         */
        OracleJob.prototype.tasks = $util.emptyArray;

        /**
         * The weight to assign to this job's result when aggregating multiple job results. A higher
         * weight means this job's result will have more influence on the final aggregated value. This
         * value must be greater than or equal to 0.
         * @member {number} weight
         * @memberof oracle_job.OracleJob
         * @instance
         */
        OracleJob.prototype.weight = 1;

        /**
         * Creates a new OracleJob instance using the specified properties.
         * @function create
         * @memberof oracle_job.OracleJob
         * @static
         * @param {oracle_job.IOracleJob=} [properties] Properties to set
         * @returns {oracle_job.OracleJob} OracleJob instance
         */
        OracleJob.create = function create(properties) {
      return OracleJob.fromObject(properties);
    };

        /**
         * Encodes the specified OracleJob message. Does not implicitly {@link oracle_job.OracleJob.verify|verify} messages.
         * @function encode
         * @memberof oracle_job.OracleJob
         * @static
         * @param {oracle_job.IOracleJob} message OracleJob message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OracleJob.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tasks != null && message.tasks.length)
                for (let i = 0; i < message.tasks.length; ++i)
                    $root.oracle_job.OracleJob.Task.encode(message.tasks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.weight != null && Object.hasOwnProperty.call(message, "weight"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.weight);
            return writer;
        };

        /**
         * Encodes the specified OracleJob message, length delimited. Does not implicitly {@link oracle_job.OracleJob.verify|verify} messages.
         * @function encodeDelimited
         * @memberof oracle_job.OracleJob
         * @static
         * @param {oracle_job.IOracleJob} message OracleJob message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OracleJob.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OracleJob message from the specified reader or buffer.
         * @function decode
         * @memberof oracle_job.OracleJob
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {oracle_job.OracleJob} OracleJob
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OracleJob.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.tasks && message.tasks.length))
                            message.tasks = [];
                        message.tasks.push($root.oracle_job.OracleJob.Task.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.weight = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OracleJob message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof oracle_job.OracleJob
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {oracle_job.OracleJob} OracleJob
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OracleJob.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OracleJob message.
         * @function verify
         * @memberof oracle_job.OracleJob
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OracleJob.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tasks != null && message.hasOwnProperty("tasks")) {
                if (!Array.isArray(message.tasks))
                    return "tasks: array expected";
                for (let i = 0; i < message.tasks.length; ++i) {
                    let error = $root.oracle_job.OracleJob.Task.verify(message.tasks[i]);
                    if (error)
                        return "tasks." + error;
                }
            }
            if (message.weight != null && message.hasOwnProperty("weight"))
                if (!$util.isInteger(message.weight))
                    return "weight: integer expected";
            return null;
        };

        /**
         * Creates an OracleJob message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof oracle_job.OracleJob
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {oracle_job.OracleJob} OracleJob
         */
        OracleJob.fromObject = function fromObject(object) {
            if (object instanceof $root.oracle_job.OracleJob)
                return object;
            let message = new $root.oracle_job.OracleJob();
            if (object.tasks) {
                if (!Array.isArray(object.tasks))
                    throw TypeError(".oracle_job.OracleJob.tasks: array expected");
                message.tasks = [];
                for (let i = 0; i < object.tasks.length; ++i) {
                    if (typeof object.tasks[i] !== "object")
                        throw TypeError(".oracle_job.OracleJob.tasks: object expected");
                    message.tasks[i] = $root.oracle_job.OracleJob.Task.fromObject(object.tasks[i]);
                }
            }
            if (object.weight != null)
                message.weight = object.weight >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an OracleJob message. Also converts values to other types if specified.
         * @function toObject
         * @memberof oracle_job.OracleJob
         * @static
         * @param {oracle_job.OracleJob} message OracleJob
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OracleJob.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.tasks = [];
            if (options.defaults)
                object.weight = 1;
            if (message.tasks && message.tasks.length) {
                object.tasks = [];
                for (let j = 0; j < message.tasks.length; ++j)
                    object.tasks[j] = $root.oracle_job.OracleJob.Task.toObject(message.tasks[j], options);
            }
            if (message.weight != null && message.hasOwnProperty("weight"))
                object.weight = message.weight;
            return object;
        };

        /**
         * Converts this OracleJob to JSON.
         * @function toJSON
         * @memberof oracle_job.OracleJob
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OracleJob.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for OracleJob
         * @function getTypeUrl
         * @memberof oracle_job.OracleJob
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        OracleJob.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/oracle_job.OracleJob";
        };

        

      /**
       * Creates an OracleJob message from a YAML string.
       */
      OracleJob.fromYaml = function fromYaml(yamlString) {
        return OracleJob.fromObject(YAML.parse(yamlString));
      };

      /**
       * Converts this OracleJob to YAML.
       */
      OracleJob.prototype.toYaml = function toYaml() {
        return YAML.stringify(this.toJSON());
      };
    
OracleJob.HttpTask = (function() {

            /**
             * Properties of a HttpTask.
             * @memberof oracle_job.OracleJob
             * @interface IHttpTask
             * @property {string|null} [url] A string containing the URL to direct this HTTP request to.
             * @property {oracle_job.OracleJob.HttpTask.Method|null} [method] The type of HTTP request to make.
             * @property {Array.<oracle_job.OracleJob.HttpTask.IHeader>|null} [headers] A list of headers to add to this HttpTask.
             * @property {string|null} [body] A stringified body (if any) to add to this HttpTask.
             */

            /**
             * Constructs a new HttpTask.
             * @memberof oracle_job.OracleJob
             * @classdesc The adapter will report the text body of a successful HTTP request to the
             * specified url, or return an error if the response status code is greater
             * than or equal to 400.
             * 
             * _**Input**_: None
             * 
             * _**Returns**_: String representation of the http response.
             * 
             * _**Example**_: Basic HttpTask
             * 
             * ```json
             * {"httpTask": {"url": "https://mywebsite.org/path"} }
             * ```
             * 
             * _**Example**_: HttpTask example with headers
             * 
             * ```json
             * { "httpTask": { "url": "https://mywebsite.org/path", "method": "METHOD_POST", "headers": [ { "key": "MY_HEADER_KEY", "value": "MY_HEADER_VALUE" } ], "body": "{\"MY_BODY_KEY\":\"MY_BODY_VALUE\"}" } }
             * ```
             * @implements IHttpTask
             * @constructor
             * @param {oracle_job.OracleJob.IHttpTask=} [properties] Properties to set
             */
            function HttpTask(properties) {
                this.headers = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * A string containing the URL to direct this HTTP request to.
             * @member {string} url
             * @memberof oracle_job.OracleJob.HttpTask
             * @instance
             */
            HttpTask.prototype.url = "";

            /**
             * The type of HTTP request to make.
             * @member {oracle_job.OracleJob.HttpTask.Method} method
             * @memberof oracle_job.OracleJob.HttpTask
             * @instance
             */
            HttpTask.prototype.method = 0;

            /**
             * A list of headers to add to this HttpTask.
             * @member {Array.<oracle_job.OracleJob.HttpTask.IHeader>} headers
             * @memberof oracle_job.OracleJob.HttpTask
             * @instance
             */
            HttpTask.prototype.headers = $util.emptyArray;

            /**
             * A stringified body (if any) to add to this HttpTask.
             * @member {string} body
             * @memberof oracle_job.OracleJob.HttpTask
             * @instance
             */
            HttpTask.prototype.body = "";

            /**
             * Creates a new HttpTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.HttpTask
             * @static
             * @param {oracle_job.OracleJob.IHttpTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.HttpTask} HttpTask instance
             */
            HttpTask.create = function create(properties) {
      return HttpTask.fromObject(properties);
    };

            /**
             * Encodes the specified HttpTask message. Does not implicitly {@link oracle_job.OracleJob.HttpTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.HttpTask
             * @static
             * @param {oracle_job.OracleJob.IHttpTask} message HttpTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HttpTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.method);
                if (message.headers != null && message.headers.length)
                    for (let i = 0; i < message.headers.length; ++i)
                        $root.oracle_job.OracleJob.HttpTask.Header.encode(message.headers[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.body != null && Object.hasOwnProperty.call(message, "body"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.body);
                return writer;
            };

            /**
             * Encodes the specified HttpTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.HttpTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.HttpTask
             * @static
             * @param {oracle_job.OracleJob.IHttpTask} message HttpTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HttpTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HttpTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.HttpTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.HttpTask} HttpTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HttpTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.HttpTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.url = reader.string();
                            break;
                        }
                    case 2: {
                            message.method = reader.int32();
                            break;
                        }
                    case 3: {
                            if (!(message.headers && message.headers.length))
                                message.headers = [];
                            message.headers.push($root.oracle_job.OracleJob.HttpTask.Header.decode(reader, reader.uint32()));
                            break;
                        }
                    case 4: {
                            message.body = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HttpTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.HttpTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.HttpTask} HttpTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HttpTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HttpTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.HttpTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HttpTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                if (message.method != null && message.hasOwnProperty("method"))
                    switch (message.method) {
                    default:
                        return "method: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.headers != null && message.hasOwnProperty("headers")) {
                    if (!Array.isArray(message.headers))
                        return "headers: array expected";
                    for (let i = 0; i < message.headers.length; ++i) {
                        let error = $root.oracle_job.OracleJob.HttpTask.Header.verify(message.headers[i]);
                        if (error)
                            return "headers." + error;
                    }
                }
                if (message.body != null && message.hasOwnProperty("body"))
                    if (!$util.isString(message.body))
                        return "body: string expected";
                return null;
            };

            /**
             * Creates a HttpTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.HttpTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.HttpTask} HttpTask
             */
            HttpTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.HttpTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.HttpTask();
                if (object.url != null)
                    message.url = String(object.url);
                switch (object.method) {
                default:
                    if (typeof object.method === "number") {
                        message.method = object.method;
                        break;
                    }
                    break;
                case "METHOD_UNKOWN":
                case 0:
                    message.method = 0;
                    break;
                case "METHOD_GET":
                case 1:
                    message.method = 1;
                    break;
                case "METHOD_POST":
                case 2:
                    message.method = 2;
                    break;
                }
                if (object.headers) {
                    if (!Array.isArray(object.headers))
                        throw TypeError(".oracle_job.OracleJob.HttpTask.headers: array expected");
                    message.headers = [];
                    for (let i = 0; i < object.headers.length; ++i) {
                        if (typeof object.headers[i] !== "object")
                            throw TypeError(".oracle_job.OracleJob.HttpTask.headers: object expected");
                        message.headers[i] = $root.oracle_job.OracleJob.HttpTask.Header.fromObject(object.headers[i]);
                    }
                }
                if (object.body != null)
                    message.body = String(object.body);
                return message;
            };

            /**
             * Creates a plain object from a HttpTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.HttpTask
             * @static
             * @param {oracle_job.OracleJob.HttpTask} message HttpTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HttpTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.headers = [];
                if (options.defaults) {
                    object.url = "";
                    object.method = options.enums === String ? "METHOD_UNKOWN" : 0;
                    object.body = "";
                }
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                if (message.method != null && message.hasOwnProperty("method"))
                    object.method = options.enums === String ? $root.oracle_job.OracleJob.HttpTask.Method[message.method] === undefined ? message.method : $root.oracle_job.OracleJob.HttpTask.Method[message.method] : message.method;
                if (message.headers && message.headers.length) {
                    object.headers = [];
                    for (let j = 0; j < message.headers.length; ++j)
                        object.headers[j] = $root.oracle_job.OracleJob.HttpTask.Header.toObject(message.headers[j], options);
                }
                if (message.body != null && message.hasOwnProperty("body"))
                    object.body = message.body;
                return object;
            };

            /**
             * Converts this HttpTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.HttpTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HttpTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for HttpTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.HttpTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            HttpTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.HttpTask";
            };

            /**
             * An enumeration representing the types of HTTP requests available to make.
             * @name oracle_job.OracleJob.HttpTask.Method
             * @enum {number}
             * @property {number} METHOD_UNKOWN=0 Unset HTTP method will default to METHOD_GET
             * @property {number} METHOD_GET=1 Perform an HTTP 'GET' request.
             * @property {number} METHOD_POST=2 Perform an HTTP 'POST' request.
             */
            HttpTask.Method = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "METHOD_UNKOWN"] = 0;
                values[valuesById[1] = "METHOD_GET"] = 1;
                values[valuesById[2] = "METHOD_POST"] = 2;
                return values;
            })();

            HttpTask.Header = (function() {

                /**
                 * Properties of a Header.
                 * @memberof oracle_job.OracleJob.HttpTask
                 * @interface IHeader
                 * @property {string|null} [key] A header key such as `Authorization` or `Content-Type`
                 * @property {string|null} [value] A value for the given header key like `Basic MYAUTHKEY` or `application/json`
                 */

                /**
                 * Constructs a new Header.
                 * @memberof oracle_job.OracleJob.HttpTask
                 * @classdesc An object that represents a header to add to an HTTP request.
                 * @implements IHeader
                 * @constructor
                 * @param {oracle_job.OracleJob.HttpTask.IHeader=} [properties] Properties to set
                 */
                function Header(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * A header key such as `Authorization` or `Content-Type`
                 * @member {string} key
                 * @memberof oracle_job.OracleJob.HttpTask.Header
                 * @instance
                 */
                Header.prototype.key = "";

                /**
                 * A value for the given header key like `Basic MYAUTHKEY` or `application/json`
                 * @member {string} value
                 * @memberof oracle_job.OracleJob.HttpTask.Header
                 * @instance
                 */
                Header.prototype.value = "";

                /**
                 * Creates a new Header instance using the specified properties.
                 * @function create
                 * @memberof oracle_job.OracleJob.HttpTask.Header
                 * @static
                 * @param {oracle_job.OracleJob.HttpTask.IHeader=} [properties] Properties to set
                 * @returns {oracle_job.OracleJob.HttpTask.Header} Header instance
                 */
                Header.create = function create(properties) {
      return Header.fromObject(properties);
    };

                /**
                 * Encodes the specified Header message. Does not implicitly {@link oracle_job.OracleJob.HttpTask.Header.verify|verify} messages.
                 * @function encode
                 * @memberof oracle_job.OracleJob.HttpTask.Header
                 * @static
                 * @param {oracle_job.OracleJob.HttpTask.IHeader} message Header message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Header.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.key != null && Object.hasOwnProperty.call(message, "key"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.key);
                    if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.value);
                    return writer;
                };

                /**
                 * Encodes the specified Header message, length delimited. Does not implicitly {@link oracle_job.OracleJob.HttpTask.Header.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof oracle_job.OracleJob.HttpTask.Header
                 * @static
                 * @param {oracle_job.OracleJob.HttpTask.IHeader} message Header message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Header.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Header message from the specified reader or buffer.
                 * @function decode
                 * @memberof oracle_job.OracleJob.HttpTask.Header
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {oracle_job.OracleJob.HttpTask.Header} Header
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Header.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.HttpTask.Header();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.key = reader.string();
                                break;
                            }
                        case 2: {
                                message.value = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Header message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof oracle_job.OracleJob.HttpTask.Header
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {oracle_job.OracleJob.HttpTask.Header} Header
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Header.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Header message.
                 * @function verify
                 * @memberof oracle_job.OracleJob.HttpTask.Header
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Header.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.key != null && message.hasOwnProperty("key"))
                        if (!$util.isString(message.key))
                            return "key: string expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (!$util.isString(message.value))
                            return "value: string expected";
                    return null;
                };

                /**
                 * Creates a Header message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof oracle_job.OracleJob.HttpTask.Header
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {oracle_job.OracleJob.HttpTask.Header} Header
                 */
                Header.fromObject = function fromObject(object) {
                    if (object instanceof $root.oracle_job.OracleJob.HttpTask.Header)
                        return object;
                    let message = new $root.oracle_job.OracleJob.HttpTask.Header();
                    if (object.key != null)
                        message.key = String(object.key);
                    if (object.value != null)
                        message.value = String(object.value);
                    return message;
                };

                /**
                 * Creates a plain object from a Header message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof oracle_job.OracleJob.HttpTask.Header
                 * @static
                 * @param {oracle_job.OracleJob.HttpTask.Header} message Header
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Header.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.key = "";
                        object.value = "";
                    }
                    if (message.key != null && message.hasOwnProperty("key"))
                        object.key = message.key;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = message.value;
                    return object;
                };

                /**
                 * Converts this Header to JSON.
                 * @function toJSON
                 * @memberof oracle_job.OracleJob.HttpTask.Header
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Header.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Header
                 * @function getTypeUrl
                 * @memberof oracle_job.OracleJob.HttpTask.Header
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Header.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/oracle_job.OracleJob.HttpTask.Header";
                };

                return Header;
            })();

            return HttpTask;
        })();

        OracleJob.JsonParseTask = (function() {

            /**
             * Properties of a JsonParseTask.
             * @memberof oracle_job.OracleJob
             * @interface IJsonParseTask
             * @property {string|null} [path] JSONPath formatted path to the element. https://t.ly/uLtw
             * https://www.npmjs.com/package/jsonpath-plus
             * @property {oracle_job.OracleJob.JsonParseTask.AggregationMethod|null} [aggregationMethod] The technique that will be used to aggregate the results if walking the specified path returns multiple numerical results.
             */

            /**
             * Constructs a new JsonParseTask.
             * @memberof oracle_job.OracleJob
             * @classdesc The adapter walks the path specified and returns the value found at that result. If returning
             * JSON data from the HttpGet or HttpPost adapters, you must use this adapter to parse the response.
             * 
             * _**Input**_: String representation of a JSON object.
             * 
             * _**Returns**_: A numerical result.
             * 
             * _**Example**_: Parses the price field from a JSON object
             * 
             * ```json
             * {"jsonParse": {"path": "$.price"} }
             * ```
             * @implements IJsonParseTask
             * @constructor
             * @param {oracle_job.OracleJob.IJsonParseTask=} [properties] Properties to set
             */
            function JsonParseTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * JSONPath formatted path to the element. https://t.ly/uLtw
             * https://www.npmjs.com/package/jsonpath-plus
             * @member {string} path
             * @memberof oracle_job.OracleJob.JsonParseTask
             * @instance
             */
            JsonParseTask.prototype.path = "";

            /**
             * The technique that will be used to aggregate the results if walking the specified path returns multiple numerical results.
             * @member {oracle_job.OracleJob.JsonParseTask.AggregationMethod} aggregationMethod
             * @memberof oracle_job.OracleJob.JsonParseTask
             * @instance
             */
            JsonParseTask.prototype.aggregationMethod = 0;

            /**
             * Creates a new JsonParseTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.JsonParseTask
             * @static
             * @param {oracle_job.OracleJob.IJsonParseTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.JsonParseTask} JsonParseTask instance
             */
            JsonParseTask.create = function create(properties) {
      return JsonParseTask.fromObject(properties);
    };

            /**
             * Encodes the specified JsonParseTask message. Does not implicitly {@link oracle_job.OracleJob.JsonParseTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.JsonParseTask
             * @static
             * @param {oracle_job.OracleJob.IJsonParseTask} message JsonParseTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JsonParseTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.path);
                if (message.aggregationMethod != null && Object.hasOwnProperty.call(message, "aggregationMethod"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.aggregationMethod);
                return writer;
            };

            /**
             * Encodes the specified JsonParseTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.JsonParseTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.JsonParseTask
             * @static
             * @param {oracle_job.OracleJob.IJsonParseTask} message JsonParseTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JsonParseTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a JsonParseTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.JsonParseTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.JsonParseTask} JsonParseTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JsonParseTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.JsonParseTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.path = reader.string();
                            break;
                        }
                    case 2: {
                            message.aggregationMethod = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a JsonParseTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.JsonParseTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.JsonParseTask} JsonParseTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JsonParseTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a JsonParseTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.JsonParseTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            JsonParseTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                if (message.aggregationMethod != null && message.hasOwnProperty("aggregationMethod"))
                    switch (message.aggregationMethod) {
                    default:
                        return "aggregationMethod: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    }
                return null;
            };

            /**
             * Creates a JsonParseTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.JsonParseTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.JsonParseTask} JsonParseTask
             */
            JsonParseTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.JsonParseTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.JsonParseTask();
                if (object.path != null)
                    message.path = String(object.path);
                switch (object.aggregationMethod) {
                default:
                    if (typeof object.aggregationMethod === "number") {
                        message.aggregationMethod = object.aggregationMethod;
                        break;
                    }
                    break;
                case "NONE":
                case 0:
                    message.aggregationMethod = 0;
                    break;
                case "MIN":
                case 1:
                    message.aggregationMethod = 1;
                    break;
                case "MAX":
                case 2:
                    message.aggregationMethod = 2;
                    break;
                case "SUM":
                case 3:
                    message.aggregationMethod = 3;
                    break;
                case "MEAN":
                case 4:
                    message.aggregationMethod = 4;
                    break;
                case "MEDIAN":
                case 5:
                    message.aggregationMethod = 5;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a JsonParseTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.JsonParseTask
             * @static
             * @param {oracle_job.OracleJob.JsonParseTask} message JsonParseTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            JsonParseTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.path = "";
                    object.aggregationMethod = options.enums === String ? "NONE" : 0;
                }
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                if (message.aggregationMethod != null && message.hasOwnProperty("aggregationMethod"))
                    object.aggregationMethod = options.enums === String ? $root.oracle_job.OracleJob.JsonParseTask.AggregationMethod[message.aggregationMethod] === undefined ? message.aggregationMethod : $root.oracle_job.OracleJob.JsonParseTask.AggregationMethod[message.aggregationMethod] : message.aggregationMethod;
                return object;
            };

            /**
             * Converts this JsonParseTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.JsonParseTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            JsonParseTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for JsonParseTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.JsonParseTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            JsonParseTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.JsonParseTask";
            };

            /**
             * The methods of combining a list of numerical results.
             * @name oracle_job.OracleJob.JsonParseTask.AggregationMethod
             * @enum {number}
             * @property {number} NONE=0 NONE value
             * @property {number} MIN=1 Grab the minimum value of the results.
             * @property {number} MAX=2 Grab the maximum value of the results.
             * @property {number} SUM=3 Sum up all of the results.
             * @property {number} MEAN=4 Average all of the results.
             * @property {number} MEDIAN=5 Grab the median of the results.
             */
            JsonParseTask.AggregationMethod = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NONE"] = 0;
                values[valuesById[1] = "MIN"] = 1;
                values[valuesById[2] = "MAX"] = 2;
                values[valuesById[3] = "SUM"] = 3;
                values[valuesById[4] = "MEAN"] = 4;
                values[valuesById[5] = "MEDIAN"] = 5;
                return values;
            })();

            return JsonParseTask;
        })();

        OracleJob.MedianTask = (function() {

            /**
             * Properties of a MedianTask.
             * @memberof oracle_job.OracleJob
             * @interface IMedianTask
             * @property {Array.<oracle_job.OracleJob.ITask>|null} [tasks] A list of subtasks to process and produce a list of result values.
             * @property {Array.<oracle_job.IOracleJob>|null} [jobs] A list of subjobs to process and produce a list of result values.
             * @property {number|null} [minSuccessfulRequired] The minimum number of values before a successful median can be yielded.
             * @property {string|null} [maxRangePercent] The maximum range between the minimum and maximum values before a successful median can be yielded.
             */

            /**
             * Constructs a new MedianTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Returns the median (middle) of all the results returned by the provided subtasks and subjobs. Nested tasks must return a Number.
             * 
             * _**Input**_: None
             * 
             * _**Returns**_: A numerical result.
             * 
             * _**Example**_: Returns the median numerical result of 3 tasks.
             * 
             * ```json
             * {"medianTask": {"tasks": [{"valueTask": {"value": 10}},{"valueTask": {"value": 20}},{"valueTask": {"value": 30}}]}}
             * ```
             * 
             * _**Example**_: Returns the median numerical result of 3 jobs.
             * 
             * ```json
             * {"medianTask": {"jobs": [{"tasks": [{"httpTask": {"url": "https://www.binance.com/api/v3/ticker/price?symbol=SOLUSDT"}},{"jsonParseTask": {"path": "$.price"}}]},{"tasks": [{"httpTask": {"url": "https://www.binance.us/api/v3/ticker/price?symbol=SOLUSD"}},{"jsonParseTask": {"path": "$.price"}}]},{"tasks": [{"httpTask": {"url": "https://api-pub.bitfinex.com/v2/tickers?symbols=tSOLUSD"}},{"jsonParseTask": {"path": "$[0][7]"}}]}]}}
             * ```
             * @implements IMedianTask
             * @constructor
             * @param {oracle_job.OracleJob.IMedianTask=} [properties] Properties to set
             */
            function MedianTask(properties) {
                this.tasks = [];
                this.jobs = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * A list of subtasks to process and produce a list of result values.
             * @member {Array.<oracle_job.OracleJob.ITask>} tasks
             * @memberof oracle_job.OracleJob.MedianTask
             * @instance
             */
            MedianTask.prototype.tasks = $util.emptyArray;

            /**
             * A list of subjobs to process and produce a list of result values.
             * @member {Array.<oracle_job.IOracleJob>} jobs
             * @memberof oracle_job.OracleJob.MedianTask
             * @instance
             */
            MedianTask.prototype.jobs = $util.emptyArray;

            /**
             * The minimum number of values before a successful median can be yielded.
             * @member {number} minSuccessfulRequired
             * @memberof oracle_job.OracleJob.MedianTask
             * @instance
             */
            MedianTask.prototype.minSuccessfulRequired = 0;

            /**
             * The maximum range between the minimum and maximum values before a successful median can be yielded.
             * @member {string} maxRangePercent
             * @memberof oracle_job.OracleJob.MedianTask
             * @instance
             */
            MedianTask.prototype.maxRangePercent = "";

            /**
             * Creates a new MedianTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.MedianTask
             * @static
             * @param {oracle_job.OracleJob.IMedianTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.MedianTask} MedianTask instance
             */
            MedianTask.create = function create(properties) {
      return MedianTask.fromObject(properties);
    };

            /**
             * Encodes the specified MedianTask message. Does not implicitly {@link oracle_job.OracleJob.MedianTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.MedianTask
             * @static
             * @param {oracle_job.OracleJob.IMedianTask} message MedianTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MedianTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tasks != null && message.tasks.length)
                    for (let i = 0; i < message.tasks.length; ++i)
                        $root.oracle_job.OracleJob.Task.encode(message.tasks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.jobs != null && message.jobs.length)
                    for (let i = 0; i < message.jobs.length; ++i)
                        $root.oracle_job.OracleJob.encode(message.jobs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.minSuccessfulRequired != null && Object.hasOwnProperty.call(message, "minSuccessfulRequired"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.minSuccessfulRequired);
                if (message.maxRangePercent != null && Object.hasOwnProperty.call(message, "maxRangePercent"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.maxRangePercent);
                return writer;
            };

            /**
             * Encodes the specified MedianTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.MedianTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.MedianTask
             * @static
             * @param {oracle_job.OracleJob.IMedianTask} message MedianTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MedianTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MedianTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.MedianTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.MedianTask} MedianTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MedianTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.MedianTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.tasks && message.tasks.length))
                                message.tasks = [];
                            message.tasks.push($root.oracle_job.OracleJob.Task.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            if (!(message.jobs && message.jobs.length))
                                message.jobs = [];
                            message.jobs.push($root.oracle_job.OracleJob.decode(reader, reader.uint32()));
                            break;
                        }
                    case 3: {
                            message.minSuccessfulRequired = reader.int32();
                            break;
                        }
                    case 4: {
                            message.maxRangePercent = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MedianTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.MedianTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.MedianTask} MedianTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MedianTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MedianTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.MedianTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MedianTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tasks != null && message.hasOwnProperty("tasks")) {
                    if (!Array.isArray(message.tasks))
                        return "tasks: array expected";
                    for (let i = 0; i < message.tasks.length; ++i) {
                        let error = $root.oracle_job.OracleJob.Task.verify(message.tasks[i]);
                        if (error)
                            return "tasks." + error;
                    }
                }
                if (message.jobs != null && message.hasOwnProperty("jobs")) {
                    if (!Array.isArray(message.jobs))
                        return "jobs: array expected";
                    for (let i = 0; i < message.jobs.length; ++i) {
                        let error = $root.oracle_job.OracleJob.verify(message.jobs[i]);
                        if (error)
                            return "jobs." + error;
                    }
                }
                if (message.minSuccessfulRequired != null && message.hasOwnProperty("minSuccessfulRequired"))
                    if (!$util.isInteger(message.minSuccessfulRequired))
                        return "minSuccessfulRequired: integer expected";
                if (message.maxRangePercent != null && message.hasOwnProperty("maxRangePercent"))
                    if (!$util.isString(message.maxRangePercent))
                        return "maxRangePercent: string expected";
                return null;
            };

            /**
             * Creates a MedianTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.MedianTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.MedianTask} MedianTask
             */
            MedianTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.MedianTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.MedianTask();
                if (object.tasks) {
                    if (!Array.isArray(object.tasks))
                        throw TypeError(".oracle_job.OracleJob.MedianTask.tasks: array expected");
                    message.tasks = [];
                    for (let i = 0; i < object.tasks.length; ++i) {
                        if (typeof object.tasks[i] !== "object")
                            throw TypeError(".oracle_job.OracleJob.MedianTask.tasks: object expected");
                        message.tasks[i] = $root.oracle_job.OracleJob.Task.fromObject(object.tasks[i]);
                    }
                }
                if (object.jobs) {
                    if (!Array.isArray(object.jobs))
                        throw TypeError(".oracle_job.OracleJob.MedianTask.jobs: array expected");
                    message.jobs = [];
                    for (let i = 0; i < object.jobs.length; ++i) {
                        if (typeof object.jobs[i] !== "object")
                            throw TypeError(".oracle_job.OracleJob.MedianTask.jobs: object expected");
                        message.jobs[i] = $root.oracle_job.OracleJob.fromObject(object.jobs[i]);
                    }
                }
                if (object.minSuccessfulRequired != null)
                    message.minSuccessfulRequired = object.minSuccessfulRequired | 0;
                if (object.maxRangePercent != null)
                    message.maxRangePercent = String(object.maxRangePercent);
                return message;
            };

            /**
             * Creates a plain object from a MedianTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.MedianTask
             * @static
             * @param {oracle_job.OracleJob.MedianTask} message MedianTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MedianTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.tasks = [];
                    object.jobs = [];
                }
                if (options.defaults) {
                    object.minSuccessfulRequired = 0;
                    object.maxRangePercent = "";
                }
                if (message.tasks && message.tasks.length) {
                    object.tasks = [];
                    for (let j = 0; j < message.tasks.length; ++j)
                        object.tasks[j] = $root.oracle_job.OracleJob.Task.toObject(message.tasks[j], options);
                }
                if (message.jobs && message.jobs.length) {
                    object.jobs = [];
                    for (let j = 0; j < message.jobs.length; ++j)
                        object.jobs[j] = $root.oracle_job.OracleJob.toObject(message.jobs[j], options);
                }
                if (message.minSuccessfulRequired != null && message.hasOwnProperty("minSuccessfulRequired"))
                    object.minSuccessfulRequired = message.minSuccessfulRequired;
                if (message.maxRangePercent != null && message.hasOwnProperty("maxRangePercent"))
                    object.maxRangePercent = message.maxRangePercent;
                return object;
            };

            /**
             * Converts this MedianTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.MedianTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MedianTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MedianTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.MedianTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MedianTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.MedianTask";
            };

            return MedianTask;
        })();

        OracleJob.MeanTask = (function() {

            /**
             * Properties of a MeanTask.
             * @memberof oracle_job.OracleJob
             * @interface IMeanTask
             * @property {Array.<oracle_job.OracleJob.ITask>|null} [tasks] A list of subtasks to process and produce a list of result values.
             * @property {Array.<oracle_job.IOracleJob>|null} [jobs] A list of subjobs to process and produce a list of result values.
             */

            /**
             * Constructs a new MeanTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Returns the mean (average) of all the results returned by the provided subtasks and subjobs. Nested tasks or jobs must return a Number.
             * 
             * _**Input**_: None
             * 
             * _**Returns**_: A numerical result.
             * 
             * _**Example**_: Returns the mean numerical result of 3 tasks.
             * 
             * ```json
             * {"meanTask": {"tasks": [{"valueTask": {"value": 10}},{"valueTask": {"value": 20}},{"valueTask": {"value": 30}}]}}
             * ```
             * 
             * _**Example**_: Returns the mean numerical result of 3 jobs.
             * 
             * ```json
             * {"meanTask": {"jobs": [{"tasks": [{"httpTask": {"url": "https://www.binance.com/api/v3/ticker/price?symbol=SOLUSDT"}},{"jsonParseTask": {"path": "$.price"}}]},{"tasks": [{"httpTask": {"url": "https://www.binance.us/api/v3/ticker/price?symbol=SOLUSD"}},{"jsonParseTask": {"path": "$.price"}}]},{"tasks": [{"httpTask": {"url": "https://api-pub.bitfinex.com/v2/tickers?symbols=tSOLUSD"}},{"jsonParseTask": {"path": "$[0][7]"}}]}]}}
             * ```
             * @implements IMeanTask
             * @constructor
             * @param {oracle_job.OracleJob.IMeanTask=} [properties] Properties to set
             */
            function MeanTask(properties) {
                this.tasks = [];
                this.jobs = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * A list of subtasks to process and produce a list of result values.
             * @member {Array.<oracle_job.OracleJob.ITask>} tasks
             * @memberof oracle_job.OracleJob.MeanTask
             * @instance
             */
            MeanTask.prototype.tasks = $util.emptyArray;

            /**
             * A list of subjobs to process and produce a list of result values.
             * @member {Array.<oracle_job.IOracleJob>} jobs
             * @memberof oracle_job.OracleJob.MeanTask
             * @instance
             */
            MeanTask.prototype.jobs = $util.emptyArray;

            /**
             * Creates a new MeanTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.MeanTask
             * @static
             * @param {oracle_job.OracleJob.IMeanTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.MeanTask} MeanTask instance
             */
            MeanTask.create = function create(properties) {
      return MeanTask.fromObject(properties);
    };

            /**
             * Encodes the specified MeanTask message. Does not implicitly {@link oracle_job.OracleJob.MeanTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.MeanTask
             * @static
             * @param {oracle_job.OracleJob.IMeanTask} message MeanTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MeanTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tasks != null && message.tasks.length)
                    for (let i = 0; i < message.tasks.length; ++i)
                        $root.oracle_job.OracleJob.Task.encode(message.tasks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.jobs != null && message.jobs.length)
                    for (let i = 0; i < message.jobs.length; ++i)
                        $root.oracle_job.OracleJob.encode(message.jobs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MeanTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.MeanTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.MeanTask
             * @static
             * @param {oracle_job.OracleJob.IMeanTask} message MeanTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MeanTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MeanTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.MeanTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.MeanTask} MeanTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MeanTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.MeanTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.tasks && message.tasks.length))
                                message.tasks = [];
                            message.tasks.push($root.oracle_job.OracleJob.Task.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            if (!(message.jobs && message.jobs.length))
                                message.jobs = [];
                            message.jobs.push($root.oracle_job.OracleJob.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MeanTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.MeanTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.MeanTask} MeanTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MeanTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MeanTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.MeanTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MeanTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tasks != null && message.hasOwnProperty("tasks")) {
                    if (!Array.isArray(message.tasks))
                        return "tasks: array expected";
                    for (let i = 0; i < message.tasks.length; ++i) {
                        let error = $root.oracle_job.OracleJob.Task.verify(message.tasks[i]);
                        if (error)
                            return "tasks." + error;
                    }
                }
                if (message.jobs != null && message.hasOwnProperty("jobs")) {
                    if (!Array.isArray(message.jobs))
                        return "jobs: array expected";
                    for (let i = 0; i < message.jobs.length; ++i) {
                        let error = $root.oracle_job.OracleJob.verify(message.jobs[i]);
                        if (error)
                            return "jobs." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MeanTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.MeanTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.MeanTask} MeanTask
             */
            MeanTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.MeanTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.MeanTask();
                if (object.tasks) {
                    if (!Array.isArray(object.tasks))
                        throw TypeError(".oracle_job.OracleJob.MeanTask.tasks: array expected");
                    message.tasks = [];
                    for (let i = 0; i < object.tasks.length; ++i) {
                        if (typeof object.tasks[i] !== "object")
                            throw TypeError(".oracle_job.OracleJob.MeanTask.tasks: object expected");
                        message.tasks[i] = $root.oracle_job.OracleJob.Task.fromObject(object.tasks[i]);
                    }
                }
                if (object.jobs) {
                    if (!Array.isArray(object.jobs))
                        throw TypeError(".oracle_job.OracleJob.MeanTask.jobs: array expected");
                    message.jobs = [];
                    for (let i = 0; i < object.jobs.length; ++i) {
                        if (typeof object.jobs[i] !== "object")
                            throw TypeError(".oracle_job.OracleJob.MeanTask.jobs: object expected");
                        message.jobs[i] = $root.oracle_job.OracleJob.fromObject(object.jobs[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MeanTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.MeanTask
             * @static
             * @param {oracle_job.OracleJob.MeanTask} message MeanTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MeanTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.tasks = [];
                    object.jobs = [];
                }
                if (message.tasks && message.tasks.length) {
                    object.tasks = [];
                    for (let j = 0; j < message.tasks.length; ++j)
                        object.tasks[j] = $root.oracle_job.OracleJob.Task.toObject(message.tasks[j], options);
                }
                if (message.jobs && message.jobs.length) {
                    object.jobs = [];
                    for (let j = 0; j < message.jobs.length; ++j)
                        object.jobs[j] = $root.oracle_job.OracleJob.toObject(message.jobs[j], options);
                }
                return object;
            };

            /**
             * Converts this MeanTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.MeanTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MeanTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MeanTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.MeanTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MeanTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.MeanTask";
            };

            return MeanTask;
        })();

        OracleJob.MaxTask = (function() {

            /**
             * Properties of a MaxTask.
             * @memberof oracle_job.OracleJob
             * @interface IMaxTask
             * @property {Array.<oracle_job.OracleJob.ITask>|null} [tasks] A list of subtasks to process and produce a list of result values.
             * @property {Array.<oracle_job.IOracleJob>|null} [jobs] A list of subjobs to process and produce a list of result values.
             */

            /**
             * Constructs a new MaxTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Returns the maximum value of all the results returned by the provided subtasks and subjobs. Nested tasks or jobs must return a Number.
             * 
             * _**Input**_: None
             * 
             * _**Returns**_: A numerical result.
             * 
             * _**Example**_: Returns the maximum numerical result from 3 tasks.
             * 
             * ```json
             * {"maxTask": {"tasks": [{"valueTask": {"value": 10}},{"valueTask": {"value": 20}},{"valueTask": {"value": 30}}]}}
             * ```
             * 
             * _**Example**_: Returns the maximum numerical result from 3 jobs.
             * 
             * ```json
             * {"maxTask": {"jobs": [{"tasks": [{"httpTask": {"url": "https://www.binance.com/api/v3/ticker/price?symbol=SOLUSDT"}},{"jsonParseTask": {"path": "$.price"}}]},{"tasks": [{"httpTask": {"url": "https://www.binance.us/api/v3/ticker/price?symbol=SOLUSD"}},{"jsonParseTask": {"path": "$.price"}}]},{"tasks": [{"httpTask": {"url": "https://api-pub.bitfinex.com/v2/tickers?symbols=tSOLUSD"}},{"jsonParseTask": {"path": "$[0][7]"}}]}]}}
             * ```
             * @implements IMaxTask
             * @constructor
             * @param {oracle_job.OracleJob.IMaxTask=} [properties] Properties to set
             */
            function MaxTask(properties) {
                this.tasks = [];
                this.jobs = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * A list of subtasks to process and produce a list of result values.
             * @member {Array.<oracle_job.OracleJob.ITask>} tasks
             * @memberof oracle_job.OracleJob.MaxTask
             * @instance
             */
            MaxTask.prototype.tasks = $util.emptyArray;

            /**
             * A list of subjobs to process and produce a list of result values.
             * @member {Array.<oracle_job.IOracleJob>} jobs
             * @memberof oracle_job.OracleJob.MaxTask
             * @instance
             */
            MaxTask.prototype.jobs = $util.emptyArray;

            /**
             * Creates a new MaxTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.MaxTask
             * @static
             * @param {oracle_job.OracleJob.IMaxTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.MaxTask} MaxTask instance
             */
            MaxTask.create = function create(properties) {
      return MaxTask.fromObject(properties);
    };

            /**
             * Encodes the specified MaxTask message. Does not implicitly {@link oracle_job.OracleJob.MaxTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.MaxTask
             * @static
             * @param {oracle_job.OracleJob.IMaxTask} message MaxTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MaxTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tasks != null && message.tasks.length)
                    for (let i = 0; i < message.tasks.length; ++i)
                        $root.oracle_job.OracleJob.Task.encode(message.tasks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.jobs != null && message.jobs.length)
                    for (let i = 0; i < message.jobs.length; ++i)
                        $root.oracle_job.OracleJob.encode(message.jobs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MaxTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.MaxTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.MaxTask
             * @static
             * @param {oracle_job.OracleJob.IMaxTask} message MaxTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MaxTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MaxTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.MaxTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.MaxTask} MaxTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MaxTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.MaxTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.tasks && message.tasks.length))
                                message.tasks = [];
                            message.tasks.push($root.oracle_job.OracleJob.Task.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            if (!(message.jobs && message.jobs.length))
                                message.jobs = [];
                            message.jobs.push($root.oracle_job.OracleJob.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MaxTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.MaxTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.MaxTask} MaxTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MaxTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MaxTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.MaxTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MaxTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tasks != null && message.hasOwnProperty("tasks")) {
                    if (!Array.isArray(message.tasks))
                        return "tasks: array expected";
                    for (let i = 0; i < message.tasks.length; ++i) {
                        let error = $root.oracle_job.OracleJob.Task.verify(message.tasks[i]);
                        if (error)
                            return "tasks." + error;
                    }
                }
                if (message.jobs != null && message.hasOwnProperty("jobs")) {
                    if (!Array.isArray(message.jobs))
                        return "jobs: array expected";
                    for (let i = 0; i < message.jobs.length; ++i) {
                        let error = $root.oracle_job.OracleJob.verify(message.jobs[i]);
                        if (error)
                            return "jobs." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MaxTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.MaxTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.MaxTask} MaxTask
             */
            MaxTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.MaxTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.MaxTask();
                if (object.tasks) {
                    if (!Array.isArray(object.tasks))
                        throw TypeError(".oracle_job.OracleJob.MaxTask.tasks: array expected");
                    message.tasks = [];
                    for (let i = 0; i < object.tasks.length; ++i) {
                        if (typeof object.tasks[i] !== "object")
                            throw TypeError(".oracle_job.OracleJob.MaxTask.tasks: object expected");
                        message.tasks[i] = $root.oracle_job.OracleJob.Task.fromObject(object.tasks[i]);
                    }
                }
                if (object.jobs) {
                    if (!Array.isArray(object.jobs))
                        throw TypeError(".oracle_job.OracleJob.MaxTask.jobs: array expected");
                    message.jobs = [];
                    for (let i = 0; i < object.jobs.length; ++i) {
                        if (typeof object.jobs[i] !== "object")
                            throw TypeError(".oracle_job.OracleJob.MaxTask.jobs: object expected");
                        message.jobs[i] = $root.oracle_job.OracleJob.fromObject(object.jobs[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MaxTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.MaxTask
             * @static
             * @param {oracle_job.OracleJob.MaxTask} message MaxTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MaxTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.tasks = [];
                    object.jobs = [];
                }
                if (message.tasks && message.tasks.length) {
                    object.tasks = [];
                    for (let j = 0; j < message.tasks.length; ++j)
                        object.tasks[j] = $root.oracle_job.OracleJob.Task.toObject(message.tasks[j], options);
                }
                if (message.jobs && message.jobs.length) {
                    object.jobs = [];
                    for (let j = 0; j < message.jobs.length; ++j)
                        object.jobs[j] = $root.oracle_job.OracleJob.toObject(message.jobs[j], options);
                }
                return object;
            };

            /**
             * Converts this MaxTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.MaxTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MaxTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MaxTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.MaxTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MaxTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.MaxTask";
            };

            return MaxTask;
        })();

        OracleJob.MinTask = (function() {

            /**
             * Properties of a MinTask.
             * @memberof oracle_job.OracleJob
             * @interface IMinTask
             * @property {Array.<oracle_job.OracleJob.ITask>|null} [tasks] A list of subtasks to process and produce a list of result values.
             * @property {Array.<oracle_job.IOracleJob>|null} [jobs] A list of subjobs to process and produce a list of result values.
             */

            /**
             * Constructs a new MinTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Returns the minimum value of all the results returned by the provided subtasks and subjobs. Nested tasks or jobs must return a Number.
             * 
             * _**Input**_: None
             * 
             * _**Returns**_: A numerical result.
             * 
             * _**Example**_: Returns the minimum numerical result from 3 tasks.
             * 
             * ```json
             * {"minTask": {"tasks": [{"valueTask": {"value": 10}},{"valueTask": {"value": 20}},{"valueTask": {"value": 30}}]}}
             * ```
             * 
             * _**Example**_: Returns the minimum numerical result from 3 jobs.
             * 
             * ```json
             * {"minTask": {"jobs": [{"tasks": [{"httpTask": {"url": "https://www.binance.com/api/v3/ticker/price?symbol=SOLUSDT"}},{"jsonParseTask": {"path": "$.price"}}]},{"tasks": [{"httpTask": {"url": "https://www.binance.us/api/v3/ticker/price?symbol=SOLUSD"}},{"jsonParseTask": {"path": "$.price"}}]},{"tasks": [{"httpTask": {"url": "https://api-pub.bitfinex.com/v2/tickers?symbols=tSOLUSD"}},{"jsonParseTask": {"path": "$[0][7]"}}]}]}}
             * ```
             * @implements IMinTask
             * @constructor
             * @param {oracle_job.OracleJob.IMinTask=} [properties] Properties to set
             */
            function MinTask(properties) {
                this.tasks = [];
                this.jobs = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * A list of subtasks to process and produce a list of result values.
             * @member {Array.<oracle_job.OracleJob.ITask>} tasks
             * @memberof oracle_job.OracleJob.MinTask
             * @instance
             */
            MinTask.prototype.tasks = $util.emptyArray;

            /**
             * A list of subjobs to process and produce a list of result values.
             * @member {Array.<oracle_job.IOracleJob>} jobs
             * @memberof oracle_job.OracleJob.MinTask
             * @instance
             */
            MinTask.prototype.jobs = $util.emptyArray;

            /**
             * Creates a new MinTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.MinTask
             * @static
             * @param {oracle_job.OracleJob.IMinTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.MinTask} MinTask instance
             */
            MinTask.create = function create(properties) {
      return MinTask.fromObject(properties);
    };

            /**
             * Encodes the specified MinTask message. Does not implicitly {@link oracle_job.OracleJob.MinTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.MinTask
             * @static
             * @param {oracle_job.OracleJob.IMinTask} message MinTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MinTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tasks != null && message.tasks.length)
                    for (let i = 0; i < message.tasks.length; ++i)
                        $root.oracle_job.OracleJob.Task.encode(message.tasks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.jobs != null && message.jobs.length)
                    for (let i = 0; i < message.jobs.length; ++i)
                        $root.oracle_job.OracleJob.encode(message.jobs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MinTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.MinTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.MinTask
             * @static
             * @param {oracle_job.OracleJob.IMinTask} message MinTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MinTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MinTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.MinTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.MinTask} MinTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MinTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.MinTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.tasks && message.tasks.length))
                                message.tasks = [];
                            message.tasks.push($root.oracle_job.OracleJob.Task.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            if (!(message.jobs && message.jobs.length))
                                message.jobs = [];
                            message.jobs.push($root.oracle_job.OracleJob.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MinTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.MinTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.MinTask} MinTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MinTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MinTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.MinTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MinTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tasks != null && message.hasOwnProperty("tasks")) {
                    if (!Array.isArray(message.tasks))
                        return "tasks: array expected";
                    for (let i = 0; i < message.tasks.length; ++i) {
                        let error = $root.oracle_job.OracleJob.Task.verify(message.tasks[i]);
                        if (error)
                            return "tasks." + error;
                    }
                }
                if (message.jobs != null && message.hasOwnProperty("jobs")) {
                    if (!Array.isArray(message.jobs))
                        return "jobs: array expected";
                    for (let i = 0; i < message.jobs.length; ++i) {
                        let error = $root.oracle_job.OracleJob.verify(message.jobs[i]);
                        if (error)
                            return "jobs." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MinTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.MinTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.MinTask} MinTask
             */
            MinTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.MinTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.MinTask();
                if (object.tasks) {
                    if (!Array.isArray(object.tasks))
                        throw TypeError(".oracle_job.OracleJob.MinTask.tasks: array expected");
                    message.tasks = [];
                    for (let i = 0; i < object.tasks.length; ++i) {
                        if (typeof object.tasks[i] !== "object")
                            throw TypeError(".oracle_job.OracleJob.MinTask.tasks: object expected");
                        message.tasks[i] = $root.oracle_job.OracleJob.Task.fromObject(object.tasks[i]);
                    }
                }
                if (object.jobs) {
                    if (!Array.isArray(object.jobs))
                        throw TypeError(".oracle_job.OracleJob.MinTask.jobs: array expected");
                    message.jobs = [];
                    for (let i = 0; i < object.jobs.length; ++i) {
                        if (typeof object.jobs[i] !== "object")
                            throw TypeError(".oracle_job.OracleJob.MinTask.jobs: object expected");
                        message.jobs[i] = $root.oracle_job.OracleJob.fromObject(object.jobs[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MinTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.MinTask
             * @static
             * @param {oracle_job.OracleJob.MinTask} message MinTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MinTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.tasks = [];
                    object.jobs = [];
                }
                if (message.tasks && message.tasks.length) {
                    object.tasks = [];
                    for (let j = 0; j < message.tasks.length; ++j)
                        object.tasks[j] = $root.oracle_job.OracleJob.Task.toObject(message.tasks[j], options);
                }
                if (message.jobs && message.jobs.length) {
                    object.jobs = [];
                    for (let j = 0; j < message.jobs.length; ++j)
                        object.jobs[j] = $root.oracle_job.OracleJob.toObject(message.jobs[j], options);
                }
                return object;
            };

            /**
             * Converts this MinTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.MinTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MinTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MinTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.MinTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MinTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.MinTask";
            };

            return MinTask;
        })();

        OracleJob.ValueTask = (function() {

            /**
             * Properties of a ValueTask.
             * @memberof oracle_job.OracleJob
             * @interface IValueTask
             * @property {number|null} [value] The value that will be returned from this task.
             * @property {string|null} [aggregatorPubkey] Specifies an aggregatorr to pull the value of.
             * @property {string|null} [big] A stringified big.js. `Accepts variable expansion syntax.`
             * @property {string|null} [hex] A stringified hex number (0x prefix is optional).
             * @property {string|null} [utf8] A utf8 string.
             */

            /**
             * Constructs a new ValueTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Returns a specified value.
             * 
             * _**Input**_: None
             * 
             * _**Returns**_: A numerical result.
             * 
             * _**Example**_: Returns the value 10
             * 
             * ```json
             * {"valueTask": {"value": 10} }
             * ```
             * 
             * _**Example**_: Returns the currentRound result of an aggregator
             * 
             * ```json
             * {"valueTask": {"aggregatorPubkey": "GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR"} }
             * ```
             * 
             * _**Example**_: Returns the value stored in a CacheTask variable
             * 
             * ```json
             * {"valueTask": {"big": "${ONE}"} }
             * ```
             * @implements IValueTask
             * @constructor
             * @param {oracle_job.OracleJob.IValueTask=} [properties] Properties to set
             */
            function ValueTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The value that will be returned from this task.
             * @member {number|null|undefined} value
             * @memberof oracle_job.OracleJob.ValueTask
             * @instance
             */
            ValueTask.prototype.value = null;

            /**
             * Specifies an aggregatorr to pull the value of.
             * @member {string|null|undefined} aggregatorPubkey
             * @memberof oracle_job.OracleJob.ValueTask
             * @instance
             */
            ValueTask.prototype.aggregatorPubkey = null;

            /**
             * A stringified big.js. `Accepts variable expansion syntax.`
             * @member {string|null|undefined} big
             * @memberof oracle_job.OracleJob.ValueTask
             * @instance
             */
            ValueTask.prototype.big = null;

            /**
             * A stringified hex number (0x prefix is optional).
             * @member {string|null|undefined} hex
             * @memberof oracle_job.OracleJob.ValueTask
             * @instance
             */
            ValueTask.prototype.hex = null;

            /**
             * A utf8 string.
             * @member {string|null|undefined} utf8
             * @memberof oracle_job.OracleJob.ValueTask
             * @instance
             */
            ValueTask.prototype.utf8 = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * ValueTask Value.
             * @member {"value"|"aggregatorPubkey"|"big"|"hex"|"utf8"|undefined} Value
             * @memberof oracle_job.OracleJob.ValueTask
             * @instance
             */
            Object.defineProperty(ValueTask.prototype, "Value", {
                get: $util.oneOfGetter($oneOfFields = ["value", "aggregatorPubkey", "big", "hex", "utf8"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ValueTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.ValueTask
             * @static
             * @param {oracle_job.OracleJob.IValueTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.ValueTask} ValueTask instance
             */
            ValueTask.create = function create(properties) {
      return ValueTask.fromObject(properties);
    };

            /**
             * Encodes the specified ValueTask message. Does not implicitly {@link oracle_job.OracleJob.ValueTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.ValueTask
             * @static
             * @param {oracle_job.OracleJob.IValueTask} message ValueTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ValueTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.value);
                if (message.aggregatorPubkey != null && Object.hasOwnProperty.call(message, "aggregatorPubkey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.aggregatorPubkey);
                if (message.big != null && Object.hasOwnProperty.call(message, "big"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.big);
                if (message.hex != null && Object.hasOwnProperty.call(message, "hex"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.hex);
                if (message.utf8 != null && Object.hasOwnProperty.call(message, "utf8"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.utf8);
                return writer;
            };

            /**
             * Encodes the specified ValueTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.ValueTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.ValueTask
             * @static
             * @param {oracle_job.OracleJob.IValueTask} message ValueTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ValueTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ValueTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.ValueTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.ValueTask} ValueTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ValueTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.ValueTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.value = reader.double();
                            break;
                        }
                    case 2: {
                            message.aggregatorPubkey = reader.string();
                            break;
                        }
                    case 3: {
                            message.big = reader.string();
                            break;
                        }
                    case 4: {
                            message.hex = reader.string();
                            break;
                        }
                    case 5: {
                            message.utf8 = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ValueTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.ValueTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.ValueTask} ValueTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ValueTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ValueTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.ValueTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ValueTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.value != null && message.hasOwnProperty("value")) {
                    properties.Value = 1;
                    if (typeof message.value !== "number")
                        return "value: number expected";
                }
                if (message.aggregatorPubkey != null && message.hasOwnProperty("aggregatorPubkey")) {
                    if (properties.Value === 1)
                        return "Value: multiple values";
                    properties.Value = 1;
                    if (!$util.isString(message.aggregatorPubkey))
                        return "aggregatorPubkey: string expected";
                }
                if (message.big != null && message.hasOwnProperty("big")) {
                    if (properties.Value === 1)
                        return "Value: multiple values";
                    properties.Value = 1;
                    if (!$util.isString(message.big))
                        return "big: string expected";
                }
                if (message.hex != null && message.hasOwnProperty("hex")) {
                    if (properties.Value === 1)
                        return "Value: multiple values";
                    properties.Value = 1;
                    if (!$util.isString(message.hex))
                        return "hex: string expected";
                }
                if (message.utf8 != null && message.hasOwnProperty("utf8")) {
                    if (properties.Value === 1)
                        return "Value: multiple values";
                    properties.Value = 1;
                    if (!$util.isString(message.utf8))
                        return "utf8: string expected";
                }
                return null;
            };

            /**
             * Creates a ValueTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.ValueTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.ValueTask} ValueTask
             */
            ValueTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.ValueTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.ValueTask();
                if (object.value != null)
                    message.value = Number(object.value);
                if (object.aggregatorPubkey != null)
                    message.aggregatorPubkey = String(object.aggregatorPubkey);
                if (object.big != null)
                    message.big = String(object.big);
                if (object.hex != null)
                    message.hex = String(object.hex);
                if (object.utf8 != null)
                    message.utf8 = String(object.utf8);
                return message;
            };

            /**
             * Creates a plain object from a ValueTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.ValueTask
             * @static
             * @param {oracle_job.OracleJob.ValueTask} message ValueTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ValueTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.value != null && message.hasOwnProperty("value")) {
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                    if (options.oneofs)
                        object.Value = "value";
                }
                if (message.aggregatorPubkey != null && message.hasOwnProperty("aggregatorPubkey")) {
                    object.aggregatorPubkey = message.aggregatorPubkey;
                    if (options.oneofs)
                        object.Value = "aggregatorPubkey";
                }
                if (message.big != null && message.hasOwnProperty("big")) {
                    object.big = message.big;
                    if (options.oneofs)
                        object.Value = "big";
                }
                if (message.hex != null && message.hasOwnProperty("hex")) {
                    object.hex = message.hex;
                    if (options.oneofs)
                        object.Value = "hex";
                }
                if (message.utf8 != null && message.hasOwnProperty("utf8")) {
                    object.utf8 = message.utf8;
                    if (options.oneofs)
                        object.Value = "utf8";
                }
                return object;
            };

            /**
             * Converts this ValueTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.ValueTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ValueTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ValueTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.ValueTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ValueTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.ValueTask";
            };

            return ValueTask;
        })();

        OracleJob.WebsocketTask = (function() {

            /**
             * Properties of a WebsocketTask.
             * @memberof oracle_job.OracleJob
             * @interface IWebsocketTask
             * @property {string|null} [url] The websocket url.
             * @property {string|null} [subscription] The websocket message to notify of a new subscription.
             * @property {number|null} [maxDataAgeSeconds] Minimum amount of time required between when the horses are taking out.
             * @property {string|null} [filter] Incoming message JSONPath filter.
             * Example: "$[?(@.channel == 'ticker' && @.market == 'BTC/USD')]"
             */

            /**
             * Constructs a new WebsocketTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Opens and maintains a websocket for light speed data retrieval.
             * 
             * _**Input**_: None
             * 
             * _**Returns**_: String representation of the websocket subscription message.
             * 
             * _**Example**_: Opens a coinbase websocket
             * 
             * ```json
             * { "websocketTask": { "url": "wss://ws-feed.pro.coinbase.com", "subscription": "{\"type\":\"subscribe\",\"product_ids\":[\"BTC-USD\"],\"channels\":[\"ticker\",{\"name\":\"ticker\",\"product_ids\":[\"BTC-USD\"]}]}", "maxDataAgeSeconds": 15, "filter": "$[?(@.type == 'ticker' && @.product_id == 'BTC-USD')]" } }
             * ```
             * @implements IWebsocketTask
             * @constructor
             * @param {oracle_job.OracleJob.IWebsocketTask=} [properties] Properties to set
             */
            function WebsocketTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The websocket url.
             * @member {string} url
             * @memberof oracle_job.OracleJob.WebsocketTask
             * @instance
             */
            WebsocketTask.prototype.url = "";

            /**
             * The websocket message to notify of a new subscription.
             * @member {string} subscription
             * @memberof oracle_job.OracleJob.WebsocketTask
             * @instance
             */
            WebsocketTask.prototype.subscription = "";

            /**
             * Minimum amount of time required between when the horses are taking out.
             * @member {number} maxDataAgeSeconds
             * @memberof oracle_job.OracleJob.WebsocketTask
             * @instance
             */
            WebsocketTask.prototype.maxDataAgeSeconds = 0;

            /**
             * Incoming message JSONPath filter.
             * Example: "$[?(@.channel == 'ticker' && @.market == 'BTC/USD')]"
             * @member {string} filter
             * @memberof oracle_job.OracleJob.WebsocketTask
             * @instance
             */
            WebsocketTask.prototype.filter = "";

            /**
             * Creates a new WebsocketTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.WebsocketTask
             * @static
             * @param {oracle_job.OracleJob.IWebsocketTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.WebsocketTask} WebsocketTask instance
             */
            WebsocketTask.create = function create(properties) {
      return WebsocketTask.fromObject(properties);
    };

            /**
             * Encodes the specified WebsocketTask message. Does not implicitly {@link oracle_job.OracleJob.WebsocketTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.WebsocketTask
             * @static
             * @param {oracle_job.OracleJob.IWebsocketTask} message WebsocketTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WebsocketTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                if (message.subscription != null && Object.hasOwnProperty.call(message, "subscription"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.subscription);
                if (message.maxDataAgeSeconds != null && Object.hasOwnProperty.call(message, "maxDataAgeSeconds"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.maxDataAgeSeconds);
                if (message.filter != null && Object.hasOwnProperty.call(message, "filter"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.filter);
                return writer;
            };

            /**
             * Encodes the specified WebsocketTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.WebsocketTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.WebsocketTask
             * @static
             * @param {oracle_job.OracleJob.IWebsocketTask} message WebsocketTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WebsocketTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WebsocketTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.WebsocketTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.WebsocketTask} WebsocketTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WebsocketTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.WebsocketTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.url = reader.string();
                            break;
                        }
                    case 2: {
                            message.subscription = reader.string();
                            break;
                        }
                    case 3: {
                            message.maxDataAgeSeconds = reader.int32();
                            break;
                        }
                    case 4: {
                            message.filter = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WebsocketTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.WebsocketTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.WebsocketTask} WebsocketTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WebsocketTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WebsocketTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.WebsocketTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WebsocketTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                if (message.subscription != null && message.hasOwnProperty("subscription"))
                    if (!$util.isString(message.subscription))
                        return "subscription: string expected";
                if (message.maxDataAgeSeconds != null && message.hasOwnProperty("maxDataAgeSeconds"))
                    if (!$util.isInteger(message.maxDataAgeSeconds))
                        return "maxDataAgeSeconds: integer expected";
                if (message.filter != null && message.hasOwnProperty("filter"))
                    if (!$util.isString(message.filter))
                        return "filter: string expected";
                return null;
            };

            /**
             * Creates a WebsocketTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.WebsocketTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.WebsocketTask} WebsocketTask
             */
            WebsocketTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.WebsocketTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.WebsocketTask();
                if (object.url != null)
                    message.url = String(object.url);
                if (object.subscription != null)
                    message.subscription = String(object.subscription);
                if (object.maxDataAgeSeconds != null)
                    message.maxDataAgeSeconds = object.maxDataAgeSeconds | 0;
                if (object.filter != null)
                    message.filter = String(object.filter);
                return message;
            };

            /**
             * Creates a plain object from a WebsocketTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.WebsocketTask
             * @static
             * @param {oracle_job.OracleJob.WebsocketTask} message WebsocketTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WebsocketTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.url = "";
                    object.subscription = "";
                    object.maxDataAgeSeconds = 0;
                    object.filter = "";
                }
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                if (message.subscription != null && message.hasOwnProperty("subscription"))
                    object.subscription = message.subscription;
                if (message.maxDataAgeSeconds != null && message.hasOwnProperty("maxDataAgeSeconds"))
                    object.maxDataAgeSeconds = message.maxDataAgeSeconds;
                if (message.filter != null && message.hasOwnProperty("filter"))
                    object.filter = message.filter;
                return object;
            };

            /**
             * Converts this WebsocketTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.WebsocketTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WebsocketTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for WebsocketTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.WebsocketTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            WebsocketTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.WebsocketTask";
            };

            return WebsocketTask;
        })();

        OracleJob.ConditionalTask = (function() {

            /**
             * Properties of a ConditionalTask.
             * @memberof oracle_job.OracleJob
             * @interface IConditionalTask
             * @property {Array.<oracle_job.OracleJob.ITask>|null} [attempt] A list of subtasks to process in an attempt to produce a valid numerical result.
             * @property {Array.<oracle_job.OracleJob.ITask>|null} [onFailure] A list of subtasks that will be run if `attempt` subtasks are unable to produce an acceptable
             * result.
             */

            /**
             * Constructs a new ConditionalTask.
             * @memberof oracle_job.OracleJob
             * @classdesc This task will run the `attempt` on the subtasks in an effort to produce a valid numerical result. If `attempt`. fails to produce an acceptable result, `on_failure` subtasks will be run instead.
             * 
             * _**Input**_: The current running numerical result output from a task.
             * 
             * _**Returns**_: A numerical result, else run `on_failure` subtasks.
             * 
             * _**Example**_: Returns the numerical result from the conditionalTask's subtasks, else `on_failure` returns the numerical result from its subtasks.
             * 
             * ```json
             * {"conditionalTask":{"attempt":[{"tasks":[{"jupiterSwapTask":{"inTokenAddress":"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v","outTokenAddress":"DUALa4FC2yREwZ59PHeu1un4wis36vHRv5hWVBmzykCJ"}}]}],"onFailure":[{"lpExchangeRateTask":{"orcaPoolAddress":"7yJ4gMRJhEoCR48aPE3EAWRmCoygakik81ZS1sajaTnE"}}]}}
             * ```
             * @implements IConditionalTask
             * @constructor
             * @param {oracle_job.OracleJob.IConditionalTask=} [properties] Properties to set
             */
            function ConditionalTask(properties) {
                this.attempt = [];
                this.onFailure = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * A list of subtasks to process in an attempt to produce a valid numerical result.
             * @member {Array.<oracle_job.OracleJob.ITask>} attempt
             * @memberof oracle_job.OracleJob.ConditionalTask
             * @instance
             */
            ConditionalTask.prototype.attempt = $util.emptyArray;

            /**
             * A list of subtasks that will be run if `attempt` subtasks are unable to produce an acceptable
             * result.
             * @member {Array.<oracle_job.OracleJob.ITask>} onFailure
             * @memberof oracle_job.OracleJob.ConditionalTask
             * @instance
             */
            ConditionalTask.prototype.onFailure = $util.emptyArray;

            /**
             * Creates a new ConditionalTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.ConditionalTask
             * @static
             * @param {oracle_job.OracleJob.IConditionalTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.ConditionalTask} ConditionalTask instance
             */
            ConditionalTask.create = function create(properties) {
      return ConditionalTask.fromObject(properties);
    };

            /**
             * Encodes the specified ConditionalTask message. Does not implicitly {@link oracle_job.OracleJob.ConditionalTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.ConditionalTask
             * @static
             * @param {oracle_job.OracleJob.IConditionalTask} message ConditionalTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConditionalTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.attempt != null && message.attempt.length)
                    for (let i = 0; i < message.attempt.length; ++i)
                        $root.oracle_job.OracleJob.Task.encode(message.attempt[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.onFailure != null && message.onFailure.length)
                    for (let i = 0; i < message.onFailure.length; ++i)
                        $root.oracle_job.OracleJob.Task.encode(message.onFailure[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ConditionalTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.ConditionalTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.ConditionalTask
             * @static
             * @param {oracle_job.OracleJob.IConditionalTask} message ConditionalTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ConditionalTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ConditionalTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.ConditionalTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.ConditionalTask} ConditionalTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConditionalTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.ConditionalTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.attempt && message.attempt.length))
                                message.attempt = [];
                            message.attempt.push($root.oracle_job.OracleJob.Task.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            if (!(message.onFailure && message.onFailure.length))
                                message.onFailure = [];
                            message.onFailure.push($root.oracle_job.OracleJob.Task.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ConditionalTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.ConditionalTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.ConditionalTask} ConditionalTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ConditionalTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ConditionalTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.ConditionalTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ConditionalTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.attempt != null && message.hasOwnProperty("attempt")) {
                    if (!Array.isArray(message.attempt))
                        return "attempt: array expected";
                    for (let i = 0; i < message.attempt.length; ++i) {
                        let error = $root.oracle_job.OracleJob.Task.verify(message.attempt[i]);
                        if (error)
                            return "attempt." + error;
                    }
                }
                if (message.onFailure != null && message.hasOwnProperty("onFailure")) {
                    if (!Array.isArray(message.onFailure))
                        return "onFailure: array expected";
                    for (let i = 0; i < message.onFailure.length; ++i) {
                        let error = $root.oracle_job.OracleJob.Task.verify(message.onFailure[i]);
                        if (error)
                            return "onFailure." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ConditionalTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.ConditionalTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.ConditionalTask} ConditionalTask
             */
            ConditionalTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.ConditionalTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.ConditionalTask();
                if (object.attempt) {
                    if (!Array.isArray(object.attempt))
                        throw TypeError(".oracle_job.OracleJob.ConditionalTask.attempt: array expected");
                    message.attempt = [];
                    for (let i = 0; i < object.attempt.length; ++i) {
                        if (typeof object.attempt[i] !== "object")
                            throw TypeError(".oracle_job.OracleJob.ConditionalTask.attempt: object expected");
                        message.attempt[i] = $root.oracle_job.OracleJob.Task.fromObject(object.attempt[i]);
                    }
                }
                if (object.onFailure) {
                    if (!Array.isArray(object.onFailure))
                        throw TypeError(".oracle_job.OracleJob.ConditionalTask.onFailure: array expected");
                    message.onFailure = [];
                    for (let i = 0; i < object.onFailure.length; ++i) {
                        if (typeof object.onFailure[i] !== "object")
                            throw TypeError(".oracle_job.OracleJob.ConditionalTask.onFailure: object expected");
                        message.onFailure[i] = $root.oracle_job.OracleJob.Task.fromObject(object.onFailure[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ConditionalTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.ConditionalTask
             * @static
             * @param {oracle_job.OracleJob.ConditionalTask} message ConditionalTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ConditionalTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.attempt = [];
                    object.onFailure = [];
                }
                if (message.attempt && message.attempt.length) {
                    object.attempt = [];
                    for (let j = 0; j < message.attempt.length; ++j)
                        object.attempt[j] = $root.oracle_job.OracleJob.Task.toObject(message.attempt[j], options);
                }
                if (message.onFailure && message.onFailure.length) {
                    object.onFailure = [];
                    for (let j = 0; j < message.onFailure.length; ++j)
                        object.onFailure[j] = $root.oracle_job.OracleJob.Task.toObject(message.onFailure[j], options);
                }
                return object;
            };

            /**
             * Converts this ConditionalTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.ConditionalTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ConditionalTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ConditionalTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.ConditionalTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ConditionalTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.ConditionalTask";
            };

            return ConditionalTask;
        })();

        OracleJob.DivideTask = (function() {

            /**
             * Properties of a DivideTask.
             * @memberof oracle_job.OracleJob
             * @interface IDivideTask
             * @property {number|null} [scalar] Specifies a basic scalar denominator to divide by.
             * @property {string|null} [aggregatorPubkey] Specifies another aggregator resut to divide by.
             * @property {oracle_job.IOracleJob|null} [job] A job whose result is computed before dividing our numerical input by that result.
             * @property {string|null} [big] A stringified big.js. `Accepts variable expansion syntax.`
             */

            /**
             * Constructs a new DivideTask.
             * @memberof oracle_job.OracleJob
             * @classdesc This task will divide a numerical input by a scalar value from a job of subtasks, an aggregator, or a big.
             * 
             * _**Input**_: The current running numerical result output from a scalar value, an aggregator, a job of subtasks or a big.
             * 
             * _**Returns**_: A numerical result.
             * 
             * _**Example**_: Returns the numerical result by dividing by a job of subtasks.
             * 
             * ```json
             * {"tasks":[{"valueTask":{"value":100}},{"divideTask":{"job":{"tasks":[{"valueTask":{"value":10}}]}}}]}
             * ```
             * 
             * _**Example**_: Returns the numerical result by dividing by an aggregator.
             * 
             * ```json
             * {"tasks":[{"valueTask":{"value":100}},{"divideTask":{"aggregatorPubkey":"GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR"}}]}
             * ```
             * 
             * _**Example**_: Returns the numerical result by dividing by a big.
             * 
             * ```json
             * {"tasks":[{"cacheTask":{"cacheItems":[{"variableName":"TEN","job":{"tasks":[{"valueTask":{"value":10}}]}}]}},{"valueTask":{"value":100}},{"divideTask":{"big":"${TEN}"}}]}
             * ```
             * @implements IDivideTask
             * @constructor
             * @param {oracle_job.OracleJob.IDivideTask=} [properties] Properties to set
             */
            function DivideTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Specifies a basic scalar denominator to divide by.
             * @member {number|null|undefined} scalar
             * @memberof oracle_job.OracleJob.DivideTask
             * @instance
             */
            DivideTask.prototype.scalar = null;

            /**
             * Specifies another aggregator resut to divide by.
             * @member {string|null|undefined} aggregatorPubkey
             * @memberof oracle_job.OracleJob.DivideTask
             * @instance
             */
            DivideTask.prototype.aggregatorPubkey = null;

            /**
             * A job whose result is computed before dividing our numerical input by that result.
             * @member {oracle_job.IOracleJob|null|undefined} job
             * @memberof oracle_job.OracleJob.DivideTask
             * @instance
             */
            DivideTask.prototype.job = null;

            /**
             * A stringified big.js. `Accepts variable expansion syntax.`
             * @member {string|null|undefined} big
             * @memberof oracle_job.OracleJob.DivideTask
             * @instance
             */
            DivideTask.prototype.big = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * DivideTask Denominator.
             * @member {"scalar"|"aggregatorPubkey"|"job"|"big"|undefined} Denominator
             * @memberof oracle_job.OracleJob.DivideTask
             * @instance
             */
            Object.defineProperty(DivideTask.prototype, "Denominator", {
                get: $util.oneOfGetter($oneOfFields = ["scalar", "aggregatorPubkey", "job", "big"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new DivideTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.DivideTask
             * @static
             * @param {oracle_job.OracleJob.IDivideTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.DivideTask} DivideTask instance
             */
            DivideTask.create = function create(properties) {
      return DivideTask.fromObject(properties);
    };

            /**
             * Encodes the specified DivideTask message. Does not implicitly {@link oracle_job.OracleJob.DivideTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.DivideTask
             * @static
             * @param {oracle_job.OracleJob.IDivideTask} message DivideTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DivideTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.scalar != null && Object.hasOwnProperty.call(message, "scalar"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.scalar);
                if (message.aggregatorPubkey != null && Object.hasOwnProperty.call(message, "aggregatorPubkey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.aggregatorPubkey);
                if (message.job != null && Object.hasOwnProperty.call(message, "job"))
                    $root.oracle_job.OracleJob.encode(message.job, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.big != null && Object.hasOwnProperty.call(message, "big"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.big);
                return writer;
            };

            /**
             * Encodes the specified DivideTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.DivideTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.DivideTask
             * @static
             * @param {oracle_job.OracleJob.IDivideTask} message DivideTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DivideTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DivideTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.DivideTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.DivideTask} DivideTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DivideTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.DivideTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.scalar = reader.double();
                            break;
                        }
                    case 2: {
                            message.aggregatorPubkey = reader.string();
                            break;
                        }
                    case 3: {
                            message.job = $root.oracle_job.OracleJob.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.big = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DivideTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.DivideTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.DivideTask} DivideTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DivideTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DivideTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.DivideTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DivideTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.scalar != null && message.hasOwnProperty("scalar")) {
                    properties.Denominator = 1;
                    if (typeof message.scalar !== "number")
                        return "scalar: number expected";
                }
                if (message.aggregatorPubkey != null && message.hasOwnProperty("aggregatorPubkey")) {
                    if (properties.Denominator === 1)
                        return "Denominator: multiple values";
                    properties.Denominator = 1;
                    if (!$util.isString(message.aggregatorPubkey))
                        return "aggregatorPubkey: string expected";
                }
                if (message.job != null && message.hasOwnProperty("job")) {
                    if (properties.Denominator === 1)
                        return "Denominator: multiple values";
                    properties.Denominator = 1;
                    {
                        let error = $root.oracle_job.OracleJob.verify(message.job);
                        if (error)
                            return "job." + error;
                    }
                }
                if (message.big != null && message.hasOwnProperty("big")) {
                    if (properties.Denominator === 1)
                        return "Denominator: multiple values";
                    properties.Denominator = 1;
                    if (!$util.isString(message.big))
                        return "big: string expected";
                }
                return null;
            };

            /**
             * Creates a DivideTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.DivideTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.DivideTask} DivideTask
             */
            DivideTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.DivideTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.DivideTask();
                if (object.scalar != null)
                    message.scalar = Number(object.scalar);
                if (object.aggregatorPubkey != null)
                    message.aggregatorPubkey = String(object.aggregatorPubkey);
                if (object.job != null) {
                    if (typeof object.job !== "object")
                        throw TypeError(".oracle_job.OracleJob.DivideTask.job: object expected");
                    message.job = $root.oracle_job.OracleJob.fromObject(object.job);
                }
                if (object.big != null)
                    message.big = String(object.big);
                return message;
            };

            /**
             * Creates a plain object from a DivideTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.DivideTask
             * @static
             * @param {oracle_job.OracleJob.DivideTask} message DivideTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DivideTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.scalar != null && message.hasOwnProperty("scalar")) {
                    object.scalar = options.json && !isFinite(message.scalar) ? String(message.scalar) : message.scalar;
                    if (options.oneofs)
                        object.Denominator = "scalar";
                }
                if (message.aggregatorPubkey != null && message.hasOwnProperty("aggregatorPubkey")) {
                    object.aggregatorPubkey = message.aggregatorPubkey;
                    if (options.oneofs)
                        object.Denominator = "aggregatorPubkey";
                }
                if (message.job != null && message.hasOwnProperty("job")) {
                    object.job = $root.oracle_job.OracleJob.toObject(message.job, options);
                    if (options.oneofs)
                        object.Denominator = "job";
                }
                if (message.big != null && message.hasOwnProperty("big")) {
                    object.big = message.big;
                    if (options.oneofs)
                        object.Denominator = "big";
                }
                return object;
            };

            /**
             * Converts this DivideTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.DivideTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DivideTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DivideTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.DivideTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DivideTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.DivideTask";
            };

            return DivideTask;
        })();

        OracleJob.MultiplyTask = (function() {

            /**
             * Properties of a MultiplyTask.
             * @memberof oracle_job.OracleJob
             * @interface IMultiplyTask
             * @property {number|null} [scalar] Specifies a scalar to multiply by.
             * @property {string|null} [aggregatorPubkey] Specifies an aggregator to multiply by.
             * @property {oracle_job.IOracleJob|null} [job] A job whose result is computed before multiplying our numerical input by that result.
             * @property {string|null} [big] A stringified big.js. `Accepts variable expansion syntax.`
             */

            /**
             * Constructs a new MultiplyTask.
             * @memberof oracle_job.OracleJob
             * @classdesc This task will multiply a numerical input by a scalar value from a job of subtasks, an aggregator, or a big.
             * 
             * _**Input**_: The current running numerical result output from a scalar value, an aggregator, a job of subtasks or a big.
             * 
             * _**Returns**_: A numerical result.
             * 
             * _**Example**_: Returns the numerical result by multiplying by a job of subtasks.
             * 
             * ```json
             * {"tasks":[{"valueTask":{"value":100}},{"multiplyTask":{"job":{"tasks":[{"valueTask":{"value":10}}]}}}]}
             * ```
             * 
             * _**Example**_: Returns the numerical result by multiplying by an aggregator.
             * 
             * ```json
             * {"tasks":[{"valueTask":{"value":100}},{"multiplyTask":{"aggregatorPubkey":"GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR"}}]}
             * ```
             * 
             * _**Example**_: Returns the numerical result by multiplying by a big.
             * 
             * ```json
             * {"tasks":[{"cacheTask":{"cacheItems":[{"variableName":"TEN","job":{"tasks":[{"valueTask":{"value":10}}]}}]}},{"valueTask":{"value":100}},{"multiplyTask":{"big":"${TEN}"}}]}
             * ```
             * @implements IMultiplyTask
             * @constructor
             * @param {oracle_job.OracleJob.IMultiplyTask=} [properties] Properties to set
             */
            function MultiplyTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Specifies a scalar to multiply by.
             * @member {number|null|undefined} scalar
             * @memberof oracle_job.OracleJob.MultiplyTask
             * @instance
             */
            MultiplyTask.prototype.scalar = null;

            /**
             * Specifies an aggregator to multiply by.
             * @member {string|null|undefined} aggregatorPubkey
             * @memberof oracle_job.OracleJob.MultiplyTask
             * @instance
             */
            MultiplyTask.prototype.aggregatorPubkey = null;

            /**
             * A job whose result is computed before multiplying our numerical input by that result.
             * @member {oracle_job.IOracleJob|null|undefined} job
             * @memberof oracle_job.OracleJob.MultiplyTask
             * @instance
             */
            MultiplyTask.prototype.job = null;

            /**
             * A stringified big.js. `Accepts variable expansion syntax.`
             * @member {string|null|undefined} big
             * @memberof oracle_job.OracleJob.MultiplyTask
             * @instance
             */
            MultiplyTask.prototype.big = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * MultiplyTask Multiple.
             * @member {"scalar"|"aggregatorPubkey"|"job"|"big"|undefined} Multiple
             * @memberof oracle_job.OracleJob.MultiplyTask
             * @instance
             */
            Object.defineProperty(MultiplyTask.prototype, "Multiple", {
                get: $util.oneOfGetter($oneOfFields = ["scalar", "aggregatorPubkey", "job", "big"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new MultiplyTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.MultiplyTask
             * @static
             * @param {oracle_job.OracleJob.IMultiplyTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.MultiplyTask} MultiplyTask instance
             */
            MultiplyTask.create = function create(properties) {
      return MultiplyTask.fromObject(properties);
    };

            /**
             * Encodes the specified MultiplyTask message. Does not implicitly {@link oracle_job.OracleJob.MultiplyTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.MultiplyTask
             * @static
             * @param {oracle_job.OracleJob.IMultiplyTask} message MultiplyTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MultiplyTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.scalar != null && Object.hasOwnProperty.call(message, "scalar"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.scalar);
                if (message.aggregatorPubkey != null && Object.hasOwnProperty.call(message, "aggregatorPubkey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.aggregatorPubkey);
                if (message.job != null && Object.hasOwnProperty.call(message, "job"))
                    $root.oracle_job.OracleJob.encode(message.job, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.big != null && Object.hasOwnProperty.call(message, "big"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.big);
                return writer;
            };

            /**
             * Encodes the specified MultiplyTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.MultiplyTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.MultiplyTask
             * @static
             * @param {oracle_job.OracleJob.IMultiplyTask} message MultiplyTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MultiplyTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MultiplyTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.MultiplyTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.MultiplyTask} MultiplyTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MultiplyTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.MultiplyTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.scalar = reader.double();
                            break;
                        }
                    case 2: {
                            message.aggregatorPubkey = reader.string();
                            break;
                        }
                    case 3: {
                            message.job = $root.oracle_job.OracleJob.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.big = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MultiplyTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.MultiplyTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.MultiplyTask} MultiplyTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MultiplyTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MultiplyTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.MultiplyTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MultiplyTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.scalar != null && message.hasOwnProperty("scalar")) {
                    properties.Multiple = 1;
                    if (typeof message.scalar !== "number")
                        return "scalar: number expected";
                }
                if (message.aggregatorPubkey != null && message.hasOwnProperty("aggregatorPubkey")) {
                    if (properties.Multiple === 1)
                        return "Multiple: multiple values";
                    properties.Multiple = 1;
                    if (!$util.isString(message.aggregatorPubkey))
                        return "aggregatorPubkey: string expected";
                }
                if (message.job != null && message.hasOwnProperty("job")) {
                    if (properties.Multiple === 1)
                        return "Multiple: multiple values";
                    properties.Multiple = 1;
                    {
                        let error = $root.oracle_job.OracleJob.verify(message.job);
                        if (error)
                            return "job." + error;
                    }
                }
                if (message.big != null && message.hasOwnProperty("big")) {
                    if (properties.Multiple === 1)
                        return "Multiple: multiple values";
                    properties.Multiple = 1;
                    if (!$util.isString(message.big))
                        return "big: string expected";
                }
                return null;
            };

            /**
             * Creates a MultiplyTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.MultiplyTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.MultiplyTask} MultiplyTask
             */
            MultiplyTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.MultiplyTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.MultiplyTask();
                if (object.scalar != null)
                    message.scalar = Number(object.scalar);
                if (object.aggregatorPubkey != null)
                    message.aggregatorPubkey = String(object.aggregatorPubkey);
                if (object.job != null) {
                    if (typeof object.job !== "object")
                        throw TypeError(".oracle_job.OracleJob.MultiplyTask.job: object expected");
                    message.job = $root.oracle_job.OracleJob.fromObject(object.job);
                }
                if (object.big != null)
                    message.big = String(object.big);
                return message;
            };

            /**
             * Creates a plain object from a MultiplyTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.MultiplyTask
             * @static
             * @param {oracle_job.OracleJob.MultiplyTask} message MultiplyTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MultiplyTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.scalar != null && message.hasOwnProperty("scalar")) {
                    object.scalar = options.json && !isFinite(message.scalar) ? String(message.scalar) : message.scalar;
                    if (options.oneofs)
                        object.Multiple = "scalar";
                }
                if (message.aggregatorPubkey != null && message.hasOwnProperty("aggregatorPubkey")) {
                    object.aggregatorPubkey = message.aggregatorPubkey;
                    if (options.oneofs)
                        object.Multiple = "aggregatorPubkey";
                }
                if (message.job != null && message.hasOwnProperty("job")) {
                    object.job = $root.oracle_job.OracleJob.toObject(message.job, options);
                    if (options.oneofs)
                        object.Multiple = "job";
                }
                if (message.big != null && message.hasOwnProperty("big")) {
                    object.big = message.big;
                    if (options.oneofs)
                        object.Multiple = "big";
                }
                return object;
            };

            /**
             * Converts this MultiplyTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.MultiplyTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MultiplyTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MultiplyTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.MultiplyTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MultiplyTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.MultiplyTask";
            };

            return MultiplyTask;
        })();

        OracleJob.AddTask = (function() {

            /**
             * Properties of an AddTask.
             * @memberof oracle_job.OracleJob
             * @interface IAddTask
             * @property {number|null} [scalar] Specifies a scalar to add by.
             * @property {string|null} [aggregatorPubkey] Specifies an aggregator to add by.
             * @property {oracle_job.IOracleJob|null} [job] A job whose result is computed before adding our numerical input by that result.
             * @property {string|null} [big] A stringified big.js. `Accepts variable expansion syntax.`
             */

            /**
             * Constructs a new AddTask.
             * @memberof oracle_job.OracleJob
             * @classdesc This task will add a numerical input by a scalar value from a job of subtasks, an aggregator, or a big.
             * 
             * _**Input**_: The current running numerical result output from a scalar value, an aggregator, a job of subtasks or a big.
             * 
             * _**Returns**_: A numerical result.
             * 
             * _**Example**_: Returns the numerical result by adding by a job of subtasks.
             * 
             * ```json
             * {"tasks":[{"valueTask":{"value":100}},{"addTask":{"job":{"tasks":[{"valueTask":{"value":10}}]}}}]}
             * ```
             * 
             * _**Example**_: Returns the numerical result by multiplying by an aggregator.
             * 
             * ```json
             * {"tasks":[{"valueTask":{"value":100}},{"addTask":{"aggregatorPubkey":"GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR"}}]}
             * ```
             * 
             * _**Example**_: Returns the numerical result by multiplying by a big.
             * 
             * ```json
             * {"tasks":[{"cacheTask":{"cacheItems":[{"variableName":"TEN","job":{"tasks":[{"valueTask":{"value":10}}]}}]}},{"valueTask":{"value":100}},{"addTask":{"big":"${TEN}"}}]}
             * ```
             * @implements IAddTask
             * @constructor
             * @param {oracle_job.OracleJob.IAddTask=} [properties] Properties to set
             */
            function AddTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Specifies a scalar to add by.
             * @member {number|null|undefined} scalar
             * @memberof oracle_job.OracleJob.AddTask
             * @instance
             */
            AddTask.prototype.scalar = null;

            /**
             * Specifies an aggregator to add by.
             * @member {string|null|undefined} aggregatorPubkey
             * @memberof oracle_job.OracleJob.AddTask
             * @instance
             */
            AddTask.prototype.aggregatorPubkey = null;

            /**
             * A job whose result is computed before adding our numerical input by that result.
             * @member {oracle_job.IOracleJob|null|undefined} job
             * @memberof oracle_job.OracleJob.AddTask
             * @instance
             */
            AddTask.prototype.job = null;

            /**
             * A stringified big.js. `Accepts variable expansion syntax.`
             * @member {string|null|undefined} big
             * @memberof oracle_job.OracleJob.AddTask
             * @instance
             */
            AddTask.prototype.big = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * AddTask Addition.
             * @member {"scalar"|"aggregatorPubkey"|"job"|"big"|undefined} Addition
             * @memberof oracle_job.OracleJob.AddTask
             * @instance
             */
            Object.defineProperty(AddTask.prototype, "Addition", {
                get: $util.oneOfGetter($oneOfFields = ["scalar", "aggregatorPubkey", "job", "big"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new AddTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.AddTask
             * @static
             * @param {oracle_job.OracleJob.IAddTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.AddTask} AddTask instance
             */
            AddTask.create = function create(properties) {
      return AddTask.fromObject(properties);
    };

            /**
             * Encodes the specified AddTask message. Does not implicitly {@link oracle_job.OracleJob.AddTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.AddTask
             * @static
             * @param {oracle_job.OracleJob.IAddTask} message AddTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.scalar != null && Object.hasOwnProperty.call(message, "scalar"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.scalar);
                if (message.aggregatorPubkey != null && Object.hasOwnProperty.call(message, "aggregatorPubkey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.aggregatorPubkey);
                if (message.job != null && Object.hasOwnProperty.call(message, "job"))
                    $root.oracle_job.OracleJob.encode(message.job, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.big != null && Object.hasOwnProperty.call(message, "big"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.big);
                return writer;
            };

            /**
             * Encodes the specified AddTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.AddTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.AddTask
             * @static
             * @param {oracle_job.OracleJob.IAddTask} message AddTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AddTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.AddTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.AddTask} AddTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.AddTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.scalar = reader.double();
                            break;
                        }
                    case 2: {
                            message.aggregatorPubkey = reader.string();
                            break;
                        }
                    case 3: {
                            message.job = $root.oracle_job.OracleJob.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.big = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AddTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.AddTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.AddTask} AddTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AddTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.AddTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AddTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.scalar != null && message.hasOwnProperty("scalar")) {
                    properties.Addition = 1;
                    if (typeof message.scalar !== "number")
                        return "scalar: number expected";
                }
                if (message.aggregatorPubkey != null && message.hasOwnProperty("aggregatorPubkey")) {
                    if (properties.Addition === 1)
                        return "Addition: multiple values";
                    properties.Addition = 1;
                    if (!$util.isString(message.aggregatorPubkey))
                        return "aggregatorPubkey: string expected";
                }
                if (message.job != null && message.hasOwnProperty("job")) {
                    if (properties.Addition === 1)
                        return "Addition: multiple values";
                    properties.Addition = 1;
                    {
                        let error = $root.oracle_job.OracleJob.verify(message.job);
                        if (error)
                            return "job." + error;
                    }
                }
                if (message.big != null && message.hasOwnProperty("big")) {
                    if (properties.Addition === 1)
                        return "Addition: multiple values";
                    properties.Addition = 1;
                    if (!$util.isString(message.big))
                        return "big: string expected";
                }
                return null;
            };

            /**
             * Creates an AddTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.AddTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.AddTask} AddTask
             */
            AddTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.AddTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.AddTask();
                if (object.scalar != null)
                    message.scalar = Number(object.scalar);
                if (object.aggregatorPubkey != null)
                    message.aggregatorPubkey = String(object.aggregatorPubkey);
                if (object.job != null) {
                    if (typeof object.job !== "object")
                        throw TypeError(".oracle_job.OracleJob.AddTask.job: object expected");
                    message.job = $root.oracle_job.OracleJob.fromObject(object.job);
                }
                if (object.big != null)
                    message.big = String(object.big);
                return message;
            };

            /**
             * Creates a plain object from an AddTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.AddTask
             * @static
             * @param {oracle_job.OracleJob.AddTask} message AddTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AddTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.scalar != null && message.hasOwnProperty("scalar")) {
                    object.scalar = options.json && !isFinite(message.scalar) ? String(message.scalar) : message.scalar;
                    if (options.oneofs)
                        object.Addition = "scalar";
                }
                if (message.aggregatorPubkey != null && message.hasOwnProperty("aggregatorPubkey")) {
                    object.aggregatorPubkey = message.aggregatorPubkey;
                    if (options.oneofs)
                        object.Addition = "aggregatorPubkey";
                }
                if (message.job != null && message.hasOwnProperty("job")) {
                    object.job = $root.oracle_job.OracleJob.toObject(message.job, options);
                    if (options.oneofs)
                        object.Addition = "job";
                }
                if (message.big != null && message.hasOwnProperty("big")) {
                    object.big = message.big;
                    if (options.oneofs)
                        object.Addition = "big";
                }
                return object;
            };

            /**
             * Converts this AddTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.AddTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AddTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AddTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.AddTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AddTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.AddTask";
            };

            return AddTask;
        })();

        OracleJob.SubtractTask = (function() {

            /**
             * Properties of a SubtractTask.
             * @memberof oracle_job.OracleJob
             * @interface ISubtractTask
             * @property {number|null} [scalar] Specifies a scalar to subtract by.
             * @property {string|null} [aggregatorPubkey] Specifies an aggregator to subtract by.
             * @property {oracle_job.IOracleJob|null} [job] A job whose result is computed before subtracting our numerical input by that result.
             * @property {string|null} [big] A stringified big.js. `Accepts variable expansion syntax.`
             */

            /**
             * Constructs a new SubtractTask.
             * @memberof oracle_job.OracleJob
             * @classdesc This task will subtract a numerical input by a scalar value from a job of subtasks, an aggregator, or a big.
             * 
             * _**Input**_: The current running numerical result output from a scalar value, an aggregator, a job of subtasks or a big.
             * 
             * _**Returns**_: A numerical result.
             * 
             * _**Example**_: Returns the numerical result by subtracting by a job of subtasks.
             * 
             * ```json
             * {"tasks":[{"valueTask":{"value":100}},{"subtractTask":{"job":{"tasks":[{"valueTask":{"value":10}}]}}}]}
             * ```
             * 
             * _**Example**_: Returns the numerical result by multiplying by an aggregator.
             * 
             * ```json
             * {"tasks":[{"valueTask":{"value":100}},{"subtractTask":{"aggregatorPubkey":"GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR"}}]}
             * ```
             * 
             * _**Example**_: Returns the numerical result by multiplying by a big.
             * 
             * ```json
             * {"tasks":[{"cacheTask":{"cacheItems":[{"variableName":"TEN","job":{"tasks":[{"valueTask":{"value":10}}]}}]}},{"valueTask":{"value":100}},{"subtractTask":{"big":"${TEN}"}}]}
             * ```
             * @implements ISubtractTask
             * @constructor
             * @param {oracle_job.OracleJob.ISubtractTask=} [properties] Properties to set
             */
            function SubtractTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Specifies a scalar to subtract by.
             * @member {number|null|undefined} scalar
             * @memberof oracle_job.OracleJob.SubtractTask
             * @instance
             */
            SubtractTask.prototype.scalar = null;

            /**
             * Specifies an aggregator to subtract by.
             * @member {string|null|undefined} aggregatorPubkey
             * @memberof oracle_job.OracleJob.SubtractTask
             * @instance
             */
            SubtractTask.prototype.aggregatorPubkey = null;

            /**
             * A job whose result is computed before subtracting our numerical input by that result.
             * @member {oracle_job.IOracleJob|null|undefined} job
             * @memberof oracle_job.OracleJob.SubtractTask
             * @instance
             */
            SubtractTask.prototype.job = null;

            /**
             * A stringified big.js. `Accepts variable expansion syntax.`
             * @member {string|null|undefined} big
             * @memberof oracle_job.OracleJob.SubtractTask
             * @instance
             */
            SubtractTask.prototype.big = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * SubtractTask Subtraction.
             * @member {"scalar"|"aggregatorPubkey"|"job"|"big"|undefined} Subtraction
             * @memberof oracle_job.OracleJob.SubtractTask
             * @instance
             */
            Object.defineProperty(SubtractTask.prototype, "Subtraction", {
                get: $util.oneOfGetter($oneOfFields = ["scalar", "aggregatorPubkey", "job", "big"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SubtractTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.SubtractTask
             * @static
             * @param {oracle_job.OracleJob.ISubtractTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.SubtractTask} SubtractTask instance
             */
            SubtractTask.create = function create(properties) {
      return SubtractTask.fromObject(properties);
    };

            /**
             * Encodes the specified SubtractTask message. Does not implicitly {@link oracle_job.OracleJob.SubtractTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.SubtractTask
             * @static
             * @param {oracle_job.OracleJob.ISubtractTask} message SubtractTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SubtractTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.scalar != null && Object.hasOwnProperty.call(message, "scalar"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.scalar);
                if (message.aggregatorPubkey != null && Object.hasOwnProperty.call(message, "aggregatorPubkey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.aggregatorPubkey);
                if (message.job != null && Object.hasOwnProperty.call(message, "job"))
                    $root.oracle_job.OracleJob.encode(message.job, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.big != null && Object.hasOwnProperty.call(message, "big"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.big);
                return writer;
            };

            /**
             * Encodes the specified SubtractTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.SubtractTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.SubtractTask
             * @static
             * @param {oracle_job.OracleJob.ISubtractTask} message SubtractTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SubtractTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SubtractTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.SubtractTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.SubtractTask} SubtractTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SubtractTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.SubtractTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.scalar = reader.double();
                            break;
                        }
                    case 2: {
                            message.aggregatorPubkey = reader.string();
                            break;
                        }
                    case 3: {
                            message.job = $root.oracle_job.OracleJob.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.big = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SubtractTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.SubtractTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.SubtractTask} SubtractTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SubtractTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SubtractTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.SubtractTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SubtractTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.scalar != null && message.hasOwnProperty("scalar")) {
                    properties.Subtraction = 1;
                    if (typeof message.scalar !== "number")
                        return "scalar: number expected";
                }
                if (message.aggregatorPubkey != null && message.hasOwnProperty("aggregatorPubkey")) {
                    if (properties.Subtraction === 1)
                        return "Subtraction: multiple values";
                    properties.Subtraction = 1;
                    if (!$util.isString(message.aggregatorPubkey))
                        return "aggregatorPubkey: string expected";
                }
                if (message.job != null && message.hasOwnProperty("job")) {
                    if (properties.Subtraction === 1)
                        return "Subtraction: multiple values";
                    properties.Subtraction = 1;
                    {
                        let error = $root.oracle_job.OracleJob.verify(message.job);
                        if (error)
                            return "job." + error;
                    }
                }
                if (message.big != null && message.hasOwnProperty("big")) {
                    if (properties.Subtraction === 1)
                        return "Subtraction: multiple values";
                    properties.Subtraction = 1;
                    if (!$util.isString(message.big))
                        return "big: string expected";
                }
                return null;
            };

            /**
             * Creates a SubtractTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.SubtractTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.SubtractTask} SubtractTask
             */
            SubtractTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.SubtractTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.SubtractTask();
                if (object.scalar != null)
                    message.scalar = Number(object.scalar);
                if (object.aggregatorPubkey != null)
                    message.aggregatorPubkey = String(object.aggregatorPubkey);
                if (object.job != null) {
                    if (typeof object.job !== "object")
                        throw TypeError(".oracle_job.OracleJob.SubtractTask.job: object expected");
                    message.job = $root.oracle_job.OracleJob.fromObject(object.job);
                }
                if (object.big != null)
                    message.big = String(object.big);
                return message;
            };

            /**
             * Creates a plain object from a SubtractTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.SubtractTask
             * @static
             * @param {oracle_job.OracleJob.SubtractTask} message SubtractTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SubtractTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.scalar != null && message.hasOwnProperty("scalar")) {
                    object.scalar = options.json && !isFinite(message.scalar) ? String(message.scalar) : message.scalar;
                    if (options.oneofs)
                        object.Subtraction = "scalar";
                }
                if (message.aggregatorPubkey != null && message.hasOwnProperty("aggregatorPubkey")) {
                    object.aggregatorPubkey = message.aggregatorPubkey;
                    if (options.oneofs)
                        object.Subtraction = "aggregatorPubkey";
                }
                if (message.job != null && message.hasOwnProperty("job")) {
                    object.job = $root.oracle_job.OracleJob.toObject(message.job, options);
                    if (options.oneofs)
                        object.Subtraction = "job";
                }
                if (message.big != null && message.hasOwnProperty("big")) {
                    object.big = message.big;
                    if (options.oneofs)
                        object.Subtraction = "big";
                }
                return object;
            };

            /**
             * Converts this SubtractTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.SubtractTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SubtractTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SubtractTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.SubtractTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SubtractTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.SubtractTask";
            };

            return SubtractTask;
        })();

        OracleJob.LpTokenPriceTask = (function() {

            /**
             * Properties of a LpTokenPriceTask.
             * @memberof oracle_job.OracleJob
             * @interface ILpTokenPriceTask
             * @property {string|null} [mercurialPoolAddress] Mercurial finance pool address. A full list can be found here: https://github.com/mercurial-finance/stable-swap-n-pool-js
             * @property {string|null} [saberPoolAddress] Saber pool address. A full list can be found here: https://github.com/saber-hq/saber-registry-dist
             * @property {string|null} [orcaPoolAddress] Orca pool address. A full list can be found here: https://www.orca.so/pools
             * @property {string|null} [raydiumPoolAddress] The Raydium liquidity pool ammId. A full list can be found here: https://raydium.io/pools
             * @property {Array.<string>|null} [priceFeedAddresses] A list of Switchboard aggregator accounts used to calculate the fair LP price. This ensures the price is based on the previous round to mitigate flash loan price manipulation.
             * @property {Array.<oracle_job.IOracleJob>|null} [priceFeedJobs] A list of OracleJobs to execute in order to yield the price feed jobs to use for the fair price formula.
             * @property {boolean|null} [useFairPrice] If enabled and price_feed_addresses provided, the oracle will calculate the fair LP price based on the liquidity pool reserves. See our blog post for more information: https://switchboardxyz.medium.com/fair-lp-token-oracles-94a457c50239
             */

            /**
             * Constructs a new LpTokenPriceTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Fetch LP token price info from a number of supported exchanges.
             * 
             * See our blog post on [Fair LP Token Oracles](/blog/2022/01/20/Fair-LP-Token-Oracles)
             * 
             * *NOTE**: This is not the swap price but the price of the underlying LP token.
             * 
             * _**Input**_: None
             * 
             * _**Returns**_: The price of an LP token for a given AMM pool.
             * 
             * _**Example**_: Fetch the Orca LP token price of the SOL/USDC pool
             * 
             * ```json
             * { "lpTokenPriceTask": { "orcaPoolAddress": "APDFRM3HMr8CAGXwKHiu2f5ePSpaiEJhaURwhsRrUUt9" } }
             * ```
             * 
             * _**Example**_: Fetch the fair price Orca LP token price of the SOL/USDC pool
             * 
             * ```json
             * { "lpTokenPriceTask": { "orcaPoolAddress": "APDFRM3HMr8CAGXwKHiu2f5ePSpaiEJhaURwhsRrUUt9", "useFairPrice": true, "priceFeedAddresses": [ "GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR", "BjUgj6YCnFBZ49wF54ddBVA9qu8TeqkFtkbqmZcee8uW" ] } }
             * ```
             * 
             * _**Example**_: Fetch the fair price Raydium LP token price of the SOL/USDC pool
             * 
             * ```json
             * { "lpTokenPriceTask": { "raydiumPoolAddress": "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2", "useFairPrice": true,"priceFeedAddresses": ["GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR","BjUgj6YCnFBZ49wF54ddBVA9qu8TeqkFtkbqmZcee8uW" ] } }
             * ```
             * @implements ILpTokenPriceTask
             * @constructor
             * @param {oracle_job.OracleJob.ILpTokenPriceTask=} [properties] Properties to set
             */
            function LpTokenPriceTask(properties) {
                this.priceFeedAddresses = [];
                this.priceFeedJobs = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Mercurial finance pool address. A full list can be found here: https://github.com/mercurial-finance/stable-swap-n-pool-js
             * @member {string|null|undefined} mercurialPoolAddress
             * @memberof oracle_job.OracleJob.LpTokenPriceTask
             * @instance
             */
            LpTokenPriceTask.prototype.mercurialPoolAddress = null;

            /**
             * Saber pool address. A full list can be found here: https://github.com/saber-hq/saber-registry-dist
             * @member {string|null|undefined} saberPoolAddress
             * @memberof oracle_job.OracleJob.LpTokenPriceTask
             * @instance
             */
            LpTokenPriceTask.prototype.saberPoolAddress = null;

            /**
             * Orca pool address. A full list can be found here: https://www.orca.so/pools
             * @member {string|null|undefined} orcaPoolAddress
             * @memberof oracle_job.OracleJob.LpTokenPriceTask
             * @instance
             */
            LpTokenPriceTask.prototype.orcaPoolAddress = null;

            /**
             * The Raydium liquidity pool ammId. A full list can be found here: https://raydium.io/pools
             * @member {string|null|undefined} raydiumPoolAddress
             * @memberof oracle_job.OracleJob.LpTokenPriceTask
             * @instance
             */
            LpTokenPriceTask.prototype.raydiumPoolAddress = null;

            /**
             * A list of Switchboard aggregator accounts used to calculate the fair LP price. This ensures the price is based on the previous round to mitigate flash loan price manipulation.
             * @member {Array.<string>} priceFeedAddresses
             * @memberof oracle_job.OracleJob.LpTokenPriceTask
             * @instance
             */
            LpTokenPriceTask.prototype.priceFeedAddresses = $util.emptyArray;

            /**
             * A list of OracleJobs to execute in order to yield the price feed jobs to use for the fair price formula.
             * @member {Array.<oracle_job.IOracleJob>} priceFeedJobs
             * @memberof oracle_job.OracleJob.LpTokenPriceTask
             * @instance
             */
            LpTokenPriceTask.prototype.priceFeedJobs = $util.emptyArray;

            /**
             * If enabled and price_feed_addresses provided, the oracle will calculate the fair LP price based on the liquidity pool reserves. See our blog post for more information: https://switchboardxyz.medium.com/fair-lp-token-oracles-94a457c50239
             * @member {boolean} useFairPrice
             * @memberof oracle_job.OracleJob.LpTokenPriceTask
             * @instance
             */
            LpTokenPriceTask.prototype.useFairPrice = false;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * LpTokenPriceTask PoolAddress.
             * @member {"mercurialPoolAddress"|"saberPoolAddress"|"orcaPoolAddress"|"raydiumPoolAddress"|undefined} PoolAddress
             * @memberof oracle_job.OracleJob.LpTokenPriceTask
             * @instance
             */
            Object.defineProperty(LpTokenPriceTask.prototype, "PoolAddress", {
                get: $util.oneOfGetter($oneOfFields = ["mercurialPoolAddress", "saberPoolAddress", "orcaPoolAddress", "raydiumPoolAddress"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new LpTokenPriceTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.LpTokenPriceTask
             * @static
             * @param {oracle_job.OracleJob.ILpTokenPriceTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.LpTokenPriceTask} LpTokenPriceTask instance
             */
            LpTokenPriceTask.create = function create(properties) {
      return LpTokenPriceTask.fromObject(properties);
    };

            /**
             * Encodes the specified LpTokenPriceTask message. Does not implicitly {@link oracle_job.OracleJob.LpTokenPriceTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.LpTokenPriceTask
             * @static
             * @param {oracle_job.OracleJob.ILpTokenPriceTask} message LpTokenPriceTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LpTokenPriceTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.mercurialPoolAddress != null && Object.hasOwnProperty.call(message, "mercurialPoolAddress"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.mercurialPoolAddress);
                if (message.saberPoolAddress != null && Object.hasOwnProperty.call(message, "saberPoolAddress"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.saberPoolAddress);
                if (message.orcaPoolAddress != null && Object.hasOwnProperty.call(message, "orcaPoolAddress"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.orcaPoolAddress);
                if (message.raydiumPoolAddress != null && Object.hasOwnProperty.call(message, "raydiumPoolAddress"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.raydiumPoolAddress);
                if (message.priceFeedAddresses != null && message.priceFeedAddresses.length)
                    for (let i = 0; i < message.priceFeedAddresses.length; ++i)
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.priceFeedAddresses[i]);
                if (message.priceFeedJobs != null && message.priceFeedJobs.length)
                    for (let i = 0; i < message.priceFeedJobs.length; ++i)
                        $root.oracle_job.OracleJob.encode(message.priceFeedJobs[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.useFairPrice != null && Object.hasOwnProperty.call(message, "useFairPrice"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.useFairPrice);
                return writer;
            };

            /**
             * Encodes the specified LpTokenPriceTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.LpTokenPriceTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.LpTokenPriceTask
             * @static
             * @param {oracle_job.OracleJob.ILpTokenPriceTask} message LpTokenPriceTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LpTokenPriceTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LpTokenPriceTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.LpTokenPriceTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.LpTokenPriceTask} LpTokenPriceTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LpTokenPriceTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.LpTokenPriceTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.mercurialPoolAddress = reader.string();
                            break;
                        }
                    case 2: {
                            message.saberPoolAddress = reader.string();
                            break;
                        }
                    case 3: {
                            message.orcaPoolAddress = reader.string();
                            break;
                        }
                    case 4: {
                            message.raydiumPoolAddress = reader.string();
                            break;
                        }
                    case 5: {
                            if (!(message.priceFeedAddresses && message.priceFeedAddresses.length))
                                message.priceFeedAddresses = [];
                            message.priceFeedAddresses.push(reader.string());
                            break;
                        }
                    case 6: {
                            if (!(message.priceFeedJobs && message.priceFeedJobs.length))
                                message.priceFeedJobs = [];
                            message.priceFeedJobs.push($root.oracle_job.OracleJob.decode(reader, reader.uint32()));
                            break;
                        }
                    case 7: {
                            message.useFairPrice = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LpTokenPriceTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.LpTokenPriceTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.LpTokenPriceTask} LpTokenPriceTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LpTokenPriceTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LpTokenPriceTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.LpTokenPriceTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LpTokenPriceTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.mercurialPoolAddress != null && message.hasOwnProperty("mercurialPoolAddress")) {
                    properties.PoolAddress = 1;
                    if (!$util.isString(message.mercurialPoolAddress))
                        return "mercurialPoolAddress: string expected";
                }
                if (message.saberPoolAddress != null && message.hasOwnProperty("saberPoolAddress")) {
                    if (properties.PoolAddress === 1)
                        return "PoolAddress: multiple values";
                    properties.PoolAddress = 1;
                    if (!$util.isString(message.saberPoolAddress))
                        return "saberPoolAddress: string expected";
                }
                if (message.orcaPoolAddress != null && message.hasOwnProperty("orcaPoolAddress")) {
                    if (properties.PoolAddress === 1)
                        return "PoolAddress: multiple values";
                    properties.PoolAddress = 1;
                    if (!$util.isString(message.orcaPoolAddress))
                        return "orcaPoolAddress: string expected";
                }
                if (message.raydiumPoolAddress != null && message.hasOwnProperty("raydiumPoolAddress")) {
                    if (properties.PoolAddress === 1)
                        return "PoolAddress: multiple values";
                    properties.PoolAddress = 1;
                    if (!$util.isString(message.raydiumPoolAddress))
                        return "raydiumPoolAddress: string expected";
                }
                if (message.priceFeedAddresses != null && message.hasOwnProperty("priceFeedAddresses")) {
                    if (!Array.isArray(message.priceFeedAddresses))
                        return "priceFeedAddresses: array expected";
                    for (let i = 0; i < message.priceFeedAddresses.length; ++i)
                        if (!$util.isString(message.priceFeedAddresses[i]))
                            return "priceFeedAddresses: string[] expected";
                }
                if (message.priceFeedJobs != null && message.hasOwnProperty("priceFeedJobs")) {
                    if (!Array.isArray(message.priceFeedJobs))
                        return "priceFeedJobs: array expected";
                    for (let i = 0; i < message.priceFeedJobs.length; ++i) {
                        let error = $root.oracle_job.OracleJob.verify(message.priceFeedJobs[i]);
                        if (error)
                            return "priceFeedJobs." + error;
                    }
                }
                if (message.useFairPrice != null && message.hasOwnProperty("useFairPrice"))
                    if (typeof message.useFairPrice !== "boolean")
                        return "useFairPrice: boolean expected";
                return null;
            };

            /**
             * Creates a LpTokenPriceTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.LpTokenPriceTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.LpTokenPriceTask} LpTokenPriceTask
             */
            LpTokenPriceTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.LpTokenPriceTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.LpTokenPriceTask();
                if (object.mercurialPoolAddress != null)
                    message.mercurialPoolAddress = String(object.mercurialPoolAddress);
                if (object.saberPoolAddress != null)
                    message.saberPoolAddress = String(object.saberPoolAddress);
                if (object.orcaPoolAddress != null)
                    message.orcaPoolAddress = String(object.orcaPoolAddress);
                if (object.raydiumPoolAddress != null)
                    message.raydiumPoolAddress = String(object.raydiumPoolAddress);
                if (object.priceFeedAddresses) {
                    if (!Array.isArray(object.priceFeedAddresses))
                        throw TypeError(".oracle_job.OracleJob.LpTokenPriceTask.priceFeedAddresses: array expected");
                    message.priceFeedAddresses = [];
                    for (let i = 0; i < object.priceFeedAddresses.length; ++i)
                        message.priceFeedAddresses[i] = String(object.priceFeedAddresses[i]);
                }
                if (object.priceFeedJobs) {
                    if (!Array.isArray(object.priceFeedJobs))
                        throw TypeError(".oracle_job.OracleJob.LpTokenPriceTask.priceFeedJobs: array expected");
                    message.priceFeedJobs = [];
                    for (let i = 0; i < object.priceFeedJobs.length; ++i) {
                        if (typeof object.priceFeedJobs[i] !== "object")
                            throw TypeError(".oracle_job.OracleJob.LpTokenPriceTask.priceFeedJobs: object expected");
                        message.priceFeedJobs[i] = $root.oracle_job.OracleJob.fromObject(object.priceFeedJobs[i]);
                    }
                }
                if (object.useFairPrice != null)
                    message.useFairPrice = Boolean(object.useFairPrice);
                return message;
            };

            /**
             * Creates a plain object from a LpTokenPriceTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.LpTokenPriceTask
             * @static
             * @param {oracle_job.OracleJob.LpTokenPriceTask} message LpTokenPriceTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LpTokenPriceTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.priceFeedAddresses = [];
                    object.priceFeedJobs = [];
                }
                if (options.defaults)
                    object.useFairPrice = false;
                if (message.mercurialPoolAddress != null && message.hasOwnProperty("mercurialPoolAddress")) {
                    object.mercurialPoolAddress = message.mercurialPoolAddress;
                    if (options.oneofs)
                        object.PoolAddress = "mercurialPoolAddress";
                }
                if (message.saberPoolAddress != null && message.hasOwnProperty("saberPoolAddress")) {
                    object.saberPoolAddress = message.saberPoolAddress;
                    if (options.oneofs)
                        object.PoolAddress = "saberPoolAddress";
                }
                if (message.orcaPoolAddress != null && message.hasOwnProperty("orcaPoolAddress")) {
                    object.orcaPoolAddress = message.orcaPoolAddress;
                    if (options.oneofs)
                        object.PoolAddress = "orcaPoolAddress";
                }
                if (message.raydiumPoolAddress != null && message.hasOwnProperty("raydiumPoolAddress")) {
                    object.raydiumPoolAddress = message.raydiumPoolAddress;
                    if (options.oneofs)
                        object.PoolAddress = "raydiumPoolAddress";
                }
                if (message.priceFeedAddresses && message.priceFeedAddresses.length) {
                    object.priceFeedAddresses = [];
                    for (let j = 0; j < message.priceFeedAddresses.length; ++j)
                        object.priceFeedAddresses[j] = message.priceFeedAddresses[j];
                }
                if (message.priceFeedJobs && message.priceFeedJobs.length) {
                    object.priceFeedJobs = [];
                    for (let j = 0; j < message.priceFeedJobs.length; ++j)
                        object.priceFeedJobs[j] = $root.oracle_job.OracleJob.toObject(message.priceFeedJobs[j], options);
                }
                if (message.useFairPrice != null && message.hasOwnProperty("useFairPrice"))
                    object.useFairPrice = message.useFairPrice;
                return object;
            };

            /**
             * Converts this LpTokenPriceTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.LpTokenPriceTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LpTokenPriceTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LpTokenPriceTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.LpTokenPriceTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LpTokenPriceTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.LpTokenPriceTask";
            };

            return LpTokenPriceTask;
        })();

        OracleJob.LpExchangeRateTask = (function() {

            /**
             * Properties of a LpExchangeRateTask.
             * @memberof oracle_job.OracleJob
             * @interface ILpExchangeRateTask
             * @property {string|null} [inTokenAddress] Used alongside mercurial_pool_address to specify the input token for a swap.
             * @property {string|null} [outTokenAddress] Used alongside mercurial_pool_address to specify the output token for a swap.
             * @property {string|null} [mercurialPoolAddress] Mercurial finance pool address. A full list can be found here: https://github.com/mercurial-finance/stable-swap-n-pool-js
             * @property {string|null} [saberPoolAddress] Saber pool address. A full list can be found here: https://github.com/saber-hq/saber-registry-dist
             * @property {string|null} [orcaPoolTokenMintAddress] **@deprecated** Use orcaPoolAddress
             * @property {string|null} [raydiumPoolAddress] The Raydium liquidity pool ammId. A full list can be found here: https://raydium.io/pools
             * @property {string|null} [orcaPoolAddress] Pool address for an Orca LP pool or whirlpool.
             * A full list of Orca LP pools can be found here: https://www.orca.so/pools
             * @property {string|null} [portReserveAddress] The Port reserve pubkey. A full list can be found here: https://api-v1.port.finance/reserves
             * @property {oracle_job.OracleJob.LpExchangeRateTask.Chain|null} [chain] LpExchangeRateTask chain
             */

            /**
             * Constructs a new LpExchangeRateTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Fetch the current swap price for a given liquidity pool
             * 
             * _**Input**_: None
             * 
             * _**Returns**_: The swap price for a given AMM pool.
             * 
             * _**Example**_: Fetch the exchange rate from the Orca SOL/USDC pool
             * 
             * ```json
             * { "lpExchangeRateTask": { "orcaPoolAddress": "APDFRM3HMr8CAGXwKHiu2f5ePSpaiEJhaURwhsRrUUt9" } }
             * ```
             * 
             * _**Example**_: Fetch the exchange rate from the Raydium SOL/USDC pool
             * 
             * ```json
             * { "lpExchangeRateTask": { "raydiumPoolAddress": "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2" } }
             * ```
             * @implements ILpExchangeRateTask
             * @constructor
             * @param {oracle_job.OracleJob.ILpExchangeRateTask=} [properties] Properties to set
             */
            function LpExchangeRateTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Used alongside mercurial_pool_address to specify the input token for a swap.
             * @member {string} inTokenAddress
             * @memberof oracle_job.OracleJob.LpExchangeRateTask
             * @instance
             */
            LpExchangeRateTask.prototype.inTokenAddress = "";

            /**
             * Used alongside mercurial_pool_address to specify the output token for a swap.
             * @member {string} outTokenAddress
             * @memberof oracle_job.OracleJob.LpExchangeRateTask
             * @instance
             */
            LpExchangeRateTask.prototype.outTokenAddress = "";

            /**
             * Mercurial finance pool address. A full list can be found here: https://github.com/mercurial-finance/stable-swap-n-pool-js
             * @member {string|null|undefined} mercurialPoolAddress
             * @memberof oracle_job.OracleJob.LpExchangeRateTask
             * @instance
             */
            LpExchangeRateTask.prototype.mercurialPoolAddress = null;

            /**
             * Saber pool address. A full list can be found here: https://github.com/saber-hq/saber-registry-dist
             * @member {string|null|undefined} saberPoolAddress
             * @memberof oracle_job.OracleJob.LpExchangeRateTask
             * @instance
             */
            LpExchangeRateTask.prototype.saberPoolAddress = null;

            /**
             * **@deprecated** Use orcaPoolAddress
             * @member {string|null|undefined} orcaPoolTokenMintAddress
             * @memberof oracle_job.OracleJob.LpExchangeRateTask
             * @instance
             */
            LpExchangeRateTask.prototype.orcaPoolTokenMintAddress = null;

            /**
             * The Raydium liquidity pool ammId. A full list can be found here: https://raydium.io/pools
             * @member {string|null|undefined} raydiumPoolAddress
             * @memberof oracle_job.OracleJob.LpExchangeRateTask
             * @instance
             */
            LpExchangeRateTask.prototype.raydiumPoolAddress = null;

            /**
             * Pool address for an Orca LP pool or whirlpool.
             * A full list of Orca LP pools can be found here: https://www.orca.so/pools
             * @member {string|null|undefined} orcaPoolAddress
             * @memberof oracle_job.OracleJob.LpExchangeRateTask
             * @instance
             */
            LpExchangeRateTask.prototype.orcaPoolAddress = null;

            /**
             * The Port reserve pubkey. A full list can be found here: https://api-v1.port.finance/reserves
             * @member {string|null|undefined} portReserveAddress
             * @memberof oracle_job.OracleJob.LpExchangeRateTask
             * @instance
             */
            LpExchangeRateTask.prototype.portReserveAddress = null;

            /**
             * LpExchangeRateTask chain.
             * @member {oracle_job.OracleJob.LpExchangeRateTask.Chain} chain
             * @memberof oracle_job.OracleJob.LpExchangeRateTask
             * @instance
             */
            LpExchangeRateTask.prototype.chain = 0;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * LpExchangeRateTask PoolAddress.
             * @member {"mercurialPoolAddress"|"saberPoolAddress"|"orcaPoolTokenMintAddress"|"raydiumPoolAddress"|"orcaPoolAddress"|"portReserveAddress"|undefined} PoolAddress
             * @memberof oracle_job.OracleJob.LpExchangeRateTask
             * @instance
             */
            Object.defineProperty(LpExchangeRateTask.prototype, "PoolAddress", {
                get: $util.oneOfGetter($oneOfFields = ["mercurialPoolAddress", "saberPoolAddress", "orcaPoolTokenMintAddress", "raydiumPoolAddress", "orcaPoolAddress", "portReserveAddress"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new LpExchangeRateTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.LpExchangeRateTask
             * @static
             * @param {oracle_job.OracleJob.ILpExchangeRateTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.LpExchangeRateTask} LpExchangeRateTask instance
             */
            LpExchangeRateTask.create = function create(properties) {
      return LpExchangeRateTask.fromObject(properties);
    };

            /**
             * Encodes the specified LpExchangeRateTask message. Does not implicitly {@link oracle_job.OracleJob.LpExchangeRateTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.LpExchangeRateTask
             * @static
             * @param {oracle_job.OracleJob.ILpExchangeRateTask} message LpExchangeRateTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LpExchangeRateTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.inTokenAddress != null && Object.hasOwnProperty.call(message, "inTokenAddress"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.inTokenAddress);
                if (message.outTokenAddress != null && Object.hasOwnProperty.call(message, "outTokenAddress"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.outTokenAddress);
                if (message.mercurialPoolAddress != null && Object.hasOwnProperty.call(message, "mercurialPoolAddress"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.mercurialPoolAddress);
                if (message.saberPoolAddress != null && Object.hasOwnProperty.call(message, "saberPoolAddress"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.saberPoolAddress);
                if (message.orcaPoolTokenMintAddress != null && Object.hasOwnProperty.call(message, "orcaPoolTokenMintAddress"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.orcaPoolTokenMintAddress);
                if (message.raydiumPoolAddress != null && Object.hasOwnProperty.call(message, "raydiumPoolAddress"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.raydiumPoolAddress);
                if (message.orcaPoolAddress != null && Object.hasOwnProperty.call(message, "orcaPoolAddress"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.orcaPoolAddress);
                if (message.portReserveAddress != null && Object.hasOwnProperty.call(message, "portReserveAddress"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.portReserveAddress);
                if (message.chain != null && Object.hasOwnProperty.call(message, "chain"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.chain);
                return writer;
            };

            /**
             * Encodes the specified LpExchangeRateTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.LpExchangeRateTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.LpExchangeRateTask
             * @static
             * @param {oracle_job.OracleJob.ILpExchangeRateTask} message LpExchangeRateTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LpExchangeRateTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LpExchangeRateTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.LpExchangeRateTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.LpExchangeRateTask} LpExchangeRateTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LpExchangeRateTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.LpExchangeRateTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.inTokenAddress = reader.string();
                            break;
                        }
                    case 2: {
                            message.outTokenAddress = reader.string();
                            break;
                        }
                    case 3: {
                            message.mercurialPoolAddress = reader.string();
                            break;
                        }
                    case 4: {
                            message.saberPoolAddress = reader.string();
                            break;
                        }
                    case 5: {
                            message.orcaPoolTokenMintAddress = reader.string();
                            break;
                        }
                    case 6: {
                            message.raydiumPoolAddress = reader.string();
                            break;
                        }
                    case 7: {
                            message.orcaPoolAddress = reader.string();
                            break;
                        }
                    case 8: {
                            message.portReserveAddress = reader.string();
                            break;
                        }
                    case 9: {
                            message.chain = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LpExchangeRateTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.LpExchangeRateTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.LpExchangeRateTask} LpExchangeRateTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LpExchangeRateTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LpExchangeRateTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.LpExchangeRateTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LpExchangeRateTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.inTokenAddress != null && message.hasOwnProperty("inTokenAddress"))
                    if (!$util.isString(message.inTokenAddress))
                        return "inTokenAddress: string expected";
                if (message.outTokenAddress != null && message.hasOwnProperty("outTokenAddress"))
                    if (!$util.isString(message.outTokenAddress))
                        return "outTokenAddress: string expected";
                if (message.mercurialPoolAddress != null && message.hasOwnProperty("mercurialPoolAddress")) {
                    properties.PoolAddress = 1;
                    if (!$util.isString(message.mercurialPoolAddress))
                        return "mercurialPoolAddress: string expected";
                }
                if (message.saberPoolAddress != null && message.hasOwnProperty("saberPoolAddress")) {
                    if (properties.PoolAddress === 1)
                        return "PoolAddress: multiple values";
                    properties.PoolAddress = 1;
                    if (!$util.isString(message.saberPoolAddress))
                        return "saberPoolAddress: string expected";
                }
                if (message.orcaPoolTokenMintAddress != null && message.hasOwnProperty("orcaPoolTokenMintAddress")) {
                    if (properties.PoolAddress === 1)
                        return "PoolAddress: multiple values";
                    properties.PoolAddress = 1;
                    if (!$util.isString(message.orcaPoolTokenMintAddress))
                        return "orcaPoolTokenMintAddress: string expected";
                }
                if (message.raydiumPoolAddress != null && message.hasOwnProperty("raydiumPoolAddress")) {
                    if (properties.PoolAddress === 1)
                        return "PoolAddress: multiple values";
                    properties.PoolAddress = 1;
                    if (!$util.isString(message.raydiumPoolAddress))
                        return "raydiumPoolAddress: string expected";
                }
                if (message.orcaPoolAddress != null && message.hasOwnProperty("orcaPoolAddress")) {
                    if (properties.PoolAddress === 1)
                        return "PoolAddress: multiple values";
                    properties.PoolAddress = 1;
                    if (!$util.isString(message.orcaPoolAddress))
                        return "orcaPoolAddress: string expected";
                }
                if (message.portReserveAddress != null && message.hasOwnProperty("portReserveAddress")) {
                    if (properties.PoolAddress === 1)
                        return "PoolAddress: multiple values";
                    properties.PoolAddress = 1;
                    if (!$util.isString(message.portReserveAddress))
                        return "portReserveAddress: string expected";
                }
                if (message.chain != null && message.hasOwnProperty("chain"))
                    switch (message.chain) {
                    default:
                        return "chain: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a LpExchangeRateTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.LpExchangeRateTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.LpExchangeRateTask} LpExchangeRateTask
             */
            LpExchangeRateTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.LpExchangeRateTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.LpExchangeRateTask();
                if (object.inTokenAddress != null)
                    message.inTokenAddress = String(object.inTokenAddress);
                if (object.outTokenAddress != null)
                    message.outTokenAddress = String(object.outTokenAddress);
                if (object.mercurialPoolAddress != null)
                    message.mercurialPoolAddress = String(object.mercurialPoolAddress);
                if (object.saberPoolAddress != null)
                    message.saberPoolAddress = String(object.saberPoolAddress);
                if (object.orcaPoolTokenMintAddress != null)
                    message.orcaPoolTokenMintAddress = String(object.orcaPoolTokenMintAddress);
                if (object.raydiumPoolAddress != null)
                    message.raydiumPoolAddress = String(object.raydiumPoolAddress);
                if (object.orcaPoolAddress != null)
                    message.orcaPoolAddress = String(object.orcaPoolAddress);
                if (object.portReserveAddress != null)
                    message.portReserveAddress = String(object.portReserveAddress);
                switch (object.chain) {
                default:
                    if (typeof object.chain === "number") {
                        message.chain = object.chain;
                        break;
                    }
                    break;
                case "SOLANA":
                case 0:
                    message.chain = 0;
                    break;
                case "ECLIPSE":
                case 1:
                    message.chain = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a LpExchangeRateTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.LpExchangeRateTask
             * @static
             * @param {oracle_job.OracleJob.LpExchangeRateTask} message LpExchangeRateTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LpExchangeRateTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.inTokenAddress = "";
                    object.outTokenAddress = "";
                    object.chain = options.enums === String ? "SOLANA" : 0;
                }
                if (message.inTokenAddress != null && message.hasOwnProperty("inTokenAddress"))
                    object.inTokenAddress = message.inTokenAddress;
                if (message.outTokenAddress != null && message.hasOwnProperty("outTokenAddress"))
                    object.outTokenAddress = message.outTokenAddress;
                if (message.mercurialPoolAddress != null && message.hasOwnProperty("mercurialPoolAddress")) {
                    object.mercurialPoolAddress = message.mercurialPoolAddress;
                    if (options.oneofs)
                        object.PoolAddress = "mercurialPoolAddress";
                }
                if (message.saberPoolAddress != null && message.hasOwnProperty("saberPoolAddress")) {
                    object.saberPoolAddress = message.saberPoolAddress;
                    if (options.oneofs)
                        object.PoolAddress = "saberPoolAddress";
                }
                if (message.orcaPoolTokenMintAddress != null && message.hasOwnProperty("orcaPoolTokenMintAddress")) {
                    object.orcaPoolTokenMintAddress = message.orcaPoolTokenMintAddress;
                    if (options.oneofs)
                        object.PoolAddress = "orcaPoolTokenMintAddress";
                }
                if (message.raydiumPoolAddress != null && message.hasOwnProperty("raydiumPoolAddress")) {
                    object.raydiumPoolAddress = message.raydiumPoolAddress;
                    if (options.oneofs)
                        object.PoolAddress = "raydiumPoolAddress";
                }
                if (message.orcaPoolAddress != null && message.hasOwnProperty("orcaPoolAddress")) {
                    object.orcaPoolAddress = message.orcaPoolAddress;
                    if (options.oneofs)
                        object.PoolAddress = "orcaPoolAddress";
                }
                if (message.portReserveAddress != null && message.hasOwnProperty("portReserveAddress")) {
                    object.portReserveAddress = message.portReserveAddress;
                    if (options.oneofs)
                        object.PoolAddress = "portReserveAddress";
                }
                if (message.chain != null && message.hasOwnProperty("chain"))
                    object.chain = options.enums === String ? $root.oracle_job.OracleJob.LpExchangeRateTask.Chain[message.chain] === undefined ? message.chain : $root.oracle_job.OracleJob.LpExchangeRateTask.Chain[message.chain] : message.chain;
                return object;
            };

            /**
             * Converts this LpExchangeRateTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.LpExchangeRateTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LpExchangeRateTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LpExchangeRateTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.LpExchangeRateTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LpExchangeRateTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.LpExchangeRateTask";
            };

            /**
             * Chain enum.
             * @name oracle_job.OracleJob.LpExchangeRateTask.Chain
             * @enum {number}
             * @property {number} SOLANA=0 SOLANA value
             * @property {number} ECLIPSE=1 ECLIPSE value
             */
            LpExchangeRateTask.Chain = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "SOLANA"] = 0;
                values[valuesById[1] = "ECLIPSE"] = 1;
                return values;
            })();

            return LpExchangeRateTask;
        })();

        OracleJob.RegexExtractTask = (function() {

            /**
             * Properties of a RegexExtractTask.
             * @memberof oracle_job.OracleJob
             * @interface IRegexExtractTask
             * @property {string|null} [pattern] The regular expression pattern to match against the input string.
             * Uses the fancy-regex Rust crate syntax.
             * @property {number|null} [groupNumber] The capture group number to extract (0 returns full match, 1+ returns respective capture group).
             * Defaults to 0 if not specified.
             */

            /**
             * Constructs a new RegexExtractTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Find and extract text using regular expressions from the previous task's output.
             * 
             * _**Input**_: String output from previous task
             * 
             * _**Returns**_: The matched string based on the regex pattern and group number
             * 
             * _**Example**_: Extract the first number from a string
             * 
             * ```json
             * {
             * "regexExtractTask": {
             * "pattern": "\\d+",
             * "groupNumber": 0
             * }
             * }
             * ```
             * 
             * _**Example**_: Extract text between quotes
             * 
             * ```json
             * {
             * "regexExtractTask": {
             * "pattern": "\"([^\"]+)\"",
             * "groupNumber": 1
             * }
             * }
             * ```
             * 
             * _**Example**_: Extract the first JSON object from a stream
             * 
             * ```json
             * {
             * "regexExtractTask": {
             * "pattern": "\\{[^}]+\\}"
             * }
             * }
             * ```
             * @implements IRegexExtractTask
             * @constructor
             * @param {oracle_job.OracleJob.IRegexExtractTask=} [properties] Properties to set
             */
            function RegexExtractTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The regular expression pattern to match against the input string.
             * Uses the fancy-regex Rust crate syntax.
             * @member {string} pattern
             * @memberof oracle_job.OracleJob.RegexExtractTask
             * @instance
             */
            RegexExtractTask.prototype.pattern = "";

            /**
             * The capture group number to extract (0 returns full match, 1+ returns respective capture group).
             * Defaults to 0 if not specified.
             * @member {number} groupNumber
             * @memberof oracle_job.OracleJob.RegexExtractTask
             * @instance
             */
            RegexExtractTask.prototype.groupNumber = 0;

            /**
             * Creates a new RegexExtractTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.RegexExtractTask
             * @static
             * @param {oracle_job.OracleJob.IRegexExtractTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.RegexExtractTask} RegexExtractTask instance
             */
            RegexExtractTask.create = function create(properties) {
      return RegexExtractTask.fromObject(properties);
    };

            /**
             * Encodes the specified RegexExtractTask message. Does not implicitly {@link oracle_job.OracleJob.RegexExtractTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.RegexExtractTask
             * @static
             * @param {oracle_job.OracleJob.IRegexExtractTask} message RegexExtractTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RegexExtractTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pattern != null && Object.hasOwnProperty.call(message, "pattern"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.pattern);
                if (message.groupNumber != null && Object.hasOwnProperty.call(message, "groupNumber"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.groupNumber);
                return writer;
            };

            /**
             * Encodes the specified RegexExtractTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.RegexExtractTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.RegexExtractTask
             * @static
             * @param {oracle_job.OracleJob.IRegexExtractTask} message RegexExtractTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RegexExtractTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RegexExtractTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.RegexExtractTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.RegexExtractTask} RegexExtractTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RegexExtractTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.RegexExtractTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.pattern = reader.string();
                            break;
                        }
                    case 2: {
                            message.groupNumber = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RegexExtractTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.RegexExtractTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.RegexExtractTask} RegexExtractTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RegexExtractTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RegexExtractTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.RegexExtractTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RegexExtractTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pattern != null && message.hasOwnProperty("pattern"))
                    if (!$util.isString(message.pattern))
                        return "pattern: string expected";
                if (message.groupNumber != null && message.hasOwnProperty("groupNumber"))
                    if (!$util.isInteger(message.groupNumber))
                        return "groupNumber: integer expected";
                return null;
            };

            /**
             * Creates a RegexExtractTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.RegexExtractTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.RegexExtractTask} RegexExtractTask
             */
            RegexExtractTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.RegexExtractTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.RegexExtractTask();
                if (object.pattern != null)
                    message.pattern = String(object.pattern);
                if (object.groupNumber != null)
                    message.groupNumber = object.groupNumber | 0;
                return message;
            };

            /**
             * Creates a plain object from a RegexExtractTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.RegexExtractTask
             * @static
             * @param {oracle_job.OracleJob.RegexExtractTask} message RegexExtractTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RegexExtractTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.pattern = "";
                    object.groupNumber = 0;
                }
                if (message.pattern != null && message.hasOwnProperty("pattern"))
                    object.pattern = message.pattern;
                if (message.groupNumber != null && message.hasOwnProperty("groupNumber"))
                    object.groupNumber = message.groupNumber;
                return object;
            };

            /**
             * Converts this RegexExtractTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.RegexExtractTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RegexExtractTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RegexExtractTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.RegexExtractTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RegexExtractTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.RegexExtractTask";
            };

            return RegexExtractTask;
        })();

        OracleJob.XStepPriceTask = (function() {

            /**
             * Properties of a XStepPriceTask.
             * @memberof oracle_job.OracleJob
             * @interface IXStepPriceTask
             * @property {oracle_job.OracleJob.IMedianTask|null} [stepJob] median task containing the job definitions to fetch the STEP/USD price
             * @property {string|null} [stepAggregatorPubkey] existing aggregator pubkey for STEP/USD
             */

            /**
             * Constructs a new XStepPriceTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Represents a XStepPriceTask.
             * @implements IXStepPriceTask
             * @constructor
             * @param {oracle_job.OracleJob.IXStepPriceTask=} [properties] Properties to set
             */
            function XStepPriceTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * median task containing the job definitions to fetch the STEP/USD price
             * @member {oracle_job.OracleJob.IMedianTask|null|undefined} stepJob
             * @memberof oracle_job.OracleJob.XStepPriceTask
             * @instance
             */
            XStepPriceTask.prototype.stepJob = null;

            /**
             * existing aggregator pubkey for STEP/USD
             * @member {string|null|undefined} stepAggregatorPubkey
             * @memberof oracle_job.OracleJob.XStepPriceTask
             * @instance
             */
            XStepPriceTask.prototype.stepAggregatorPubkey = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * XStepPriceTask StepSource.
             * @member {"stepJob"|"stepAggregatorPubkey"|undefined} StepSource
             * @memberof oracle_job.OracleJob.XStepPriceTask
             * @instance
             */
            Object.defineProperty(XStepPriceTask.prototype, "StepSource", {
                get: $util.oneOfGetter($oneOfFields = ["stepJob", "stepAggregatorPubkey"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new XStepPriceTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.XStepPriceTask
             * @static
             * @param {oracle_job.OracleJob.IXStepPriceTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.XStepPriceTask} XStepPriceTask instance
             */
            XStepPriceTask.create = function create(properties) {
      return XStepPriceTask.fromObject(properties);
    };

            /**
             * Encodes the specified XStepPriceTask message. Does not implicitly {@link oracle_job.OracleJob.XStepPriceTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.XStepPriceTask
             * @static
             * @param {oracle_job.OracleJob.IXStepPriceTask} message XStepPriceTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            XStepPriceTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stepJob != null && Object.hasOwnProperty.call(message, "stepJob"))
                    $root.oracle_job.OracleJob.MedianTask.encode(message.stepJob, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.stepAggregatorPubkey != null && Object.hasOwnProperty.call(message, "stepAggregatorPubkey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.stepAggregatorPubkey);
                return writer;
            };

            /**
             * Encodes the specified XStepPriceTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.XStepPriceTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.XStepPriceTask
             * @static
             * @param {oracle_job.OracleJob.IXStepPriceTask} message XStepPriceTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            XStepPriceTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a XStepPriceTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.XStepPriceTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.XStepPriceTask} XStepPriceTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            XStepPriceTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.XStepPriceTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.stepJob = $root.oracle_job.OracleJob.MedianTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.stepAggregatorPubkey = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a XStepPriceTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.XStepPriceTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.XStepPriceTask} XStepPriceTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            XStepPriceTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a XStepPriceTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.XStepPriceTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            XStepPriceTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.stepJob != null && message.hasOwnProperty("stepJob")) {
                    properties.StepSource = 1;
                    {
                        let error = $root.oracle_job.OracleJob.MedianTask.verify(message.stepJob);
                        if (error)
                            return "stepJob." + error;
                    }
                }
                if (message.stepAggregatorPubkey != null && message.hasOwnProperty("stepAggregatorPubkey")) {
                    if (properties.StepSource === 1)
                        return "StepSource: multiple values";
                    properties.StepSource = 1;
                    if (!$util.isString(message.stepAggregatorPubkey))
                        return "stepAggregatorPubkey: string expected";
                }
                return null;
            };

            /**
             * Creates a XStepPriceTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.XStepPriceTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.XStepPriceTask} XStepPriceTask
             */
            XStepPriceTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.XStepPriceTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.XStepPriceTask();
                if (object.stepJob != null) {
                    if (typeof object.stepJob !== "object")
                        throw TypeError(".oracle_job.OracleJob.XStepPriceTask.stepJob: object expected");
                    message.stepJob = $root.oracle_job.OracleJob.MedianTask.fromObject(object.stepJob);
                }
                if (object.stepAggregatorPubkey != null)
                    message.stepAggregatorPubkey = String(object.stepAggregatorPubkey);
                return message;
            };

            /**
             * Creates a plain object from a XStepPriceTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.XStepPriceTask
             * @static
             * @param {oracle_job.OracleJob.XStepPriceTask} message XStepPriceTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            XStepPriceTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.stepJob != null && message.hasOwnProperty("stepJob")) {
                    object.stepJob = $root.oracle_job.OracleJob.MedianTask.toObject(message.stepJob, options);
                    if (options.oneofs)
                        object.StepSource = "stepJob";
                }
                if (message.stepAggregatorPubkey != null && message.hasOwnProperty("stepAggregatorPubkey")) {
                    object.stepAggregatorPubkey = message.stepAggregatorPubkey;
                    if (options.oneofs)
                        object.StepSource = "stepAggregatorPubkey";
                }
                return object;
            };

            /**
             * Converts this XStepPriceTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.XStepPriceTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            XStepPriceTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for XStepPriceTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.XStepPriceTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            XStepPriceTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.XStepPriceTask";
            };

            return XStepPriceTask;
        })();

        OracleJob.TwapTask = (function() {

            /**
             * Properties of a TwapTask.
             * @memberof oracle_job.OracleJob
             * @interface ITwapTask
             * @property {string|null} [aggregatorPubkey] The target aggregator for the TWAP.
             * @property {number|null} [period] Period, in seconds, the twap should account for
             * @property {boolean|null} [weightByPropagationTime] Weight samples by their propagation time
             * @property {number|null} [minSamples] Minimum number of samples in the history to calculate a valid result
             * @property {number|null} [endingUnixTimestamp] Ending unix timestamp to collect values up to
             * @property {oracle_job.OracleJob.ICronParseTask|null} [endingUnixTimestampTask] Execute the task to get the ending unix timestamp
             */

            /**
             * Constructs a new TwapTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Takes a twap over a set period for a certain aggregator. Aggregators have an optional history buffer account storing the last N accepted results. The TwapTask will iterate over an aggregators history buffer and calculate the time weighted average of the samples within a given time period.
             * 
             * _**Input**_: None
             * 
             * _**Returns**_: The time weighted average of an aggregator over a given time period.
             * 
             * _**Example**_: The 1hr Twap of the SOL/USD Aggregator, requiring at least 60 samples.
             * 
             * ```json
             * { "twapTask": { "aggregatorPubkey": "GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR", "period": 3600, "minSamples": 60, "weightByPropagationTime": true  } }
             * ```
             * @implements ITwapTask
             * @constructor
             * @param {oracle_job.OracleJob.ITwapTask=} [properties] Properties to set
             */
            function TwapTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The target aggregator for the TWAP.
             * @member {string} aggregatorPubkey
             * @memberof oracle_job.OracleJob.TwapTask
             * @instance
             */
            TwapTask.prototype.aggregatorPubkey = "";

            /**
             * Period, in seconds, the twap should account for
             * @member {number} period
             * @memberof oracle_job.OracleJob.TwapTask
             * @instance
             */
            TwapTask.prototype.period = 0;

            /**
             * Weight samples by their propagation time
             * @member {boolean} weightByPropagationTime
             * @memberof oracle_job.OracleJob.TwapTask
             * @instance
             */
            TwapTask.prototype.weightByPropagationTime = false;

            /**
             * Minimum number of samples in the history to calculate a valid result
             * @member {number} minSamples
             * @memberof oracle_job.OracleJob.TwapTask
             * @instance
             */
            TwapTask.prototype.minSamples = 0;

            /**
             * Ending unix timestamp to collect values up to
             * @member {number} endingUnixTimestamp
             * @memberof oracle_job.OracleJob.TwapTask
             * @instance
             */
            TwapTask.prototype.endingUnixTimestamp = 0;

            /**
             * Execute the task to get the ending unix timestamp
             * @member {oracle_job.OracleJob.ICronParseTask|null|undefined} endingUnixTimestampTask
             * @memberof oracle_job.OracleJob.TwapTask
             * @instance
             */
            TwapTask.prototype.endingUnixTimestampTask = null;

            /**
             * Creates a new TwapTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.TwapTask
             * @static
             * @param {oracle_job.OracleJob.ITwapTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.TwapTask} TwapTask instance
             */
            TwapTask.create = function create(properties) {
      return TwapTask.fromObject(properties);
    };

            /**
             * Encodes the specified TwapTask message. Does not implicitly {@link oracle_job.OracleJob.TwapTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.TwapTask
             * @static
             * @param {oracle_job.OracleJob.ITwapTask} message TwapTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TwapTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.aggregatorPubkey != null && Object.hasOwnProperty.call(message, "aggregatorPubkey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.aggregatorPubkey);
                if (message.period != null && Object.hasOwnProperty.call(message, "period"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.period);
                if (message.weightByPropagationTime != null && Object.hasOwnProperty.call(message, "weightByPropagationTime"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.weightByPropagationTime);
                if (message.minSamples != null && Object.hasOwnProperty.call(message, "minSamples"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.minSamples);
                if (message.endingUnixTimestamp != null && Object.hasOwnProperty.call(message, "endingUnixTimestamp"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.endingUnixTimestamp);
                if (message.endingUnixTimestampTask != null && Object.hasOwnProperty.call(message, "endingUnixTimestampTask"))
                    $root.oracle_job.OracleJob.CronParseTask.encode(message.endingUnixTimestampTask, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified TwapTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.TwapTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.TwapTask
             * @static
             * @param {oracle_job.OracleJob.ITwapTask} message TwapTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TwapTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TwapTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.TwapTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.TwapTask} TwapTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TwapTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.TwapTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.aggregatorPubkey = reader.string();
                            break;
                        }
                    case 2: {
                            message.period = reader.int32();
                            break;
                        }
                    case 3: {
                            message.weightByPropagationTime = reader.bool();
                            break;
                        }
                    case 4: {
                            message.minSamples = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.endingUnixTimestamp = reader.int32();
                            break;
                        }
                    case 6: {
                            message.endingUnixTimestampTask = $root.oracle_job.OracleJob.CronParseTask.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TwapTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.TwapTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.TwapTask} TwapTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TwapTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TwapTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.TwapTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TwapTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.aggregatorPubkey != null && message.hasOwnProperty("aggregatorPubkey"))
                    if (!$util.isString(message.aggregatorPubkey))
                        return "aggregatorPubkey: string expected";
                if (message.period != null && message.hasOwnProperty("period"))
                    if (!$util.isInteger(message.period))
                        return "period: integer expected";
                if (message.weightByPropagationTime != null && message.hasOwnProperty("weightByPropagationTime"))
                    if (typeof message.weightByPropagationTime !== "boolean")
                        return "weightByPropagationTime: boolean expected";
                if (message.minSamples != null && message.hasOwnProperty("minSamples"))
                    if (!$util.isInteger(message.minSamples))
                        return "minSamples: integer expected";
                if (message.endingUnixTimestamp != null && message.hasOwnProperty("endingUnixTimestamp"))
                    if (!$util.isInteger(message.endingUnixTimestamp))
                        return "endingUnixTimestamp: integer expected";
                if (message.endingUnixTimestampTask != null && message.hasOwnProperty("endingUnixTimestampTask")) {
                    let error = $root.oracle_job.OracleJob.CronParseTask.verify(message.endingUnixTimestampTask);
                    if (error)
                        return "endingUnixTimestampTask." + error;
                }
                return null;
            };

            /**
             * Creates a TwapTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.TwapTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.TwapTask} TwapTask
             */
            TwapTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.TwapTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.TwapTask();
                if (object.aggregatorPubkey != null)
                    message.aggregatorPubkey = String(object.aggregatorPubkey);
                if (object.period != null)
                    message.period = object.period | 0;
                if (object.weightByPropagationTime != null)
                    message.weightByPropagationTime = Boolean(object.weightByPropagationTime);
                if (object.minSamples != null)
                    message.minSamples = object.minSamples >>> 0;
                if (object.endingUnixTimestamp != null)
                    message.endingUnixTimestamp = object.endingUnixTimestamp | 0;
                if (object.endingUnixTimestampTask != null) {
                    if (typeof object.endingUnixTimestampTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.TwapTask.endingUnixTimestampTask: object expected");
                    message.endingUnixTimestampTask = $root.oracle_job.OracleJob.CronParseTask.fromObject(object.endingUnixTimestampTask);
                }
                return message;
            };

            /**
             * Creates a plain object from a TwapTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.TwapTask
             * @static
             * @param {oracle_job.OracleJob.TwapTask} message TwapTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TwapTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.aggregatorPubkey = "";
                    object.period = 0;
                    object.weightByPropagationTime = false;
                    object.minSamples = 0;
                    object.endingUnixTimestamp = 0;
                    object.endingUnixTimestampTask = null;
                }
                if (message.aggregatorPubkey != null && message.hasOwnProperty("aggregatorPubkey"))
                    object.aggregatorPubkey = message.aggregatorPubkey;
                if (message.period != null && message.hasOwnProperty("period"))
                    object.period = message.period;
                if (message.weightByPropagationTime != null && message.hasOwnProperty("weightByPropagationTime"))
                    object.weightByPropagationTime = message.weightByPropagationTime;
                if (message.minSamples != null && message.hasOwnProperty("minSamples"))
                    object.minSamples = message.minSamples;
                if (message.endingUnixTimestamp != null && message.hasOwnProperty("endingUnixTimestamp"))
                    object.endingUnixTimestamp = message.endingUnixTimestamp;
                if (message.endingUnixTimestampTask != null && message.hasOwnProperty("endingUnixTimestampTask"))
                    object.endingUnixTimestampTask = $root.oracle_job.OracleJob.CronParseTask.toObject(message.endingUnixTimestampTask, options);
                return object;
            };

            /**
             * Converts this TwapTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.TwapTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TwapTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TwapTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.TwapTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TwapTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.TwapTask";
            };

            return TwapTask;
        })();

        OracleJob.SerumSwapTask = (function() {

            /**
             * Properties of a SerumSwapTask.
             * @memberof oracle_job.OracleJob
             * @interface ISerumSwapTask
             * @property {string|null} [serumPoolAddress] The serum pool to fetch swap price for
             */

            /**
             * Constructs a new SerumSwapTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Fetch the latest swap price on Serum's orderbook
             * @implements ISerumSwapTask
             * @constructor
             * @param {oracle_job.OracleJob.ISerumSwapTask=} [properties] Properties to set
             */
            function SerumSwapTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The serum pool to fetch swap price for
             * @member {string} serumPoolAddress
             * @memberof oracle_job.OracleJob.SerumSwapTask
             * @instance
             */
            SerumSwapTask.prototype.serumPoolAddress = "";

            /**
             * Creates a new SerumSwapTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.SerumSwapTask
             * @static
             * @param {oracle_job.OracleJob.ISerumSwapTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.SerumSwapTask} SerumSwapTask instance
             */
            SerumSwapTask.create = function create(properties) {
      return SerumSwapTask.fromObject(properties);
    };

            /**
             * Encodes the specified SerumSwapTask message. Does not implicitly {@link oracle_job.OracleJob.SerumSwapTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.SerumSwapTask
             * @static
             * @param {oracle_job.OracleJob.ISerumSwapTask} message SerumSwapTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SerumSwapTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.serumPoolAddress != null && Object.hasOwnProperty.call(message, "serumPoolAddress"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.serumPoolAddress);
                return writer;
            };

            /**
             * Encodes the specified SerumSwapTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.SerumSwapTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.SerumSwapTask
             * @static
             * @param {oracle_job.OracleJob.ISerumSwapTask} message SerumSwapTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SerumSwapTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SerumSwapTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.SerumSwapTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.SerumSwapTask} SerumSwapTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SerumSwapTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.SerumSwapTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.serumPoolAddress = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SerumSwapTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.SerumSwapTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.SerumSwapTask} SerumSwapTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SerumSwapTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SerumSwapTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.SerumSwapTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SerumSwapTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.serumPoolAddress != null && message.hasOwnProperty("serumPoolAddress"))
                    if (!$util.isString(message.serumPoolAddress))
                        return "serumPoolAddress: string expected";
                return null;
            };

            /**
             * Creates a SerumSwapTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.SerumSwapTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.SerumSwapTask} SerumSwapTask
             */
            SerumSwapTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.SerumSwapTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.SerumSwapTask();
                if (object.serumPoolAddress != null)
                    message.serumPoolAddress = String(object.serumPoolAddress);
                return message;
            };

            /**
             * Creates a plain object from a SerumSwapTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.SerumSwapTask
             * @static
             * @param {oracle_job.OracleJob.SerumSwapTask} message SerumSwapTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SerumSwapTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.serumPoolAddress = "";
                if (message.serumPoolAddress != null && message.hasOwnProperty("serumPoolAddress"))
                    object.serumPoolAddress = message.serumPoolAddress;
                return object;
            };

            /**
             * Converts this SerumSwapTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.SerumSwapTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SerumSwapTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SerumSwapTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.SerumSwapTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SerumSwapTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.SerumSwapTask";
            };

            return SerumSwapTask;
        })();

        OracleJob.PowTask = (function() {

            /**
             * Properties of a PowTask.
             * @memberof oracle_job.OracleJob
             * @interface IPowTask
             * @property {number|null} [scalar] Take the working value to the exponent of value.
             * @property {string|null} [aggregatorPubkey] Take the working value to the exponent of the aggregators value.
             * @property {string|null} [big] A stringified big.js. `Accepts variable expansion syntax.`
             */

            /**
             * Constructs a new PowTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Round the current running result to an exponential power.
             * 
             * _**Input**_: The current running numerical result.
             * 
             * _**Returns**_: The input raised to an exponential power.
             * 
             * _**Example**_: Raise 2 to the power of 3, 2^3
             * 
             * ```json
             * {"tasks":[{"valueTask":{"value":2}},{"powTask":{"scalar":3}}]}
             * ```
             * @implements IPowTask
             * @constructor
             * @param {oracle_job.OracleJob.IPowTask=} [properties] Properties to set
             */
            function PowTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Take the working value to the exponent of value.
             * @member {number|null|undefined} scalar
             * @memberof oracle_job.OracleJob.PowTask
             * @instance
             */
            PowTask.prototype.scalar = null;

            /**
             * Take the working value to the exponent of the aggregators value.
             * @member {string|null|undefined} aggregatorPubkey
             * @memberof oracle_job.OracleJob.PowTask
             * @instance
             */
            PowTask.prototype.aggregatorPubkey = null;

            /**
             * A stringified big.js. `Accepts variable expansion syntax.`
             * @member {string|null|undefined} big
             * @memberof oracle_job.OracleJob.PowTask
             * @instance
             */
            PowTask.prototype.big = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * PowTask Exponent.
             * @member {"scalar"|"aggregatorPubkey"|"big"|undefined} Exponent
             * @memberof oracle_job.OracleJob.PowTask
             * @instance
             */
            Object.defineProperty(PowTask.prototype, "Exponent", {
                get: $util.oneOfGetter($oneOfFields = ["scalar", "aggregatorPubkey", "big"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new PowTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.PowTask
             * @static
             * @param {oracle_job.OracleJob.IPowTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.PowTask} PowTask instance
             */
            PowTask.create = function create(properties) {
      return PowTask.fromObject(properties);
    };

            /**
             * Encodes the specified PowTask message. Does not implicitly {@link oracle_job.OracleJob.PowTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.PowTask
             * @static
             * @param {oracle_job.OracleJob.IPowTask} message PowTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PowTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.scalar != null && Object.hasOwnProperty.call(message, "scalar"))
                    writer.uint32(/* id 1, wireType 1 =*/9).double(message.scalar);
                if (message.aggregatorPubkey != null && Object.hasOwnProperty.call(message, "aggregatorPubkey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.aggregatorPubkey);
                if (message.big != null && Object.hasOwnProperty.call(message, "big"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.big);
                return writer;
            };

            /**
             * Encodes the specified PowTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.PowTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.PowTask
             * @static
             * @param {oracle_job.OracleJob.IPowTask} message PowTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PowTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PowTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.PowTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.PowTask} PowTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PowTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.PowTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.scalar = reader.double();
                            break;
                        }
                    case 2: {
                            message.aggregatorPubkey = reader.string();
                            break;
                        }
                    case 3: {
                            message.big = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PowTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.PowTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.PowTask} PowTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PowTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PowTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.PowTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PowTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.scalar != null && message.hasOwnProperty("scalar")) {
                    properties.Exponent = 1;
                    if (typeof message.scalar !== "number")
                        return "scalar: number expected";
                }
                if (message.aggregatorPubkey != null && message.hasOwnProperty("aggregatorPubkey")) {
                    if (properties.Exponent === 1)
                        return "Exponent: multiple values";
                    properties.Exponent = 1;
                    if (!$util.isString(message.aggregatorPubkey))
                        return "aggregatorPubkey: string expected";
                }
                if (message.big != null && message.hasOwnProperty("big")) {
                    if (properties.Exponent === 1)
                        return "Exponent: multiple values";
                    properties.Exponent = 1;
                    if (!$util.isString(message.big))
                        return "big: string expected";
                }
                return null;
            };

            /**
             * Creates a PowTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.PowTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.PowTask} PowTask
             */
            PowTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.PowTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.PowTask();
                if (object.scalar != null)
                    message.scalar = Number(object.scalar);
                if (object.aggregatorPubkey != null)
                    message.aggregatorPubkey = String(object.aggregatorPubkey);
                if (object.big != null)
                    message.big = String(object.big);
                return message;
            };

            /**
             * Creates a plain object from a PowTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.PowTask
             * @static
             * @param {oracle_job.OracleJob.PowTask} message PowTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PowTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.scalar != null && message.hasOwnProperty("scalar")) {
                    object.scalar = options.json && !isFinite(message.scalar) ? String(message.scalar) : message.scalar;
                    if (options.oneofs)
                        object.Exponent = "scalar";
                }
                if (message.aggregatorPubkey != null && message.hasOwnProperty("aggregatorPubkey")) {
                    object.aggregatorPubkey = message.aggregatorPubkey;
                    if (options.oneofs)
                        object.Exponent = "aggregatorPubkey";
                }
                if (message.big != null && message.hasOwnProperty("big")) {
                    object.big = message.big;
                    if (options.oneofs)
                        object.Exponent = "big";
                }
                return object;
            };

            /**
             * Converts this PowTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.PowTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PowTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PowTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.PowTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PowTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.PowTask";
            };

            return PowTask;
        })();

        OracleJob.LendingRateTask = (function() {

            /**
             * Properties of a LendingRateTask.
             * @memberof oracle_job.OracleJob
             * @interface ILendingRateTask
             * @property {string|null} [protocol] 01, apricot, francium, jet, larix, mango, port, solend, tulip
             * @property {string|null} [assetMint] A token mint address supported by the chosen protocol
             * @property {oracle_job.OracleJob.LendingRateTask.Field|null} [field] LendingRateTask field
             */

            /**
             * Constructs a new LendingRateTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Fetch the lending rates for various Solana protocols
             * @implements ILendingRateTask
             * @constructor
             * @param {oracle_job.OracleJob.ILendingRateTask=} [properties] Properties to set
             */
            function LendingRateTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * 01, apricot, francium, jet, larix, mango, port, solend, tulip
             * @member {string} protocol
             * @memberof oracle_job.OracleJob.LendingRateTask
             * @instance
             */
            LendingRateTask.prototype.protocol = "";

            /**
             * A token mint address supported by the chosen protocol
             * @member {string} assetMint
             * @memberof oracle_job.OracleJob.LendingRateTask
             * @instance
             */
            LendingRateTask.prototype.assetMint = "";

            /**
             * LendingRateTask field.
             * @member {oracle_job.OracleJob.LendingRateTask.Field} field
             * @memberof oracle_job.OracleJob.LendingRateTask
             * @instance
             */
            LendingRateTask.prototype.field = 0;

            /**
             * Creates a new LendingRateTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.LendingRateTask
             * @static
             * @param {oracle_job.OracleJob.ILendingRateTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.LendingRateTask} LendingRateTask instance
             */
            LendingRateTask.create = function create(properties) {
      return LendingRateTask.fromObject(properties);
    };

            /**
             * Encodes the specified LendingRateTask message. Does not implicitly {@link oracle_job.OracleJob.LendingRateTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.LendingRateTask
             * @static
             * @param {oracle_job.OracleJob.ILendingRateTask} message LendingRateTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LendingRateTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.protocol != null && Object.hasOwnProperty.call(message, "protocol"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.protocol);
                if (message.assetMint != null && Object.hasOwnProperty.call(message, "assetMint"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.assetMint);
                if (message.field != null && Object.hasOwnProperty.call(message, "field"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.field);
                return writer;
            };

            /**
             * Encodes the specified LendingRateTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.LendingRateTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.LendingRateTask
             * @static
             * @param {oracle_job.OracleJob.ILendingRateTask} message LendingRateTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LendingRateTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LendingRateTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.LendingRateTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.LendingRateTask} LendingRateTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LendingRateTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.LendingRateTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.protocol = reader.string();
                            break;
                        }
                    case 2: {
                            message.assetMint = reader.string();
                            break;
                        }
                    case 3: {
                            message.field = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LendingRateTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.LendingRateTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.LendingRateTask} LendingRateTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LendingRateTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LendingRateTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.LendingRateTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LendingRateTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.protocol != null && message.hasOwnProperty("protocol"))
                    if (!$util.isString(message.protocol))
                        return "protocol: string expected";
                if (message.assetMint != null && message.hasOwnProperty("assetMint"))
                    if (!$util.isString(message.assetMint))
                        return "assetMint: string expected";
                if (message.field != null && message.hasOwnProperty("field"))
                    switch (message.field) {
                    default:
                        return "field: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a LendingRateTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.LendingRateTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.LendingRateTask} LendingRateTask
             */
            LendingRateTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.LendingRateTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.LendingRateTask();
                if (object.protocol != null)
                    message.protocol = String(object.protocol);
                if (object.assetMint != null)
                    message.assetMint = String(object.assetMint);
                switch (object.field) {
                default:
                    if (typeof object.field === "number") {
                        message.field = object.field;
                        break;
                    }
                    break;
                case "FIELD_DEPOSIT_RATE":
                case 0:
                    message.field = 0;
                    break;
                case "FIELD_BORROW_RATE":
                case 1:
                    message.field = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a LendingRateTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.LendingRateTask
             * @static
             * @param {oracle_job.OracleJob.LendingRateTask} message LendingRateTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LendingRateTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.protocol = "";
                    object.assetMint = "";
                    object.field = options.enums === String ? "FIELD_DEPOSIT_RATE" : 0;
                }
                if (message.protocol != null && message.hasOwnProperty("protocol"))
                    object.protocol = message.protocol;
                if (message.assetMint != null && message.hasOwnProperty("assetMint"))
                    object.assetMint = message.assetMint;
                if (message.field != null && message.hasOwnProperty("field"))
                    object.field = options.enums === String ? $root.oracle_job.OracleJob.LendingRateTask.Field[message.field] === undefined ? message.field : $root.oracle_job.OracleJob.LendingRateTask.Field[message.field] : message.field;
                return object;
            };

            /**
             * Converts this LendingRateTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.LendingRateTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LendingRateTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LendingRateTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.LendingRateTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LendingRateTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.LendingRateTask";
            };

            /**
             * Field enum.
             * @name oracle_job.OracleJob.LendingRateTask.Field
             * @enum {number}
             * @property {number} FIELD_DEPOSIT_RATE=0 deposit lending rate
             * @property {number} FIELD_BORROW_RATE=1 borrow lending rate
             */
            LendingRateTask.Field = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "FIELD_DEPOSIT_RATE"] = 0;
                values[valuesById[1] = "FIELD_BORROW_RATE"] = 1;
                return values;
            })();

            return LendingRateTask;
        })();

        OracleJob.MangoPerpMarketTask = (function() {

            /**
             * Properties of a MangoPerpMarketTask.
             * @memberof oracle_job.OracleJob
             * @interface IMangoPerpMarketTask
             * @property {string|null} [perpMarketAddress] Mainnet address for a mango perpetual market. A full list can be found here: https://github.com/blockworks-foundation/mango-client-v3/blob/main/src/ids.json
             */

            /**
             * Constructs a new MangoPerpMarketTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Fetch the current price for a Mango perpetual market
             * @implements IMangoPerpMarketTask
             * @constructor
             * @param {oracle_job.OracleJob.IMangoPerpMarketTask=} [properties] Properties to set
             */
            function MangoPerpMarketTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Mainnet address for a mango perpetual market. A full list can be found here: https://github.com/blockworks-foundation/mango-client-v3/blob/main/src/ids.json
             * @member {string} perpMarketAddress
             * @memberof oracle_job.OracleJob.MangoPerpMarketTask
             * @instance
             */
            MangoPerpMarketTask.prototype.perpMarketAddress = "";

            /**
             * Creates a new MangoPerpMarketTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.MangoPerpMarketTask
             * @static
             * @param {oracle_job.OracleJob.IMangoPerpMarketTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.MangoPerpMarketTask} MangoPerpMarketTask instance
             */
            MangoPerpMarketTask.create = function create(properties) {
      return MangoPerpMarketTask.fromObject(properties);
    };

            /**
             * Encodes the specified MangoPerpMarketTask message. Does not implicitly {@link oracle_job.OracleJob.MangoPerpMarketTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.MangoPerpMarketTask
             * @static
             * @param {oracle_job.OracleJob.IMangoPerpMarketTask} message MangoPerpMarketTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MangoPerpMarketTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.perpMarketAddress != null && Object.hasOwnProperty.call(message, "perpMarketAddress"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.perpMarketAddress);
                return writer;
            };

            /**
             * Encodes the specified MangoPerpMarketTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.MangoPerpMarketTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.MangoPerpMarketTask
             * @static
             * @param {oracle_job.OracleJob.IMangoPerpMarketTask} message MangoPerpMarketTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MangoPerpMarketTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MangoPerpMarketTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.MangoPerpMarketTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.MangoPerpMarketTask} MangoPerpMarketTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MangoPerpMarketTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.MangoPerpMarketTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.perpMarketAddress = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MangoPerpMarketTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.MangoPerpMarketTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.MangoPerpMarketTask} MangoPerpMarketTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MangoPerpMarketTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MangoPerpMarketTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.MangoPerpMarketTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MangoPerpMarketTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.perpMarketAddress != null && message.hasOwnProperty("perpMarketAddress"))
                    if (!$util.isString(message.perpMarketAddress))
                        return "perpMarketAddress: string expected";
                return null;
            };

            /**
             * Creates a MangoPerpMarketTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.MangoPerpMarketTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.MangoPerpMarketTask} MangoPerpMarketTask
             */
            MangoPerpMarketTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.MangoPerpMarketTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.MangoPerpMarketTask();
                if (object.perpMarketAddress != null)
                    message.perpMarketAddress = String(object.perpMarketAddress);
                return message;
            };

            /**
             * Creates a plain object from a MangoPerpMarketTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.MangoPerpMarketTask
             * @static
             * @param {oracle_job.OracleJob.MangoPerpMarketTask} message MangoPerpMarketTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MangoPerpMarketTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.perpMarketAddress = "";
                if (message.perpMarketAddress != null && message.hasOwnProperty("perpMarketAddress"))
                    object.perpMarketAddress = message.perpMarketAddress;
                return object;
            };

            /**
             * Converts this MangoPerpMarketTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.MangoPerpMarketTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MangoPerpMarketTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MangoPerpMarketTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.MangoPerpMarketTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MangoPerpMarketTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.MangoPerpMarketTask";
            };

            return MangoPerpMarketTask;
        })();

        OracleJob.JupiterSwapTask = (function() {

            /**
             * Properties of a JupiterSwapTask.
             * @memberof oracle_job.OracleJob
             * @interface IJupiterSwapTask
             * @property {string|null} [inTokenAddress] The input token address.
             * @property {string|null} [outTokenAddress] The output token address.
             * @property {oracle_job.OracleJob.JupiterSwapTask.IFilterList|null} [allowList] A list of AMM markets to allow.
             * @property {oracle_job.OracleJob.JupiterSwapTask.IFilterList|null} [denyList] A list of AMM markets to deny.
             * @property {number|null} [baseAmount] The amount of `in_token_address` tokens to swap.
             * @property {number|null} [quoteAmount] The amount of `out_token_address` tokens to swap.
             * @property {string|null} [baseAmountString] The amount of `in_token_address` tokens to swap.
             * @property {string|null} [quoteAmountString] The amount of `out_token_address` tokens to swap.
             * @property {number|null} [slippage] The allowable slippage on the swap in decimal form (e.g. 0.5 is 0.5% slippage)
             * @property {oracle_job.OracleJob.JupiterSwapTask.Version|null} [version] JupiterSwapTask version
             * @property {boolean|null} [directRoutesOnly] JupiterSwapTask directRoutesOnly
             * @property {string|null} [apiKey] Optional API key for authenticated requests
             */

            /**
             * Constructs a new JupiterSwapTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Fetch the simulated price for a swap on JupiterSwap.
             * 
             * _**Input**_: None
             * 
             * _**Returns**_: The swap price on Jupiter for a given input and output token mint address.
             * 
             * _**Example**_: Fetch the JupiterSwap price for exchanging 1 SOL into USDC.
             * 
             * ```json
             * { "jupiterSwapTask": { "inTokenAddress": "So11111111111111111111111111111111111111112", "outTokenAddress": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v" } }
             * ```
             * 
             * _**Example**_: Fetch the JupiterSwap price for exchanging 1000 SOL into USDC.
             * 
             * ```json
             * { "jupiterSwapTask": { "inTokenAddress": "So11111111111111111111111111111111111111112", "outTokenAddress": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", "baseAmount": "1000" } }
             * ```
             * @implements IJupiterSwapTask
             * @constructor
             * @param {oracle_job.OracleJob.IJupiterSwapTask=} [properties] Properties to set
             */
            function JupiterSwapTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The input token address.
             * @member {string} inTokenAddress
             * @memberof oracle_job.OracleJob.JupiterSwapTask
             * @instance
             */
            JupiterSwapTask.prototype.inTokenAddress = "";

            /**
             * The output token address.
             * @member {string} outTokenAddress
             * @memberof oracle_job.OracleJob.JupiterSwapTask
             * @instance
             */
            JupiterSwapTask.prototype.outTokenAddress = "";

            /**
             * A list of AMM markets to allow.
             * @member {oracle_job.OracleJob.JupiterSwapTask.IFilterList|null|undefined} allowList
             * @memberof oracle_job.OracleJob.JupiterSwapTask
             * @instance
             */
            JupiterSwapTask.prototype.allowList = null;

            /**
             * A list of AMM markets to deny.
             * @member {oracle_job.OracleJob.JupiterSwapTask.IFilterList|null|undefined} denyList
             * @memberof oracle_job.OracleJob.JupiterSwapTask
             * @instance
             */
            JupiterSwapTask.prototype.denyList = null;

            /**
             * The amount of `in_token_address` tokens to swap.
             * @member {number|null|undefined} baseAmount
             * @memberof oracle_job.OracleJob.JupiterSwapTask
             * @instance
             */
            JupiterSwapTask.prototype.baseAmount = null;

            /**
             * The amount of `out_token_address` tokens to swap.
             * @member {number|null|undefined} quoteAmount
             * @memberof oracle_job.OracleJob.JupiterSwapTask
             * @instance
             */
            JupiterSwapTask.prototype.quoteAmount = null;

            /**
             * The amount of `in_token_address` tokens to swap.
             * @member {string|null|undefined} baseAmountString
             * @memberof oracle_job.OracleJob.JupiterSwapTask
             * @instance
             */
            JupiterSwapTask.prototype.baseAmountString = null;

            /**
             * The amount of `out_token_address` tokens to swap.
             * @member {string|null|undefined} quoteAmountString
             * @memberof oracle_job.OracleJob.JupiterSwapTask
             * @instance
             */
            JupiterSwapTask.prototype.quoteAmountString = null;

            /**
             * The allowable slippage on the swap in decimal form (e.g. 0.5 is 0.5% slippage)
             * @member {number} slippage
             * @memberof oracle_job.OracleJob.JupiterSwapTask
             * @instance
             */
            JupiterSwapTask.prototype.slippage = 0;

            /**
             * JupiterSwapTask version.
             * @member {oracle_job.OracleJob.JupiterSwapTask.Version} version
             * @memberof oracle_job.OracleJob.JupiterSwapTask
             * @instance
             */
            JupiterSwapTask.prototype.version = 0;

            /**
             * JupiterSwapTask directRoutesOnly.
             * @member {boolean} directRoutesOnly
             * @memberof oracle_job.OracleJob.JupiterSwapTask
             * @instance
             */
            JupiterSwapTask.prototype.directRoutesOnly = false;

            /**
             * Optional API key for authenticated requests
             * @member {string} apiKey
             * @memberof oracle_job.OracleJob.JupiterSwapTask
             * @instance
             */
            JupiterSwapTask.prototype.apiKey = "";

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * JupiterSwapTask RoutesFilters.
             * @member {"allowList"|"denyList"|undefined} RoutesFilters
             * @memberof oracle_job.OracleJob.JupiterSwapTask
             * @instance
             */
            Object.defineProperty(JupiterSwapTask.prototype, "RoutesFilters", {
                get: $util.oneOfGetter($oneOfFields = ["allowList", "denyList"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * JupiterSwapTask SwapAmount.
             * @member {"baseAmount"|"quoteAmount"|"baseAmountString"|"quoteAmountString"|undefined} SwapAmount
             * @memberof oracle_job.OracleJob.JupiterSwapTask
             * @instance
             */
            Object.defineProperty(JupiterSwapTask.prototype, "SwapAmount", {
                get: $util.oneOfGetter($oneOfFields = ["baseAmount", "quoteAmount", "baseAmountString", "quoteAmountString"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new JupiterSwapTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.JupiterSwapTask
             * @static
             * @param {oracle_job.OracleJob.IJupiterSwapTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.JupiterSwapTask} JupiterSwapTask instance
             */
            JupiterSwapTask.create = function create(properties) {
      return JupiterSwapTask.fromObject(properties);
    };

            /**
             * Encodes the specified JupiterSwapTask message. Does not implicitly {@link oracle_job.OracleJob.JupiterSwapTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.JupiterSwapTask
             * @static
             * @param {oracle_job.OracleJob.IJupiterSwapTask} message JupiterSwapTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JupiterSwapTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.inTokenAddress != null && Object.hasOwnProperty.call(message, "inTokenAddress"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.inTokenAddress);
                if (message.outTokenAddress != null && Object.hasOwnProperty.call(message, "outTokenAddress"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.outTokenAddress);
                if (message.baseAmount != null && Object.hasOwnProperty.call(message, "baseAmount"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.baseAmount);
                if (message.allowList != null && Object.hasOwnProperty.call(message, "allowList"))
                    $root.oracle_job.OracleJob.JupiterSwapTask.FilterList.encode(message.allowList, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.denyList != null && Object.hasOwnProperty.call(message, "denyList"))
                    $root.oracle_job.OracleJob.JupiterSwapTask.FilterList.encode(message.denyList, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.quoteAmount != null && Object.hasOwnProperty.call(message, "quoteAmount"))
                    writer.uint32(/* id 6, wireType 1 =*/49).double(message.quoteAmount);
                if (message.baseAmountString != null && Object.hasOwnProperty.call(message, "baseAmountString"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.baseAmountString);
                if (message.quoteAmountString != null && Object.hasOwnProperty.call(message, "quoteAmountString"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.quoteAmountString);
                if (message.slippage != null && Object.hasOwnProperty.call(message, "slippage"))
                    writer.uint32(/* id 9, wireType 1 =*/73).double(message.slippage);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.version);
                if (message.directRoutesOnly != null && Object.hasOwnProperty.call(message, "directRoutesOnly"))
                    writer.uint32(/* id 11, wireType 0 =*/88).bool(message.directRoutesOnly);
                if (message.apiKey != null && Object.hasOwnProperty.call(message, "apiKey"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.apiKey);
                return writer;
            };

            /**
             * Encodes the specified JupiterSwapTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.JupiterSwapTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.JupiterSwapTask
             * @static
             * @param {oracle_job.OracleJob.IJupiterSwapTask} message JupiterSwapTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JupiterSwapTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a JupiterSwapTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.JupiterSwapTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.JupiterSwapTask} JupiterSwapTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JupiterSwapTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.JupiterSwapTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.inTokenAddress = reader.string();
                            break;
                        }
                    case 2: {
                            message.outTokenAddress = reader.string();
                            break;
                        }
                    case 4: {
                            message.allowList = $root.oracle_job.OracleJob.JupiterSwapTask.FilterList.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.denyList = $root.oracle_job.OracleJob.JupiterSwapTask.FilterList.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.baseAmount = reader.double();
                            break;
                        }
                    case 6: {
                            message.quoteAmount = reader.double();
                            break;
                        }
                    case 7: {
                            message.baseAmountString = reader.string();
                            break;
                        }
                    case 8: {
                            message.quoteAmountString = reader.string();
                            break;
                        }
                    case 9: {
                            message.slippage = reader.double();
                            break;
                        }
                    case 10: {
                            message.version = reader.int32();
                            break;
                        }
                    case 11: {
                            message.directRoutesOnly = reader.bool();
                            break;
                        }
                    case 12: {
                            message.apiKey = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a JupiterSwapTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.JupiterSwapTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.JupiterSwapTask} JupiterSwapTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JupiterSwapTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a JupiterSwapTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.JupiterSwapTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            JupiterSwapTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.inTokenAddress != null && message.hasOwnProperty("inTokenAddress"))
                    if (!$util.isString(message.inTokenAddress))
                        return "inTokenAddress: string expected";
                if (message.outTokenAddress != null && message.hasOwnProperty("outTokenAddress"))
                    if (!$util.isString(message.outTokenAddress))
                        return "outTokenAddress: string expected";
                if (message.allowList != null && message.hasOwnProperty("allowList")) {
                    properties.RoutesFilters = 1;
                    {
                        let error = $root.oracle_job.OracleJob.JupiterSwapTask.FilterList.verify(message.allowList);
                        if (error)
                            return "allowList." + error;
                    }
                }
                if (message.denyList != null && message.hasOwnProperty("denyList")) {
                    if (properties.RoutesFilters === 1)
                        return "RoutesFilters: multiple values";
                    properties.RoutesFilters = 1;
                    {
                        let error = $root.oracle_job.OracleJob.JupiterSwapTask.FilterList.verify(message.denyList);
                        if (error)
                            return "denyList." + error;
                    }
                }
                if (message.baseAmount != null && message.hasOwnProperty("baseAmount")) {
                    properties.SwapAmount = 1;
                    if (typeof message.baseAmount !== "number")
                        return "baseAmount: number expected";
                }
                if (message.quoteAmount != null && message.hasOwnProperty("quoteAmount")) {
                    if (properties.SwapAmount === 1)
                        return "SwapAmount: multiple values";
                    properties.SwapAmount = 1;
                    if (typeof message.quoteAmount !== "number")
                        return "quoteAmount: number expected";
                }
                if (message.baseAmountString != null && message.hasOwnProperty("baseAmountString")) {
                    if (properties.SwapAmount === 1)
                        return "SwapAmount: multiple values";
                    properties.SwapAmount = 1;
                    if (!$util.isString(message.baseAmountString))
                        return "baseAmountString: string expected";
                }
                if (message.quoteAmountString != null && message.hasOwnProperty("quoteAmountString")) {
                    if (properties.SwapAmount === 1)
                        return "SwapAmount: multiple values";
                    properties.SwapAmount = 1;
                    if (!$util.isString(message.quoteAmountString))
                        return "quoteAmountString: string expected";
                }
                if (message.slippage != null && message.hasOwnProperty("slippage"))
                    if (typeof message.slippage !== "number")
                        return "slippage: number expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    switch (message.version) {
                    default:
                        return "version: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.directRoutesOnly != null && message.hasOwnProperty("directRoutesOnly"))
                    if (typeof message.directRoutesOnly !== "boolean")
                        return "directRoutesOnly: boolean expected";
                if (message.apiKey != null && message.hasOwnProperty("apiKey"))
                    if (!$util.isString(message.apiKey))
                        return "apiKey: string expected";
                return null;
            };

            /**
             * Creates a JupiterSwapTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.JupiterSwapTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.JupiterSwapTask} JupiterSwapTask
             */
            JupiterSwapTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.JupiterSwapTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.JupiterSwapTask();
                if (object.inTokenAddress != null)
                    message.inTokenAddress = String(object.inTokenAddress);
                if (object.outTokenAddress != null)
                    message.outTokenAddress = String(object.outTokenAddress);
                if (object.allowList != null) {
                    if (typeof object.allowList !== "object")
                        throw TypeError(".oracle_job.OracleJob.JupiterSwapTask.allowList: object expected");
                    message.allowList = $root.oracle_job.OracleJob.JupiterSwapTask.FilterList.fromObject(object.allowList);
                }
                if (object.denyList != null) {
                    if (typeof object.denyList !== "object")
                        throw TypeError(".oracle_job.OracleJob.JupiterSwapTask.denyList: object expected");
                    message.denyList = $root.oracle_job.OracleJob.JupiterSwapTask.FilterList.fromObject(object.denyList);
                }
                if (object.baseAmount != null)
                    message.baseAmount = Number(object.baseAmount);
                if (object.quoteAmount != null)
                    message.quoteAmount = Number(object.quoteAmount);
                if (object.baseAmountString != null)
                    message.baseAmountString = String(object.baseAmountString);
                if (object.quoteAmountString != null)
                    message.quoteAmountString = String(object.quoteAmountString);
                if (object.slippage != null)
                    message.slippage = Number(object.slippage);
                switch (object.version) {
                default:
                    if (typeof object.version === "number") {
                        message.version = object.version;
                        break;
                    }
                    break;
                case "VERSION_V1":
                case 0:
                    message.version = 0;
                    break;
                case "VERSION_V2":
                case 1:
                    message.version = 1;
                    break;
                }
                if (object.directRoutesOnly != null)
                    message.directRoutesOnly = Boolean(object.directRoutesOnly);
                if (object.apiKey != null)
                    message.apiKey = String(object.apiKey);
                return message;
            };

            /**
             * Creates a plain object from a JupiterSwapTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.JupiterSwapTask
             * @static
             * @param {oracle_job.OracleJob.JupiterSwapTask} message JupiterSwapTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            JupiterSwapTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.inTokenAddress = "";
                    object.outTokenAddress = "";
                    object.slippage = 0;
                    object.version = options.enums === String ? "VERSION_V1" : 0;
                    object.directRoutesOnly = false;
                    object.apiKey = "";
                }
                if (message.inTokenAddress != null && message.hasOwnProperty("inTokenAddress"))
                    object.inTokenAddress = message.inTokenAddress;
                if (message.outTokenAddress != null && message.hasOwnProperty("outTokenAddress"))
                    object.outTokenAddress = message.outTokenAddress;
                if (message.baseAmount != null && message.hasOwnProperty("baseAmount")) {
                    object.baseAmount = options.json && !isFinite(message.baseAmount) ? String(message.baseAmount) : message.baseAmount;
                    if (options.oneofs)
                        object.SwapAmount = "baseAmount";
                }
                if (message.allowList != null && message.hasOwnProperty("allowList")) {
                    object.allowList = $root.oracle_job.OracleJob.JupiterSwapTask.FilterList.toObject(message.allowList, options);
                    if (options.oneofs)
                        object.RoutesFilters = "allowList";
                }
                if (message.denyList != null && message.hasOwnProperty("denyList")) {
                    object.denyList = $root.oracle_job.OracleJob.JupiterSwapTask.FilterList.toObject(message.denyList, options);
                    if (options.oneofs)
                        object.RoutesFilters = "denyList";
                }
                if (message.quoteAmount != null && message.hasOwnProperty("quoteAmount")) {
                    object.quoteAmount = options.json && !isFinite(message.quoteAmount) ? String(message.quoteAmount) : message.quoteAmount;
                    if (options.oneofs)
                        object.SwapAmount = "quoteAmount";
                }
                if (message.baseAmountString != null && message.hasOwnProperty("baseAmountString")) {
                    object.baseAmountString = message.baseAmountString;
                    if (options.oneofs)
                        object.SwapAmount = "baseAmountString";
                }
                if (message.quoteAmountString != null && message.hasOwnProperty("quoteAmountString")) {
                    object.quoteAmountString = message.quoteAmountString;
                    if (options.oneofs)
                        object.SwapAmount = "quoteAmountString";
                }
                if (message.slippage != null && message.hasOwnProperty("slippage"))
                    object.slippage = options.json && !isFinite(message.slippage) ? String(message.slippage) : message.slippage;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = options.enums === String ? $root.oracle_job.OracleJob.JupiterSwapTask.Version[message.version] === undefined ? message.version : $root.oracle_job.OracleJob.JupiterSwapTask.Version[message.version] : message.version;
                if (message.directRoutesOnly != null && message.hasOwnProperty("directRoutesOnly"))
                    object.directRoutesOnly = message.directRoutesOnly;
                if (message.apiKey != null && message.hasOwnProperty("apiKey"))
                    object.apiKey = message.apiKey;
                return object;
            };

            /**
             * Converts this JupiterSwapTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.JupiterSwapTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            JupiterSwapTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for JupiterSwapTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.JupiterSwapTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            JupiterSwapTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.JupiterSwapTask";
            };

            JupiterSwapTask.FilterList = (function() {

                /**
                 * Properties of a FilterList.
                 * @memberof oracle_job.OracleJob.JupiterSwapTask
                 * @interface IFilterList
                 * @property {Array.<string>|null} [labels] A list of Jupiter AMM labels to allow or deny (e.g. 'Raydium', 'Orca')
                 */

                /**
                 * Constructs a new FilterList.
                 * @memberof oracle_job.OracleJob.JupiterSwapTask
                 * @classdesc Represents a FilterList.
                 * @implements IFilterList
                 * @constructor
                 * @param {oracle_job.OracleJob.JupiterSwapTask.IFilterList=} [properties] Properties to set
                 */
                function FilterList(properties) {
                    this.labels = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * A list of Jupiter AMM labels to allow or deny (e.g. 'Raydium', 'Orca')
                 * @member {Array.<string>} labels
                 * @memberof oracle_job.OracleJob.JupiterSwapTask.FilterList
                 * @instance
                 */
                FilterList.prototype.labels = $util.emptyArray;

                /**
                 * Creates a new FilterList instance using the specified properties.
                 * @function create
                 * @memberof oracle_job.OracleJob.JupiterSwapTask.FilterList
                 * @static
                 * @param {oracle_job.OracleJob.JupiterSwapTask.IFilterList=} [properties] Properties to set
                 * @returns {oracle_job.OracleJob.JupiterSwapTask.FilterList} FilterList instance
                 */
                FilterList.create = function create(properties) {
      return FilterList.fromObject(properties);
    };

                /**
                 * Encodes the specified FilterList message. Does not implicitly {@link oracle_job.OracleJob.JupiterSwapTask.FilterList.verify|verify} messages.
                 * @function encode
                 * @memberof oracle_job.OracleJob.JupiterSwapTask.FilterList
                 * @static
                 * @param {oracle_job.OracleJob.JupiterSwapTask.IFilterList} message FilterList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FilterList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.labels != null && message.labels.length)
                        for (let i = 0; i < message.labels.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.labels[i]);
                    return writer;
                };

                /**
                 * Encodes the specified FilterList message, length delimited. Does not implicitly {@link oracle_job.OracleJob.JupiterSwapTask.FilterList.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof oracle_job.OracleJob.JupiterSwapTask.FilterList
                 * @static
                 * @param {oracle_job.OracleJob.JupiterSwapTask.IFilterList} message FilterList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FilterList.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a FilterList message from the specified reader or buffer.
                 * @function decode
                 * @memberof oracle_job.OracleJob.JupiterSwapTask.FilterList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {oracle_job.OracleJob.JupiterSwapTask.FilterList} FilterList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FilterList.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.JupiterSwapTask.FilterList();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.labels && message.labels.length))
                                    message.labels = [];
                                message.labels.push(reader.string());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a FilterList message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof oracle_job.OracleJob.JupiterSwapTask.FilterList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {oracle_job.OracleJob.JupiterSwapTask.FilterList} FilterList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FilterList.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a FilterList message.
                 * @function verify
                 * @memberof oracle_job.OracleJob.JupiterSwapTask.FilterList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FilterList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        if (!Array.isArray(message.labels))
                            return "labels: array expected";
                        for (let i = 0; i < message.labels.length; ++i)
                            if (!$util.isString(message.labels[i]))
                                return "labels: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a FilterList message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof oracle_job.OracleJob.JupiterSwapTask.FilterList
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {oracle_job.OracleJob.JupiterSwapTask.FilterList} FilterList
                 */
                FilterList.fromObject = function fromObject(object) {
                    if (object instanceof $root.oracle_job.OracleJob.JupiterSwapTask.FilterList)
                        return object;
                    let message = new $root.oracle_job.OracleJob.JupiterSwapTask.FilterList();
                    if (object.labels) {
                        if (!Array.isArray(object.labels))
                            throw TypeError(".oracle_job.OracleJob.JupiterSwapTask.FilterList.labels: array expected");
                        message.labels = [];
                        for (let i = 0; i < object.labels.length; ++i)
                            message.labels[i] = String(object.labels[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a FilterList message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof oracle_job.OracleJob.JupiterSwapTask.FilterList
                 * @static
                 * @param {oracle_job.OracleJob.JupiterSwapTask.FilterList} message FilterList
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FilterList.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.labels = [];
                    if (message.labels && message.labels.length) {
                        object.labels = [];
                        for (let j = 0; j < message.labels.length; ++j)
                            object.labels[j] = message.labels[j];
                    }
                    return object;
                };

                /**
                 * Converts this FilterList to JSON.
                 * @function toJSON
                 * @memberof oracle_job.OracleJob.JupiterSwapTask.FilterList
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FilterList.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for FilterList
                 * @function getTypeUrl
                 * @memberof oracle_job.OracleJob.JupiterSwapTask.FilterList
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                FilterList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/oracle_job.OracleJob.JupiterSwapTask.FilterList";
                };

                return FilterList;
            })();

            /**
             * Version enum.
             * @name oracle_job.OracleJob.JupiterSwapTask.Version
             * @enum {number}
             * @property {number} VERSION_V1=0 VERSION_V1 value
             * @property {number} VERSION_V2=1 VERSION_V2 value
             */
            JupiterSwapTask.Version = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "VERSION_V1"] = 0;
                values[valuesById[1] = "VERSION_V2"] = 1;
                return values;
            })();

            return JupiterSwapTask;
        })();

        OracleJob.TitanTask = (function() {

            /**
             * Properties of a TitanTask.
             * @memberof oracle_job.OracleJob
             * @interface ITitanTask
             * @property {string|null} [inTokenAddress] The input token mint address (base58 encoded).
             * @property {string|null} [outTokenAddress] The output token mint address (base58 encoded).
             * @property {string|null} [amount] The amount of tokens to swap (raw atoms, not scaled by decimals).
             * @property {string|null} [userPublicKey] Optional user public key for transaction generation (base58 encoded).
             * @property {oracle_job.OracleJob.TitanTask.SwapMode|null} [swapMode] Whether the amount is in terms of input or output token. Defaults to ExactIn.
             * @property {number|null} [slippageBps] Allowed slippage in basis points (e.g., 50 = 0.5%).
             * @property {oracle_job.OracleJob.TitanTask.IFilterList|null} [dexes] If set, constrain quotes to the given set of DEXes.
             * @property {oracle_job.OracleJob.TitanTask.IFilterList|null} [excludeDexes] If set, exclude the following DEXes when determining routes.
             * @property {boolean|null} [onlyDirectRoutes] If set to true, only direct routes between the input and output mint will be considered.
             * @property {Array.<string>|null} [providers] If set, limit quotes to the given set of provider IDs.
             * @property {string|null} [accessToken] Optional API access token for authenticated requests
             * @property {string|null} [apiEndpoint] Optional API endpoint override (defaults to partners.api.titan.exchange)
             */

            /**
             * Constructs a new TitanTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Fetch the simulated swap price from Titan API.
             * 
             * _**Input**_: None
             * 
             * _**Returns**_: The swap price on Titan for a given input and output token mint address.
             * 
             * _**Example**_: Fetch the Titan price for exchanging 1 SOL into USDC.
             * 
             * ```json
             * { "titanTask": { "inTokenAddress": "So11111111111111111111111111111111111111112", "outTokenAddress": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v" } }
             * ```
             * 
             * _**Example**_: Fetch the Titan price for exchanging 1000 SOL into USDC with slippage.
             * 
             * ```json
             * { "titanTask": { "inTokenAddress": "So11111111111111111111111111111111111111112", "outTokenAddress": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", "amount": "1000", "slippageBps": 50 } }
             * ```
             * @implements ITitanTask
             * @constructor
             * @param {oracle_job.OracleJob.ITitanTask=} [properties] Properties to set
             */
            function TitanTask(properties) {
                this.providers = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The input token mint address (base58 encoded).
             * @member {string} inTokenAddress
             * @memberof oracle_job.OracleJob.TitanTask
             * @instance
             */
            TitanTask.prototype.inTokenAddress = "";

            /**
             * The output token mint address (base58 encoded).
             * @member {string} outTokenAddress
             * @memberof oracle_job.OracleJob.TitanTask
             * @instance
             */
            TitanTask.prototype.outTokenAddress = "";

            /**
             * The amount of tokens to swap (raw atoms, not scaled by decimals).
             * @member {string} amount
             * @memberof oracle_job.OracleJob.TitanTask
             * @instance
             */
            TitanTask.prototype.amount = "";

            /**
             * Optional user public key for transaction generation (base58 encoded).
             * @member {string} userPublicKey
             * @memberof oracle_job.OracleJob.TitanTask
             * @instance
             */
            TitanTask.prototype.userPublicKey = "";

            /**
             * Whether the amount is in terms of input or output token. Defaults to ExactIn.
             * @member {oracle_job.OracleJob.TitanTask.SwapMode} swapMode
             * @memberof oracle_job.OracleJob.TitanTask
             * @instance
             */
            TitanTask.prototype.swapMode = 0;

            /**
             * Allowed slippage in basis points (e.g., 50 = 0.5%).
             * @member {number} slippageBps
             * @memberof oracle_job.OracleJob.TitanTask
             * @instance
             */
            TitanTask.prototype.slippageBps = 0;

            /**
             * If set, constrain quotes to the given set of DEXes.
             * @member {oracle_job.OracleJob.TitanTask.IFilterList|null|undefined} dexes
             * @memberof oracle_job.OracleJob.TitanTask
             * @instance
             */
            TitanTask.prototype.dexes = null;

            /**
             * If set, exclude the following DEXes when determining routes.
             * @member {oracle_job.OracleJob.TitanTask.IFilterList|null|undefined} excludeDexes
             * @memberof oracle_job.OracleJob.TitanTask
             * @instance
             */
            TitanTask.prototype.excludeDexes = null;

            /**
             * If set to true, only direct routes between the input and output mint will be considered.
             * @member {boolean} onlyDirectRoutes
             * @memberof oracle_job.OracleJob.TitanTask
             * @instance
             */
            TitanTask.prototype.onlyDirectRoutes = false;

            /**
             * If set, limit quotes to the given set of provider IDs.
             * @member {Array.<string>} providers
             * @memberof oracle_job.OracleJob.TitanTask
             * @instance
             */
            TitanTask.prototype.providers = $util.emptyArray;

            /**
             * Optional API access token for authenticated requests
             * @member {string} accessToken
             * @memberof oracle_job.OracleJob.TitanTask
             * @instance
             */
            TitanTask.prototype.accessToken = "";

            /**
             * Optional API endpoint override (defaults to partners.api.titan.exchange)
             * @member {string} apiEndpoint
             * @memberof oracle_job.OracleJob.TitanTask
             * @instance
             */
            TitanTask.prototype.apiEndpoint = "";

            /**
             * Creates a new TitanTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.TitanTask
             * @static
             * @param {oracle_job.OracleJob.ITitanTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.TitanTask} TitanTask instance
             */
            TitanTask.create = function create(properties) {
      return TitanTask.fromObject(properties);
    };

            /**
             * Encodes the specified TitanTask message. Does not implicitly {@link oracle_job.OracleJob.TitanTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.TitanTask
             * @static
             * @param {oracle_job.OracleJob.ITitanTask} message TitanTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TitanTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.inTokenAddress != null && Object.hasOwnProperty.call(message, "inTokenAddress"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.inTokenAddress);
                if (message.outTokenAddress != null && Object.hasOwnProperty.call(message, "outTokenAddress"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.outTokenAddress);
                if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.amount);
                if (message.userPublicKey != null && Object.hasOwnProperty.call(message, "userPublicKey"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.userPublicKey);
                if (message.swapMode != null && Object.hasOwnProperty.call(message, "swapMode"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.swapMode);
                if (message.slippageBps != null && Object.hasOwnProperty.call(message, "slippageBps"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.slippageBps);
                if (message.dexes != null && Object.hasOwnProperty.call(message, "dexes"))
                    $root.oracle_job.OracleJob.TitanTask.FilterList.encode(message.dexes, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.excludeDexes != null && Object.hasOwnProperty.call(message, "excludeDexes"))
                    $root.oracle_job.OracleJob.TitanTask.FilterList.encode(message.excludeDexes, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.onlyDirectRoutes != null && Object.hasOwnProperty.call(message, "onlyDirectRoutes"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.onlyDirectRoutes);
                if (message.providers != null && message.providers.length)
                    for (let i = 0; i < message.providers.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.providers[i]);
                if (message.accessToken != null && Object.hasOwnProperty.call(message, "accessToken"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.accessToken);
                if (message.apiEndpoint != null && Object.hasOwnProperty.call(message, "apiEndpoint"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.apiEndpoint);
                return writer;
            };

            /**
             * Encodes the specified TitanTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.TitanTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.TitanTask
             * @static
             * @param {oracle_job.OracleJob.ITitanTask} message TitanTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TitanTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TitanTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.TitanTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.TitanTask} TitanTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TitanTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.TitanTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.inTokenAddress = reader.string();
                            break;
                        }
                    case 2: {
                            message.outTokenAddress = reader.string();
                            break;
                        }
                    case 3: {
                            message.amount = reader.string();
                            break;
                        }
                    case 4: {
                            message.userPublicKey = reader.string();
                            break;
                        }
                    case 5: {
                            message.swapMode = reader.int32();
                            break;
                        }
                    case 6: {
                            message.slippageBps = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.dexes = $root.oracle_job.OracleJob.TitanTask.FilterList.decode(reader, reader.uint32());
                            break;
                        }
                    case 8: {
                            message.excludeDexes = $root.oracle_job.OracleJob.TitanTask.FilterList.decode(reader, reader.uint32());
                            break;
                        }
                    case 9: {
                            message.onlyDirectRoutes = reader.bool();
                            break;
                        }
                    case 10: {
                            if (!(message.providers && message.providers.length))
                                message.providers = [];
                            message.providers.push(reader.string());
                            break;
                        }
                    case 11: {
                            message.accessToken = reader.string();
                            break;
                        }
                    case 12: {
                            message.apiEndpoint = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TitanTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.TitanTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.TitanTask} TitanTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TitanTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TitanTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.TitanTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TitanTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.inTokenAddress != null && message.hasOwnProperty("inTokenAddress"))
                    if (!$util.isString(message.inTokenAddress))
                        return "inTokenAddress: string expected";
                if (message.outTokenAddress != null && message.hasOwnProperty("outTokenAddress"))
                    if (!$util.isString(message.outTokenAddress))
                        return "outTokenAddress: string expected";
                if (message.amount != null && message.hasOwnProperty("amount"))
                    if (!$util.isString(message.amount))
                        return "amount: string expected";
                if (message.userPublicKey != null && message.hasOwnProperty("userPublicKey"))
                    if (!$util.isString(message.userPublicKey))
                        return "userPublicKey: string expected";
                if (message.swapMode != null && message.hasOwnProperty("swapMode"))
                    switch (message.swapMode) {
                    default:
                        return "swapMode: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.slippageBps != null && message.hasOwnProperty("slippageBps"))
                    if (!$util.isInteger(message.slippageBps))
                        return "slippageBps: integer expected";
                if (message.dexes != null && message.hasOwnProperty("dexes")) {
                    let error = $root.oracle_job.OracleJob.TitanTask.FilterList.verify(message.dexes);
                    if (error)
                        return "dexes." + error;
                }
                if (message.excludeDexes != null && message.hasOwnProperty("excludeDexes")) {
                    let error = $root.oracle_job.OracleJob.TitanTask.FilterList.verify(message.excludeDexes);
                    if (error)
                        return "excludeDexes." + error;
                }
                if (message.onlyDirectRoutes != null && message.hasOwnProperty("onlyDirectRoutes"))
                    if (typeof message.onlyDirectRoutes !== "boolean")
                        return "onlyDirectRoutes: boolean expected";
                if (message.providers != null && message.hasOwnProperty("providers")) {
                    if (!Array.isArray(message.providers))
                        return "providers: array expected";
                    for (let i = 0; i < message.providers.length; ++i)
                        if (!$util.isString(message.providers[i]))
                            return "providers: string[] expected";
                }
                if (message.accessToken != null && message.hasOwnProperty("accessToken"))
                    if (!$util.isString(message.accessToken))
                        return "accessToken: string expected";
                if (message.apiEndpoint != null && message.hasOwnProperty("apiEndpoint"))
                    if (!$util.isString(message.apiEndpoint))
                        return "apiEndpoint: string expected";
                return null;
            };

            /**
             * Creates a TitanTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.TitanTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.TitanTask} TitanTask
             */
            TitanTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.TitanTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.TitanTask();
                if (object.inTokenAddress != null)
                    message.inTokenAddress = String(object.inTokenAddress);
                if (object.outTokenAddress != null)
                    message.outTokenAddress = String(object.outTokenAddress);
                if (object.amount != null)
                    message.amount = String(object.amount);
                if (object.userPublicKey != null)
                    message.userPublicKey = String(object.userPublicKey);
                switch (object.swapMode) {
                default:
                    if (typeof object.swapMode === "number") {
                        message.swapMode = object.swapMode;
                        break;
                    }
                    break;
                case "SWAP_MODE_EXACT_IN":
                case 0:
                    message.swapMode = 0;
                    break;
                case "SWAP_MODE_EXACT_OUT":
                case 1:
                    message.swapMode = 1;
                    break;
                }
                if (object.slippageBps != null)
                    message.slippageBps = object.slippageBps >>> 0;
                if (object.dexes != null) {
                    if (typeof object.dexes !== "object")
                        throw TypeError(".oracle_job.OracleJob.TitanTask.dexes: object expected");
                    message.dexes = $root.oracle_job.OracleJob.TitanTask.FilterList.fromObject(object.dexes);
                }
                if (object.excludeDexes != null) {
                    if (typeof object.excludeDexes !== "object")
                        throw TypeError(".oracle_job.OracleJob.TitanTask.excludeDexes: object expected");
                    message.excludeDexes = $root.oracle_job.OracleJob.TitanTask.FilterList.fromObject(object.excludeDexes);
                }
                if (object.onlyDirectRoutes != null)
                    message.onlyDirectRoutes = Boolean(object.onlyDirectRoutes);
                if (object.providers) {
                    if (!Array.isArray(object.providers))
                        throw TypeError(".oracle_job.OracleJob.TitanTask.providers: array expected");
                    message.providers = [];
                    for (let i = 0; i < object.providers.length; ++i)
                        message.providers[i] = String(object.providers[i]);
                }
                if (object.accessToken != null)
                    message.accessToken = String(object.accessToken);
                if (object.apiEndpoint != null)
                    message.apiEndpoint = String(object.apiEndpoint);
                return message;
            };

            /**
             * Creates a plain object from a TitanTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.TitanTask
             * @static
             * @param {oracle_job.OracleJob.TitanTask} message TitanTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TitanTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.providers = [];
                if (options.defaults) {
                    object.inTokenAddress = "";
                    object.outTokenAddress = "";
                    object.amount = "";
                    object.userPublicKey = "";
                    object.swapMode = options.enums === String ? "SWAP_MODE_EXACT_IN" : 0;
                    object.slippageBps = 0;
                    object.dexes = null;
                    object.excludeDexes = null;
                    object.onlyDirectRoutes = false;
                    object.accessToken = "";
                    object.apiEndpoint = "";
                }
                if (message.inTokenAddress != null && message.hasOwnProperty("inTokenAddress"))
                    object.inTokenAddress = message.inTokenAddress;
                if (message.outTokenAddress != null && message.hasOwnProperty("outTokenAddress"))
                    object.outTokenAddress = message.outTokenAddress;
                if (message.amount != null && message.hasOwnProperty("amount"))
                    object.amount = message.amount;
                if (message.userPublicKey != null && message.hasOwnProperty("userPublicKey"))
                    object.userPublicKey = message.userPublicKey;
                if (message.swapMode != null && message.hasOwnProperty("swapMode"))
                    object.swapMode = options.enums === String ? $root.oracle_job.OracleJob.TitanTask.SwapMode[message.swapMode] === undefined ? message.swapMode : $root.oracle_job.OracleJob.TitanTask.SwapMode[message.swapMode] : message.swapMode;
                if (message.slippageBps != null && message.hasOwnProperty("slippageBps"))
                    object.slippageBps = message.slippageBps;
                if (message.dexes != null && message.hasOwnProperty("dexes"))
                    object.dexes = $root.oracle_job.OracleJob.TitanTask.FilterList.toObject(message.dexes, options);
                if (message.excludeDexes != null && message.hasOwnProperty("excludeDexes"))
                    object.excludeDexes = $root.oracle_job.OracleJob.TitanTask.FilterList.toObject(message.excludeDexes, options);
                if (message.onlyDirectRoutes != null && message.hasOwnProperty("onlyDirectRoutes"))
                    object.onlyDirectRoutes = message.onlyDirectRoutes;
                if (message.providers && message.providers.length) {
                    object.providers = [];
                    for (let j = 0; j < message.providers.length; ++j)
                        object.providers[j] = message.providers[j];
                }
                if (message.accessToken != null && message.hasOwnProperty("accessToken"))
                    object.accessToken = message.accessToken;
                if (message.apiEndpoint != null && message.hasOwnProperty("apiEndpoint"))
                    object.apiEndpoint = message.apiEndpoint;
                return object;
            };

            /**
             * Converts this TitanTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.TitanTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TitanTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TitanTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.TitanTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TitanTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.TitanTask";
            };

            /**
             * SwapMode enum.
             * @name oracle_job.OracleJob.TitanTask.SwapMode
             * @enum {number}
             * @property {number} SWAP_MODE_EXACT_IN=0 The amount is in terms of the input token.
             * @property {number} SWAP_MODE_EXACT_OUT=1 The amount is in terms of the output token.
             */
            TitanTask.SwapMode = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "SWAP_MODE_EXACT_IN"] = 0;
                values[valuesById[1] = "SWAP_MODE_EXACT_OUT"] = 1;
                return values;
            })();

            TitanTask.FilterList = (function() {

                /**
                 * Properties of a FilterList.
                 * @memberof oracle_job.OracleJob.TitanTask
                 * @interface IFilterList
                 * @property {Array.<string>|null} [labels] A list of DEX labels to allow or deny (e.g., 'Raydium', 'Orca')
                 */

                /**
                 * Constructs a new FilterList.
                 * @memberof oracle_job.OracleJob.TitanTask
                 * @classdesc Represents a FilterList.
                 * @implements IFilterList
                 * @constructor
                 * @param {oracle_job.OracleJob.TitanTask.IFilterList=} [properties] Properties to set
                 */
                function FilterList(properties) {
                    this.labels = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * A list of DEX labels to allow or deny (e.g., 'Raydium', 'Orca')
                 * @member {Array.<string>} labels
                 * @memberof oracle_job.OracleJob.TitanTask.FilterList
                 * @instance
                 */
                FilterList.prototype.labels = $util.emptyArray;

                /**
                 * Creates a new FilterList instance using the specified properties.
                 * @function create
                 * @memberof oracle_job.OracleJob.TitanTask.FilterList
                 * @static
                 * @param {oracle_job.OracleJob.TitanTask.IFilterList=} [properties] Properties to set
                 * @returns {oracle_job.OracleJob.TitanTask.FilterList} FilterList instance
                 */
                FilterList.create = function create(properties) {
      return FilterList.fromObject(properties);
    };

                /**
                 * Encodes the specified FilterList message. Does not implicitly {@link oracle_job.OracleJob.TitanTask.FilterList.verify|verify} messages.
                 * @function encode
                 * @memberof oracle_job.OracleJob.TitanTask.FilterList
                 * @static
                 * @param {oracle_job.OracleJob.TitanTask.IFilterList} message FilterList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FilterList.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.labels != null && message.labels.length)
                        for (let i = 0; i < message.labels.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.labels[i]);
                    return writer;
                };

                /**
                 * Encodes the specified FilterList message, length delimited. Does not implicitly {@link oracle_job.OracleJob.TitanTask.FilterList.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof oracle_job.OracleJob.TitanTask.FilterList
                 * @static
                 * @param {oracle_job.OracleJob.TitanTask.IFilterList} message FilterList message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FilterList.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a FilterList message from the specified reader or buffer.
                 * @function decode
                 * @memberof oracle_job.OracleJob.TitanTask.FilterList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {oracle_job.OracleJob.TitanTask.FilterList} FilterList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FilterList.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.TitanTask.FilterList();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                if (!(message.labels && message.labels.length))
                                    message.labels = [];
                                message.labels.push(reader.string());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a FilterList message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof oracle_job.OracleJob.TitanTask.FilterList
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {oracle_job.OracleJob.TitanTask.FilterList} FilterList
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FilterList.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a FilterList message.
                 * @function verify
                 * @memberof oracle_job.OracleJob.TitanTask.FilterList
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FilterList.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        if (!Array.isArray(message.labels))
                            return "labels: array expected";
                        for (let i = 0; i < message.labels.length; ++i)
                            if (!$util.isString(message.labels[i]))
                                return "labels: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a FilterList message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof oracle_job.OracleJob.TitanTask.FilterList
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {oracle_job.OracleJob.TitanTask.FilterList} FilterList
                 */
                FilterList.fromObject = function fromObject(object) {
                    if (object instanceof $root.oracle_job.OracleJob.TitanTask.FilterList)
                        return object;
                    let message = new $root.oracle_job.OracleJob.TitanTask.FilterList();
                    if (object.labels) {
                        if (!Array.isArray(object.labels))
                            throw TypeError(".oracle_job.OracleJob.TitanTask.FilterList.labels: array expected");
                        message.labels = [];
                        for (let i = 0; i < object.labels.length; ++i)
                            message.labels[i] = String(object.labels[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a FilterList message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof oracle_job.OracleJob.TitanTask.FilterList
                 * @static
                 * @param {oracle_job.OracleJob.TitanTask.FilterList} message FilterList
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FilterList.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.labels = [];
                    if (message.labels && message.labels.length) {
                        object.labels = [];
                        for (let j = 0; j < message.labels.length; ++j)
                            object.labels[j] = message.labels[j];
                    }
                    return object;
                };

                /**
                 * Converts this FilterList to JSON.
                 * @function toJSON
                 * @memberof oracle_job.OracleJob.TitanTask.FilterList
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FilterList.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for FilterList
                 * @function getTypeUrl
                 * @memberof oracle_job.OracleJob.TitanTask.FilterList
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                FilterList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/oracle_job.OracleJob.TitanTask.FilterList";
                };

                return FilterList;
            })();

            return TitanTask;
        })();

        OracleJob.PerpMarketTask = (function() {

            /**
             * Properties of a PerpMarketTask.
             * @memberof oracle_job.OracleJob
             * @interface IPerpMarketTask
             * @property {string|null} [mangoMarketAddress] Market address for a mango perpetual market. A full list can be found here: https://github.com/blockworks-foundation/mango-client-v3/blob/main/src/ids.json
             * @property {string|null} [driftMarketAddress] Market address for a drift perpetual market. A full list can be found here: https://github.com/drift-labs/protocol-v1/blob/master/sdk/src/constants/markets.ts
             * @property {string|null} [zetaMarketAddress] Market address for a zeta perpetual market.
             * @property {string|null} [zoMarketAddress] Market address for a 01 protocol perpetual market.
             */

            /**
             * Constructs a new PerpMarketTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Fetch the current price of a perpetual market.
             * @implements IPerpMarketTask
             * @constructor
             * @param {oracle_job.OracleJob.IPerpMarketTask=} [properties] Properties to set
             */
            function PerpMarketTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Market address for a mango perpetual market. A full list can be found here: https://github.com/blockworks-foundation/mango-client-v3/blob/main/src/ids.json
             * @member {string|null|undefined} mangoMarketAddress
             * @memberof oracle_job.OracleJob.PerpMarketTask
             * @instance
             */
            PerpMarketTask.prototype.mangoMarketAddress = null;

            /**
             * Market address for a drift perpetual market. A full list can be found here: https://github.com/drift-labs/protocol-v1/blob/master/sdk/src/constants/markets.ts
             * @member {string|null|undefined} driftMarketAddress
             * @memberof oracle_job.OracleJob.PerpMarketTask
             * @instance
             */
            PerpMarketTask.prototype.driftMarketAddress = null;

            /**
             * Market address for a zeta perpetual market.
             * @member {string|null|undefined} zetaMarketAddress
             * @memberof oracle_job.OracleJob.PerpMarketTask
             * @instance
             */
            PerpMarketTask.prototype.zetaMarketAddress = null;

            /**
             * Market address for a 01 protocol perpetual market.
             * @member {string|null|undefined} zoMarketAddress
             * @memberof oracle_job.OracleJob.PerpMarketTask
             * @instance
             */
            PerpMarketTask.prototype.zoMarketAddress = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * PerpMarketTask MarketAddress.
             * @member {"mangoMarketAddress"|"driftMarketAddress"|"zetaMarketAddress"|"zoMarketAddress"|undefined} MarketAddress
             * @memberof oracle_job.OracleJob.PerpMarketTask
             * @instance
             */
            Object.defineProperty(PerpMarketTask.prototype, "MarketAddress", {
                get: $util.oneOfGetter($oneOfFields = ["mangoMarketAddress", "driftMarketAddress", "zetaMarketAddress", "zoMarketAddress"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new PerpMarketTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.PerpMarketTask
             * @static
             * @param {oracle_job.OracleJob.IPerpMarketTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.PerpMarketTask} PerpMarketTask instance
             */
            PerpMarketTask.create = function create(properties) {
      return PerpMarketTask.fromObject(properties);
    };

            /**
             * Encodes the specified PerpMarketTask message. Does not implicitly {@link oracle_job.OracleJob.PerpMarketTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.PerpMarketTask
             * @static
             * @param {oracle_job.OracleJob.IPerpMarketTask} message PerpMarketTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PerpMarketTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.mangoMarketAddress != null && Object.hasOwnProperty.call(message, "mangoMarketAddress"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.mangoMarketAddress);
                if (message.driftMarketAddress != null && Object.hasOwnProperty.call(message, "driftMarketAddress"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.driftMarketAddress);
                if (message.zetaMarketAddress != null && Object.hasOwnProperty.call(message, "zetaMarketAddress"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.zetaMarketAddress);
                if (message.zoMarketAddress != null && Object.hasOwnProperty.call(message, "zoMarketAddress"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.zoMarketAddress);
                return writer;
            };

            /**
             * Encodes the specified PerpMarketTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.PerpMarketTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.PerpMarketTask
             * @static
             * @param {oracle_job.OracleJob.IPerpMarketTask} message PerpMarketTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PerpMarketTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PerpMarketTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.PerpMarketTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.PerpMarketTask} PerpMarketTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PerpMarketTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.PerpMarketTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.mangoMarketAddress = reader.string();
                            break;
                        }
                    case 2: {
                            message.driftMarketAddress = reader.string();
                            break;
                        }
                    case 3: {
                            message.zetaMarketAddress = reader.string();
                            break;
                        }
                    case 4: {
                            message.zoMarketAddress = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PerpMarketTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.PerpMarketTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.PerpMarketTask} PerpMarketTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PerpMarketTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PerpMarketTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.PerpMarketTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PerpMarketTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.mangoMarketAddress != null && message.hasOwnProperty("mangoMarketAddress")) {
                    properties.MarketAddress = 1;
                    if (!$util.isString(message.mangoMarketAddress))
                        return "mangoMarketAddress: string expected";
                }
                if (message.driftMarketAddress != null && message.hasOwnProperty("driftMarketAddress")) {
                    if (properties.MarketAddress === 1)
                        return "MarketAddress: multiple values";
                    properties.MarketAddress = 1;
                    if (!$util.isString(message.driftMarketAddress))
                        return "driftMarketAddress: string expected";
                }
                if (message.zetaMarketAddress != null && message.hasOwnProperty("zetaMarketAddress")) {
                    if (properties.MarketAddress === 1)
                        return "MarketAddress: multiple values";
                    properties.MarketAddress = 1;
                    if (!$util.isString(message.zetaMarketAddress))
                        return "zetaMarketAddress: string expected";
                }
                if (message.zoMarketAddress != null && message.hasOwnProperty("zoMarketAddress")) {
                    if (properties.MarketAddress === 1)
                        return "MarketAddress: multiple values";
                    properties.MarketAddress = 1;
                    if (!$util.isString(message.zoMarketAddress))
                        return "zoMarketAddress: string expected";
                }
                return null;
            };

            /**
             * Creates a PerpMarketTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.PerpMarketTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.PerpMarketTask} PerpMarketTask
             */
            PerpMarketTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.PerpMarketTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.PerpMarketTask();
                if (object.mangoMarketAddress != null)
                    message.mangoMarketAddress = String(object.mangoMarketAddress);
                if (object.driftMarketAddress != null)
                    message.driftMarketAddress = String(object.driftMarketAddress);
                if (object.zetaMarketAddress != null)
                    message.zetaMarketAddress = String(object.zetaMarketAddress);
                if (object.zoMarketAddress != null)
                    message.zoMarketAddress = String(object.zoMarketAddress);
                return message;
            };

            /**
             * Creates a plain object from a PerpMarketTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.PerpMarketTask
             * @static
             * @param {oracle_job.OracleJob.PerpMarketTask} message PerpMarketTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PerpMarketTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.mangoMarketAddress != null && message.hasOwnProperty("mangoMarketAddress")) {
                    object.mangoMarketAddress = message.mangoMarketAddress;
                    if (options.oneofs)
                        object.MarketAddress = "mangoMarketAddress";
                }
                if (message.driftMarketAddress != null && message.hasOwnProperty("driftMarketAddress")) {
                    object.driftMarketAddress = message.driftMarketAddress;
                    if (options.oneofs)
                        object.MarketAddress = "driftMarketAddress";
                }
                if (message.zetaMarketAddress != null && message.hasOwnProperty("zetaMarketAddress")) {
                    object.zetaMarketAddress = message.zetaMarketAddress;
                    if (options.oneofs)
                        object.MarketAddress = "zetaMarketAddress";
                }
                if (message.zoMarketAddress != null && message.hasOwnProperty("zoMarketAddress")) {
                    object.zoMarketAddress = message.zoMarketAddress;
                    if (options.oneofs)
                        object.MarketAddress = "zoMarketAddress";
                }
                return object;
            };

            /**
             * Converts this PerpMarketTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.PerpMarketTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PerpMarketTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PerpMarketTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.PerpMarketTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PerpMarketTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.PerpMarketTask";
            };

            return PerpMarketTask;
        })();

        OracleJob.OracleTask = (function() {

            /**
             * Properties of an OracleTask.
             * @memberof oracle_job.OracleJob
             * @interface IOracleTask
             * @property {string|null} [switchboardAddress] Mainnet address of a Switchboard feed. Switchboard is decentralized and allows anyone to build their own feed.
             * @property {string|null} [pythAddress] Mainnet address for a Pyth feed. A full list can be found here: https://pyth.network/price-feeds/
             * @property {string|null} [chainlinkAddress] Mainnet address for a Chainlink feed. A full list can be found here: https://docs.chain.link/docs/solana/data-feeds-solana
             * @property {string|null} [edgeId] OracleTask edgeId
             * @property {string|null} [redstoneId] OracleTask redstoneId
             * @property {number|null} [pythAllowedConfidenceInterval] Value (as a percentage) that the lower bound confidence interval is of the actual value.
             * Confidence intervals that are larger that this treshold are rejected.
             * 
             * The confidence interval should be provided as a raw percentage value. For example, to
             * represent 10%, enter the value as 10, not 0.1.
             * @property {oracle_job.OracleJob.OracleTask.IChainlinkConfigs|null} [chainlinkConfigs] OracleTask chainlinkConfigs
             * @property {oracle_job.OracleJob.OracleTask.IPythConfigs|null} [pythConfigs] OracleTask pythConfigs
             * @property {oracle_job.OracleJob.OracleTask.ISwitchboardConfigs|null} [switchboardConfigs] OracleTask switchboardConfigs
             * @property {oracle_job.OracleJob.OracleTask.IEdgeConfigs|null} [edgeConfigs] OracleTask edgeConfigs
             * @property {oracle_job.OracleJob.OracleTask.IRedstoneConfigs|null} [redstoneConfigs] OracleTask redstoneConfigs
             */

            /**
             * Constructs a new OracleTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Fetch the current price of a Solana oracle protocol.
             * 
             * _**Input**_: None
             * 
             * _**Returns**_: The current price of an on-chain oracle.
             * 
             * _**Example**_: The Switchboard SOL/USD oracle price.
             * 
             * ```json
             * { "oracleTask": { "switchboardAddress": "GvDMxPzN1sCj7L26YDK2HnMRXEQmQ2aemov8YBtPS7vR" } }
             * ```
             * 
             * _**Example**_: The Pyth SOL/USD oracle price.
             * 
             * ```json
             * { "oracleTask": { "pythAddress": "H6ARHf6YXhGYeQfUzQNGk6rDNnLBQKrenN712K4AQJEG" } }
             * ```
             * 
             * _**Example**_: The Chainlink SOL/USD oracle price.
             * 
             * ```json
             * { "oracleTask": { "chainlinkAddress": "CcPVS9bqyXbD9cLnTbhhHazLsrua8QMFUHTutPtjyDzq" } }
             * ```
             * @implements IOracleTask
             * @constructor
             * @param {oracle_job.OracleJob.IOracleTask=} [properties] Properties to set
             */
            function OracleTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Mainnet address of a Switchboard feed. Switchboard is decentralized and allows anyone to build their own feed.
             * @member {string|null|undefined} switchboardAddress
             * @memberof oracle_job.OracleJob.OracleTask
             * @instance
             */
            OracleTask.prototype.switchboardAddress = null;

            /**
             * Mainnet address for a Pyth feed. A full list can be found here: https://pyth.network/price-feeds/
             * @member {string|null|undefined} pythAddress
             * @memberof oracle_job.OracleJob.OracleTask
             * @instance
             */
            OracleTask.prototype.pythAddress = null;

            /**
             * Mainnet address for a Chainlink feed. A full list can be found here: https://docs.chain.link/docs/solana/data-feeds-solana
             * @member {string|null|undefined} chainlinkAddress
             * @memberof oracle_job.OracleJob.OracleTask
             * @instance
             */
            OracleTask.prototype.chainlinkAddress = null;

            /**
             * OracleTask edgeId.
             * @member {string|null|undefined} edgeId
             * @memberof oracle_job.OracleJob.OracleTask
             * @instance
             */
            OracleTask.prototype.edgeId = null;

            /**
             * OracleTask redstoneId.
             * @member {string|null|undefined} redstoneId
             * @memberof oracle_job.OracleJob.OracleTask
             * @instance
             */
            OracleTask.prototype.redstoneId = null;

            /**
             * Value (as a percentage) that the lower bound confidence interval is of the actual value.
             * Confidence intervals that are larger that this treshold are rejected.
             * 
             * The confidence interval should be provided as a raw percentage value. For example, to
             * represent 10%, enter the value as 10, not 0.1.
             * @member {number} pythAllowedConfidenceInterval
             * @memberof oracle_job.OracleJob.OracleTask
             * @instance
             */
            OracleTask.prototype.pythAllowedConfidenceInterval = 0;

            /**
             * OracleTask chainlinkConfigs.
             * @member {oracle_job.OracleJob.OracleTask.IChainlinkConfigs|null|undefined} chainlinkConfigs
             * @memberof oracle_job.OracleJob.OracleTask
             * @instance
             */
            OracleTask.prototype.chainlinkConfigs = null;

            /**
             * OracleTask pythConfigs.
             * @member {oracle_job.OracleJob.OracleTask.IPythConfigs|null|undefined} pythConfigs
             * @memberof oracle_job.OracleJob.OracleTask
             * @instance
             */
            OracleTask.prototype.pythConfigs = null;

            /**
             * OracleTask switchboardConfigs.
             * @member {oracle_job.OracleJob.OracleTask.ISwitchboardConfigs|null|undefined} switchboardConfigs
             * @memberof oracle_job.OracleJob.OracleTask
             * @instance
             */
            OracleTask.prototype.switchboardConfigs = null;

            /**
             * OracleTask edgeConfigs.
             * @member {oracle_job.OracleJob.OracleTask.IEdgeConfigs|null|undefined} edgeConfigs
             * @memberof oracle_job.OracleJob.OracleTask
             * @instance
             */
            OracleTask.prototype.edgeConfigs = null;

            /**
             * OracleTask redstoneConfigs.
             * @member {oracle_job.OracleJob.OracleTask.IRedstoneConfigs|null|undefined} redstoneConfigs
             * @memberof oracle_job.OracleJob.OracleTask
             * @instance
             */
            OracleTask.prototype.redstoneConfigs = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * OracleTask AggregatorAddress.
             * @member {"switchboardAddress"|"pythAddress"|"chainlinkAddress"|"edgeId"|"redstoneId"|undefined} AggregatorAddress
             * @memberof oracle_job.OracleJob.OracleTask
             * @instance
             */
            Object.defineProperty(OracleTask.prototype, "AggregatorAddress", {
                get: $util.oneOfGetter($oneOfFields = ["switchboardAddress", "pythAddress", "chainlinkAddress", "edgeId", "redstoneId"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new OracleTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.OracleTask
             * @static
             * @param {oracle_job.OracleJob.IOracleTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.OracleTask} OracleTask instance
             */
            OracleTask.create = function create(properties) {
      return OracleTask.fromObject(properties);
    };

            /**
             * Encodes the specified OracleTask message. Does not implicitly {@link oracle_job.OracleJob.OracleTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.OracleTask
             * @static
             * @param {oracle_job.OracleJob.IOracleTask} message OracleTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OracleTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.switchboardAddress != null && Object.hasOwnProperty.call(message, "switchboardAddress"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.switchboardAddress);
                if (message.pythAddress != null && Object.hasOwnProperty.call(message, "pythAddress"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.pythAddress);
                if (message.chainlinkAddress != null && Object.hasOwnProperty.call(message, "chainlinkAddress"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.chainlinkAddress);
                if (message.pythAllowedConfidenceInterval != null && Object.hasOwnProperty.call(message, "pythAllowedConfidenceInterval"))
                    writer.uint32(/* id 4, wireType 1 =*/33).double(message.pythAllowedConfidenceInterval);
                if (message.chainlinkConfigs != null && Object.hasOwnProperty.call(message, "chainlinkConfigs"))
                    $root.oracle_job.OracleJob.OracleTask.ChainlinkConfigs.encode(message.chainlinkConfigs, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.pythConfigs != null && Object.hasOwnProperty.call(message, "pythConfigs"))
                    $root.oracle_job.OracleJob.OracleTask.PythConfigs.encode(message.pythConfigs, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.edgeId != null && Object.hasOwnProperty.call(message, "edgeId"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.edgeId);
                if (message.redstoneId != null && Object.hasOwnProperty.call(message, "redstoneId"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.redstoneId);
                if (message.switchboardConfigs != null && Object.hasOwnProperty.call(message, "switchboardConfigs"))
                    $root.oracle_job.OracleJob.OracleTask.SwitchboardConfigs.encode(message.switchboardConfigs, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.edgeConfigs != null && Object.hasOwnProperty.call(message, "edgeConfigs"))
                    $root.oracle_job.OracleJob.OracleTask.EdgeConfigs.encode(message.edgeConfigs, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.redstoneConfigs != null && Object.hasOwnProperty.call(message, "redstoneConfigs"))
                    $root.oracle_job.OracleJob.OracleTask.RedstoneConfigs.encode(message.redstoneConfigs, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OracleTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.OracleTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.OracleTask
             * @static
             * @param {oracle_job.OracleJob.IOracleTask} message OracleTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OracleTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OracleTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.OracleTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.OracleTask} OracleTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OracleTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.OracleTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.switchboardAddress = reader.string();
                            break;
                        }
                    case 2: {
                            message.pythAddress = reader.string();
                            break;
                        }
                    case 3: {
                            message.chainlinkAddress = reader.string();
                            break;
                        }
                    case 7: {
                            message.edgeId = reader.string();
                            break;
                        }
                    case 8: {
                            message.redstoneId = reader.string();
                            break;
                        }
                    case 4: {
                            message.pythAllowedConfidenceInterval = reader.double();
                            break;
                        }
                    case 5: {
                            message.chainlinkConfigs = $root.oracle_job.OracleJob.OracleTask.ChainlinkConfigs.decode(reader, reader.uint32());
                            break;
                        }
                    case 6: {
                            message.pythConfigs = $root.oracle_job.OracleJob.OracleTask.PythConfigs.decode(reader, reader.uint32());
                            break;
                        }
                    case 9: {
                            message.switchboardConfigs = $root.oracle_job.OracleJob.OracleTask.SwitchboardConfigs.decode(reader, reader.uint32());
                            break;
                        }
                    case 10: {
                            message.edgeConfigs = $root.oracle_job.OracleJob.OracleTask.EdgeConfigs.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message.redstoneConfigs = $root.oracle_job.OracleJob.OracleTask.RedstoneConfigs.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OracleTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.OracleTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.OracleTask} OracleTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OracleTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OracleTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.OracleTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OracleTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.switchboardAddress != null && message.hasOwnProperty("switchboardAddress")) {
                    properties.AggregatorAddress = 1;
                    if (!$util.isString(message.switchboardAddress))
                        return "switchboardAddress: string expected";
                }
                if (message.pythAddress != null && message.hasOwnProperty("pythAddress")) {
                    if (properties.AggregatorAddress === 1)
                        return "AggregatorAddress: multiple values";
                    properties.AggregatorAddress = 1;
                    if (!$util.isString(message.pythAddress))
                        return "pythAddress: string expected";
                }
                if (message.chainlinkAddress != null && message.hasOwnProperty("chainlinkAddress")) {
                    if (properties.AggregatorAddress === 1)
                        return "AggregatorAddress: multiple values";
                    properties.AggregatorAddress = 1;
                    if (!$util.isString(message.chainlinkAddress))
                        return "chainlinkAddress: string expected";
                }
                if (message.edgeId != null && message.hasOwnProperty("edgeId")) {
                    if (properties.AggregatorAddress === 1)
                        return "AggregatorAddress: multiple values";
                    properties.AggregatorAddress = 1;
                    if (!$util.isString(message.edgeId))
                        return "edgeId: string expected";
                }
                if (message.redstoneId != null && message.hasOwnProperty("redstoneId")) {
                    if (properties.AggregatorAddress === 1)
                        return "AggregatorAddress: multiple values";
                    properties.AggregatorAddress = 1;
                    if (!$util.isString(message.redstoneId))
                        return "redstoneId: string expected";
                }
                if (message.pythAllowedConfidenceInterval != null && message.hasOwnProperty("pythAllowedConfidenceInterval"))
                    if (typeof message.pythAllowedConfidenceInterval !== "number")
                        return "pythAllowedConfidenceInterval: number expected";
                if (message.chainlinkConfigs != null && message.hasOwnProperty("chainlinkConfigs")) {
                    let error = $root.oracle_job.OracleJob.OracleTask.ChainlinkConfigs.verify(message.chainlinkConfigs);
                    if (error)
                        return "chainlinkConfigs." + error;
                }
                if (message.pythConfigs != null && message.hasOwnProperty("pythConfigs")) {
                    let error = $root.oracle_job.OracleJob.OracleTask.PythConfigs.verify(message.pythConfigs);
                    if (error)
                        return "pythConfigs." + error;
                }
                if (message.switchboardConfigs != null && message.hasOwnProperty("switchboardConfigs")) {
                    let error = $root.oracle_job.OracleJob.OracleTask.SwitchboardConfigs.verify(message.switchboardConfigs);
                    if (error)
                        return "switchboardConfigs." + error;
                }
                if (message.edgeConfigs != null && message.hasOwnProperty("edgeConfigs")) {
                    let error = $root.oracle_job.OracleJob.OracleTask.EdgeConfigs.verify(message.edgeConfigs);
                    if (error)
                        return "edgeConfigs." + error;
                }
                if (message.redstoneConfigs != null && message.hasOwnProperty("redstoneConfigs")) {
                    let error = $root.oracle_job.OracleJob.OracleTask.RedstoneConfigs.verify(message.redstoneConfigs);
                    if (error)
                        return "redstoneConfigs." + error;
                }
                return null;
            };

            /**
             * Creates an OracleTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.OracleTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.OracleTask} OracleTask
             */
            OracleTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.OracleTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.OracleTask();
                if (object.switchboardAddress != null)
                    message.switchboardAddress = String(object.switchboardAddress);
                if (object.pythAddress != null)
                    message.pythAddress = String(object.pythAddress);
                if (object.chainlinkAddress != null)
                    message.chainlinkAddress = String(object.chainlinkAddress);
                if (object.edgeId != null)
                    message.edgeId = String(object.edgeId);
                if (object.redstoneId != null)
                    message.redstoneId = String(object.redstoneId);
                if (object.pythAllowedConfidenceInterval != null)
                    message.pythAllowedConfidenceInterval = Number(object.pythAllowedConfidenceInterval);
                if (object.chainlinkConfigs != null) {
                    if (typeof object.chainlinkConfigs !== "object")
                        throw TypeError(".oracle_job.OracleJob.OracleTask.chainlinkConfigs: object expected");
                    message.chainlinkConfigs = $root.oracle_job.OracleJob.OracleTask.ChainlinkConfigs.fromObject(object.chainlinkConfigs);
                }
                if (object.pythConfigs != null) {
                    if (typeof object.pythConfigs !== "object")
                        throw TypeError(".oracle_job.OracleJob.OracleTask.pythConfigs: object expected");
                    message.pythConfigs = $root.oracle_job.OracleJob.OracleTask.PythConfigs.fromObject(object.pythConfigs);
                }
                if (object.switchboardConfigs != null) {
                    if (typeof object.switchboardConfigs !== "object")
                        throw TypeError(".oracle_job.OracleJob.OracleTask.switchboardConfigs: object expected");
                    message.switchboardConfigs = $root.oracle_job.OracleJob.OracleTask.SwitchboardConfigs.fromObject(object.switchboardConfigs);
                }
                if (object.edgeConfigs != null) {
                    if (typeof object.edgeConfigs !== "object")
                        throw TypeError(".oracle_job.OracleJob.OracleTask.edgeConfigs: object expected");
                    message.edgeConfigs = $root.oracle_job.OracleJob.OracleTask.EdgeConfigs.fromObject(object.edgeConfigs);
                }
                if (object.redstoneConfigs != null) {
                    if (typeof object.redstoneConfigs !== "object")
                        throw TypeError(".oracle_job.OracleJob.OracleTask.redstoneConfigs: object expected");
                    message.redstoneConfigs = $root.oracle_job.OracleJob.OracleTask.RedstoneConfigs.fromObject(object.redstoneConfigs);
                }
                return message;
            };

            /**
             * Creates a plain object from an OracleTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.OracleTask
             * @static
             * @param {oracle_job.OracleJob.OracleTask} message OracleTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OracleTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.pythAllowedConfidenceInterval = 0;
                    object.chainlinkConfigs = null;
                    object.pythConfigs = null;
                    object.switchboardConfigs = null;
                    object.edgeConfigs = null;
                    object.redstoneConfigs = null;
                }
                if (message.switchboardAddress != null && message.hasOwnProperty("switchboardAddress")) {
                    object.switchboardAddress = message.switchboardAddress;
                    if (options.oneofs)
                        object.AggregatorAddress = "switchboardAddress";
                }
                if (message.pythAddress != null && message.hasOwnProperty("pythAddress")) {
                    object.pythAddress = message.pythAddress;
                    if (options.oneofs)
                        object.AggregatorAddress = "pythAddress";
                }
                if (message.chainlinkAddress != null && message.hasOwnProperty("chainlinkAddress")) {
                    object.chainlinkAddress = message.chainlinkAddress;
                    if (options.oneofs)
                        object.AggregatorAddress = "chainlinkAddress";
                }
                if (message.pythAllowedConfidenceInterval != null && message.hasOwnProperty("pythAllowedConfidenceInterval"))
                    object.pythAllowedConfidenceInterval = options.json && !isFinite(message.pythAllowedConfidenceInterval) ? String(message.pythAllowedConfidenceInterval) : message.pythAllowedConfidenceInterval;
                if (message.chainlinkConfigs != null && message.hasOwnProperty("chainlinkConfigs"))
                    object.chainlinkConfigs = $root.oracle_job.OracleJob.OracleTask.ChainlinkConfigs.toObject(message.chainlinkConfigs, options);
                if (message.pythConfigs != null && message.hasOwnProperty("pythConfigs"))
                    object.pythConfigs = $root.oracle_job.OracleJob.OracleTask.PythConfigs.toObject(message.pythConfigs, options);
                if (message.edgeId != null && message.hasOwnProperty("edgeId")) {
                    object.edgeId = message.edgeId;
                    if (options.oneofs)
                        object.AggregatorAddress = "edgeId";
                }
                if (message.redstoneId != null && message.hasOwnProperty("redstoneId")) {
                    object.redstoneId = message.redstoneId;
                    if (options.oneofs)
                        object.AggregatorAddress = "redstoneId";
                }
                if (message.switchboardConfigs != null && message.hasOwnProperty("switchboardConfigs"))
                    object.switchboardConfigs = $root.oracle_job.OracleJob.OracleTask.SwitchboardConfigs.toObject(message.switchboardConfigs, options);
                if (message.edgeConfigs != null && message.hasOwnProperty("edgeConfigs"))
                    object.edgeConfigs = $root.oracle_job.OracleJob.OracleTask.EdgeConfigs.toObject(message.edgeConfigs, options);
                if (message.redstoneConfigs != null && message.hasOwnProperty("redstoneConfigs"))
                    object.redstoneConfigs = $root.oracle_job.OracleJob.OracleTask.RedstoneConfigs.toObject(message.redstoneConfigs, options);
                return object;
            };

            /**
             * Converts this OracleTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.OracleTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OracleTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for OracleTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.OracleTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            OracleTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.OracleTask";
            };

            OracleTask.ChainlinkConfigs = (function() {

                /**
                 * Properties of a ChainlinkConfigs.
                 * @memberof oracle_job.OracleJob.OracleTask
                 * @interface IChainlinkConfigs
                 * @property {string|null} [provider] ChainlinkConfigs provider
                 */

                /**
                 * Constructs a new ChainlinkConfigs.
                 * @memberof oracle_job.OracleJob.OracleTask
                 * @classdesc Represents a ChainlinkConfigs.
                 * @implements IChainlinkConfigs
                 * @constructor
                 * @param {oracle_job.OracleJob.OracleTask.IChainlinkConfigs=} [properties] Properties to set
                 */
                function ChainlinkConfigs(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ChainlinkConfigs provider.
                 * @member {string} provider
                 * @memberof oracle_job.OracleJob.OracleTask.ChainlinkConfigs
                 * @instance
                 */
                ChainlinkConfigs.prototype.provider = "";

                /**
                 * Creates a new ChainlinkConfigs instance using the specified properties.
                 * @function create
                 * @memberof oracle_job.OracleJob.OracleTask.ChainlinkConfigs
                 * @static
                 * @param {oracle_job.OracleJob.OracleTask.IChainlinkConfigs=} [properties] Properties to set
                 * @returns {oracle_job.OracleJob.OracleTask.ChainlinkConfigs} ChainlinkConfigs instance
                 */
                ChainlinkConfigs.create = function create(properties) {
      return ChainlinkConfigs.fromObject(properties);
    };

                /**
                 * Encodes the specified ChainlinkConfigs message. Does not implicitly {@link oracle_job.OracleJob.OracleTask.ChainlinkConfigs.verify|verify} messages.
                 * @function encode
                 * @memberof oracle_job.OracleJob.OracleTask.ChainlinkConfigs
                 * @static
                 * @param {oracle_job.OracleJob.OracleTask.IChainlinkConfigs} message ChainlinkConfigs message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChainlinkConfigs.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.provider != null && Object.hasOwnProperty.call(message, "provider"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.provider);
                    return writer;
                };

                /**
                 * Encodes the specified ChainlinkConfigs message, length delimited. Does not implicitly {@link oracle_job.OracleJob.OracleTask.ChainlinkConfigs.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof oracle_job.OracleJob.OracleTask.ChainlinkConfigs
                 * @static
                 * @param {oracle_job.OracleJob.OracleTask.IChainlinkConfigs} message ChainlinkConfigs message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ChainlinkConfigs.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ChainlinkConfigs message from the specified reader or buffer.
                 * @function decode
                 * @memberof oracle_job.OracleJob.OracleTask.ChainlinkConfigs
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {oracle_job.OracleJob.OracleTask.ChainlinkConfigs} ChainlinkConfigs
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChainlinkConfigs.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.OracleTask.ChainlinkConfigs();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.provider = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ChainlinkConfigs message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof oracle_job.OracleJob.OracleTask.ChainlinkConfigs
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {oracle_job.OracleJob.OracleTask.ChainlinkConfigs} ChainlinkConfigs
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ChainlinkConfigs.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ChainlinkConfigs message.
                 * @function verify
                 * @memberof oracle_job.OracleJob.OracleTask.ChainlinkConfigs
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ChainlinkConfigs.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.provider != null && message.hasOwnProperty("provider"))
                        if (!$util.isString(message.provider))
                            return "provider: string expected";
                    return null;
                };

                /**
                 * Creates a ChainlinkConfigs message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof oracle_job.OracleJob.OracleTask.ChainlinkConfigs
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {oracle_job.OracleJob.OracleTask.ChainlinkConfigs} ChainlinkConfigs
                 */
                ChainlinkConfigs.fromObject = function fromObject(object) {
                    if (object instanceof $root.oracle_job.OracleJob.OracleTask.ChainlinkConfigs)
                        return object;
                    let message = new $root.oracle_job.OracleJob.OracleTask.ChainlinkConfigs();
                    if (object.provider != null)
                        message.provider = String(object.provider);
                    return message;
                };

                /**
                 * Creates a plain object from a ChainlinkConfigs message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof oracle_job.OracleJob.OracleTask.ChainlinkConfigs
                 * @static
                 * @param {oracle_job.OracleJob.OracleTask.ChainlinkConfigs} message ChainlinkConfigs
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ChainlinkConfigs.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.provider = "";
                    if (message.provider != null && message.hasOwnProperty("provider"))
                        object.provider = message.provider;
                    return object;
                };

                /**
                 * Converts this ChainlinkConfigs to JSON.
                 * @function toJSON
                 * @memberof oracle_job.OracleJob.OracleTask.ChainlinkConfigs
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ChainlinkConfigs.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ChainlinkConfigs
                 * @function getTypeUrl
                 * @memberof oracle_job.OracleJob.OracleTask.ChainlinkConfigs
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ChainlinkConfigs.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/oracle_job.OracleJob.OracleTask.ChainlinkConfigs";
                };

                return ChainlinkConfigs;
            })();

            OracleTask.PythConfigs = (function() {

                /**
                 * Properties of a PythConfigs.
                 * @memberof oracle_job.OracleJob.OracleTask
                 * @interface IPythConfigs
                 * @property {string|null} [hermesUrl] PythConfigs hermesUrl
                 * @property {number|null} [pythAllowedConfidenceInterval] PythConfigs pythAllowedConfidenceInterval
                 * @property {number|null} [maxStaleSeconds] PythConfigs maxStaleSeconds
                 */

                /**
                 * Constructs a new PythConfigs.
                 * @memberof oracle_job.OracleJob.OracleTask
                 * @classdesc Represents a PythConfigs.
                 * @implements IPythConfigs
                 * @constructor
                 * @param {oracle_job.OracleJob.OracleTask.IPythConfigs=} [properties] Properties to set
                 */
                function PythConfigs(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PythConfigs hermesUrl.
                 * @member {string} hermesUrl
                 * @memberof oracle_job.OracleJob.OracleTask.PythConfigs
                 * @instance
                 */
                PythConfigs.prototype.hermesUrl = "";

                /**
                 * PythConfigs pythAllowedConfidenceInterval.
                 * @member {number} pythAllowedConfidenceInterval
                 * @memberof oracle_job.OracleJob.OracleTask.PythConfigs
                 * @instance
                 */
                PythConfigs.prototype.pythAllowedConfidenceInterval = 0;

                /**
                 * PythConfigs maxStaleSeconds.
                 * @member {number} maxStaleSeconds
                 * @memberof oracle_job.OracleJob.OracleTask.PythConfigs
                 * @instance
                 */
                PythConfigs.prototype.maxStaleSeconds = 0;

                /**
                 * Creates a new PythConfigs instance using the specified properties.
                 * @function create
                 * @memberof oracle_job.OracleJob.OracleTask.PythConfigs
                 * @static
                 * @param {oracle_job.OracleJob.OracleTask.IPythConfigs=} [properties] Properties to set
                 * @returns {oracle_job.OracleJob.OracleTask.PythConfigs} PythConfigs instance
                 */
                PythConfigs.create = function create(properties) {
      return PythConfigs.fromObject(properties);
    };

                /**
                 * Encodes the specified PythConfigs message. Does not implicitly {@link oracle_job.OracleJob.OracleTask.PythConfigs.verify|verify} messages.
                 * @function encode
                 * @memberof oracle_job.OracleJob.OracleTask.PythConfigs
                 * @static
                 * @param {oracle_job.OracleJob.OracleTask.IPythConfigs} message PythConfigs message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PythConfigs.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.hermesUrl != null && Object.hasOwnProperty.call(message, "hermesUrl"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.hermesUrl);
                    if (message.pythAllowedConfidenceInterval != null && Object.hasOwnProperty.call(message, "pythAllowedConfidenceInterval"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.pythAllowedConfidenceInterval);
                    if (message.maxStaleSeconds != null && Object.hasOwnProperty.call(message, "maxStaleSeconds"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.maxStaleSeconds);
                    return writer;
                };

                /**
                 * Encodes the specified PythConfigs message, length delimited. Does not implicitly {@link oracle_job.OracleJob.OracleTask.PythConfigs.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof oracle_job.OracleJob.OracleTask.PythConfigs
                 * @static
                 * @param {oracle_job.OracleJob.OracleTask.IPythConfigs} message PythConfigs message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PythConfigs.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PythConfigs message from the specified reader or buffer.
                 * @function decode
                 * @memberof oracle_job.OracleJob.OracleTask.PythConfigs
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {oracle_job.OracleJob.OracleTask.PythConfigs} PythConfigs
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PythConfigs.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.OracleTask.PythConfigs();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.hermesUrl = reader.string();
                                break;
                            }
                        case 2: {
                                message.pythAllowedConfidenceInterval = reader.double();
                                break;
                            }
                        case 3: {
                                message.maxStaleSeconds = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PythConfigs message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof oracle_job.OracleJob.OracleTask.PythConfigs
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {oracle_job.OracleJob.OracleTask.PythConfigs} PythConfigs
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PythConfigs.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PythConfigs message.
                 * @function verify
                 * @memberof oracle_job.OracleJob.OracleTask.PythConfigs
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PythConfigs.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.hermesUrl != null && message.hasOwnProperty("hermesUrl"))
                        if (!$util.isString(message.hermesUrl))
                            return "hermesUrl: string expected";
                    if (message.pythAllowedConfidenceInterval != null && message.hasOwnProperty("pythAllowedConfidenceInterval"))
                        if (typeof message.pythAllowedConfidenceInterval !== "number")
                            return "pythAllowedConfidenceInterval: number expected";
                    if (message.maxStaleSeconds != null && message.hasOwnProperty("maxStaleSeconds"))
                        if (!$util.isInteger(message.maxStaleSeconds))
                            return "maxStaleSeconds: integer expected";
                    return null;
                };

                /**
                 * Creates a PythConfigs message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof oracle_job.OracleJob.OracleTask.PythConfigs
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {oracle_job.OracleJob.OracleTask.PythConfigs} PythConfigs
                 */
                PythConfigs.fromObject = function fromObject(object) {
                    if (object instanceof $root.oracle_job.OracleJob.OracleTask.PythConfigs)
                        return object;
                    let message = new $root.oracle_job.OracleJob.OracleTask.PythConfigs();
                    if (object.hermesUrl != null)
                        message.hermesUrl = String(object.hermesUrl);
                    if (object.pythAllowedConfidenceInterval != null)
                        message.pythAllowedConfidenceInterval = Number(object.pythAllowedConfidenceInterval);
                    if (object.maxStaleSeconds != null)
                        message.maxStaleSeconds = object.maxStaleSeconds | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a PythConfigs message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof oracle_job.OracleJob.OracleTask.PythConfigs
                 * @static
                 * @param {oracle_job.OracleJob.OracleTask.PythConfigs} message PythConfigs
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PythConfigs.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.hermesUrl = "";
                        object.pythAllowedConfidenceInterval = 0;
                        object.maxStaleSeconds = 0;
                    }
                    if (message.hermesUrl != null && message.hasOwnProperty("hermesUrl"))
                        object.hermesUrl = message.hermesUrl;
                    if (message.pythAllowedConfidenceInterval != null && message.hasOwnProperty("pythAllowedConfidenceInterval"))
                        object.pythAllowedConfidenceInterval = options.json && !isFinite(message.pythAllowedConfidenceInterval) ? String(message.pythAllowedConfidenceInterval) : message.pythAllowedConfidenceInterval;
                    if (message.maxStaleSeconds != null && message.hasOwnProperty("maxStaleSeconds"))
                        object.maxStaleSeconds = message.maxStaleSeconds;
                    return object;
                };

                /**
                 * Converts this PythConfigs to JSON.
                 * @function toJSON
                 * @memberof oracle_job.OracleJob.OracleTask.PythConfigs
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PythConfigs.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for PythConfigs
                 * @function getTypeUrl
                 * @memberof oracle_job.OracleJob.OracleTask.PythConfigs
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                PythConfigs.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/oracle_job.OracleJob.OracleTask.PythConfigs";
                };

                return PythConfigs;
            })();

            OracleTask.SwitchboardConfigs = (function() {

                /**
                 * Properties of a SwitchboardConfigs.
                 * @memberof oracle_job.OracleJob.OracleTask
                 * @interface ISwitchboardConfigs
                 * @property {number|null} [version] SwitchboardConfigs version
                 * @property {Array.<oracle_job.IOracleJob>|null} [jobs] SwitchboardConfigs jobs
                 */

                /**
                 * Constructs a new SwitchboardConfigs.
                 * @memberof oracle_job.OracleJob.OracleTask
                 * @classdesc Represents a SwitchboardConfigs.
                 * @implements ISwitchboardConfigs
                 * @constructor
                 * @param {oracle_job.OracleJob.OracleTask.ISwitchboardConfigs=} [properties] Properties to set
                 */
                function SwitchboardConfigs(properties) {
                    this.jobs = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SwitchboardConfigs version.
                 * @member {number} version
                 * @memberof oracle_job.OracleJob.OracleTask.SwitchboardConfigs
                 * @instance
                 */
                SwitchboardConfigs.prototype.version = 0;

                /**
                 * SwitchboardConfigs jobs.
                 * @member {Array.<oracle_job.IOracleJob>} jobs
                 * @memberof oracle_job.OracleJob.OracleTask.SwitchboardConfigs
                 * @instance
                 */
                SwitchboardConfigs.prototype.jobs = $util.emptyArray;

                /**
                 * Creates a new SwitchboardConfigs instance using the specified properties.
                 * @function create
                 * @memberof oracle_job.OracleJob.OracleTask.SwitchboardConfigs
                 * @static
                 * @param {oracle_job.OracleJob.OracleTask.ISwitchboardConfigs=} [properties] Properties to set
                 * @returns {oracle_job.OracleJob.OracleTask.SwitchboardConfigs} SwitchboardConfigs instance
                 */
                SwitchboardConfigs.create = function create(properties) {
      return SwitchboardConfigs.fromObject(properties);
    };

                /**
                 * Encodes the specified SwitchboardConfigs message. Does not implicitly {@link oracle_job.OracleJob.OracleTask.SwitchboardConfigs.verify|verify} messages.
                 * @function encode
                 * @memberof oracle_job.OracleJob.OracleTask.SwitchboardConfigs
                 * @static
                 * @param {oracle_job.OracleJob.OracleTask.ISwitchboardConfigs} message SwitchboardConfigs message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SwitchboardConfigs.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.version);
                    if (message.jobs != null && message.jobs.length)
                        for (let i = 0; i < message.jobs.length; ++i)
                            $root.oracle_job.OracleJob.encode(message.jobs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified SwitchboardConfigs message, length delimited. Does not implicitly {@link oracle_job.OracleJob.OracleTask.SwitchboardConfigs.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof oracle_job.OracleJob.OracleTask.SwitchboardConfigs
                 * @static
                 * @param {oracle_job.OracleJob.OracleTask.ISwitchboardConfigs} message SwitchboardConfigs message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SwitchboardConfigs.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SwitchboardConfigs message from the specified reader or buffer.
                 * @function decode
                 * @memberof oracle_job.OracleJob.OracleTask.SwitchboardConfigs
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {oracle_job.OracleJob.OracleTask.SwitchboardConfigs} SwitchboardConfigs
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SwitchboardConfigs.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.OracleTask.SwitchboardConfigs();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.version = reader.int32();
                                break;
                            }
                        case 2: {
                                if (!(message.jobs && message.jobs.length))
                                    message.jobs = [];
                                message.jobs.push($root.oracle_job.OracleJob.decode(reader, reader.uint32()));
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SwitchboardConfigs message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof oracle_job.OracleJob.OracleTask.SwitchboardConfigs
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {oracle_job.OracleJob.OracleTask.SwitchboardConfigs} SwitchboardConfigs
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SwitchboardConfigs.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SwitchboardConfigs message.
                 * @function verify
                 * @memberof oracle_job.OracleJob.OracleTask.SwitchboardConfigs
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SwitchboardConfigs.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.version != null && message.hasOwnProperty("version"))
                        if (!$util.isInteger(message.version))
                            return "version: integer expected";
                    if (message.jobs != null && message.hasOwnProperty("jobs")) {
                        if (!Array.isArray(message.jobs))
                            return "jobs: array expected";
                        for (let i = 0; i < message.jobs.length; ++i) {
                            let error = $root.oracle_job.OracleJob.verify(message.jobs[i]);
                            if (error)
                                return "jobs." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a SwitchboardConfigs message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof oracle_job.OracleJob.OracleTask.SwitchboardConfigs
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {oracle_job.OracleJob.OracleTask.SwitchboardConfigs} SwitchboardConfigs
                 */
                SwitchboardConfigs.fromObject = function fromObject(object) {
                    if (object instanceof $root.oracle_job.OracleJob.OracleTask.SwitchboardConfigs)
                        return object;
                    let message = new $root.oracle_job.OracleJob.OracleTask.SwitchboardConfigs();
                    if (object.version != null)
                        message.version = object.version | 0;
                    if (object.jobs) {
                        if (!Array.isArray(object.jobs))
                            throw TypeError(".oracle_job.OracleJob.OracleTask.SwitchboardConfigs.jobs: array expected");
                        message.jobs = [];
                        for (let i = 0; i < object.jobs.length; ++i) {
                            if (typeof object.jobs[i] !== "object")
                                throw TypeError(".oracle_job.OracleJob.OracleTask.SwitchboardConfigs.jobs: object expected");
                            message.jobs[i] = $root.oracle_job.OracleJob.fromObject(object.jobs[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SwitchboardConfigs message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof oracle_job.OracleJob.OracleTask.SwitchboardConfigs
                 * @static
                 * @param {oracle_job.OracleJob.OracleTask.SwitchboardConfigs} message SwitchboardConfigs
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SwitchboardConfigs.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.jobs = [];
                    if (options.defaults)
                        object.version = 0;
                    if (message.version != null && message.hasOwnProperty("version"))
                        object.version = message.version;
                    if (message.jobs && message.jobs.length) {
                        object.jobs = [];
                        for (let j = 0; j < message.jobs.length; ++j)
                            object.jobs[j] = $root.oracle_job.OracleJob.toObject(message.jobs[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this SwitchboardConfigs to JSON.
                 * @function toJSON
                 * @memberof oracle_job.OracleJob.OracleTask.SwitchboardConfigs
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SwitchboardConfigs.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for SwitchboardConfigs
                 * @function getTypeUrl
                 * @memberof oracle_job.OracleJob.OracleTask.SwitchboardConfigs
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                SwitchboardConfigs.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/oracle_job.OracleJob.OracleTask.SwitchboardConfigs";
                };

                return SwitchboardConfigs;
            })();

            OracleTask.EdgeConfigs = (function() {

                /**
                 * Properties of an EdgeConfigs.
                 * @memberof oracle_job.OracleJob.OracleTask
                 * @interface IEdgeConfigs
                 */

                /**
                 * Constructs a new EdgeConfigs.
                 * @memberof oracle_job.OracleJob.OracleTask
                 * @classdesc Represents an EdgeConfigs.
                 * @implements IEdgeConfigs
                 * @constructor
                 * @param {oracle_job.OracleJob.OracleTask.IEdgeConfigs=} [properties] Properties to set
                 */
                function EdgeConfigs(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new EdgeConfigs instance using the specified properties.
                 * @function create
                 * @memberof oracle_job.OracleJob.OracleTask.EdgeConfigs
                 * @static
                 * @param {oracle_job.OracleJob.OracleTask.IEdgeConfigs=} [properties] Properties to set
                 * @returns {oracle_job.OracleJob.OracleTask.EdgeConfigs} EdgeConfigs instance
                 */
                EdgeConfigs.create = function create(properties) {
      return EdgeConfigs.fromObject(properties);
    };

                /**
                 * Encodes the specified EdgeConfigs message. Does not implicitly {@link oracle_job.OracleJob.OracleTask.EdgeConfigs.verify|verify} messages.
                 * @function encode
                 * @memberof oracle_job.OracleJob.OracleTask.EdgeConfigs
                 * @static
                 * @param {oracle_job.OracleJob.OracleTask.IEdgeConfigs} message EdgeConfigs message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EdgeConfigs.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified EdgeConfigs message, length delimited. Does not implicitly {@link oracle_job.OracleJob.OracleTask.EdgeConfigs.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof oracle_job.OracleJob.OracleTask.EdgeConfigs
                 * @static
                 * @param {oracle_job.OracleJob.OracleTask.IEdgeConfigs} message EdgeConfigs message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EdgeConfigs.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an EdgeConfigs message from the specified reader or buffer.
                 * @function decode
                 * @memberof oracle_job.OracleJob.OracleTask.EdgeConfigs
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {oracle_job.OracleJob.OracleTask.EdgeConfigs} EdgeConfigs
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EdgeConfigs.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.OracleTask.EdgeConfigs();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an EdgeConfigs message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof oracle_job.OracleJob.OracleTask.EdgeConfigs
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {oracle_job.OracleJob.OracleTask.EdgeConfigs} EdgeConfigs
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EdgeConfigs.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an EdgeConfigs message.
                 * @function verify
                 * @memberof oracle_job.OracleJob.OracleTask.EdgeConfigs
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EdgeConfigs.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates an EdgeConfigs message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof oracle_job.OracleJob.OracleTask.EdgeConfigs
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {oracle_job.OracleJob.OracleTask.EdgeConfigs} EdgeConfigs
                 */
                EdgeConfigs.fromObject = function fromObject(object) {
                    if (object instanceof $root.oracle_job.OracleJob.OracleTask.EdgeConfigs)
                        return object;
                    return new $root.oracle_job.OracleJob.OracleTask.EdgeConfigs();
                };

                /**
                 * Creates a plain object from an EdgeConfigs message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof oracle_job.OracleJob.OracleTask.EdgeConfigs
                 * @static
                 * @param {oracle_job.OracleJob.OracleTask.EdgeConfigs} message EdgeConfigs
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EdgeConfigs.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this EdgeConfigs to JSON.
                 * @function toJSON
                 * @memberof oracle_job.OracleJob.OracleTask.EdgeConfigs
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EdgeConfigs.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for EdgeConfigs
                 * @function getTypeUrl
                 * @memberof oracle_job.OracleJob.OracleTask.EdgeConfigs
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                EdgeConfigs.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/oracle_job.OracleJob.OracleTask.EdgeConfigs";
                };

                return EdgeConfigs;
            })();

            OracleTask.RedstoneConfigs = (function() {

                /**
                 * Properties of a RedstoneConfigs.
                 * @memberof oracle_job.OracleJob.OracleTask
                 * @interface IRedstoneConfigs
                 */

                /**
                 * Constructs a new RedstoneConfigs.
                 * @memberof oracle_job.OracleJob.OracleTask
                 * @classdesc Represents a RedstoneConfigs.
                 * @implements IRedstoneConfigs
                 * @constructor
                 * @param {oracle_job.OracleJob.OracleTask.IRedstoneConfigs=} [properties] Properties to set
                 */
                function RedstoneConfigs(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new RedstoneConfigs instance using the specified properties.
                 * @function create
                 * @memberof oracle_job.OracleJob.OracleTask.RedstoneConfigs
                 * @static
                 * @param {oracle_job.OracleJob.OracleTask.IRedstoneConfigs=} [properties] Properties to set
                 * @returns {oracle_job.OracleJob.OracleTask.RedstoneConfigs} RedstoneConfigs instance
                 */
                RedstoneConfigs.create = function create(properties) {
      return RedstoneConfigs.fromObject(properties);
    };

                /**
                 * Encodes the specified RedstoneConfigs message. Does not implicitly {@link oracle_job.OracleJob.OracleTask.RedstoneConfigs.verify|verify} messages.
                 * @function encode
                 * @memberof oracle_job.OracleJob.OracleTask.RedstoneConfigs
                 * @static
                 * @param {oracle_job.OracleJob.OracleTask.IRedstoneConfigs} message RedstoneConfigs message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RedstoneConfigs.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified RedstoneConfigs message, length delimited. Does not implicitly {@link oracle_job.OracleJob.OracleTask.RedstoneConfigs.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof oracle_job.OracleJob.OracleTask.RedstoneConfigs
                 * @static
                 * @param {oracle_job.OracleJob.OracleTask.IRedstoneConfigs} message RedstoneConfigs message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RedstoneConfigs.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a RedstoneConfigs message from the specified reader or buffer.
                 * @function decode
                 * @memberof oracle_job.OracleJob.OracleTask.RedstoneConfigs
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {oracle_job.OracleJob.OracleTask.RedstoneConfigs} RedstoneConfigs
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RedstoneConfigs.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.OracleTask.RedstoneConfigs();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a RedstoneConfigs message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof oracle_job.OracleJob.OracleTask.RedstoneConfigs
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {oracle_job.OracleJob.OracleTask.RedstoneConfigs} RedstoneConfigs
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RedstoneConfigs.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a RedstoneConfigs message.
                 * @function verify
                 * @memberof oracle_job.OracleJob.OracleTask.RedstoneConfigs
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RedstoneConfigs.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a RedstoneConfigs message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof oracle_job.OracleJob.OracleTask.RedstoneConfigs
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {oracle_job.OracleJob.OracleTask.RedstoneConfigs} RedstoneConfigs
                 */
                RedstoneConfigs.fromObject = function fromObject(object) {
                    if (object instanceof $root.oracle_job.OracleJob.OracleTask.RedstoneConfigs)
                        return object;
                    return new $root.oracle_job.OracleJob.OracleTask.RedstoneConfigs();
                };

                /**
                 * Creates a plain object from a RedstoneConfigs message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof oracle_job.OracleJob.OracleTask.RedstoneConfigs
                 * @static
                 * @param {oracle_job.OracleJob.OracleTask.RedstoneConfigs} message RedstoneConfigs
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RedstoneConfigs.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this RedstoneConfigs to JSON.
                 * @function toJSON
                 * @memberof oracle_job.OracleJob.OracleTask.RedstoneConfigs
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RedstoneConfigs.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for RedstoneConfigs
                 * @function getTypeUrl
                 * @memberof oracle_job.OracleJob.OracleTask.RedstoneConfigs
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                RedstoneConfigs.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/oracle_job.OracleJob.OracleTask.RedstoneConfigs";
                };

                return RedstoneConfigs;
            })();

            return OracleTask;
        })();

        OracleJob.AnchorFetchTask = (function() {

            /**
             * Properties of an AnchorFetchTask.
             * @memberof oracle_job.OracleJob
             * @interface IAnchorFetchTask
             * @property {string|null} [programId] Owning program of the account to parse.
             * @property {string|null} [accountAddress] The account to parse.
             */

            /**
             * Constructs a new AnchorFetchTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Load a parse an Anchor based solana account.
             * @implements IAnchorFetchTask
             * @constructor
             * @param {oracle_job.OracleJob.IAnchorFetchTask=} [properties] Properties to set
             */
            function AnchorFetchTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Owning program of the account to parse.
             * @member {string} programId
             * @memberof oracle_job.OracleJob.AnchorFetchTask
             * @instance
             */
            AnchorFetchTask.prototype.programId = "";

            /**
             * The account to parse.
             * @member {string} accountAddress
             * @memberof oracle_job.OracleJob.AnchorFetchTask
             * @instance
             */
            AnchorFetchTask.prototype.accountAddress = "";

            /**
             * Creates a new AnchorFetchTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.AnchorFetchTask
             * @static
             * @param {oracle_job.OracleJob.IAnchorFetchTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.AnchorFetchTask} AnchorFetchTask instance
             */
            AnchorFetchTask.create = function create(properties) {
      return AnchorFetchTask.fromObject(properties);
    };

            /**
             * Encodes the specified AnchorFetchTask message. Does not implicitly {@link oracle_job.OracleJob.AnchorFetchTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.AnchorFetchTask
             * @static
             * @param {oracle_job.OracleJob.IAnchorFetchTask} message AnchorFetchTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AnchorFetchTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.programId != null && Object.hasOwnProperty.call(message, "programId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.programId);
                if (message.accountAddress != null && Object.hasOwnProperty.call(message, "accountAddress"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.accountAddress);
                return writer;
            };

            /**
             * Encodes the specified AnchorFetchTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.AnchorFetchTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.AnchorFetchTask
             * @static
             * @param {oracle_job.OracleJob.IAnchorFetchTask} message AnchorFetchTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AnchorFetchTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AnchorFetchTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.AnchorFetchTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.AnchorFetchTask} AnchorFetchTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AnchorFetchTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.AnchorFetchTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.programId = reader.string();
                            break;
                        }
                    case 2: {
                            message.accountAddress = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AnchorFetchTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.AnchorFetchTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.AnchorFetchTask} AnchorFetchTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AnchorFetchTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AnchorFetchTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.AnchorFetchTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AnchorFetchTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.programId != null && message.hasOwnProperty("programId"))
                    if (!$util.isString(message.programId))
                        return "programId: string expected";
                if (message.accountAddress != null && message.hasOwnProperty("accountAddress"))
                    if (!$util.isString(message.accountAddress))
                        return "accountAddress: string expected";
                return null;
            };

            /**
             * Creates an AnchorFetchTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.AnchorFetchTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.AnchorFetchTask} AnchorFetchTask
             */
            AnchorFetchTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.AnchorFetchTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.AnchorFetchTask();
                if (object.programId != null)
                    message.programId = String(object.programId);
                if (object.accountAddress != null)
                    message.accountAddress = String(object.accountAddress);
                return message;
            };

            /**
             * Creates a plain object from an AnchorFetchTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.AnchorFetchTask
             * @static
             * @param {oracle_job.OracleJob.AnchorFetchTask} message AnchorFetchTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AnchorFetchTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.programId = "";
                    object.accountAddress = "";
                }
                if (message.programId != null && message.hasOwnProperty("programId"))
                    object.programId = message.programId;
                if (message.accountAddress != null && message.hasOwnProperty("accountAddress"))
                    object.accountAddress = message.accountAddress;
                return object;
            };

            /**
             * Converts this AnchorFetchTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.AnchorFetchTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AnchorFetchTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AnchorFetchTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.AnchorFetchTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AnchorFetchTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.AnchorFetchTask";
            };

            return AnchorFetchTask;
        })();

        OracleJob.SplStakePoolTask = (function() {

            /**
             * Properties of a SplStakePoolTask.
             * @memberof oracle_job.OracleJob
             * @interface ISplStakePoolTask
             * @property {string|null} [pubkey] The pubkey of the SPL Stake Pool.
             */

            /**
             * Constructs a new SplStakePoolTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Fetch the JSON representation of an SPL Stake Pool account.
             * @implements ISplStakePoolTask
             * @constructor
             * @param {oracle_job.OracleJob.ISplStakePoolTask=} [properties] Properties to set
             */
            function SplStakePoolTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The pubkey of the SPL Stake Pool.
             * @member {string} pubkey
             * @memberof oracle_job.OracleJob.SplStakePoolTask
             * @instance
             */
            SplStakePoolTask.prototype.pubkey = "";

            /**
             * Creates a new SplStakePoolTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.SplStakePoolTask
             * @static
             * @param {oracle_job.OracleJob.ISplStakePoolTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.SplStakePoolTask} SplStakePoolTask instance
             */
            SplStakePoolTask.create = function create(properties) {
      return SplStakePoolTask.fromObject(properties);
    };

            /**
             * Encodes the specified SplStakePoolTask message. Does not implicitly {@link oracle_job.OracleJob.SplStakePoolTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.SplStakePoolTask
             * @static
             * @param {oracle_job.OracleJob.ISplStakePoolTask} message SplStakePoolTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SplStakePoolTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pubkey != null && Object.hasOwnProperty.call(message, "pubkey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.pubkey);
                return writer;
            };

            /**
             * Encodes the specified SplStakePoolTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.SplStakePoolTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.SplStakePoolTask
             * @static
             * @param {oracle_job.OracleJob.ISplStakePoolTask} message SplStakePoolTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SplStakePoolTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SplStakePoolTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.SplStakePoolTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.SplStakePoolTask} SplStakePoolTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SplStakePoolTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.SplStakePoolTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.pubkey = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SplStakePoolTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.SplStakePoolTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.SplStakePoolTask} SplStakePoolTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SplStakePoolTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SplStakePoolTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.SplStakePoolTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SplStakePoolTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                    if (!$util.isString(message.pubkey))
                        return "pubkey: string expected";
                return null;
            };

            /**
             * Creates a SplStakePoolTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.SplStakePoolTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.SplStakePoolTask} SplStakePoolTask
             */
            SplStakePoolTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.SplStakePoolTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.SplStakePoolTask();
                if (object.pubkey != null)
                    message.pubkey = String(object.pubkey);
                return message;
            };

            /**
             * Creates a plain object from a SplStakePoolTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.SplStakePoolTask
             * @static
             * @param {oracle_job.OracleJob.SplStakePoolTask} message SplStakePoolTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SplStakePoolTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.pubkey = "";
                if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                    object.pubkey = message.pubkey;
                return object;
            };

            /**
             * Converts this SplStakePoolTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.SplStakePoolTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SplStakePoolTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SplStakePoolTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.SplStakePoolTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SplStakePoolTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.SplStakePoolTask";
            };

            return SplStakePoolTask;
        })();

        OracleJob.SplTokenParseTask = (function() {

            /**
             * Properties of a SplTokenParseTask.
             * @memberof oracle_job.OracleJob
             * @interface ISplTokenParseTask
             * @property {string|null} [tokenAccountAddress] The publicKey of a token account to fetch the mintInfo for.
             * @property {string|null} [mintAddress] The publicKey of the token mint address.
             */

            /**
             * Constructs a new SplTokenParseTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Fetch the JSON representation of an SPL token mint.
             * @implements ISplTokenParseTask
             * @constructor
             * @param {oracle_job.OracleJob.ISplTokenParseTask=} [properties] Properties to set
             */
            function SplTokenParseTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The publicKey of a token account to fetch the mintInfo for.
             * @member {string|null|undefined} tokenAccountAddress
             * @memberof oracle_job.OracleJob.SplTokenParseTask
             * @instance
             */
            SplTokenParseTask.prototype.tokenAccountAddress = null;

            /**
             * The publicKey of the token mint address.
             * @member {string|null|undefined} mintAddress
             * @memberof oracle_job.OracleJob.SplTokenParseTask
             * @instance
             */
            SplTokenParseTask.prototype.mintAddress = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * SplTokenParseTask AccountAddress.
             * @member {"tokenAccountAddress"|"mintAddress"|undefined} AccountAddress
             * @memberof oracle_job.OracleJob.SplTokenParseTask
             * @instance
             */
            Object.defineProperty(SplTokenParseTask.prototype, "AccountAddress", {
                get: $util.oneOfGetter($oneOfFields = ["tokenAccountAddress", "mintAddress"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SplTokenParseTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.SplTokenParseTask
             * @static
             * @param {oracle_job.OracleJob.ISplTokenParseTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.SplTokenParseTask} SplTokenParseTask instance
             */
            SplTokenParseTask.create = function create(properties) {
      return SplTokenParseTask.fromObject(properties);
    };

            /**
             * Encodes the specified SplTokenParseTask message. Does not implicitly {@link oracle_job.OracleJob.SplTokenParseTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.SplTokenParseTask
             * @static
             * @param {oracle_job.OracleJob.ISplTokenParseTask} message SplTokenParseTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SplTokenParseTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tokenAccountAddress != null && Object.hasOwnProperty.call(message, "tokenAccountAddress"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.tokenAccountAddress);
                if (message.mintAddress != null && Object.hasOwnProperty.call(message, "mintAddress"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.mintAddress);
                return writer;
            };

            /**
             * Encodes the specified SplTokenParseTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.SplTokenParseTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.SplTokenParseTask
             * @static
             * @param {oracle_job.OracleJob.ISplTokenParseTask} message SplTokenParseTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SplTokenParseTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SplTokenParseTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.SplTokenParseTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.SplTokenParseTask} SplTokenParseTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SplTokenParseTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.SplTokenParseTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.tokenAccountAddress = reader.string();
                            break;
                        }
                    case 2: {
                            message.mintAddress = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SplTokenParseTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.SplTokenParseTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.SplTokenParseTask} SplTokenParseTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SplTokenParseTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SplTokenParseTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.SplTokenParseTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SplTokenParseTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.tokenAccountAddress != null && message.hasOwnProperty("tokenAccountAddress")) {
                    properties.AccountAddress = 1;
                    if (!$util.isString(message.tokenAccountAddress))
                        return "tokenAccountAddress: string expected";
                }
                if (message.mintAddress != null && message.hasOwnProperty("mintAddress")) {
                    if (properties.AccountAddress === 1)
                        return "AccountAddress: multiple values";
                    properties.AccountAddress = 1;
                    if (!$util.isString(message.mintAddress))
                        return "mintAddress: string expected";
                }
                return null;
            };

            /**
             * Creates a SplTokenParseTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.SplTokenParseTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.SplTokenParseTask} SplTokenParseTask
             */
            SplTokenParseTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.SplTokenParseTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.SplTokenParseTask();
                if (object.tokenAccountAddress != null)
                    message.tokenAccountAddress = String(object.tokenAccountAddress);
                if (object.mintAddress != null)
                    message.mintAddress = String(object.mintAddress);
                return message;
            };

            /**
             * Creates a plain object from a SplTokenParseTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.SplTokenParseTask
             * @static
             * @param {oracle_job.OracleJob.SplTokenParseTask} message SplTokenParseTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SplTokenParseTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.tokenAccountAddress != null && message.hasOwnProperty("tokenAccountAddress")) {
                    object.tokenAccountAddress = message.tokenAccountAddress;
                    if (options.oneofs)
                        object.AccountAddress = "tokenAccountAddress";
                }
                if (message.mintAddress != null && message.hasOwnProperty("mintAddress")) {
                    object.mintAddress = message.mintAddress;
                    if (options.oneofs)
                        object.AccountAddress = "mintAddress";
                }
                return object;
            };

            /**
             * Converts this SplTokenParseTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.SplTokenParseTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SplTokenParseTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SplTokenParseTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.SplTokenParseTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SplTokenParseTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.SplTokenParseTask";
            };

            return SplTokenParseTask;
        })();

        OracleJob.UniswapExchangeRateTask = (function() {

            /**
             * Properties of an UniswapExchangeRateTask.
             * @memberof oracle_job.OracleJob
             * @interface IUniswapExchangeRateTask
             * @property {string|null} [inTokenAddress] The input token address.
             * @property {string|null} [outTokenAddress] The output token address.
             * @property {number|null} [inTokenAmount] The amount of tokens to swap.
             * @property {number|null} [slippage] The allowable slippage in percent for the swap.
             * @property {string|null} [provider] The RPC provider to use for the swap.
             * @property {oracle_job.OracleJob.UniswapExchangeRateTask.Version|null} [version] The version of the Uniswap exchange to use.
             * @property {string|null} [routerAddress] UniswapExchangeRateTask routerAddress
             * @property {string|null} [factoryAddress] UniswapExchangeRateTask factoryAddress
             * @property {string|null} [quoterAddress] UniswapExchangeRateTask quoterAddress
             */

            /**
             * Constructs a new UniswapExchangeRateTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Fetch the swap price from UniSwap.
             * @implements IUniswapExchangeRateTask
             * @constructor
             * @param {oracle_job.OracleJob.IUniswapExchangeRateTask=} [properties] Properties to set
             */
            function UniswapExchangeRateTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The input token address.
             * @member {string} inTokenAddress
             * @memberof oracle_job.OracleJob.UniswapExchangeRateTask
             * @instance
             */
            UniswapExchangeRateTask.prototype.inTokenAddress = "";

            /**
             * The output token address.
             * @member {string} outTokenAddress
             * @memberof oracle_job.OracleJob.UniswapExchangeRateTask
             * @instance
             */
            UniswapExchangeRateTask.prototype.outTokenAddress = "";

            /**
             * The amount of tokens to swap.
             * @member {number} inTokenAmount
             * @memberof oracle_job.OracleJob.UniswapExchangeRateTask
             * @instance
             */
            UniswapExchangeRateTask.prototype.inTokenAmount = 0;

            /**
             * The allowable slippage in percent for the swap.
             * @member {number} slippage
             * @memberof oracle_job.OracleJob.UniswapExchangeRateTask
             * @instance
             */
            UniswapExchangeRateTask.prototype.slippage = 0;

            /**
             * The RPC provider to use for the swap.
             * @member {string} provider
             * @memberof oracle_job.OracleJob.UniswapExchangeRateTask
             * @instance
             */
            UniswapExchangeRateTask.prototype.provider = "";

            /**
             * The version of the Uniswap exchange to use.
             * @member {oracle_job.OracleJob.UniswapExchangeRateTask.Version} version
             * @memberof oracle_job.OracleJob.UniswapExchangeRateTask
             * @instance
             */
            UniswapExchangeRateTask.prototype.version = 0;

            /**
             * UniswapExchangeRateTask routerAddress.
             * @member {string} routerAddress
             * @memberof oracle_job.OracleJob.UniswapExchangeRateTask
             * @instance
             */
            UniswapExchangeRateTask.prototype.routerAddress = "";

            /**
             * UniswapExchangeRateTask factoryAddress.
             * @member {string} factoryAddress
             * @memberof oracle_job.OracleJob.UniswapExchangeRateTask
             * @instance
             */
            UniswapExchangeRateTask.prototype.factoryAddress = "";

            /**
             * UniswapExchangeRateTask quoterAddress.
             * @member {string} quoterAddress
             * @memberof oracle_job.OracleJob.UniswapExchangeRateTask
             * @instance
             */
            UniswapExchangeRateTask.prototype.quoterAddress = "";

            /**
             * Creates a new UniswapExchangeRateTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.UniswapExchangeRateTask
             * @static
             * @param {oracle_job.OracleJob.IUniswapExchangeRateTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.UniswapExchangeRateTask} UniswapExchangeRateTask instance
             */
            UniswapExchangeRateTask.create = function create(properties) {
      return UniswapExchangeRateTask.fromObject(properties);
    };

            /**
             * Encodes the specified UniswapExchangeRateTask message. Does not implicitly {@link oracle_job.OracleJob.UniswapExchangeRateTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.UniswapExchangeRateTask
             * @static
             * @param {oracle_job.OracleJob.IUniswapExchangeRateTask} message UniswapExchangeRateTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UniswapExchangeRateTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.inTokenAddress != null && Object.hasOwnProperty.call(message, "inTokenAddress"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.inTokenAddress);
                if (message.outTokenAddress != null && Object.hasOwnProperty.call(message, "outTokenAddress"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.outTokenAddress);
                if (message.inTokenAmount != null && Object.hasOwnProperty.call(message, "inTokenAmount"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.inTokenAmount);
                if (message.slippage != null && Object.hasOwnProperty.call(message, "slippage"))
                    writer.uint32(/* id 4, wireType 1 =*/33).double(message.slippage);
                if (message.provider != null && Object.hasOwnProperty.call(message, "provider"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.provider);
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.version);
                if (message.routerAddress != null && Object.hasOwnProperty.call(message, "routerAddress"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.routerAddress);
                if (message.factoryAddress != null && Object.hasOwnProperty.call(message, "factoryAddress"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.factoryAddress);
                if (message.quoterAddress != null && Object.hasOwnProperty.call(message, "quoterAddress"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.quoterAddress);
                return writer;
            };

            /**
             * Encodes the specified UniswapExchangeRateTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.UniswapExchangeRateTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.UniswapExchangeRateTask
             * @static
             * @param {oracle_job.OracleJob.IUniswapExchangeRateTask} message UniswapExchangeRateTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UniswapExchangeRateTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UniswapExchangeRateTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.UniswapExchangeRateTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.UniswapExchangeRateTask} UniswapExchangeRateTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UniswapExchangeRateTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.UniswapExchangeRateTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.inTokenAddress = reader.string();
                            break;
                        }
                    case 2: {
                            message.outTokenAddress = reader.string();
                            break;
                        }
                    case 3: {
                            message.inTokenAmount = reader.double();
                            break;
                        }
                    case 4: {
                            message.slippage = reader.double();
                            break;
                        }
                    case 5: {
                            message.provider = reader.string();
                            break;
                        }
                    case 6: {
                            message.version = reader.int32();
                            break;
                        }
                    case 7: {
                            message.routerAddress = reader.string();
                            break;
                        }
                    case 8: {
                            message.factoryAddress = reader.string();
                            break;
                        }
                    case 9: {
                            message.quoterAddress = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UniswapExchangeRateTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.UniswapExchangeRateTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.UniswapExchangeRateTask} UniswapExchangeRateTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UniswapExchangeRateTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UniswapExchangeRateTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.UniswapExchangeRateTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UniswapExchangeRateTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.inTokenAddress != null && message.hasOwnProperty("inTokenAddress"))
                    if (!$util.isString(message.inTokenAddress))
                        return "inTokenAddress: string expected";
                if (message.outTokenAddress != null && message.hasOwnProperty("outTokenAddress"))
                    if (!$util.isString(message.outTokenAddress))
                        return "outTokenAddress: string expected";
                if (message.inTokenAmount != null && message.hasOwnProperty("inTokenAmount"))
                    if (typeof message.inTokenAmount !== "number")
                        return "inTokenAmount: number expected";
                if (message.slippage != null && message.hasOwnProperty("slippage"))
                    if (typeof message.slippage !== "number")
                        return "slippage: number expected";
                if (message.provider != null && message.hasOwnProperty("provider"))
                    if (!$util.isString(message.provider))
                        return "provider: string expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    switch (message.version) {
                    default:
                        return "version: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.routerAddress != null && message.hasOwnProperty("routerAddress"))
                    if (!$util.isString(message.routerAddress))
                        return "routerAddress: string expected";
                if (message.factoryAddress != null && message.hasOwnProperty("factoryAddress"))
                    if (!$util.isString(message.factoryAddress))
                        return "factoryAddress: string expected";
                if (message.quoterAddress != null && message.hasOwnProperty("quoterAddress"))
                    if (!$util.isString(message.quoterAddress))
                        return "quoterAddress: string expected";
                return null;
            };

            /**
             * Creates an UniswapExchangeRateTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.UniswapExchangeRateTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.UniswapExchangeRateTask} UniswapExchangeRateTask
             */
            UniswapExchangeRateTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.UniswapExchangeRateTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.UniswapExchangeRateTask();
                if (object.inTokenAddress != null)
                    message.inTokenAddress = String(object.inTokenAddress);
                if (object.outTokenAddress != null)
                    message.outTokenAddress = String(object.outTokenAddress);
                if (object.inTokenAmount != null)
                    message.inTokenAmount = Number(object.inTokenAmount);
                if (object.slippage != null)
                    message.slippage = Number(object.slippage);
                if (object.provider != null)
                    message.provider = String(object.provider);
                switch (object.version) {
                default:
                    if (typeof object.version === "number") {
                        message.version = object.version;
                        break;
                    }
                    break;
                case "VERSION_V2_DEPRECATED":
                case 0:
                    message.version = 0;
                    break;
                case "VERSION_V3_DEPRECATED":
                case 1:
                    message.version = 1;
                    break;
                case "VERSION_V2":
                case 2:
                    message.version = 2;
                    break;
                case "VERSION_V3":
                case 3:
                    message.version = 3;
                    break;
                }
                if (object.routerAddress != null)
                    message.routerAddress = String(object.routerAddress);
                if (object.factoryAddress != null)
                    message.factoryAddress = String(object.factoryAddress);
                if (object.quoterAddress != null)
                    message.quoterAddress = String(object.quoterAddress);
                return message;
            };

            /**
             * Creates a plain object from an UniswapExchangeRateTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.UniswapExchangeRateTask
             * @static
             * @param {oracle_job.OracleJob.UniswapExchangeRateTask} message UniswapExchangeRateTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UniswapExchangeRateTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.inTokenAddress = "";
                    object.outTokenAddress = "";
                    object.inTokenAmount = 0;
                    object.slippage = 0;
                    object.provider = "";
                    object.version = options.enums === String ? "VERSION_V2_DEPRECATED" : 0;
                    object.routerAddress = "";
                    object.factoryAddress = "";
                    object.quoterAddress = "";
                }
                if (message.inTokenAddress != null && message.hasOwnProperty("inTokenAddress"))
                    object.inTokenAddress = message.inTokenAddress;
                if (message.outTokenAddress != null && message.hasOwnProperty("outTokenAddress"))
                    object.outTokenAddress = message.outTokenAddress;
                if (message.inTokenAmount != null && message.hasOwnProperty("inTokenAmount"))
                    object.inTokenAmount = options.json && !isFinite(message.inTokenAmount) ? String(message.inTokenAmount) : message.inTokenAmount;
                if (message.slippage != null && message.hasOwnProperty("slippage"))
                    object.slippage = options.json && !isFinite(message.slippage) ? String(message.slippage) : message.slippage;
                if (message.provider != null && message.hasOwnProperty("provider"))
                    object.provider = message.provider;
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = options.enums === String ? $root.oracle_job.OracleJob.UniswapExchangeRateTask.Version[message.version] === undefined ? message.version : $root.oracle_job.OracleJob.UniswapExchangeRateTask.Version[message.version] : message.version;
                if (message.routerAddress != null && message.hasOwnProperty("routerAddress"))
                    object.routerAddress = message.routerAddress;
                if (message.factoryAddress != null && message.hasOwnProperty("factoryAddress"))
                    object.factoryAddress = message.factoryAddress;
                if (message.quoterAddress != null && message.hasOwnProperty("quoterAddress"))
                    object.quoterAddress = message.quoterAddress;
                return object;
            };

            /**
             * Converts this UniswapExchangeRateTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.UniswapExchangeRateTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UniswapExchangeRateTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UniswapExchangeRateTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.UniswapExchangeRateTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UniswapExchangeRateTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.UniswapExchangeRateTask";
            };

            /**
             * Version enum.
             * @name oracle_job.OracleJob.UniswapExchangeRateTask.Version
             * @enum {number}
             * @property {number} VERSION_V2_DEPRECATED=0 VERSION_V2_DEPRECATED value
             * @property {number} VERSION_V3_DEPRECATED=1 VERSION_V3_DEPRECATED value
             * @property {number} VERSION_V2=2 VERSION_V2 value
             * @property {number} VERSION_V3=3 VERSION_V3 value
             */
            UniswapExchangeRateTask.Version = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "VERSION_V2_DEPRECATED"] = 0;
                values[valuesById[1] = "VERSION_V3_DEPRECATED"] = 1;
                values[valuesById[2] = "VERSION_V2"] = 2;
                values[valuesById[3] = "VERSION_V3"] = 3;
                return values;
            })();

            return UniswapExchangeRateTask;
        })();

        OracleJob.SushiswapExchangeRateTask = (function() {

            /**
             * Properties of a SushiswapExchangeRateTask.
             * @memberof oracle_job.OracleJob
             * @interface ISushiswapExchangeRateTask
             * @property {string|null} [inTokenAddress] The input token address.
             * @property {string|null} [outTokenAddress] The output token address.
             * @property {number|null} [inTokenAmount] The amount of tokens to swap.
             * @property {number|null} [slippage] The allowable slippage in percent for the swap.
             * @property {string|null} [provider] The RPC provider to use for the swap.
             */

            /**
             * Constructs a new SushiswapExchangeRateTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Fetch the swap price from SushiSwap.
             * @implements ISushiswapExchangeRateTask
             * @constructor
             * @param {oracle_job.OracleJob.ISushiswapExchangeRateTask=} [properties] Properties to set
             */
            function SushiswapExchangeRateTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The input token address.
             * @member {string} inTokenAddress
             * @memberof oracle_job.OracleJob.SushiswapExchangeRateTask
             * @instance
             */
            SushiswapExchangeRateTask.prototype.inTokenAddress = "";

            /**
             * The output token address.
             * @member {string} outTokenAddress
             * @memberof oracle_job.OracleJob.SushiswapExchangeRateTask
             * @instance
             */
            SushiswapExchangeRateTask.prototype.outTokenAddress = "";

            /**
             * The amount of tokens to swap.
             * @member {number} inTokenAmount
             * @memberof oracle_job.OracleJob.SushiswapExchangeRateTask
             * @instance
             */
            SushiswapExchangeRateTask.prototype.inTokenAmount = 0;

            /**
             * The allowable slippage in percent for the swap.
             * @member {number} slippage
             * @memberof oracle_job.OracleJob.SushiswapExchangeRateTask
             * @instance
             */
            SushiswapExchangeRateTask.prototype.slippage = 0;

            /**
             * The RPC provider to use for the swap.
             * @member {string} provider
             * @memberof oracle_job.OracleJob.SushiswapExchangeRateTask
             * @instance
             */
            SushiswapExchangeRateTask.prototype.provider = "";

            /**
             * Creates a new SushiswapExchangeRateTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.SushiswapExchangeRateTask
             * @static
             * @param {oracle_job.OracleJob.ISushiswapExchangeRateTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.SushiswapExchangeRateTask} SushiswapExchangeRateTask instance
             */
            SushiswapExchangeRateTask.create = function create(properties) {
      return SushiswapExchangeRateTask.fromObject(properties);
    };

            /**
             * Encodes the specified SushiswapExchangeRateTask message. Does not implicitly {@link oracle_job.OracleJob.SushiswapExchangeRateTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.SushiswapExchangeRateTask
             * @static
             * @param {oracle_job.OracleJob.ISushiswapExchangeRateTask} message SushiswapExchangeRateTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SushiswapExchangeRateTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.inTokenAddress != null && Object.hasOwnProperty.call(message, "inTokenAddress"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.inTokenAddress);
                if (message.outTokenAddress != null && Object.hasOwnProperty.call(message, "outTokenAddress"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.outTokenAddress);
                if (message.inTokenAmount != null && Object.hasOwnProperty.call(message, "inTokenAmount"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.inTokenAmount);
                if (message.slippage != null && Object.hasOwnProperty.call(message, "slippage"))
                    writer.uint32(/* id 4, wireType 1 =*/33).double(message.slippage);
                if (message.provider != null && Object.hasOwnProperty.call(message, "provider"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.provider);
                return writer;
            };

            /**
             * Encodes the specified SushiswapExchangeRateTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.SushiswapExchangeRateTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.SushiswapExchangeRateTask
             * @static
             * @param {oracle_job.OracleJob.ISushiswapExchangeRateTask} message SushiswapExchangeRateTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SushiswapExchangeRateTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SushiswapExchangeRateTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.SushiswapExchangeRateTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.SushiswapExchangeRateTask} SushiswapExchangeRateTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SushiswapExchangeRateTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.SushiswapExchangeRateTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.inTokenAddress = reader.string();
                            break;
                        }
                    case 2: {
                            message.outTokenAddress = reader.string();
                            break;
                        }
                    case 3: {
                            message.inTokenAmount = reader.double();
                            break;
                        }
                    case 4: {
                            message.slippage = reader.double();
                            break;
                        }
                    case 5: {
                            message.provider = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SushiswapExchangeRateTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.SushiswapExchangeRateTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.SushiswapExchangeRateTask} SushiswapExchangeRateTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SushiswapExchangeRateTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SushiswapExchangeRateTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.SushiswapExchangeRateTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SushiswapExchangeRateTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.inTokenAddress != null && message.hasOwnProperty("inTokenAddress"))
                    if (!$util.isString(message.inTokenAddress))
                        return "inTokenAddress: string expected";
                if (message.outTokenAddress != null && message.hasOwnProperty("outTokenAddress"))
                    if (!$util.isString(message.outTokenAddress))
                        return "outTokenAddress: string expected";
                if (message.inTokenAmount != null && message.hasOwnProperty("inTokenAmount"))
                    if (typeof message.inTokenAmount !== "number")
                        return "inTokenAmount: number expected";
                if (message.slippage != null && message.hasOwnProperty("slippage"))
                    if (typeof message.slippage !== "number")
                        return "slippage: number expected";
                if (message.provider != null && message.hasOwnProperty("provider"))
                    if (!$util.isString(message.provider))
                        return "provider: string expected";
                return null;
            };

            /**
             * Creates a SushiswapExchangeRateTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.SushiswapExchangeRateTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.SushiswapExchangeRateTask} SushiswapExchangeRateTask
             */
            SushiswapExchangeRateTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.SushiswapExchangeRateTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.SushiswapExchangeRateTask();
                if (object.inTokenAddress != null)
                    message.inTokenAddress = String(object.inTokenAddress);
                if (object.outTokenAddress != null)
                    message.outTokenAddress = String(object.outTokenAddress);
                if (object.inTokenAmount != null)
                    message.inTokenAmount = Number(object.inTokenAmount);
                if (object.slippage != null)
                    message.slippage = Number(object.slippage);
                if (object.provider != null)
                    message.provider = String(object.provider);
                return message;
            };

            /**
             * Creates a plain object from a SushiswapExchangeRateTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.SushiswapExchangeRateTask
             * @static
             * @param {oracle_job.OracleJob.SushiswapExchangeRateTask} message SushiswapExchangeRateTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SushiswapExchangeRateTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.inTokenAddress = "";
                    object.outTokenAddress = "";
                    object.inTokenAmount = 0;
                    object.slippage = 0;
                    object.provider = "";
                }
                if (message.inTokenAddress != null && message.hasOwnProperty("inTokenAddress"))
                    object.inTokenAddress = message.inTokenAddress;
                if (message.outTokenAddress != null && message.hasOwnProperty("outTokenAddress"))
                    object.outTokenAddress = message.outTokenAddress;
                if (message.inTokenAmount != null && message.hasOwnProperty("inTokenAmount"))
                    object.inTokenAmount = options.json && !isFinite(message.inTokenAmount) ? String(message.inTokenAmount) : message.inTokenAmount;
                if (message.slippage != null && message.hasOwnProperty("slippage"))
                    object.slippage = options.json && !isFinite(message.slippage) ? String(message.slippage) : message.slippage;
                if (message.provider != null && message.hasOwnProperty("provider"))
                    object.provider = message.provider;
                return object;
            };

            /**
             * Converts this SushiswapExchangeRateTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.SushiswapExchangeRateTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SushiswapExchangeRateTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SushiswapExchangeRateTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.SushiswapExchangeRateTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SushiswapExchangeRateTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.SushiswapExchangeRateTask";
            };

            return SushiswapExchangeRateTask;
        })();

        OracleJob.PancakeswapExchangeRateTask = (function() {

            /**
             * Properties of a PancakeswapExchangeRateTask.
             * @memberof oracle_job.OracleJob
             * @interface IPancakeswapExchangeRateTask
             * @property {string|null} [inTokenAddress] The input token address.
             * @property {string|null} [outTokenAddress] The output token address.
             * @property {number|null} [inTokenAmount] The amount of tokens to swap.
             * @property {number|null} [slippage] The allowable slippage in percent for the swap.
             * @property {string|null} [provider] The RPC provider to use for the swap.
             */

            /**
             * Constructs a new PancakeswapExchangeRateTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Fetch the swap price from PancakeSwap.
             * @implements IPancakeswapExchangeRateTask
             * @constructor
             * @param {oracle_job.OracleJob.IPancakeswapExchangeRateTask=} [properties] Properties to set
             */
            function PancakeswapExchangeRateTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The input token address.
             * @member {string} inTokenAddress
             * @memberof oracle_job.OracleJob.PancakeswapExchangeRateTask
             * @instance
             */
            PancakeswapExchangeRateTask.prototype.inTokenAddress = "";

            /**
             * The output token address.
             * @member {string} outTokenAddress
             * @memberof oracle_job.OracleJob.PancakeswapExchangeRateTask
             * @instance
             */
            PancakeswapExchangeRateTask.prototype.outTokenAddress = "";

            /**
             * The amount of tokens to swap.
             * @member {number} inTokenAmount
             * @memberof oracle_job.OracleJob.PancakeswapExchangeRateTask
             * @instance
             */
            PancakeswapExchangeRateTask.prototype.inTokenAmount = 0;

            /**
             * The allowable slippage in percent for the swap.
             * @member {number} slippage
             * @memberof oracle_job.OracleJob.PancakeswapExchangeRateTask
             * @instance
             */
            PancakeswapExchangeRateTask.prototype.slippage = 0;

            /**
             * The RPC provider to use for the swap.
             * @member {string} provider
             * @memberof oracle_job.OracleJob.PancakeswapExchangeRateTask
             * @instance
             */
            PancakeswapExchangeRateTask.prototype.provider = "";

            /**
             * Creates a new PancakeswapExchangeRateTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.PancakeswapExchangeRateTask
             * @static
             * @param {oracle_job.OracleJob.IPancakeswapExchangeRateTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.PancakeswapExchangeRateTask} PancakeswapExchangeRateTask instance
             */
            PancakeswapExchangeRateTask.create = function create(properties) {
      return PancakeswapExchangeRateTask.fromObject(properties);
    };

            /**
             * Encodes the specified PancakeswapExchangeRateTask message. Does not implicitly {@link oracle_job.OracleJob.PancakeswapExchangeRateTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.PancakeswapExchangeRateTask
             * @static
             * @param {oracle_job.OracleJob.IPancakeswapExchangeRateTask} message PancakeswapExchangeRateTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PancakeswapExchangeRateTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.inTokenAddress != null && Object.hasOwnProperty.call(message, "inTokenAddress"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.inTokenAddress);
                if (message.outTokenAddress != null && Object.hasOwnProperty.call(message, "outTokenAddress"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.outTokenAddress);
                if (message.inTokenAmount != null && Object.hasOwnProperty.call(message, "inTokenAmount"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.inTokenAmount);
                if (message.slippage != null && Object.hasOwnProperty.call(message, "slippage"))
                    writer.uint32(/* id 4, wireType 1 =*/33).double(message.slippage);
                if (message.provider != null && Object.hasOwnProperty.call(message, "provider"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.provider);
                return writer;
            };

            /**
             * Encodes the specified PancakeswapExchangeRateTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.PancakeswapExchangeRateTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.PancakeswapExchangeRateTask
             * @static
             * @param {oracle_job.OracleJob.IPancakeswapExchangeRateTask} message PancakeswapExchangeRateTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PancakeswapExchangeRateTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PancakeswapExchangeRateTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.PancakeswapExchangeRateTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.PancakeswapExchangeRateTask} PancakeswapExchangeRateTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PancakeswapExchangeRateTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.PancakeswapExchangeRateTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.inTokenAddress = reader.string();
                            break;
                        }
                    case 2: {
                            message.outTokenAddress = reader.string();
                            break;
                        }
                    case 3: {
                            message.inTokenAmount = reader.double();
                            break;
                        }
                    case 4: {
                            message.slippage = reader.double();
                            break;
                        }
                    case 5: {
                            message.provider = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PancakeswapExchangeRateTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.PancakeswapExchangeRateTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.PancakeswapExchangeRateTask} PancakeswapExchangeRateTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PancakeswapExchangeRateTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PancakeswapExchangeRateTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.PancakeswapExchangeRateTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PancakeswapExchangeRateTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.inTokenAddress != null && message.hasOwnProperty("inTokenAddress"))
                    if (!$util.isString(message.inTokenAddress))
                        return "inTokenAddress: string expected";
                if (message.outTokenAddress != null && message.hasOwnProperty("outTokenAddress"))
                    if (!$util.isString(message.outTokenAddress))
                        return "outTokenAddress: string expected";
                if (message.inTokenAmount != null && message.hasOwnProperty("inTokenAmount"))
                    if (typeof message.inTokenAmount !== "number")
                        return "inTokenAmount: number expected";
                if (message.slippage != null && message.hasOwnProperty("slippage"))
                    if (typeof message.slippage !== "number")
                        return "slippage: number expected";
                if (message.provider != null && message.hasOwnProperty("provider"))
                    if (!$util.isString(message.provider))
                        return "provider: string expected";
                return null;
            };

            /**
             * Creates a PancakeswapExchangeRateTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.PancakeswapExchangeRateTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.PancakeswapExchangeRateTask} PancakeswapExchangeRateTask
             */
            PancakeswapExchangeRateTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.PancakeswapExchangeRateTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.PancakeswapExchangeRateTask();
                if (object.inTokenAddress != null)
                    message.inTokenAddress = String(object.inTokenAddress);
                if (object.outTokenAddress != null)
                    message.outTokenAddress = String(object.outTokenAddress);
                if (object.inTokenAmount != null)
                    message.inTokenAmount = Number(object.inTokenAmount);
                if (object.slippage != null)
                    message.slippage = Number(object.slippage);
                if (object.provider != null)
                    message.provider = String(object.provider);
                return message;
            };

            /**
             * Creates a plain object from a PancakeswapExchangeRateTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.PancakeswapExchangeRateTask
             * @static
             * @param {oracle_job.OracleJob.PancakeswapExchangeRateTask} message PancakeswapExchangeRateTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PancakeswapExchangeRateTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.inTokenAddress = "";
                    object.outTokenAddress = "";
                    object.inTokenAmount = 0;
                    object.slippage = 0;
                    object.provider = "";
                }
                if (message.inTokenAddress != null && message.hasOwnProperty("inTokenAddress"))
                    object.inTokenAddress = message.inTokenAddress;
                if (message.outTokenAddress != null && message.hasOwnProperty("outTokenAddress"))
                    object.outTokenAddress = message.outTokenAddress;
                if (message.inTokenAmount != null && message.hasOwnProperty("inTokenAmount"))
                    object.inTokenAmount = options.json && !isFinite(message.inTokenAmount) ? String(message.inTokenAmount) : message.inTokenAmount;
                if (message.slippage != null && message.hasOwnProperty("slippage"))
                    object.slippage = options.json && !isFinite(message.slippage) ? String(message.slippage) : message.slippage;
                if (message.provider != null && message.hasOwnProperty("provider"))
                    object.provider = message.provider;
                return object;
            };

            /**
             * Converts this PancakeswapExchangeRateTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.PancakeswapExchangeRateTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PancakeswapExchangeRateTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PancakeswapExchangeRateTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.PancakeswapExchangeRateTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PancakeswapExchangeRateTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.PancakeswapExchangeRateTask";
            };

            return PancakeswapExchangeRateTask;
        })();

        OracleJob.CacheTask = (function() {

            /**
             * Properties of a CacheTask.
             * @memberof oracle_job.OracleJob
             * @interface ICacheTask
             * @property {Array.<oracle_job.OracleJob.CacheTask.ICacheItem>|null} [cacheItems] A list of cached variables to reference in the job with `${VARIABLE_NAME}`.
             */

            /**
             * Constructs a new CacheTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Execute a job and store the result in a variable to reference later.
             * 
             * _**Input**_: None
             * 
             * _**Returns**_: The input
             * 
             * _**Example**_: CacheTask storing ${ONE} = 1
             * 
             * ```json
             * { "cacheTask": { "cacheItems": [ { "variableName": "ONE", "job": { "tasks": [ { "valueTask": { "value": 1 } } ] } } ] } }
             * ```
             * @implements ICacheTask
             * @constructor
             * @param {oracle_job.OracleJob.ICacheTask=} [properties] Properties to set
             */
            function CacheTask(properties) {
                this.cacheItems = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * A list of cached variables to reference in the job with `${VARIABLE_NAME}`.
             * @member {Array.<oracle_job.OracleJob.CacheTask.ICacheItem>} cacheItems
             * @memberof oracle_job.OracleJob.CacheTask
             * @instance
             */
            CacheTask.prototype.cacheItems = $util.emptyArray;

            /**
             * Creates a new CacheTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.CacheTask
             * @static
             * @param {oracle_job.OracleJob.ICacheTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.CacheTask} CacheTask instance
             */
            CacheTask.create = function create(properties) {
      return CacheTask.fromObject(properties);
    };

            /**
             * Encodes the specified CacheTask message. Does not implicitly {@link oracle_job.OracleJob.CacheTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.CacheTask
             * @static
             * @param {oracle_job.OracleJob.ICacheTask} message CacheTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CacheTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cacheItems != null && message.cacheItems.length)
                    for (let i = 0; i < message.cacheItems.length; ++i)
                        $root.oracle_job.OracleJob.CacheTask.CacheItem.encode(message.cacheItems[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified CacheTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.CacheTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.CacheTask
             * @static
             * @param {oracle_job.OracleJob.ICacheTask} message CacheTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CacheTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CacheTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.CacheTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.CacheTask} CacheTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CacheTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.CacheTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.cacheItems && message.cacheItems.length))
                                message.cacheItems = [];
                            message.cacheItems.push($root.oracle_job.OracleJob.CacheTask.CacheItem.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CacheTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.CacheTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.CacheTask} CacheTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CacheTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CacheTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.CacheTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CacheTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.cacheItems != null && message.hasOwnProperty("cacheItems")) {
                    if (!Array.isArray(message.cacheItems))
                        return "cacheItems: array expected";
                    for (let i = 0; i < message.cacheItems.length; ++i) {
                        let error = $root.oracle_job.OracleJob.CacheTask.CacheItem.verify(message.cacheItems[i]);
                        if (error)
                            return "cacheItems." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a CacheTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.CacheTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.CacheTask} CacheTask
             */
            CacheTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.CacheTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.CacheTask();
                if (object.cacheItems) {
                    if (!Array.isArray(object.cacheItems))
                        throw TypeError(".oracle_job.OracleJob.CacheTask.cacheItems: array expected");
                    message.cacheItems = [];
                    for (let i = 0; i < object.cacheItems.length; ++i) {
                        if (typeof object.cacheItems[i] !== "object")
                            throw TypeError(".oracle_job.OracleJob.CacheTask.cacheItems: object expected");
                        message.cacheItems[i] = $root.oracle_job.OracleJob.CacheTask.CacheItem.fromObject(object.cacheItems[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a CacheTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.CacheTask
             * @static
             * @param {oracle_job.OracleJob.CacheTask} message CacheTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CacheTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.cacheItems = [];
                if (message.cacheItems && message.cacheItems.length) {
                    object.cacheItems = [];
                    for (let j = 0; j < message.cacheItems.length; ++j)
                        object.cacheItems[j] = $root.oracle_job.OracleJob.CacheTask.CacheItem.toObject(message.cacheItems[j], options);
                }
                return object;
            };

            /**
             * Converts this CacheTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.CacheTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CacheTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CacheTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.CacheTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CacheTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.CacheTask";
            };

            CacheTask.CacheItem = (function() {

                /**
                 * Properties of a CacheItem.
                 * @memberof oracle_job.OracleJob.CacheTask
                 * @interface ICacheItem
                 * @property {string|null} [variableName] The name of the variable to store in cache to reference later with `${VARIABLE_NAME}`.
                 * @property {oracle_job.IOracleJob|null} [job] The OracleJob to execute to yield the value to store in cache.
                 */

                /**
                 * Constructs a new CacheItem.
                 * @memberof oracle_job.OracleJob.CacheTask
                 * @classdesc Represents a CacheItem.
                 * @implements ICacheItem
                 * @constructor
                 * @param {oracle_job.OracleJob.CacheTask.ICacheItem=} [properties] Properties to set
                 */
                function CacheItem(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * The name of the variable to store in cache to reference later with `${VARIABLE_NAME}`.
                 * @member {string} variableName
                 * @memberof oracle_job.OracleJob.CacheTask.CacheItem
                 * @instance
                 */
                CacheItem.prototype.variableName = "";

                /**
                 * The OracleJob to execute to yield the value to store in cache.
                 * @member {oracle_job.IOracleJob|null|undefined} job
                 * @memberof oracle_job.OracleJob.CacheTask.CacheItem
                 * @instance
                 */
                CacheItem.prototype.job = null;

                /**
                 * Creates a new CacheItem instance using the specified properties.
                 * @function create
                 * @memberof oracle_job.OracleJob.CacheTask.CacheItem
                 * @static
                 * @param {oracle_job.OracleJob.CacheTask.ICacheItem=} [properties] Properties to set
                 * @returns {oracle_job.OracleJob.CacheTask.CacheItem} CacheItem instance
                 */
                CacheItem.create = function create(properties) {
      return CacheItem.fromObject(properties);
    };

                /**
                 * Encodes the specified CacheItem message. Does not implicitly {@link oracle_job.OracleJob.CacheTask.CacheItem.verify|verify} messages.
                 * @function encode
                 * @memberof oracle_job.OracleJob.CacheTask.CacheItem
                 * @static
                 * @param {oracle_job.OracleJob.CacheTask.ICacheItem} message CacheItem message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CacheItem.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.variableName != null && Object.hasOwnProperty.call(message, "variableName"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.variableName);
                    if (message.job != null && Object.hasOwnProperty.call(message, "job"))
                        $root.oracle_job.OracleJob.encode(message.job, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified CacheItem message, length delimited. Does not implicitly {@link oracle_job.OracleJob.CacheTask.CacheItem.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof oracle_job.OracleJob.CacheTask.CacheItem
                 * @static
                 * @param {oracle_job.OracleJob.CacheTask.ICacheItem} message CacheItem message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CacheItem.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CacheItem message from the specified reader or buffer.
                 * @function decode
                 * @memberof oracle_job.OracleJob.CacheTask.CacheItem
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {oracle_job.OracleJob.CacheTask.CacheItem} CacheItem
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CacheItem.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.CacheTask.CacheItem();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.variableName = reader.string();
                                break;
                            }
                        case 2: {
                                message.job = $root.oracle_job.OracleJob.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CacheItem message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof oracle_job.OracleJob.CacheTask.CacheItem
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {oracle_job.OracleJob.CacheTask.CacheItem} CacheItem
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CacheItem.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CacheItem message.
                 * @function verify
                 * @memberof oracle_job.OracleJob.CacheTask.CacheItem
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CacheItem.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.variableName != null && message.hasOwnProperty("variableName"))
                        if (!$util.isString(message.variableName))
                            return "variableName: string expected";
                    if (message.job != null && message.hasOwnProperty("job")) {
                        let error = $root.oracle_job.OracleJob.verify(message.job);
                        if (error)
                            return "job." + error;
                    }
                    return null;
                };

                /**
                 * Creates a CacheItem message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof oracle_job.OracleJob.CacheTask.CacheItem
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {oracle_job.OracleJob.CacheTask.CacheItem} CacheItem
                 */
                CacheItem.fromObject = function fromObject(object) {
                    if (object instanceof $root.oracle_job.OracleJob.CacheTask.CacheItem)
                        return object;
                    let message = new $root.oracle_job.OracleJob.CacheTask.CacheItem();
                    if (object.variableName != null)
                        message.variableName = String(object.variableName);
                    if (object.job != null) {
                        if (typeof object.job !== "object")
                            throw TypeError(".oracle_job.OracleJob.CacheTask.CacheItem.job: object expected");
                        message.job = $root.oracle_job.OracleJob.fromObject(object.job);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CacheItem message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof oracle_job.OracleJob.CacheTask.CacheItem
                 * @static
                 * @param {oracle_job.OracleJob.CacheTask.CacheItem} message CacheItem
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CacheItem.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.variableName = "";
                        object.job = null;
                    }
                    if (message.variableName != null && message.hasOwnProperty("variableName"))
                        object.variableName = message.variableName;
                    if (message.job != null && message.hasOwnProperty("job"))
                        object.job = $root.oracle_job.OracleJob.toObject(message.job, options);
                    return object;
                };

                /**
                 * Converts this CacheItem to JSON.
                 * @function toJSON
                 * @memberof oracle_job.OracleJob.CacheTask.CacheItem
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CacheItem.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for CacheItem
                 * @function getTypeUrl
                 * @memberof oracle_job.OracleJob.CacheTask.CacheItem
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                CacheItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/oracle_job.OracleJob.CacheTask.CacheItem";
                };

                return CacheItem;
            })();

            return CacheTask;
        })();

        OracleJob.SysclockOffsetTask = (function() {

            /**
             * Properties of a SysclockOffsetTask.
             * @memberof oracle_job.OracleJob
             * @interface ISysclockOffsetTask
             */

            /**
             * Constructs a new SysclockOffsetTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Return the difference between an oracle's clock and the current timestamp at `SYSVAR_CLOCK_PUBKEY`.
             * @implements ISysclockOffsetTask
             * @constructor
             * @param {oracle_job.OracleJob.ISysclockOffsetTask=} [properties] Properties to set
             */
            function SysclockOffsetTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SysclockOffsetTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.SysclockOffsetTask
             * @static
             * @param {oracle_job.OracleJob.ISysclockOffsetTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.SysclockOffsetTask} SysclockOffsetTask instance
             */
            SysclockOffsetTask.create = function create(properties) {
      return SysclockOffsetTask.fromObject(properties);
    };

            /**
             * Encodes the specified SysclockOffsetTask message. Does not implicitly {@link oracle_job.OracleJob.SysclockOffsetTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.SysclockOffsetTask
             * @static
             * @param {oracle_job.OracleJob.ISysclockOffsetTask} message SysclockOffsetTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SysclockOffsetTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SysclockOffsetTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.SysclockOffsetTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.SysclockOffsetTask
             * @static
             * @param {oracle_job.OracleJob.ISysclockOffsetTask} message SysclockOffsetTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SysclockOffsetTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SysclockOffsetTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.SysclockOffsetTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.SysclockOffsetTask} SysclockOffsetTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SysclockOffsetTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.SysclockOffsetTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SysclockOffsetTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.SysclockOffsetTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.SysclockOffsetTask} SysclockOffsetTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SysclockOffsetTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SysclockOffsetTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.SysclockOffsetTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SysclockOffsetTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SysclockOffsetTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.SysclockOffsetTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.SysclockOffsetTask} SysclockOffsetTask
             */
            SysclockOffsetTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.SysclockOffsetTask)
                    return object;
                return new $root.oracle_job.OracleJob.SysclockOffsetTask();
            };

            /**
             * Creates a plain object from a SysclockOffsetTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.SysclockOffsetTask
             * @static
             * @param {oracle_job.OracleJob.SysclockOffsetTask} message SysclockOffsetTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SysclockOffsetTask.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SysclockOffsetTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.SysclockOffsetTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SysclockOffsetTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SysclockOffsetTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.SysclockOffsetTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SysclockOffsetTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.SysclockOffsetTask";
            };

            return SysclockOffsetTask;
        })();

        OracleJob.MarinadeStateTask = (function() {

            /**
             * Properties of a MarinadeStateTask.
             * @memberof oracle_job.OracleJob
             * @interface IMarinadeStateTask
             */

            /**
             * Constructs a new MarinadeStateTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Represents a MarinadeStateTask.
             * @implements IMarinadeStateTask
             * @constructor
             * @param {oracle_job.OracleJob.IMarinadeStateTask=} [properties] Properties to set
             */
            function MarinadeStateTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new MarinadeStateTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.MarinadeStateTask
             * @static
             * @param {oracle_job.OracleJob.IMarinadeStateTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.MarinadeStateTask} MarinadeStateTask instance
             */
            MarinadeStateTask.create = function create(properties) {
      return MarinadeStateTask.fromObject(properties);
    };

            /**
             * Encodes the specified MarinadeStateTask message. Does not implicitly {@link oracle_job.OracleJob.MarinadeStateTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.MarinadeStateTask
             * @static
             * @param {oracle_job.OracleJob.IMarinadeStateTask} message MarinadeStateTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MarinadeStateTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified MarinadeStateTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.MarinadeStateTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.MarinadeStateTask
             * @static
             * @param {oracle_job.OracleJob.IMarinadeStateTask} message MarinadeStateTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MarinadeStateTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MarinadeStateTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.MarinadeStateTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.MarinadeStateTask} MarinadeStateTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MarinadeStateTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.MarinadeStateTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MarinadeStateTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.MarinadeStateTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.MarinadeStateTask} MarinadeStateTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MarinadeStateTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MarinadeStateTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.MarinadeStateTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MarinadeStateTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a MarinadeStateTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.MarinadeStateTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.MarinadeStateTask} MarinadeStateTask
             */
            MarinadeStateTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.MarinadeStateTask)
                    return object;
                return new $root.oracle_job.OracleJob.MarinadeStateTask();
            };

            /**
             * Creates a plain object from a MarinadeStateTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.MarinadeStateTask
             * @static
             * @param {oracle_job.OracleJob.MarinadeStateTask} message MarinadeStateTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MarinadeStateTask.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this MarinadeStateTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.MarinadeStateTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MarinadeStateTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MarinadeStateTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.MarinadeStateTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MarinadeStateTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.MarinadeStateTask";
            };

            return MarinadeStateTask;
        })();

        OracleJob.SolanaAccountDataFetchTask = (function() {

            /**
             * Properties of a SolanaAccountDataFetchTask.
             * @memberof oracle_job.OracleJob
             * @interface ISolanaAccountDataFetchTask
             * @property {string|null} [pubkey] The on-chain account to fetch the account data from.
             * @property {oracle_job.OracleJob.SolanaAccountDataFetchTask.Network|null} [network] SolanaAccountDataFetchTask network
             */

            /**
             * Constructs a new SolanaAccountDataFetchTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Fetch the account data in a stringified buffer format.
             * @implements ISolanaAccountDataFetchTask
             * @constructor
             * @param {oracle_job.OracleJob.ISolanaAccountDataFetchTask=} [properties] Properties to set
             */
            function SolanaAccountDataFetchTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The on-chain account to fetch the account data from.
             * @member {string} pubkey
             * @memberof oracle_job.OracleJob.SolanaAccountDataFetchTask
             * @instance
             */
            SolanaAccountDataFetchTask.prototype.pubkey = "";

            /**
             * SolanaAccountDataFetchTask network.
             * @member {oracle_job.OracleJob.SolanaAccountDataFetchTask.Network} network
             * @memberof oracle_job.OracleJob.SolanaAccountDataFetchTask
             * @instance
             */
            SolanaAccountDataFetchTask.prototype.network = 0;

            /**
             * Creates a new SolanaAccountDataFetchTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.SolanaAccountDataFetchTask
             * @static
             * @param {oracle_job.OracleJob.ISolanaAccountDataFetchTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.SolanaAccountDataFetchTask} SolanaAccountDataFetchTask instance
             */
            SolanaAccountDataFetchTask.create = function create(properties) {
      return SolanaAccountDataFetchTask.fromObject(properties);
    };

            /**
             * Encodes the specified SolanaAccountDataFetchTask message. Does not implicitly {@link oracle_job.OracleJob.SolanaAccountDataFetchTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.SolanaAccountDataFetchTask
             * @static
             * @param {oracle_job.OracleJob.ISolanaAccountDataFetchTask} message SolanaAccountDataFetchTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SolanaAccountDataFetchTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pubkey != null && Object.hasOwnProperty.call(message, "pubkey"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.pubkey);
                if (message.network != null && Object.hasOwnProperty.call(message, "network"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.network);
                return writer;
            };

            /**
             * Encodes the specified SolanaAccountDataFetchTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.SolanaAccountDataFetchTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.SolanaAccountDataFetchTask
             * @static
             * @param {oracle_job.OracleJob.ISolanaAccountDataFetchTask} message SolanaAccountDataFetchTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SolanaAccountDataFetchTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SolanaAccountDataFetchTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.SolanaAccountDataFetchTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.SolanaAccountDataFetchTask} SolanaAccountDataFetchTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SolanaAccountDataFetchTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.SolanaAccountDataFetchTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.pubkey = reader.string();
                            break;
                        }
                    case 2: {
                            message.network = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SolanaAccountDataFetchTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.SolanaAccountDataFetchTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.SolanaAccountDataFetchTask} SolanaAccountDataFetchTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SolanaAccountDataFetchTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SolanaAccountDataFetchTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.SolanaAccountDataFetchTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SolanaAccountDataFetchTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                    if (!$util.isString(message.pubkey))
                        return "pubkey: string expected";
                if (message.network != null && message.hasOwnProperty("network"))
                    switch (message.network) {
                    default:
                        return "network: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a SolanaAccountDataFetchTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.SolanaAccountDataFetchTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.SolanaAccountDataFetchTask} SolanaAccountDataFetchTask
             */
            SolanaAccountDataFetchTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.SolanaAccountDataFetchTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.SolanaAccountDataFetchTask();
                if (object.pubkey != null)
                    message.pubkey = String(object.pubkey);
                switch (object.network) {
                default:
                    if (typeof object.network === "number") {
                        message.network = object.network;
                        break;
                    }
                    break;
                case "NETWORK_MAINNET":
                case 0:
                    message.network = 0;
                    break;
                case "NETWORK_TESTNET":
                case 1:
                    message.network = 1;
                    break;
                case "NETWORK_DEVNET":
                case 2:
                    message.network = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a SolanaAccountDataFetchTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.SolanaAccountDataFetchTask
             * @static
             * @param {oracle_job.OracleJob.SolanaAccountDataFetchTask} message SolanaAccountDataFetchTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SolanaAccountDataFetchTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.pubkey = "";
                    object.network = options.enums === String ? "NETWORK_MAINNET" : 0;
                }
                if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                    object.pubkey = message.pubkey;
                if (message.network != null && message.hasOwnProperty("network"))
                    object.network = options.enums === String ? $root.oracle_job.OracleJob.SolanaAccountDataFetchTask.Network[message.network] === undefined ? message.network : $root.oracle_job.OracleJob.SolanaAccountDataFetchTask.Network[message.network] : message.network;
                return object;
            };

            /**
             * Converts this SolanaAccountDataFetchTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.SolanaAccountDataFetchTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SolanaAccountDataFetchTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SolanaAccountDataFetchTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.SolanaAccountDataFetchTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SolanaAccountDataFetchTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.SolanaAccountDataFetchTask";
            };

            /**
             * Network enum.
             * @name oracle_job.OracleJob.SolanaAccountDataFetchTask.Network
             * @enum {number}
             * @property {number} NETWORK_MAINNET=0 NETWORK_MAINNET value
             * @property {number} NETWORK_TESTNET=1 NETWORK_TESTNET value
             * @property {number} NETWORK_DEVNET=2 NETWORK_DEVNET value
             */
            SolanaAccountDataFetchTask.Network = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NETWORK_MAINNET"] = 0;
                values[valuesById[1] = "NETWORK_TESTNET"] = 1;
                values[valuesById[2] = "NETWORK_DEVNET"] = 2;
                return values;
            })();

            return SolanaAccountDataFetchTask;
        })();

        OracleJob.CronParseTask = (function() {

            /**
             * Properties of a CronParseTask.
             * @memberof oracle_job.OracleJob
             * @interface ICronParseTask
             * @property {string|null} [cronPattern] The cron pattern to parse.
             * @property {number|null} [clockOffset] The timestamp offset to calculate the next run.
             * @property {oracle_job.OracleJob.CronParseTask.ClockType|null} [clock] Use the TaskRunner's clock or the on-chain SYSCLOCK.
             */

            /**
             * Constructs a new CronParseTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Return a timestamp from a crontab instruction.
             * 
             * _**Input**_: None
             * 
             * _**Returns**_: A timestamp
             * 
             * _**Example**_: Return the unix timestamp for the on-chain SYSCLOCK
             * 
             * ```json
             * {"cronParseTask":{"cronPattern":"* * * * * *","clockOffset":0,"clock":"SYSCLOCK"}}
             * ```
             * 
             * _**Example**_: Return the unix timestamp for next friday at 5pm UTC
             * 
             * ```json
             * {"cronParseTask":{"cronPattern":"0 17 * * 5","clockOffset":0,"clock":0}}
             * ```
             * @implements ICronParseTask
             * @constructor
             * @param {oracle_job.OracleJob.ICronParseTask=} [properties] Properties to set
             */
            function CronParseTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The cron pattern to parse.
             * @member {string} cronPattern
             * @memberof oracle_job.OracleJob.CronParseTask
             * @instance
             */
            CronParseTask.prototype.cronPattern = "";

            /**
             * The timestamp offset to calculate the next run.
             * @member {number} clockOffset
             * @memberof oracle_job.OracleJob.CronParseTask
             * @instance
             */
            CronParseTask.prototype.clockOffset = 0;

            /**
             * Use the TaskRunner's clock or the on-chain SYSCLOCK.
             * @member {oracle_job.OracleJob.CronParseTask.ClockType} clock
             * @memberof oracle_job.OracleJob.CronParseTask
             * @instance
             */
            CronParseTask.prototype.clock = 0;

            /**
             * Creates a new CronParseTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.CronParseTask
             * @static
             * @param {oracle_job.OracleJob.ICronParseTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.CronParseTask} CronParseTask instance
             */
            CronParseTask.create = function create(properties) {
      return CronParseTask.fromObject(properties);
    };

            /**
             * Encodes the specified CronParseTask message. Does not implicitly {@link oracle_job.OracleJob.CronParseTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.CronParseTask
             * @static
             * @param {oracle_job.OracleJob.ICronParseTask} message CronParseTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CronParseTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cronPattern != null && Object.hasOwnProperty.call(message, "cronPattern"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.cronPattern);
                if (message.clockOffset != null && Object.hasOwnProperty.call(message, "clockOffset"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.clockOffset);
                if (message.clock != null && Object.hasOwnProperty.call(message, "clock"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.clock);
                return writer;
            };

            /**
             * Encodes the specified CronParseTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.CronParseTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.CronParseTask
             * @static
             * @param {oracle_job.OracleJob.ICronParseTask} message CronParseTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CronParseTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CronParseTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.CronParseTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.CronParseTask} CronParseTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CronParseTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.CronParseTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.cronPattern = reader.string();
                            break;
                        }
                    case 2: {
                            message.clockOffset = reader.int32();
                            break;
                        }
                    case 3: {
                            message.clock = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CronParseTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.CronParseTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.CronParseTask} CronParseTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CronParseTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CronParseTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.CronParseTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CronParseTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.cronPattern != null && message.hasOwnProperty("cronPattern"))
                    if (!$util.isString(message.cronPattern))
                        return "cronPattern: string expected";
                if (message.clockOffset != null && message.hasOwnProperty("clockOffset"))
                    if (!$util.isInteger(message.clockOffset))
                        return "clockOffset: integer expected";
                if (message.clock != null && message.hasOwnProperty("clock"))
                    switch (message.clock) {
                    default:
                        return "clock: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a CronParseTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.CronParseTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.CronParseTask} CronParseTask
             */
            CronParseTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.CronParseTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.CronParseTask();
                if (object.cronPattern != null)
                    message.cronPattern = String(object.cronPattern);
                if (object.clockOffset != null)
                    message.clockOffset = object.clockOffset | 0;
                switch (object.clock) {
                default:
                    if (typeof object.clock === "number") {
                        message.clock = object.clock;
                        break;
                    }
                    break;
                case "ORACLE":
                case 0:
                    message.clock = 0;
                    break;
                case "SYSCLOCK":
                case 1:
                    message.clock = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a CronParseTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.CronParseTask
             * @static
             * @param {oracle_job.OracleJob.CronParseTask} message CronParseTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CronParseTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.cronPattern = "";
                    object.clockOffset = 0;
                    object.clock = options.enums === String ? "ORACLE" : 0;
                }
                if (message.cronPattern != null && message.hasOwnProperty("cronPattern"))
                    object.cronPattern = message.cronPattern;
                if (message.clockOffset != null && message.hasOwnProperty("clockOffset"))
                    object.clockOffset = message.clockOffset;
                if (message.clock != null && message.hasOwnProperty("clock"))
                    object.clock = options.enums === String ? $root.oracle_job.OracleJob.CronParseTask.ClockType[message.clock] === undefined ? message.clock : $root.oracle_job.OracleJob.CronParseTask.ClockType[message.clock] : message.clock;
                return object;
            };

            /**
             * Converts this CronParseTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.CronParseTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CronParseTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CronParseTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.CronParseTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CronParseTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.CronParseTask";
            };

            /**
             * ClockType enum.
             * @name oracle_job.OracleJob.CronParseTask.ClockType
             * @enum {number}
             * @property {number} ORACLE=0 Use the TaskRunners system clock for the current time.
             * @property {number} SYSCLOCK=1 Use the on-chain SYSCLOCK for the current time.
             */
            CronParseTask.ClockType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ORACLE"] = 0;
                values[valuesById[1] = "SYSCLOCK"] = 1;
                return values;
            })();

            return CronParseTask;
        })();

        OracleJob.BufferLayoutParseTask = (function() {

            /**
             * Properties of a BufferLayoutParseTask.
             * @memberof oracle_job.OracleJob
             * @interface IBufferLayoutParseTask
             * @property {number|null} [offset] The buffer offset to start deserializing from.
             * @property {oracle_job.OracleJob.BufferLayoutParseTask.Endian|null} [endian] The endianness of the stored value.
             * @property {oracle_job.OracleJob.BufferLayoutParseTask.BufferParseType|null} [type] The type of value to deserialize.
             */

            /**
             * Constructs a new BufferLayoutParseTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Return the deserialized value from a stringified buffer.
             * @implements IBufferLayoutParseTask
             * @constructor
             * @param {oracle_job.OracleJob.IBufferLayoutParseTask=} [properties] Properties to set
             */
            function BufferLayoutParseTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The buffer offset to start deserializing from.
             * @member {number} offset
             * @memberof oracle_job.OracleJob.BufferLayoutParseTask
             * @instance
             */
            BufferLayoutParseTask.prototype.offset = 0;

            /**
             * The endianness of the stored value.
             * @member {oracle_job.OracleJob.BufferLayoutParseTask.Endian} endian
             * @memberof oracle_job.OracleJob.BufferLayoutParseTask
             * @instance
             */
            BufferLayoutParseTask.prototype.endian = 0;

            /**
             * The type of value to deserialize.
             * @member {oracle_job.OracleJob.BufferLayoutParseTask.BufferParseType} type
             * @memberof oracle_job.OracleJob.BufferLayoutParseTask
             * @instance
             */
            BufferLayoutParseTask.prototype.type = 1;

            /**
             * Creates a new BufferLayoutParseTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.BufferLayoutParseTask
             * @static
             * @param {oracle_job.OracleJob.IBufferLayoutParseTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.BufferLayoutParseTask} BufferLayoutParseTask instance
             */
            BufferLayoutParseTask.create = function create(properties) {
      return BufferLayoutParseTask.fromObject(properties);
    };

            /**
             * Encodes the specified BufferLayoutParseTask message. Does not implicitly {@link oracle_job.OracleJob.BufferLayoutParseTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.BufferLayoutParseTask
             * @static
             * @param {oracle_job.OracleJob.IBufferLayoutParseTask} message BufferLayoutParseTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BufferLayoutParseTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.offset);
                if (message.endian != null && Object.hasOwnProperty.call(message, "endian"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.endian);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified BufferLayoutParseTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.BufferLayoutParseTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.BufferLayoutParseTask
             * @static
             * @param {oracle_job.OracleJob.IBufferLayoutParseTask} message BufferLayoutParseTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BufferLayoutParseTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BufferLayoutParseTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.BufferLayoutParseTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.BufferLayoutParseTask} BufferLayoutParseTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BufferLayoutParseTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.BufferLayoutParseTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.offset = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.endian = reader.int32();
                            break;
                        }
                    case 3: {
                            message.type = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BufferLayoutParseTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.BufferLayoutParseTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.BufferLayoutParseTask} BufferLayoutParseTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BufferLayoutParseTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BufferLayoutParseTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.BufferLayoutParseTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BufferLayoutParseTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (!$util.isInteger(message.offset))
                        return "offset: integer expected";
                if (message.endian != null && message.hasOwnProperty("endian"))
                    switch (message.endian) {
                    default:
                        return "endian: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                        break;
                    }
                return null;
            };

            /**
             * Creates a BufferLayoutParseTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.BufferLayoutParseTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.BufferLayoutParseTask} BufferLayoutParseTask
             */
            BufferLayoutParseTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.BufferLayoutParseTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.BufferLayoutParseTask();
                if (object.offset != null)
                    message.offset = object.offset >>> 0;
                switch (object.endian) {
                default:
                    if (typeof object.endian === "number") {
                        message.endian = object.endian;
                        break;
                    }
                    break;
                case "LITTLE_ENDIAN":
                case 0:
                    message.endian = 0;
                    break;
                case "BIG_ENDIAN":
                case 1:
                    message.endian = 1;
                    break;
                }
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "pubkey":
                case 1:
                    message.type = 1;
                    break;
                case "bool":
                case 2:
                    message.type = 2;
                    break;
                case "u8":
                case 3:
                    message.type = 3;
                    break;
                case "i8":
                case 4:
                    message.type = 4;
                    break;
                case "u16":
                case 5:
                    message.type = 5;
                    break;
                case "i16":
                case 6:
                    message.type = 6;
                    break;
                case "u32":
                case 7:
                    message.type = 7;
                    break;
                case "i32":
                case 8:
                    message.type = 8;
                    break;
                case "f32":
                case 9:
                    message.type = 9;
                    break;
                case "u64":
                case 10:
                    message.type = 10;
                    break;
                case "i64":
                case 11:
                    message.type = 11;
                    break;
                case "f64":
                case 12:
                    message.type = 12;
                    break;
                case "u128":
                case 13:
                    message.type = 13;
                    break;
                case "i128":
                case 14:
                    message.type = 14;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a BufferLayoutParseTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.BufferLayoutParseTask
             * @static
             * @param {oracle_job.OracleJob.BufferLayoutParseTask} message BufferLayoutParseTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BufferLayoutParseTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.offset = 0;
                    object.endian = options.enums === String ? "LITTLE_ENDIAN" : 0;
                    object.type = options.enums === String ? "pubkey" : 1;
                }
                if (message.offset != null && message.hasOwnProperty("offset"))
                    object.offset = message.offset;
                if (message.endian != null && message.hasOwnProperty("endian"))
                    object.endian = options.enums === String ? $root.oracle_job.OracleJob.BufferLayoutParseTask.Endian[message.endian] === undefined ? message.endian : $root.oracle_job.OracleJob.BufferLayoutParseTask.Endian[message.endian] : message.endian;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.oracle_job.OracleJob.BufferLayoutParseTask.BufferParseType[message.type] === undefined ? message.type : $root.oracle_job.OracleJob.BufferLayoutParseTask.BufferParseType[message.type] : message.type;
                return object;
            };

            /**
             * Converts this BufferLayoutParseTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.BufferLayoutParseTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BufferLayoutParseTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BufferLayoutParseTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.BufferLayoutParseTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BufferLayoutParseTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.BufferLayoutParseTask";
            };

            /**
             * Endian enum.
             * @name oracle_job.OracleJob.BufferLayoutParseTask.Endian
             * @enum {number}
             * @property {number} LITTLE_ENDIAN=0 Use little endian byte order.
             * @property {number} BIG_ENDIAN=1 Use big endian byte order.
             */
            BufferLayoutParseTask.Endian = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "LITTLE_ENDIAN"] = 0;
                values[valuesById[1] = "BIG_ENDIAN"] = 1;
                return values;
            })();

            /**
             * BufferParseType enum.
             * @name oracle_job.OracleJob.BufferLayoutParseTask.BufferParseType
             * @enum {number}
             * @property {number} pubkey=1 A public key.
             * @property {number} bool=2 A boolean.
             * @property {number} u8=3 An 8-bit unsigned value.
             * @property {number} i8=4 An 8-bit signed value.
             * @property {number} u16=5 A 16-bit unsigned value.
             * @property {number} i16=6 A 16-bit signed value.
             * @property {number} u32=7 A 32-bit unsigned value.
             * @property {number} i32=8 A 32-bit signed value.
             * @property {number} f32=9 A 32-bit IEEE floating point value.
             * @property {number} u64=10 A 64-bit unsigned value.
             * @property {number} i64=11 A 64-bit signed value.
             * @property {number} f64=12 A 64-bit IEEE floating point value.
             * @property {number} u128=13 A 128-bit unsigned value.
             * @property {number} i128=14 A 128-bit signed value.
             */
            BufferLayoutParseTask.BufferParseType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "pubkey"] = 1;
                values[valuesById[2] = "bool"] = 2;
                values[valuesById[3] = "u8"] = 3;
                values[valuesById[4] = "i8"] = 4;
                values[valuesById[5] = "u16"] = 5;
                values[valuesById[6] = "i16"] = 6;
                values[valuesById[7] = "u32"] = 7;
                values[valuesById[8] = "i32"] = 8;
                values[valuesById[9] = "f32"] = 9;
                values[valuesById[10] = "u64"] = 10;
                values[valuesById[11] = "i64"] = 11;
                values[valuesById[12] = "f64"] = 12;
                values[valuesById[13] = "u128"] = 13;
                values[valuesById[14] = "i128"] = 14;
                return values;
            })();

            return BufferLayoutParseTask;
        })();

        OracleJob.HistoryFunctionTask = (function() {

            /**
             * Properties of a HistoryFunctionTask.
             * @memberof oracle_job.OracleJob
             * @interface IHistoryFunctionTask
             * @property {oracle_job.OracleJob.HistoryFunctionTask.Method|null} [method] HistoryFunctionTask method
             * @property {string|null} [aggregatorAddress] HistoryFunctionTask aggregatorAddress
             * @property {number|null} [period] HistoryFunctionTask period
             */

            /**
             * Constructs a new HistoryFunctionTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Represents a HistoryFunctionTask.
             * @implements IHistoryFunctionTask
             * @constructor
             * @param {oracle_job.OracleJob.IHistoryFunctionTask=} [properties] Properties to set
             */
            function HistoryFunctionTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HistoryFunctionTask method.
             * @member {oracle_job.OracleJob.HistoryFunctionTask.Method} method
             * @memberof oracle_job.OracleJob.HistoryFunctionTask
             * @instance
             */
            HistoryFunctionTask.prototype.method = 0;

            /**
             * HistoryFunctionTask aggregatorAddress.
             * @member {string} aggregatorAddress
             * @memberof oracle_job.OracleJob.HistoryFunctionTask
             * @instance
             */
            HistoryFunctionTask.prototype.aggregatorAddress = "";

            /**
             * HistoryFunctionTask period.
             * @member {number} period
             * @memberof oracle_job.OracleJob.HistoryFunctionTask
             * @instance
             */
            HistoryFunctionTask.prototype.period = 0;

            /**
             * Creates a new HistoryFunctionTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.HistoryFunctionTask
             * @static
             * @param {oracle_job.OracleJob.IHistoryFunctionTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.HistoryFunctionTask} HistoryFunctionTask instance
             */
            HistoryFunctionTask.create = function create(properties) {
      return HistoryFunctionTask.fromObject(properties);
    };

            /**
             * Encodes the specified HistoryFunctionTask message. Does not implicitly {@link oracle_job.OracleJob.HistoryFunctionTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.HistoryFunctionTask
             * @static
             * @param {oracle_job.OracleJob.IHistoryFunctionTask} message HistoryFunctionTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HistoryFunctionTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.method);
                if (message.aggregatorAddress != null && Object.hasOwnProperty.call(message, "aggregatorAddress"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.aggregatorAddress);
                if (message.period != null && Object.hasOwnProperty.call(message, "period"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.period);
                return writer;
            };

            /**
             * Encodes the specified HistoryFunctionTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.HistoryFunctionTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.HistoryFunctionTask
             * @static
             * @param {oracle_job.OracleJob.IHistoryFunctionTask} message HistoryFunctionTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HistoryFunctionTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HistoryFunctionTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.HistoryFunctionTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.HistoryFunctionTask} HistoryFunctionTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HistoryFunctionTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.HistoryFunctionTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.method = reader.int32();
                            break;
                        }
                    case 2: {
                            message.aggregatorAddress = reader.string();
                            break;
                        }
                    case 3: {
                            message.period = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HistoryFunctionTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.HistoryFunctionTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.HistoryFunctionTask} HistoryFunctionTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HistoryFunctionTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HistoryFunctionTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.HistoryFunctionTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HistoryFunctionTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.method != null && message.hasOwnProperty("method"))
                    switch (message.method) {
                    default:
                        return "method: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.aggregatorAddress != null && message.hasOwnProperty("aggregatorAddress"))
                    if (!$util.isString(message.aggregatorAddress))
                        return "aggregatorAddress: string expected";
                if (message.period != null && message.hasOwnProperty("period"))
                    if (!$util.isInteger(message.period))
                        return "period: integer expected";
                return null;
            };

            /**
             * Creates a HistoryFunctionTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.HistoryFunctionTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.HistoryFunctionTask} HistoryFunctionTask
             */
            HistoryFunctionTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.HistoryFunctionTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.HistoryFunctionTask();
                switch (object.method) {
                default:
                    if (typeof object.method === "number") {
                        message.method = object.method;
                        break;
                    }
                    break;
                case "METHOD_MIN":
                case 0:
                    message.method = 0;
                    break;
                case "METHOD_MAX":
                case 1:
                    message.method = 1;
                    break;
                }
                if (object.aggregatorAddress != null)
                    message.aggregatorAddress = String(object.aggregatorAddress);
                if (object.period != null)
                    message.period = object.period >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a HistoryFunctionTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.HistoryFunctionTask
             * @static
             * @param {oracle_job.OracleJob.HistoryFunctionTask} message HistoryFunctionTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HistoryFunctionTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.method = options.enums === String ? "METHOD_MIN" : 0;
                    object.aggregatorAddress = "";
                    object.period = 0;
                }
                if (message.method != null && message.hasOwnProperty("method"))
                    object.method = options.enums === String ? $root.oracle_job.OracleJob.HistoryFunctionTask.Method[message.method] === undefined ? message.method : $root.oracle_job.OracleJob.HistoryFunctionTask.Method[message.method] : message.method;
                if (message.aggregatorAddress != null && message.hasOwnProperty("aggregatorAddress"))
                    object.aggregatorAddress = message.aggregatorAddress;
                if (message.period != null && message.hasOwnProperty("period"))
                    object.period = message.period;
                return object;
            };

            /**
             * Converts this HistoryFunctionTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.HistoryFunctionTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HistoryFunctionTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for HistoryFunctionTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.HistoryFunctionTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            HistoryFunctionTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.HistoryFunctionTask";
            };

            /**
             * Method enum.
             * @name oracle_job.OracleJob.HistoryFunctionTask.Method
             * @enum {number}
             * @property {number} METHOD_MIN=0 METHOD_MIN value
             * @property {number} METHOD_MAX=1 METHOD_MAX value
             */
            HistoryFunctionTask.Method = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "METHOD_MIN"] = 0;
                values[valuesById[1] = "METHOD_MAX"] = 1;
                return values;
            })();

            return HistoryFunctionTask;
        })();

        OracleJob.VwapTask = (function() {

            /**
             * Properties of a VwapTask.
             * @memberof oracle_job.OracleJob
             * @interface IVwapTask
             * @property {string|null} [priceAggregatorAddress] VwapTask priceAggregatorAddress
             * @property {string|null} [volumeAggregatorAddress] VwapTask volumeAggregatorAddress
             * @property {number|null} [period] VwapTask period
             */

            /**
             * Constructs a new VwapTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Represents a VwapTask.
             * @implements IVwapTask
             * @constructor
             * @param {oracle_job.OracleJob.IVwapTask=} [properties] Properties to set
             */
            function VwapTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VwapTask priceAggregatorAddress.
             * @member {string} priceAggregatorAddress
             * @memberof oracle_job.OracleJob.VwapTask
             * @instance
             */
            VwapTask.prototype.priceAggregatorAddress = "";

            /**
             * VwapTask volumeAggregatorAddress.
             * @member {string} volumeAggregatorAddress
             * @memberof oracle_job.OracleJob.VwapTask
             * @instance
             */
            VwapTask.prototype.volumeAggregatorAddress = "";

            /**
             * VwapTask period.
             * @member {number} period
             * @memberof oracle_job.OracleJob.VwapTask
             * @instance
             */
            VwapTask.prototype.period = 0;

            /**
             * Creates a new VwapTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.VwapTask
             * @static
             * @param {oracle_job.OracleJob.IVwapTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.VwapTask} VwapTask instance
             */
            VwapTask.create = function create(properties) {
      return VwapTask.fromObject(properties);
    };

            /**
             * Encodes the specified VwapTask message. Does not implicitly {@link oracle_job.OracleJob.VwapTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.VwapTask
             * @static
             * @param {oracle_job.OracleJob.IVwapTask} message VwapTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VwapTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.priceAggregatorAddress != null && Object.hasOwnProperty.call(message, "priceAggregatorAddress"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.priceAggregatorAddress);
                if (message.volumeAggregatorAddress != null && Object.hasOwnProperty.call(message, "volumeAggregatorAddress"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.volumeAggregatorAddress);
                if (message.period != null && Object.hasOwnProperty.call(message, "period"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.period);
                return writer;
            };

            /**
             * Encodes the specified VwapTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.VwapTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.VwapTask
             * @static
             * @param {oracle_job.OracleJob.IVwapTask} message VwapTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VwapTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VwapTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.VwapTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.VwapTask} VwapTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VwapTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.VwapTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.priceAggregatorAddress = reader.string();
                            break;
                        }
                    case 2: {
                            message.volumeAggregatorAddress = reader.string();
                            break;
                        }
                    case 3: {
                            message.period = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VwapTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.VwapTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.VwapTask} VwapTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VwapTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VwapTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.VwapTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VwapTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.priceAggregatorAddress != null && message.hasOwnProperty("priceAggregatorAddress"))
                    if (!$util.isString(message.priceAggregatorAddress))
                        return "priceAggregatorAddress: string expected";
                if (message.volumeAggregatorAddress != null && message.hasOwnProperty("volumeAggregatorAddress"))
                    if (!$util.isString(message.volumeAggregatorAddress))
                        return "volumeAggregatorAddress: string expected";
                if (message.period != null && message.hasOwnProperty("period"))
                    if (!$util.isInteger(message.period))
                        return "period: integer expected";
                return null;
            };

            /**
             * Creates a VwapTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.VwapTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.VwapTask} VwapTask
             */
            VwapTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.VwapTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.VwapTask();
                if (object.priceAggregatorAddress != null)
                    message.priceAggregatorAddress = String(object.priceAggregatorAddress);
                if (object.volumeAggregatorAddress != null)
                    message.volumeAggregatorAddress = String(object.volumeAggregatorAddress);
                if (object.period != null)
                    message.period = object.period >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a VwapTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.VwapTask
             * @static
             * @param {oracle_job.OracleJob.VwapTask} message VwapTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VwapTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.priceAggregatorAddress = "";
                    object.volumeAggregatorAddress = "";
                    object.period = 0;
                }
                if (message.priceAggregatorAddress != null && message.hasOwnProperty("priceAggregatorAddress"))
                    object.priceAggregatorAddress = message.priceAggregatorAddress;
                if (message.volumeAggregatorAddress != null && message.hasOwnProperty("volumeAggregatorAddress"))
                    object.volumeAggregatorAddress = message.volumeAggregatorAddress;
                if (message.period != null && message.hasOwnProperty("period"))
                    object.period = message.period;
                return object;
            };

            /**
             * Converts this VwapTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.VwapTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VwapTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VwapTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.VwapTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VwapTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.VwapTask";
            };

            return VwapTask;
        })();

        OracleJob.EwmaTask = (function() {

            /**
             * Properties of an EwmaTask.
             * @memberof oracle_job.OracleJob
             * @interface IEwmaTask
             * @property {string|null} [aggregatorAddress] EwmaTask aggregatorAddress
             * @property {number|null} [period] EwmaTask period
             * @property {number|null} [lambda] EwmaTask lambda
             */

            /**
             * Constructs a new EwmaTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Represents an EwmaTask.
             * @implements IEwmaTask
             * @constructor
             * @param {oracle_job.OracleJob.IEwmaTask=} [properties] Properties to set
             */
            function EwmaTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EwmaTask aggregatorAddress.
             * @member {string} aggregatorAddress
             * @memberof oracle_job.OracleJob.EwmaTask
             * @instance
             */
            EwmaTask.prototype.aggregatorAddress = "";

            /**
             * EwmaTask period.
             * @member {number} period
             * @memberof oracle_job.OracleJob.EwmaTask
             * @instance
             */
            EwmaTask.prototype.period = 0;

            /**
             * EwmaTask lambda.
             * @member {number} lambda
             * @memberof oracle_job.OracleJob.EwmaTask
             * @instance
             */
            EwmaTask.prototype.lambda = 0;

            /**
             * Creates a new EwmaTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.EwmaTask
             * @static
             * @param {oracle_job.OracleJob.IEwmaTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.EwmaTask} EwmaTask instance
             */
            EwmaTask.create = function create(properties) {
      return EwmaTask.fromObject(properties);
    };

            /**
             * Encodes the specified EwmaTask message. Does not implicitly {@link oracle_job.OracleJob.EwmaTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.EwmaTask
             * @static
             * @param {oracle_job.OracleJob.IEwmaTask} message EwmaTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EwmaTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.aggregatorAddress != null && Object.hasOwnProperty.call(message, "aggregatorAddress"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.aggregatorAddress);
                if (message.period != null && Object.hasOwnProperty.call(message, "period"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.period);
                if (message.lambda != null && Object.hasOwnProperty.call(message, "lambda"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.lambda);
                return writer;
            };

            /**
             * Encodes the specified EwmaTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.EwmaTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.EwmaTask
             * @static
             * @param {oracle_job.OracleJob.IEwmaTask} message EwmaTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EwmaTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EwmaTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.EwmaTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.EwmaTask} EwmaTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EwmaTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.EwmaTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.aggregatorAddress = reader.string();
                            break;
                        }
                    case 2: {
                            message.period = reader.int32();
                            break;
                        }
                    case 3: {
                            message.lambda = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EwmaTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.EwmaTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.EwmaTask} EwmaTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EwmaTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EwmaTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.EwmaTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EwmaTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.aggregatorAddress != null && message.hasOwnProperty("aggregatorAddress"))
                    if (!$util.isString(message.aggregatorAddress))
                        return "aggregatorAddress: string expected";
                if (message.period != null && message.hasOwnProperty("period"))
                    if (!$util.isInteger(message.period))
                        return "period: integer expected";
                if (message.lambda != null && message.hasOwnProperty("lambda"))
                    if (typeof message.lambda !== "number")
                        return "lambda: number expected";
                return null;
            };

            /**
             * Creates an EwmaTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.EwmaTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.EwmaTask} EwmaTask
             */
            EwmaTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.EwmaTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.EwmaTask();
                if (object.aggregatorAddress != null)
                    message.aggregatorAddress = String(object.aggregatorAddress);
                if (object.period != null)
                    message.period = object.period | 0;
                if (object.lambda != null)
                    message.lambda = Number(object.lambda);
                return message;
            };

            /**
             * Creates a plain object from an EwmaTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.EwmaTask
             * @static
             * @param {oracle_job.OracleJob.EwmaTask} message EwmaTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EwmaTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.aggregatorAddress = "";
                    object.period = 0;
                    object.lambda = 0;
                }
                if (message.aggregatorAddress != null && message.hasOwnProperty("aggregatorAddress"))
                    object.aggregatorAddress = message.aggregatorAddress;
                if (message.period != null && message.hasOwnProperty("period"))
                    object.period = message.period;
                if (message.lambda != null && message.hasOwnProperty("lambda"))
                    object.lambda = options.json && !isFinite(message.lambda) ? String(message.lambda) : message.lambda;
                return object;
            };

            /**
             * Converts this EwmaTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.EwmaTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EwmaTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EwmaTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.EwmaTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EwmaTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.EwmaTask";
            };

            return EwmaTask;
        })();

        OracleJob.ComparisonTask = (function() {

            /**
             * Properties of a ComparisonTask.
             * @memberof oracle_job.OracleJob
             * @interface IComparisonTask
             * @property {oracle_job.OracleJob.ComparisonTask.Operation|null} [op] The type of operator to use on the left (lhs) and right (rhs) operand.
             * @property {oracle_job.IOracleJob|null} [lhs] OracleJob where the executed result is equal to the left hand side operand.
             * @property {string|null} [lhsValue] String or `${CACHE_KEY}` representing the left hand side operand.
             * @property {oracle_job.IOracleJob|null} [rhs] OracleJob where the executed result is equal to the right hand side operand.
             * @property {string|null} [rhsValue] String or `${CACHE_KEY}` representing the right hand side operand.
             * @property {oracle_job.IOracleJob|null} [onTrue] The OracleJob to execute if the condition evaluates to true.
             * @property {string|null} [onTrueValue] The result to use if the condition evaluates to true. Can be set to a `${CACHE_KEY}`.
             * @property {oracle_job.IOracleJob|null} [onFalse] The OracleJob to execute if the condition evaluates to false.
             * @property {string|null} [onFalseValue] The result to use if the condition evaluates to false. Can be set to a `${CACHE_KEY}`.
             * @property {oracle_job.IOracleJob|null} [onFailure] The OracleJob to execute if the condition fails to evaluate.
             * @property {string|null} [onFailureValue] The result to use if the condition fails to evaluate. Can be set to a `${CACHE_KEY}`.
             */

            /**
             * Constructs a new ComparisonTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Represents a ComparisonTask.
             * @implements IComparisonTask
             * @constructor
             * @param {oracle_job.OracleJob.IComparisonTask=} [properties] Properties to set
             */
            function ComparisonTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The type of operator to use on the left (lhs) and right (rhs) operand.
             * @member {oracle_job.OracleJob.ComparisonTask.Operation} op
             * @memberof oracle_job.OracleJob.ComparisonTask
             * @instance
             */
            ComparisonTask.prototype.op = 0;

            /**
             * OracleJob where the executed result is equal to the left hand side operand.
             * @member {oracle_job.IOracleJob|null|undefined} lhs
             * @memberof oracle_job.OracleJob.ComparisonTask
             * @instance
             */
            ComparisonTask.prototype.lhs = null;

            /**
             * String or `${CACHE_KEY}` representing the left hand side operand.
             * @member {string|null|undefined} lhsValue
             * @memberof oracle_job.OracleJob.ComparisonTask
             * @instance
             */
            ComparisonTask.prototype.lhsValue = null;

            /**
             * OracleJob where the executed result is equal to the right hand side operand.
             * @member {oracle_job.IOracleJob|null|undefined} rhs
             * @memberof oracle_job.OracleJob.ComparisonTask
             * @instance
             */
            ComparisonTask.prototype.rhs = null;

            /**
             * String or `${CACHE_KEY}` representing the right hand side operand.
             * @member {string|null|undefined} rhsValue
             * @memberof oracle_job.OracleJob.ComparisonTask
             * @instance
             */
            ComparisonTask.prototype.rhsValue = null;

            /**
             * The OracleJob to execute if the condition evaluates to true.
             * @member {oracle_job.IOracleJob|null|undefined} onTrue
             * @memberof oracle_job.OracleJob.ComparisonTask
             * @instance
             */
            ComparisonTask.prototype.onTrue = null;

            /**
             * The result to use if the condition evaluates to true. Can be set to a `${CACHE_KEY}`.
             * @member {string} onTrueValue
             * @memberof oracle_job.OracleJob.ComparisonTask
             * @instance
             */
            ComparisonTask.prototype.onTrueValue = "";

            /**
             * The OracleJob to execute if the condition evaluates to false.
             * @member {oracle_job.IOracleJob|null|undefined} onFalse
             * @memberof oracle_job.OracleJob.ComparisonTask
             * @instance
             */
            ComparisonTask.prototype.onFalse = null;

            /**
             * The result to use if the condition evaluates to false. Can be set to a `${CACHE_KEY}`.
             * @member {string} onFalseValue
             * @memberof oracle_job.OracleJob.ComparisonTask
             * @instance
             */
            ComparisonTask.prototype.onFalseValue = "";

            /**
             * The OracleJob to execute if the condition fails to evaluate.
             * @member {oracle_job.IOracleJob|null|undefined} onFailure
             * @memberof oracle_job.OracleJob.ComparisonTask
             * @instance
             */
            ComparisonTask.prototype.onFailure = null;

            /**
             * The result to use if the condition fails to evaluate. Can be set to a `${CACHE_KEY}`.
             * @member {string} onFailureValue
             * @memberof oracle_job.OracleJob.ComparisonTask
             * @instance
             */
            ComparisonTask.prototype.onFailureValue = "";

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * ComparisonTask LHS.
             * @member {"lhs"|"lhsValue"|undefined} LHS
             * @memberof oracle_job.OracleJob.ComparisonTask
             * @instance
             */
            Object.defineProperty(ComparisonTask.prototype, "LHS", {
                get: $util.oneOfGetter($oneOfFields = ["lhs", "lhsValue"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ComparisonTask RHS.
             * @member {"rhs"|"rhsValue"|undefined} RHS
             * @memberof oracle_job.OracleJob.ComparisonTask
             * @instance
             */
            Object.defineProperty(ComparisonTask.prototype, "RHS", {
                get: $util.oneOfGetter($oneOfFields = ["rhs", "rhsValue"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ComparisonTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.ComparisonTask
             * @static
             * @param {oracle_job.OracleJob.IComparisonTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.ComparisonTask} ComparisonTask instance
             */
            ComparisonTask.create = function create(properties) {
      return ComparisonTask.fromObject(properties);
    };

            /**
             * Encodes the specified ComparisonTask message. Does not implicitly {@link oracle_job.OracleJob.ComparisonTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.ComparisonTask
             * @static
             * @param {oracle_job.OracleJob.IComparisonTask} message ComparisonTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ComparisonTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.op != null && Object.hasOwnProperty.call(message, "op"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.op);
                if (message.lhs != null && Object.hasOwnProperty.call(message, "lhs"))
                    $root.oracle_job.OracleJob.encode(message.lhs, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.lhsValue != null && Object.hasOwnProperty.call(message, "lhsValue"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.lhsValue);
                if (message.rhs != null && Object.hasOwnProperty.call(message, "rhs"))
                    $root.oracle_job.OracleJob.encode(message.rhs, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.rhsValue != null && Object.hasOwnProperty.call(message, "rhsValue"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.rhsValue);
                if (message.onTrue != null && Object.hasOwnProperty.call(message, "onTrue"))
                    $root.oracle_job.OracleJob.encode(message.onTrue, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.onTrueValue != null && Object.hasOwnProperty.call(message, "onTrueValue"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.onTrueValue);
                if (message.onFalse != null && Object.hasOwnProperty.call(message, "onFalse"))
                    $root.oracle_job.OracleJob.encode(message.onFalse, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.onFalseValue != null && Object.hasOwnProperty.call(message, "onFalseValue"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.onFalseValue);
                if (message.onFailure != null && Object.hasOwnProperty.call(message, "onFailure"))
                    $root.oracle_job.OracleJob.encode(message.onFailure, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.onFailureValue != null && Object.hasOwnProperty.call(message, "onFailureValue"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.onFailureValue);
                return writer;
            };

            /**
             * Encodes the specified ComparisonTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.ComparisonTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.ComparisonTask
             * @static
             * @param {oracle_job.OracleJob.IComparisonTask} message ComparisonTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ComparisonTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ComparisonTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.ComparisonTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.ComparisonTask} ComparisonTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ComparisonTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.ComparisonTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.op = reader.int32();
                            break;
                        }
                    case 2: {
                            message.lhs = $root.oracle_job.OracleJob.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.lhsValue = reader.string();
                            break;
                        }
                    case 4: {
                            message.rhs = $root.oracle_job.OracleJob.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.rhsValue = reader.string();
                            break;
                        }
                    case 6: {
                            message.onTrue = $root.oracle_job.OracleJob.decode(reader, reader.uint32());
                            break;
                        }
                    case 7: {
                            message.onTrueValue = reader.string();
                            break;
                        }
                    case 8: {
                            message.onFalse = $root.oracle_job.OracleJob.decode(reader, reader.uint32());
                            break;
                        }
                    case 9: {
                            message.onFalseValue = reader.string();
                            break;
                        }
                    case 10: {
                            message.onFailure = $root.oracle_job.OracleJob.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message.onFailureValue = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ComparisonTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.ComparisonTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.ComparisonTask} ComparisonTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ComparisonTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ComparisonTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.ComparisonTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ComparisonTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.op != null && message.hasOwnProperty("op"))
                    switch (message.op) {
                    default:
                        return "op: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.lhs != null && message.hasOwnProperty("lhs")) {
                    properties.LHS = 1;
                    {
                        let error = $root.oracle_job.OracleJob.verify(message.lhs);
                        if (error)
                            return "lhs." + error;
                    }
                }
                if (message.lhsValue != null && message.hasOwnProperty("lhsValue")) {
                    if (properties.LHS === 1)
                        return "LHS: multiple values";
                    properties.LHS = 1;
                    if (!$util.isString(message.lhsValue))
                        return "lhsValue: string expected";
                }
                if (message.rhs != null && message.hasOwnProperty("rhs")) {
                    properties.RHS = 1;
                    {
                        let error = $root.oracle_job.OracleJob.verify(message.rhs);
                        if (error)
                            return "rhs." + error;
                    }
                }
                if (message.rhsValue != null && message.hasOwnProperty("rhsValue")) {
                    if (properties.RHS === 1)
                        return "RHS: multiple values";
                    properties.RHS = 1;
                    if (!$util.isString(message.rhsValue))
                        return "rhsValue: string expected";
                }
                if (message.onTrue != null && message.hasOwnProperty("onTrue")) {
                    let error = $root.oracle_job.OracleJob.verify(message.onTrue);
                    if (error)
                        return "onTrue." + error;
                }
                if (message.onTrueValue != null && message.hasOwnProperty("onTrueValue"))
                    if (!$util.isString(message.onTrueValue))
                        return "onTrueValue: string expected";
                if (message.onFalse != null && message.hasOwnProperty("onFalse")) {
                    let error = $root.oracle_job.OracleJob.verify(message.onFalse);
                    if (error)
                        return "onFalse." + error;
                }
                if (message.onFalseValue != null && message.hasOwnProperty("onFalseValue"))
                    if (!$util.isString(message.onFalseValue))
                        return "onFalseValue: string expected";
                if (message.onFailure != null && message.hasOwnProperty("onFailure")) {
                    let error = $root.oracle_job.OracleJob.verify(message.onFailure);
                    if (error)
                        return "onFailure." + error;
                }
                if (message.onFailureValue != null && message.hasOwnProperty("onFailureValue"))
                    if (!$util.isString(message.onFailureValue))
                        return "onFailureValue: string expected";
                return null;
            };

            /**
             * Creates a ComparisonTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.ComparisonTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.ComparisonTask} ComparisonTask
             */
            ComparisonTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.ComparisonTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.ComparisonTask();
                switch (object.op) {
                default:
                    if (typeof object.op === "number") {
                        message.op = object.op;
                        break;
                    }
                    break;
                case "OPERATION_EQ":
                case 0:
                    message.op = 0;
                    break;
                case "OPERATION_GT":
                case 1:
                    message.op = 1;
                    break;
                case "OPERATION_LT":
                case 2:
                    message.op = 2;
                    break;
                }
                if (object.lhs != null) {
                    if (typeof object.lhs !== "object")
                        throw TypeError(".oracle_job.OracleJob.ComparisonTask.lhs: object expected");
                    message.lhs = $root.oracle_job.OracleJob.fromObject(object.lhs);
                }
                if (object.lhsValue != null)
                    message.lhsValue = String(object.lhsValue);
                if (object.rhs != null) {
                    if (typeof object.rhs !== "object")
                        throw TypeError(".oracle_job.OracleJob.ComparisonTask.rhs: object expected");
                    message.rhs = $root.oracle_job.OracleJob.fromObject(object.rhs);
                }
                if (object.rhsValue != null)
                    message.rhsValue = String(object.rhsValue);
                if (object.onTrue != null) {
                    if (typeof object.onTrue !== "object")
                        throw TypeError(".oracle_job.OracleJob.ComparisonTask.onTrue: object expected");
                    message.onTrue = $root.oracle_job.OracleJob.fromObject(object.onTrue);
                }
                if (object.onTrueValue != null)
                    message.onTrueValue = String(object.onTrueValue);
                if (object.onFalse != null) {
                    if (typeof object.onFalse !== "object")
                        throw TypeError(".oracle_job.OracleJob.ComparisonTask.onFalse: object expected");
                    message.onFalse = $root.oracle_job.OracleJob.fromObject(object.onFalse);
                }
                if (object.onFalseValue != null)
                    message.onFalseValue = String(object.onFalseValue);
                if (object.onFailure != null) {
                    if (typeof object.onFailure !== "object")
                        throw TypeError(".oracle_job.OracleJob.ComparisonTask.onFailure: object expected");
                    message.onFailure = $root.oracle_job.OracleJob.fromObject(object.onFailure);
                }
                if (object.onFailureValue != null)
                    message.onFailureValue = String(object.onFailureValue);
                return message;
            };

            /**
             * Creates a plain object from a ComparisonTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.ComparisonTask
             * @static
             * @param {oracle_job.OracleJob.ComparisonTask} message ComparisonTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ComparisonTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.op = options.enums === String ? "OPERATION_EQ" : 0;
                    object.onTrue = null;
                    object.onTrueValue = "";
                    object.onFalse = null;
                    object.onFalseValue = "";
                    object.onFailure = null;
                    object.onFailureValue = "";
                }
                if (message.op != null && message.hasOwnProperty("op"))
                    object.op = options.enums === String ? $root.oracle_job.OracleJob.ComparisonTask.Operation[message.op] === undefined ? message.op : $root.oracle_job.OracleJob.ComparisonTask.Operation[message.op] : message.op;
                if (message.lhs != null && message.hasOwnProperty("lhs")) {
                    object.lhs = $root.oracle_job.OracleJob.toObject(message.lhs, options);
                    if (options.oneofs)
                        object.LHS = "lhs";
                }
                if (message.lhsValue != null && message.hasOwnProperty("lhsValue")) {
                    object.lhsValue = message.lhsValue;
                    if (options.oneofs)
                        object.LHS = "lhsValue";
                }
                if (message.rhs != null && message.hasOwnProperty("rhs")) {
                    object.rhs = $root.oracle_job.OracleJob.toObject(message.rhs, options);
                    if (options.oneofs)
                        object.RHS = "rhs";
                }
                if (message.rhsValue != null && message.hasOwnProperty("rhsValue")) {
                    object.rhsValue = message.rhsValue;
                    if (options.oneofs)
                        object.RHS = "rhsValue";
                }
                if (message.onTrue != null && message.hasOwnProperty("onTrue"))
                    object.onTrue = $root.oracle_job.OracleJob.toObject(message.onTrue, options);
                if (message.onTrueValue != null && message.hasOwnProperty("onTrueValue"))
                    object.onTrueValue = message.onTrueValue;
                if (message.onFalse != null && message.hasOwnProperty("onFalse"))
                    object.onFalse = $root.oracle_job.OracleJob.toObject(message.onFalse, options);
                if (message.onFalseValue != null && message.hasOwnProperty("onFalseValue"))
                    object.onFalseValue = message.onFalseValue;
                if (message.onFailure != null && message.hasOwnProperty("onFailure"))
                    object.onFailure = $root.oracle_job.OracleJob.toObject(message.onFailure, options);
                if (message.onFailureValue != null && message.hasOwnProperty("onFailureValue"))
                    object.onFailureValue = message.onFailureValue;
                return object;
            };

            /**
             * Converts this ComparisonTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.ComparisonTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ComparisonTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ComparisonTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.ComparisonTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ComparisonTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.ComparisonTask";
            };

            /**
             * Operation enum.
             * @name oracle_job.OracleJob.ComparisonTask.Operation
             * @enum {number}
             * @property {number} OPERATION_EQ=0 Use the equals to '==' operator.
             * @property {number} OPERATION_GT=1 Use the greater than '>' operator.
             * @property {number} OPERATION_LT=2 Use the less than '<' operator.
             */
            ComparisonTask.Operation = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "OPERATION_EQ"] = 0;
                values[valuesById[1] = "OPERATION_GT"] = 1;
                values[valuesById[2] = "OPERATION_LT"] = 2;
                return values;
            })();

            return ComparisonTask;
        })();

        OracleJob.RoundTask = (function() {

            /**
             * Properties of a RoundTask.
             * @memberof oracle_job.OracleJob
             * @interface IRoundTask
             * @property {oracle_job.OracleJob.RoundTask.Method|null} [method] The rounding method to use.
             * @property {number|null} [decimals] The number of decimals to round to.
             */

            /**
             * Constructs a new RoundTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Round the current running result to a set number of decimal places.
             * 
             * _**Input**_: The current running numerical result.
             * 
             * _**Returns**_: The running result rounded to a set number of decimal places.
             * 
             * _**Example**_: Round down the running resul to 8 decimal places
             * 
             * ```json
             * { "roundTask": { "method": "METHOD_ROUND_DOWN", "decimals": 8 } }
             * ```
             * @implements IRoundTask
             * @constructor
             * @param {oracle_job.OracleJob.IRoundTask=} [properties] Properties to set
             */
            function RoundTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The rounding method to use.
             * @member {oracle_job.OracleJob.RoundTask.Method} method
             * @memberof oracle_job.OracleJob.RoundTask
             * @instance
             */
            RoundTask.prototype.method = 0;

            /**
             * The number of decimals to round to.
             * @member {number} decimals
             * @memberof oracle_job.OracleJob.RoundTask
             * @instance
             */
            RoundTask.prototype.decimals = 0;

            /**
             * Creates a new RoundTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.RoundTask
             * @static
             * @param {oracle_job.OracleJob.IRoundTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.RoundTask} RoundTask instance
             */
            RoundTask.create = function create(properties) {
      return RoundTask.fromObject(properties);
    };

            /**
             * Encodes the specified RoundTask message. Does not implicitly {@link oracle_job.OracleJob.RoundTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.RoundTask
             * @static
             * @param {oracle_job.OracleJob.IRoundTask} message RoundTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RoundTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.method);
                if (message.decimals != null && Object.hasOwnProperty.call(message, "decimals"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.decimals);
                return writer;
            };

            /**
             * Encodes the specified RoundTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.RoundTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.RoundTask
             * @static
             * @param {oracle_job.OracleJob.IRoundTask} message RoundTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RoundTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RoundTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.RoundTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.RoundTask} RoundTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RoundTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.RoundTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.method = reader.int32();
                            break;
                        }
                    case 2: {
                            message.decimals = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RoundTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.RoundTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.RoundTask} RoundTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RoundTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RoundTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.RoundTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RoundTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.method != null && message.hasOwnProperty("method"))
                    switch (message.method) {
                    default:
                        return "method: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.decimals != null && message.hasOwnProperty("decimals"))
                    if (!$util.isInteger(message.decimals))
                        return "decimals: integer expected";
                return null;
            };

            /**
             * Creates a RoundTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.RoundTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.RoundTask} RoundTask
             */
            RoundTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.RoundTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.RoundTask();
                switch (object.method) {
                default:
                    if (typeof object.method === "number") {
                        message.method = object.method;
                        break;
                    }
                    break;
                case "METHOD_ROUND_UP":
                case 0:
                    message.method = 0;
                    break;
                case "METHOD_ROUND_DOWN":
                case 1:
                    message.method = 1;
                    break;
                }
                if (object.decimals != null)
                    message.decimals = object.decimals | 0;
                return message;
            };

            /**
             * Creates a plain object from a RoundTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.RoundTask
             * @static
             * @param {oracle_job.OracleJob.RoundTask} message RoundTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RoundTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.method = options.enums === String ? "METHOD_ROUND_UP" : 0;
                    object.decimals = 0;
                }
                if (message.method != null && message.hasOwnProperty("method"))
                    object.method = options.enums === String ? $root.oracle_job.OracleJob.RoundTask.Method[message.method] === undefined ? message.method : $root.oracle_job.OracleJob.RoundTask.Method[message.method] : message.method;
                if (message.decimals != null && message.hasOwnProperty("decimals"))
                    object.decimals = message.decimals;
                return object;
            };

            /**
             * Converts this RoundTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.RoundTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RoundTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RoundTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.RoundTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RoundTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.RoundTask";
            };

            /**
             * Method enum.
             * @name oracle_job.OracleJob.RoundTask.Method
             * @enum {number}
             * @property {number} METHOD_ROUND_UP=0 Round the result down.
             * @property {number} METHOD_ROUND_DOWN=1 Round the result up.
             */
            RoundTask.Method = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "METHOD_ROUND_UP"] = 0;
                values[valuesById[1] = "METHOD_ROUND_DOWN"] = 1;
                return values;
            })();

            return RoundTask;
        })();

        OracleJob.BoundTask = (function() {

            /**
             * Properties of a BoundTask.
             * @memberof oracle_job.OracleJob
             * @interface IBoundTask
             * @property {oracle_job.IOracleJob|null} [lowerBound] The OracleJob to execute for the lower bound value.
             * @property {string|null} [lowerBoundValue] The value to use for the lower bound. Can be set to a `${CACHE_KEY}`.
             * @property {oracle_job.IOracleJob|null} [upperBound] The OracleJob to execute for the upper bound value.
             * @property {string|null} [upperBoundValue] The value to use for the upper bound. Can be set to a `${CACHE_KEY}`.
             * @property {oracle_job.IOracleJob|null} [onExceedsUpperBound] The OracleJob to execute if the upper bound is exceeded.
             * @property {string|null} [onExceedsUpperBoundValue] The value to use if the upper bound is exceeded. Can be set to a `${CACHE_KEY}`.
             * @property {oracle_job.IOracleJob|null} [onExceedsLowerBound] The OracleJob to execute if the lower bound is exceeded.
             * @property {string|null} [onExceedsLowerBoundValue] The value to use if the lower bound is exceeded. Can be set to a `${CACHE_KEY}`.
             */

            /**
             * Constructs a new BoundTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Bound the running result to an upper/lower bound. This is typically the last task in an OracleJob.
             * 
             * _**Input**_: The current running numerical result.
             * 
             * _**Returns**_: The running result bounded to an upper or lower bound if it exceeds a given threshold.
             * 
             * _**Example**_: Bound the running result to a value between 0.90 and 1.10
             * 
             * ```json
             * { "boundTask": { "lowerBoundValue": "0.90","onExceedsLowerBoundValue": "0.90","upperBoundValue": "1.10","onExceedsUpperBoundValue": "1.10" } }
             * ```
             * @implements IBoundTask
             * @constructor
             * @param {oracle_job.OracleJob.IBoundTask=} [properties] Properties to set
             */
            function BoundTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The OracleJob to execute for the lower bound value.
             * @member {oracle_job.IOracleJob|null|undefined} lowerBound
             * @memberof oracle_job.OracleJob.BoundTask
             * @instance
             */
            BoundTask.prototype.lowerBound = null;

            /**
             * The value to use for the lower bound. Can be set to a `${CACHE_KEY}`.
             * @member {string} lowerBoundValue
             * @memberof oracle_job.OracleJob.BoundTask
             * @instance
             */
            BoundTask.prototype.lowerBoundValue = "";

            /**
             * The OracleJob to execute for the upper bound value.
             * @member {oracle_job.IOracleJob|null|undefined} upperBound
             * @memberof oracle_job.OracleJob.BoundTask
             * @instance
             */
            BoundTask.prototype.upperBound = null;

            /**
             * The value to use for the upper bound. Can be set to a `${CACHE_KEY}`.
             * @member {string} upperBoundValue
             * @memberof oracle_job.OracleJob.BoundTask
             * @instance
             */
            BoundTask.prototype.upperBoundValue = "";

            /**
             * The OracleJob to execute if the upper bound is exceeded.
             * @member {oracle_job.IOracleJob|null|undefined} onExceedsUpperBound
             * @memberof oracle_job.OracleJob.BoundTask
             * @instance
             */
            BoundTask.prototype.onExceedsUpperBound = null;

            /**
             * The value to use if the upper bound is exceeded. Can be set to a `${CACHE_KEY}`.
             * @member {string} onExceedsUpperBoundValue
             * @memberof oracle_job.OracleJob.BoundTask
             * @instance
             */
            BoundTask.prototype.onExceedsUpperBoundValue = "";

            /**
             * The OracleJob to execute if the lower bound is exceeded.
             * @member {oracle_job.IOracleJob|null|undefined} onExceedsLowerBound
             * @memberof oracle_job.OracleJob.BoundTask
             * @instance
             */
            BoundTask.prototype.onExceedsLowerBound = null;

            /**
             * The value to use if the lower bound is exceeded. Can be set to a `${CACHE_KEY}`.
             * @member {string} onExceedsLowerBoundValue
             * @memberof oracle_job.OracleJob.BoundTask
             * @instance
             */
            BoundTask.prototype.onExceedsLowerBoundValue = "";

            /**
             * Creates a new BoundTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.BoundTask
             * @static
             * @param {oracle_job.OracleJob.IBoundTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.BoundTask} BoundTask instance
             */
            BoundTask.create = function create(properties) {
      return BoundTask.fromObject(properties);
    };

            /**
             * Encodes the specified BoundTask message. Does not implicitly {@link oracle_job.OracleJob.BoundTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.BoundTask
             * @static
             * @param {oracle_job.OracleJob.IBoundTask} message BoundTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BoundTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.lowerBound != null && Object.hasOwnProperty.call(message, "lowerBound"))
                    $root.oracle_job.OracleJob.encode(message.lowerBound, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.lowerBoundValue != null && Object.hasOwnProperty.call(message, "lowerBoundValue"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.lowerBoundValue);
                if (message.upperBound != null && Object.hasOwnProperty.call(message, "upperBound"))
                    $root.oracle_job.OracleJob.encode(message.upperBound, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.upperBoundValue != null && Object.hasOwnProperty.call(message, "upperBoundValue"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.upperBoundValue);
                if (message.onExceedsUpperBound != null && Object.hasOwnProperty.call(message, "onExceedsUpperBound"))
                    $root.oracle_job.OracleJob.encode(message.onExceedsUpperBound, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.onExceedsUpperBoundValue != null && Object.hasOwnProperty.call(message, "onExceedsUpperBoundValue"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.onExceedsUpperBoundValue);
                if (message.onExceedsLowerBound != null && Object.hasOwnProperty.call(message, "onExceedsLowerBound"))
                    $root.oracle_job.OracleJob.encode(message.onExceedsLowerBound, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.onExceedsLowerBoundValue != null && Object.hasOwnProperty.call(message, "onExceedsLowerBoundValue"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.onExceedsLowerBoundValue);
                return writer;
            };

            /**
             * Encodes the specified BoundTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.BoundTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.BoundTask
             * @static
             * @param {oracle_job.OracleJob.IBoundTask} message BoundTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BoundTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BoundTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.BoundTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.BoundTask} BoundTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BoundTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.BoundTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.lowerBound = $root.oracle_job.OracleJob.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.lowerBoundValue = reader.string();
                            break;
                        }
                    case 3: {
                            message.upperBound = $root.oracle_job.OracleJob.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.upperBoundValue = reader.string();
                            break;
                        }
                    case 5: {
                            message.onExceedsUpperBound = $root.oracle_job.OracleJob.decode(reader, reader.uint32());
                            break;
                        }
                    case 6: {
                            message.onExceedsUpperBoundValue = reader.string();
                            break;
                        }
                    case 7: {
                            message.onExceedsLowerBound = $root.oracle_job.OracleJob.decode(reader, reader.uint32());
                            break;
                        }
                    case 8: {
                            message.onExceedsLowerBoundValue = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BoundTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.BoundTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.BoundTask} BoundTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BoundTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BoundTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.BoundTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BoundTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.lowerBound != null && message.hasOwnProperty("lowerBound")) {
                    let error = $root.oracle_job.OracleJob.verify(message.lowerBound);
                    if (error)
                        return "lowerBound." + error;
                }
                if (message.lowerBoundValue != null && message.hasOwnProperty("lowerBoundValue"))
                    if (!$util.isString(message.lowerBoundValue))
                        return "lowerBoundValue: string expected";
                if (message.upperBound != null && message.hasOwnProperty("upperBound")) {
                    let error = $root.oracle_job.OracleJob.verify(message.upperBound);
                    if (error)
                        return "upperBound." + error;
                }
                if (message.upperBoundValue != null && message.hasOwnProperty("upperBoundValue"))
                    if (!$util.isString(message.upperBoundValue))
                        return "upperBoundValue: string expected";
                if (message.onExceedsUpperBound != null && message.hasOwnProperty("onExceedsUpperBound")) {
                    let error = $root.oracle_job.OracleJob.verify(message.onExceedsUpperBound);
                    if (error)
                        return "onExceedsUpperBound." + error;
                }
                if (message.onExceedsUpperBoundValue != null && message.hasOwnProperty("onExceedsUpperBoundValue"))
                    if (!$util.isString(message.onExceedsUpperBoundValue))
                        return "onExceedsUpperBoundValue: string expected";
                if (message.onExceedsLowerBound != null && message.hasOwnProperty("onExceedsLowerBound")) {
                    let error = $root.oracle_job.OracleJob.verify(message.onExceedsLowerBound);
                    if (error)
                        return "onExceedsLowerBound." + error;
                }
                if (message.onExceedsLowerBoundValue != null && message.hasOwnProperty("onExceedsLowerBoundValue"))
                    if (!$util.isString(message.onExceedsLowerBoundValue))
                        return "onExceedsLowerBoundValue: string expected";
                return null;
            };

            /**
             * Creates a BoundTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.BoundTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.BoundTask} BoundTask
             */
            BoundTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.BoundTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.BoundTask();
                if (object.lowerBound != null) {
                    if (typeof object.lowerBound !== "object")
                        throw TypeError(".oracle_job.OracleJob.BoundTask.lowerBound: object expected");
                    message.lowerBound = $root.oracle_job.OracleJob.fromObject(object.lowerBound);
                }
                if (object.lowerBoundValue != null)
                    message.lowerBoundValue = String(object.lowerBoundValue);
                if (object.upperBound != null) {
                    if (typeof object.upperBound !== "object")
                        throw TypeError(".oracle_job.OracleJob.BoundTask.upperBound: object expected");
                    message.upperBound = $root.oracle_job.OracleJob.fromObject(object.upperBound);
                }
                if (object.upperBoundValue != null)
                    message.upperBoundValue = String(object.upperBoundValue);
                if (object.onExceedsUpperBound != null) {
                    if (typeof object.onExceedsUpperBound !== "object")
                        throw TypeError(".oracle_job.OracleJob.BoundTask.onExceedsUpperBound: object expected");
                    message.onExceedsUpperBound = $root.oracle_job.OracleJob.fromObject(object.onExceedsUpperBound);
                }
                if (object.onExceedsUpperBoundValue != null)
                    message.onExceedsUpperBoundValue = String(object.onExceedsUpperBoundValue);
                if (object.onExceedsLowerBound != null) {
                    if (typeof object.onExceedsLowerBound !== "object")
                        throw TypeError(".oracle_job.OracleJob.BoundTask.onExceedsLowerBound: object expected");
                    message.onExceedsLowerBound = $root.oracle_job.OracleJob.fromObject(object.onExceedsLowerBound);
                }
                if (object.onExceedsLowerBoundValue != null)
                    message.onExceedsLowerBoundValue = String(object.onExceedsLowerBoundValue);
                return message;
            };

            /**
             * Creates a plain object from a BoundTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.BoundTask
             * @static
             * @param {oracle_job.OracleJob.BoundTask} message BoundTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BoundTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.lowerBound = null;
                    object.lowerBoundValue = "";
                    object.upperBound = null;
                    object.upperBoundValue = "";
                    object.onExceedsUpperBound = null;
                    object.onExceedsUpperBoundValue = "";
                    object.onExceedsLowerBound = null;
                    object.onExceedsLowerBoundValue = "";
                }
                if (message.lowerBound != null && message.hasOwnProperty("lowerBound"))
                    object.lowerBound = $root.oracle_job.OracleJob.toObject(message.lowerBound, options);
                if (message.lowerBoundValue != null && message.hasOwnProperty("lowerBoundValue"))
                    object.lowerBoundValue = message.lowerBoundValue;
                if (message.upperBound != null && message.hasOwnProperty("upperBound"))
                    object.upperBound = $root.oracle_job.OracleJob.toObject(message.upperBound, options);
                if (message.upperBoundValue != null && message.hasOwnProperty("upperBoundValue"))
                    object.upperBoundValue = message.upperBoundValue;
                if (message.onExceedsUpperBound != null && message.hasOwnProperty("onExceedsUpperBound"))
                    object.onExceedsUpperBound = $root.oracle_job.OracleJob.toObject(message.onExceedsUpperBound, options);
                if (message.onExceedsUpperBoundValue != null && message.hasOwnProperty("onExceedsUpperBoundValue"))
                    object.onExceedsUpperBoundValue = message.onExceedsUpperBoundValue;
                if (message.onExceedsLowerBound != null && message.hasOwnProperty("onExceedsLowerBound"))
                    object.onExceedsLowerBound = $root.oracle_job.OracleJob.toObject(message.onExceedsLowerBound, options);
                if (message.onExceedsLowerBoundValue != null && message.hasOwnProperty("onExceedsLowerBoundValue"))
                    object.onExceedsLowerBoundValue = message.onExceedsLowerBoundValue;
                return object;
            };

            /**
             * Converts this BoundTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.BoundTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BoundTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BoundTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.BoundTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BoundTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.BoundTask";
            };

            return BoundTask;
        })();

        OracleJob.SecretsTask = (function() {

            /**
             * Properties of a SecretsTask.
             * @memberof oracle_job.OracleJob
             * @interface ISecretsTask
             * @property {string|null} [authority] The authority of the secrets that are to be requested.
             * @property {string|null} [url] The url of the server to request secrets from. The default is https://api.secrets.switchboard.xyz.
             */

            /**
             * Constructs a new SecretsTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Securely request secrets from a Switchboard SecretsServer that are owned by a specific authority. Any secrets that are returned for the current feed will then be unwrapped into variables to be accessed later.
             * 
             * _**Input**_: None
             * 
             * _**Returns**_: The input
             * 
             * _**Example**_: SecretsTask
             * 
             * ```json
             * { "secretsTask": { "authority": "Accb21tUCWocJea6Uk3DgrNZawgmKegDVeHw8cGMDPi5" } }
             * ```
             * @implements ISecretsTask
             * @constructor
             * @param {oracle_job.OracleJob.ISecretsTask=} [properties] Properties to set
             */
            function SecretsTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The authority of the secrets that are to be requested.
             * @member {string} authority
             * @memberof oracle_job.OracleJob.SecretsTask
             * @instance
             */
            SecretsTask.prototype.authority = "";

            /**
             * The url of the server to request secrets from. The default is https://api.secrets.switchboard.xyz.
             * @member {string} url
             * @memberof oracle_job.OracleJob.SecretsTask
             * @instance
             */
            SecretsTask.prototype.url = "";

            /**
             * Creates a new SecretsTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.SecretsTask
             * @static
             * @param {oracle_job.OracleJob.ISecretsTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.SecretsTask} SecretsTask instance
             */
            SecretsTask.create = function create(properties) {
      return SecretsTask.fromObject(properties);
    };

            /**
             * Encodes the specified SecretsTask message. Does not implicitly {@link oracle_job.OracleJob.SecretsTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.SecretsTask
             * @static
             * @param {oracle_job.OracleJob.ISecretsTask} message SecretsTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SecretsTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.authority != null && Object.hasOwnProperty.call(message, "authority"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.authority);
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.url);
                return writer;
            };

            /**
             * Encodes the specified SecretsTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.SecretsTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.SecretsTask
             * @static
             * @param {oracle_job.OracleJob.ISecretsTask} message SecretsTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SecretsTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SecretsTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.SecretsTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.SecretsTask} SecretsTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SecretsTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.SecretsTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.authority = reader.string();
                            break;
                        }
                    case 2: {
                            message.url = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SecretsTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.SecretsTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.SecretsTask} SecretsTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SecretsTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SecretsTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.SecretsTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SecretsTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.authority != null && message.hasOwnProperty("authority"))
                    if (!$util.isString(message.authority))
                        return "authority: string expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                return null;
            };

            /**
             * Creates a SecretsTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.SecretsTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.SecretsTask} SecretsTask
             */
            SecretsTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.SecretsTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.SecretsTask();
                if (object.authority != null)
                    message.authority = String(object.authority);
                if (object.url != null)
                    message.url = String(object.url);
                return message;
            };

            /**
             * Creates a plain object from a SecretsTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.SecretsTask
             * @static
             * @param {oracle_job.OracleJob.SecretsTask} message SecretsTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SecretsTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.authority = "";
                    object.url = "";
                }
                if (message.authority != null && message.hasOwnProperty("authority"))
                    object.authority = message.authority;
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                return object;
            };

            /**
             * Converts this SecretsTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.SecretsTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SecretsTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SecretsTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.SecretsTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SecretsTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.SecretsTask";
            };

            return SecretsTask;
        })();

        OracleJob.SanctumLstPriceTask = (function() {

            /**
             * Properties of a SanctumLstPriceTask.
             * @memberof oracle_job.OracleJob
             * @interface ISanctumLstPriceTask
             * @property {string|null} [lstMint] The address of the LST mint.
             * 
             * e.g. INF - 5oVNBeEEQvYi1cX3ir8Dx5n1P7pdxydbGF2X4TxVusJm
             * @property {boolean|null} [skipEpochCheck] Allow the check to see if the LST was cranked for the current epoch to be skipped.
             */

            /**
             * Constructs a new SanctumLstPriceTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Grab the price of an Sanctum LST relative to SOL.
             * @implements ISanctumLstPriceTask
             * @constructor
             * @param {oracle_job.OracleJob.ISanctumLstPriceTask=} [properties] Properties to set
             */
            function SanctumLstPriceTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The address of the LST mint.
             * 
             * e.g. INF - 5oVNBeEEQvYi1cX3ir8Dx5n1P7pdxydbGF2X4TxVusJm
             * @member {string} lstMint
             * @memberof oracle_job.OracleJob.SanctumLstPriceTask
             * @instance
             */
            SanctumLstPriceTask.prototype.lstMint = "";

            /**
             * Allow the check to see if the LST was cranked for the current epoch to be skipped.
             * @member {boolean} skipEpochCheck
             * @memberof oracle_job.OracleJob.SanctumLstPriceTask
             * @instance
             */
            SanctumLstPriceTask.prototype.skipEpochCheck = false;

            /**
             * Creates a new SanctumLstPriceTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.SanctumLstPriceTask
             * @static
             * @param {oracle_job.OracleJob.ISanctumLstPriceTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.SanctumLstPriceTask} SanctumLstPriceTask instance
             */
            SanctumLstPriceTask.create = function create(properties) {
      return SanctumLstPriceTask.fromObject(properties);
    };

            /**
             * Encodes the specified SanctumLstPriceTask message. Does not implicitly {@link oracle_job.OracleJob.SanctumLstPriceTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.SanctumLstPriceTask
             * @static
             * @param {oracle_job.OracleJob.ISanctumLstPriceTask} message SanctumLstPriceTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SanctumLstPriceTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.lstMint != null && Object.hasOwnProperty.call(message, "lstMint"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.lstMint);
                if (message.skipEpochCheck != null && Object.hasOwnProperty.call(message, "skipEpochCheck"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.skipEpochCheck);
                return writer;
            };

            /**
             * Encodes the specified SanctumLstPriceTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.SanctumLstPriceTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.SanctumLstPriceTask
             * @static
             * @param {oracle_job.OracleJob.ISanctumLstPriceTask} message SanctumLstPriceTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SanctumLstPriceTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SanctumLstPriceTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.SanctumLstPriceTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.SanctumLstPriceTask} SanctumLstPriceTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SanctumLstPriceTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.SanctumLstPriceTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.lstMint = reader.string();
                            break;
                        }
                    case 2: {
                            message.skipEpochCheck = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SanctumLstPriceTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.SanctumLstPriceTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.SanctumLstPriceTask} SanctumLstPriceTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SanctumLstPriceTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SanctumLstPriceTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.SanctumLstPriceTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SanctumLstPriceTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.lstMint != null && message.hasOwnProperty("lstMint"))
                    if (!$util.isString(message.lstMint))
                        return "lstMint: string expected";
                if (message.skipEpochCheck != null && message.hasOwnProperty("skipEpochCheck"))
                    if (typeof message.skipEpochCheck !== "boolean")
                        return "skipEpochCheck: boolean expected";
                return null;
            };

            /**
             * Creates a SanctumLstPriceTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.SanctumLstPriceTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.SanctumLstPriceTask} SanctumLstPriceTask
             */
            SanctumLstPriceTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.SanctumLstPriceTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.SanctumLstPriceTask();
                if (object.lstMint != null)
                    message.lstMint = String(object.lstMint);
                if (object.skipEpochCheck != null)
                    message.skipEpochCheck = Boolean(object.skipEpochCheck);
                return message;
            };

            /**
             * Creates a plain object from a SanctumLstPriceTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.SanctumLstPriceTask
             * @static
             * @param {oracle_job.OracleJob.SanctumLstPriceTask} message SanctumLstPriceTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SanctumLstPriceTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.lstMint = "";
                    object.skipEpochCheck = false;
                }
                if (message.lstMint != null && message.hasOwnProperty("lstMint"))
                    object.lstMint = message.lstMint;
                if (message.skipEpochCheck != null && message.hasOwnProperty("skipEpochCheck"))
                    object.skipEpochCheck = message.skipEpochCheck;
                return object;
            };

            /**
             * Converts this SanctumLstPriceTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.SanctumLstPriceTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SanctumLstPriceTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SanctumLstPriceTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.SanctumLstPriceTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SanctumLstPriceTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.SanctumLstPriceTask";
            };

            return SanctumLstPriceTask;
        })();

        OracleJob.OndoUsdyTask = (function() {

            /**
             * Properties of an OndoUsdyTask.
             * @memberof oracle_job.OracleJob
             * @interface IOndoUsdyTask
             * @property {oracle_job.OracleJob.OndoUsdyTask.Strategy|null} [strategy] The strategy used to determine the price of USDY.
             */

            /**
             * Constructs a new OndoUsdyTask.
             * @memberof oracle_job.OracleJob
             * @classdesc OndoUsdyTask represents a task that computes the price of USDY relative to USD using a
             * specified strategy.
             * @implements IOndoUsdyTask
             * @constructor
             * @param {oracle_job.OracleJob.IOndoUsdyTask=} [properties] Properties to set
             */
            function OndoUsdyTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The strategy used to determine the price of USDY.
             * @member {oracle_job.OracleJob.OndoUsdyTask.Strategy} strategy
             * @memberof oracle_job.OracleJob.OndoUsdyTask
             * @instance
             */
            OndoUsdyTask.prototype.strategy = 0;

            /**
             * Creates a new OndoUsdyTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.OndoUsdyTask
             * @static
             * @param {oracle_job.OracleJob.IOndoUsdyTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.OndoUsdyTask} OndoUsdyTask instance
             */
            OndoUsdyTask.create = function create(properties) {
      return OndoUsdyTask.fromObject(properties);
    };

            /**
             * Encodes the specified OndoUsdyTask message. Does not implicitly {@link oracle_job.OracleJob.OndoUsdyTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.OndoUsdyTask
             * @static
             * @param {oracle_job.OracleJob.IOndoUsdyTask} message OndoUsdyTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OndoUsdyTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.strategy != null && Object.hasOwnProperty.call(message, "strategy"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.strategy);
                return writer;
            };

            /**
             * Encodes the specified OndoUsdyTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.OndoUsdyTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.OndoUsdyTask
             * @static
             * @param {oracle_job.OracleJob.IOndoUsdyTask} message OndoUsdyTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OndoUsdyTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OndoUsdyTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.OndoUsdyTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.OndoUsdyTask} OndoUsdyTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OndoUsdyTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.OndoUsdyTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.strategy = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OndoUsdyTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.OndoUsdyTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.OndoUsdyTask} OndoUsdyTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OndoUsdyTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OndoUsdyTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.OndoUsdyTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OndoUsdyTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.strategy != null && message.hasOwnProperty("strategy"))
                    switch (message.strategy) {
                    default:
                        return "strategy: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates an OndoUsdyTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.OndoUsdyTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.OndoUsdyTask} OndoUsdyTask
             */
            OndoUsdyTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.OndoUsdyTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.OndoUsdyTask();
                switch (object.strategy) {
                default:
                    if (typeof object.strategy === "number") {
                        message.strategy = object.strategy;
                        break;
                    }
                    break;
                case "STRATEGY_FAIR_VALUE":
                case 0:
                    message.strategy = 0;
                    break;
                case "STRATEGY_MARKET":
                case 1:
                    message.strategy = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from an OndoUsdyTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.OndoUsdyTask
             * @static
             * @param {oracle_job.OracleJob.OndoUsdyTask} message OndoUsdyTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OndoUsdyTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.strategy = options.enums === String ? "STRATEGY_FAIR_VALUE" : 0;
                if (message.strategy != null && message.hasOwnProperty("strategy"))
                    object.strategy = options.enums === String ? $root.oracle_job.OracleJob.OndoUsdyTask.Strategy[message.strategy] === undefined ? message.strategy : $root.oracle_job.OracleJob.OndoUsdyTask.Strategy[message.strategy] : message.strategy;
                return object;
            };

            /**
             * Converts this OndoUsdyTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.OndoUsdyTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OndoUsdyTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for OndoUsdyTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.OndoUsdyTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            OndoUsdyTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.OndoUsdyTask";
            };

            /**
             * Strategy specifies the method used to determine the price of USDY.
             * 
             * - STRATEGY_FAIR_VALUE: Computes the price based on a fair value model.
             * - STRATEGY_MARKET: Fetches the price directly from the market.
             * @name oracle_job.OracleJob.OndoUsdyTask.Strategy
             * @enum {number}
             * @property {number} STRATEGY_FAIR_VALUE=0 STRATEGY_FAIR_VALUE value
             * @property {number} STRATEGY_MARKET=1 STRATEGY_MARKET value
             */
            OndoUsdyTask.Strategy = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STRATEGY_FAIR_VALUE"] = 0;
                values[valuesById[1] = "STRATEGY_MARKET"] = 1;
                return values;
            })();

            return OndoUsdyTask;
        })();

        OracleJob.KalshiApiTask = (function() {

            /**
             * Properties of a KalshiApiTask.
             * @memberof oracle_job.OracleJob
             * @interface IKalshiApiTask
             * @property {string|null} [url] A string containing the URL to direct this HTTP request to.
             * @property {string|null} [apiKeyId] A string containing the API Key ID
             * @property {string|null} [privateKey] A string containing the private key for authentication
             * @property {string|null} [signature] Optional signature string field
             * @property {string|null} [timestamp] Optional timestamp in milliseconds (used with signature)
             */

            /**
             * Constructs a new KalshiApiTask.
             * @memberof oracle_job.OracleJob
             * @classdesc KalshiApiTask fetches a GET endpoint from the Kalshi API (with a token if supplied) and returns the JSON result
             * @implements IKalshiApiTask
             * @constructor
             * @param {oracle_job.OracleJob.IKalshiApiTask=} [properties] Properties to set
             */
            function KalshiApiTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * A string containing the URL to direct this HTTP request to.
             * @member {string} url
             * @memberof oracle_job.OracleJob.KalshiApiTask
             * @instance
             */
            KalshiApiTask.prototype.url = "";

            /**
             * A string containing the API Key ID
             * @member {string} apiKeyId
             * @memberof oracle_job.OracleJob.KalshiApiTask
             * @instance
             */
            KalshiApiTask.prototype.apiKeyId = "";

            /**
             * A string containing the private key for authentication
             * @member {string} privateKey
             * @memberof oracle_job.OracleJob.KalshiApiTask
             * @instance
             */
            KalshiApiTask.prototype.privateKey = "";

            /**
             * Optional signature string field
             * @member {string} signature
             * @memberof oracle_job.OracleJob.KalshiApiTask
             * @instance
             */
            KalshiApiTask.prototype.signature = "";

            /**
             * Optional timestamp in milliseconds (used with signature)
             * @member {string} timestamp
             * @memberof oracle_job.OracleJob.KalshiApiTask
             * @instance
             */
            KalshiApiTask.prototype.timestamp = "";

            /**
             * Creates a new KalshiApiTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.KalshiApiTask
             * @static
             * @param {oracle_job.OracleJob.IKalshiApiTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.KalshiApiTask} KalshiApiTask instance
             */
            KalshiApiTask.create = function create(properties) {
      return KalshiApiTask.fromObject(properties);
    };

            /**
             * Encodes the specified KalshiApiTask message. Does not implicitly {@link oracle_job.OracleJob.KalshiApiTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.KalshiApiTask
             * @static
             * @param {oracle_job.OracleJob.IKalshiApiTask} message KalshiApiTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KalshiApiTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                if (message.apiKeyId != null && Object.hasOwnProperty.call(message, "apiKeyId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.apiKeyId);
                if (message.privateKey != null && Object.hasOwnProperty.call(message, "privateKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.privateKey);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.signature);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.timestamp);
                return writer;
            };

            /**
             * Encodes the specified KalshiApiTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.KalshiApiTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.KalshiApiTask
             * @static
             * @param {oracle_job.OracleJob.IKalshiApiTask} message KalshiApiTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KalshiApiTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KalshiApiTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.KalshiApiTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.KalshiApiTask} KalshiApiTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KalshiApiTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.KalshiApiTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.url = reader.string();
                            break;
                        }
                    case 2: {
                            message.apiKeyId = reader.string();
                            break;
                        }
                    case 3: {
                            message.privateKey = reader.string();
                            break;
                        }
                    case 4: {
                            message.signature = reader.string();
                            break;
                        }
                    case 5: {
                            message.timestamp = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KalshiApiTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.KalshiApiTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.KalshiApiTask} KalshiApiTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KalshiApiTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KalshiApiTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.KalshiApiTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KalshiApiTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                if (message.apiKeyId != null && message.hasOwnProperty("apiKeyId"))
                    if (!$util.isString(message.apiKeyId))
                        return "apiKeyId: string expected";
                if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                    if (!$util.isString(message.privateKey))
                        return "privateKey: string expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!$util.isString(message.signature))
                        return "signature: string expected";
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    if (!$util.isString(message.timestamp))
                        return "timestamp: string expected";
                return null;
            };

            /**
             * Creates a KalshiApiTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.KalshiApiTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.KalshiApiTask} KalshiApiTask
             */
            KalshiApiTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.KalshiApiTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.KalshiApiTask();
                if (object.url != null)
                    message.url = String(object.url);
                if (object.apiKeyId != null)
                    message.apiKeyId = String(object.apiKeyId);
                if (object.privateKey != null)
                    message.privateKey = String(object.privateKey);
                if (object.signature != null)
                    message.signature = String(object.signature);
                if (object.timestamp != null)
                    message.timestamp = String(object.timestamp);
                return message;
            };

            /**
             * Creates a plain object from a KalshiApiTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.KalshiApiTask
             * @static
             * @param {oracle_job.OracleJob.KalshiApiTask} message KalshiApiTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KalshiApiTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.url = "";
                    object.apiKeyId = "";
                    object.privateKey = "";
                    object.signature = "";
                    object.timestamp = "";
                }
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                if (message.apiKeyId != null && message.hasOwnProperty("apiKeyId"))
                    object.apiKeyId = message.apiKeyId;
                if (message.privateKey != null && message.hasOwnProperty("privateKey"))
                    object.privateKey = message.privateKey;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = message.signature;
                if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                    object.timestamp = message.timestamp;
                return object;
            };

            /**
             * Converts this KalshiApiTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.KalshiApiTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KalshiApiTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for KalshiApiTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.KalshiApiTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            KalshiApiTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.KalshiApiTask";
            };

            return KalshiApiTask;
        })();

        OracleJob.MeteoraSwapTask = (function() {

            /**
             * Properties of a MeteoraSwapTask.
             * @memberof oracle_job.OracleJob
             * @interface IMeteoraSwapTask
             * @property {string|null} [pool] The address of the pool.
             * @property {oracle_job.OracleJob.MeteoraSwapTask.Type|null} [type] The pool type.
             */

            /**
             * Constructs a new MeteoraSwapTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Grab the swap price from a Meteora pool.
             * @implements IMeteoraSwapTask
             * @constructor
             * @param {oracle_job.OracleJob.IMeteoraSwapTask=} [properties] Properties to set
             */
            function MeteoraSwapTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The address of the pool.
             * @member {string} pool
             * @memberof oracle_job.OracleJob.MeteoraSwapTask
             * @instance
             */
            MeteoraSwapTask.prototype.pool = "";

            /**
             * The pool type.
             * @member {oracle_job.OracleJob.MeteoraSwapTask.Type} type
             * @memberof oracle_job.OracleJob.MeteoraSwapTask
             * @instance
             */
            MeteoraSwapTask.prototype.type = 0;

            /**
             * Creates a new MeteoraSwapTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.MeteoraSwapTask
             * @static
             * @param {oracle_job.OracleJob.IMeteoraSwapTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.MeteoraSwapTask} MeteoraSwapTask instance
             */
            MeteoraSwapTask.create = function create(properties) {
      return MeteoraSwapTask.fromObject(properties);
    };

            /**
             * Encodes the specified MeteoraSwapTask message. Does not implicitly {@link oracle_job.OracleJob.MeteoraSwapTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.MeteoraSwapTask
             * @static
             * @param {oracle_job.OracleJob.IMeteoraSwapTask} message MeteoraSwapTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MeteoraSwapTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.pool != null && Object.hasOwnProperty.call(message, "pool"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.pool);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified MeteoraSwapTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.MeteoraSwapTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.MeteoraSwapTask
             * @static
             * @param {oracle_job.OracleJob.IMeteoraSwapTask} message MeteoraSwapTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MeteoraSwapTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MeteoraSwapTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.MeteoraSwapTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.MeteoraSwapTask} MeteoraSwapTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MeteoraSwapTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.MeteoraSwapTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.pool = reader.string();
                            break;
                        }
                    case 2: {
                            message.type = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MeteoraSwapTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.MeteoraSwapTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.MeteoraSwapTask} MeteoraSwapTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MeteoraSwapTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MeteoraSwapTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.MeteoraSwapTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MeteoraSwapTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.pool != null && message.hasOwnProperty("pool"))
                    if (!$util.isString(message.pool))
                        return "pool: string expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a MeteoraSwapTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.MeteoraSwapTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.MeteoraSwapTask} MeteoraSwapTask
             */
            MeteoraSwapTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.MeteoraSwapTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.MeteoraSwapTask();
                if (object.pool != null)
                    message.pool = String(object.pool);
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "TYPE_DLMM":
                case 0:
                    message.type = 0;
                    break;
                case "TYPE_STANDARD":
                case 1:
                    message.type = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a MeteoraSwapTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.MeteoraSwapTask
             * @static
             * @param {oracle_job.OracleJob.MeteoraSwapTask} message MeteoraSwapTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MeteoraSwapTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.pool = "";
                    object.type = options.enums === String ? "TYPE_DLMM" : 0;
                }
                if (message.pool != null && message.hasOwnProperty("pool"))
                    object.pool = message.pool;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.oracle_job.OracleJob.MeteoraSwapTask.Type[message.type] === undefined ? message.type : $root.oracle_job.OracleJob.MeteoraSwapTask.Type[message.type] : message.type;
                return object;
            };

            /**
             * Converts this MeteoraSwapTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.MeteoraSwapTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MeteoraSwapTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MeteoraSwapTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.MeteoraSwapTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MeteoraSwapTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.MeteoraSwapTask";
            };

            /**
             * Type enum.
             * @name oracle_job.OracleJob.MeteoraSwapTask.Type
             * @enum {number}
             * @property {number} TYPE_DLMM=0 TYPE_DLMM value
             * @property {number} TYPE_STANDARD=1 TYPE_STANDARD value
             */
            MeteoraSwapTask.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "TYPE_DLMM"] = 0;
                values[valuesById[1] = "TYPE_STANDARD"] = 1;
                return values;
            })();

            return MeteoraSwapTask;
        })();

        OracleJob.UnixTimeTask = (function() {

            /**
             * Properties of an UnixTimeTask.
             * @memberof oracle_job.OracleJob
             * @interface IUnixTimeTask
             * @property {number|null} [offset] The offset to subtract from the current time.
             */

            /**
             * Constructs a new UnixTimeTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Get current time in seconds since Unix epoch.
             * @implements IUnixTimeTask
             * @constructor
             * @param {oracle_job.OracleJob.IUnixTimeTask=} [properties] Properties to set
             */
            function UnixTimeTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The offset to subtract from the current time.
             * @member {number} offset
             * @memberof oracle_job.OracleJob.UnixTimeTask
             * @instance
             */
            UnixTimeTask.prototype.offset = 0;

            /**
             * Creates a new UnixTimeTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.UnixTimeTask
             * @static
             * @param {oracle_job.OracleJob.IUnixTimeTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.UnixTimeTask} UnixTimeTask instance
             */
            UnixTimeTask.create = function create(properties) {
      return UnixTimeTask.fromObject(properties);
    };

            /**
             * Encodes the specified UnixTimeTask message. Does not implicitly {@link oracle_job.OracleJob.UnixTimeTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.UnixTimeTask
             * @static
             * @param {oracle_job.OracleJob.IUnixTimeTask} message UnixTimeTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnixTimeTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.offset);
                return writer;
            };

            /**
             * Encodes the specified UnixTimeTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.UnixTimeTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.UnixTimeTask
             * @static
             * @param {oracle_job.OracleJob.IUnixTimeTask} message UnixTimeTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnixTimeTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UnixTimeTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.UnixTimeTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.UnixTimeTask} UnixTimeTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnixTimeTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.UnixTimeTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.offset = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UnixTimeTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.UnixTimeTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.UnixTimeTask} UnixTimeTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnixTimeTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UnixTimeTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.UnixTimeTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UnixTimeTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.offset != null && message.hasOwnProperty("offset"))
                    if (!$util.isInteger(message.offset))
                        return "offset: integer expected";
                return null;
            };

            /**
             * Creates an UnixTimeTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.UnixTimeTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.UnixTimeTask} UnixTimeTask
             */
            UnixTimeTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.UnixTimeTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.UnixTimeTask();
                if (object.offset != null)
                    message.offset = object.offset | 0;
                return message;
            };

            /**
             * Creates a plain object from an UnixTimeTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.UnixTimeTask
             * @static
             * @param {oracle_job.OracleJob.UnixTimeTask} message UnixTimeTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UnixTimeTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.offset = 0;
                if (message.offset != null && message.hasOwnProperty("offset"))
                    object.offset = message.offset;
                return object;
            };

            /**
             * Converts this UnixTimeTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.UnixTimeTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UnixTimeTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UnixTimeTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.UnixTimeTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UnixTimeTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.UnixTimeTask";
            };

            return UnixTimeTask;
        })();

        OracleJob.MapleFinanceTask = (function() {

            /**
             * Properties of a MapleFinanceTask.
             * @memberof oracle_job.OracleJob
             * @interface IMapleFinanceTask
             * @property {oracle_job.OracleJob.MapleFinanceTask.Method|null} [method] The specific method to use for this task.
             */

            /**
             * Constructs a new MapleFinanceTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Fetch pricing information for Maple Finance assets.
             * 
             * _**Input**_: None
             * 
             * _**Returns**_: The requested price or value based on the specified method.
             * 
             * _**Example**_: Fetch the syrupUSDC fair price from Maple Finance
             * 
             * ```json
             * { "mapleFinanceTask": { "method": "METHOD_SYRUP_USDC_FAIR_PRICE" } }
             * ```
             * @implements IMapleFinanceTask
             * @constructor
             * @param {oracle_job.OracleJob.IMapleFinanceTask=} [properties] Properties to set
             */
            function MapleFinanceTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The specific method to use for this task.
             * @member {oracle_job.OracleJob.MapleFinanceTask.Method} method
             * @memberof oracle_job.OracleJob.MapleFinanceTask
             * @instance
             */
            MapleFinanceTask.prototype.method = 0;

            /**
             * Creates a new MapleFinanceTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.MapleFinanceTask
             * @static
             * @param {oracle_job.OracleJob.IMapleFinanceTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.MapleFinanceTask} MapleFinanceTask instance
             */
            MapleFinanceTask.create = function create(properties) {
      return MapleFinanceTask.fromObject(properties);
    };

            /**
             * Encodes the specified MapleFinanceTask message. Does not implicitly {@link oracle_job.OracleJob.MapleFinanceTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.MapleFinanceTask
             * @static
             * @param {oracle_job.OracleJob.IMapleFinanceTask} message MapleFinanceTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MapleFinanceTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.method != null && Object.hasOwnProperty.call(message, "method"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.method);
                return writer;
            };

            /**
             * Encodes the specified MapleFinanceTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.MapleFinanceTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.MapleFinanceTask
             * @static
             * @param {oracle_job.OracleJob.IMapleFinanceTask} message MapleFinanceTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MapleFinanceTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MapleFinanceTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.MapleFinanceTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.MapleFinanceTask} MapleFinanceTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MapleFinanceTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.MapleFinanceTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.method = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MapleFinanceTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.MapleFinanceTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.MapleFinanceTask} MapleFinanceTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MapleFinanceTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MapleFinanceTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.MapleFinanceTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MapleFinanceTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.method != null && message.hasOwnProperty("method"))
                    switch (message.method) {
                    default:
                        return "method: enum value expected";
                    case 0:
                        break;
                    }
                return null;
            };

            /**
             * Creates a MapleFinanceTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.MapleFinanceTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.MapleFinanceTask} MapleFinanceTask
             */
            MapleFinanceTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.MapleFinanceTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.MapleFinanceTask();
                switch (object.method) {
                default:
                    if (typeof object.method === "number") {
                        message.method = object.method;
                        break;
                    }
                    break;
                case "METHOD_SYRUP_USDC_FAIR_PRICE":
                case 0:
                    message.method = 0;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a MapleFinanceTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.MapleFinanceTask
             * @static
             * @param {oracle_job.OracleJob.MapleFinanceTask} message MapleFinanceTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MapleFinanceTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.method = options.enums === String ? "METHOD_SYRUP_USDC_FAIR_PRICE" : 0;
                if (message.method != null && message.hasOwnProperty("method"))
                    object.method = options.enums === String ? $root.oracle_job.OracleJob.MapleFinanceTask.Method[message.method] === undefined ? message.method : $root.oracle_job.OracleJob.MapleFinanceTask.Method[message.method] : message.method;
                return object;
            };

            /**
             * Converts this MapleFinanceTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.MapleFinanceTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MapleFinanceTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MapleFinanceTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.MapleFinanceTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MapleFinanceTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.MapleFinanceTask";
            };

            /**
             * Specifies the method to use for fetching Maple Finance data.
             * @name oracle_job.OracleJob.MapleFinanceTask.Method
             * @enum {number}
             * @property {number} METHOD_SYRUP_USDC_FAIR_PRICE=0 Fetch the fair price of syrupUSDC in the Maple Finance ecosystem.
             */
            MapleFinanceTask.Method = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "METHOD_SYRUP_USDC_FAIR_PRICE"] = 0;
                return values;
            })();

            return MapleFinanceTask;
        })();

        OracleJob.GlyphTask = (function() {

            /**
             * Properties of a GlyphTask.
             * @memberof oracle_job.OracleJob
             * @interface IGlyphTask
             * @property {string|null} [poolAddress] GlyphTask poolAddress
             * @property {boolean|null} [zeroForOne] GlyphTask zeroForOne
             */

            /**
             * Constructs a new GlyphTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Represents a GlyphTask.
             * @implements IGlyphTask
             * @constructor
             * @param {oracle_job.OracleJob.IGlyphTask=} [properties] Properties to set
             */
            function GlyphTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GlyphTask poolAddress.
             * @member {string} poolAddress
             * @memberof oracle_job.OracleJob.GlyphTask
             * @instance
             */
            GlyphTask.prototype.poolAddress = "";

            /**
             * GlyphTask zeroForOne.
             * @member {boolean} zeroForOne
             * @memberof oracle_job.OracleJob.GlyphTask
             * @instance
             */
            GlyphTask.prototype.zeroForOne = false;

            /**
             * Creates a new GlyphTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.GlyphTask
             * @static
             * @param {oracle_job.OracleJob.IGlyphTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.GlyphTask} GlyphTask instance
             */
            GlyphTask.create = function create(properties) {
      return GlyphTask.fromObject(properties);
    };

            /**
             * Encodes the specified GlyphTask message. Does not implicitly {@link oracle_job.OracleJob.GlyphTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.GlyphTask
             * @static
             * @param {oracle_job.OracleJob.IGlyphTask} message GlyphTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GlyphTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.poolAddress != null && Object.hasOwnProperty.call(message, "poolAddress"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.poolAddress);
                if (message.zeroForOne != null && Object.hasOwnProperty.call(message, "zeroForOne"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.zeroForOne);
                return writer;
            };

            /**
             * Encodes the specified GlyphTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.GlyphTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.GlyphTask
             * @static
             * @param {oracle_job.OracleJob.IGlyphTask} message GlyphTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GlyphTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GlyphTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.GlyphTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.GlyphTask} GlyphTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GlyphTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.GlyphTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.poolAddress = reader.string();
                            break;
                        }
                    case 2: {
                            message.zeroForOne = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GlyphTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.GlyphTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.GlyphTask} GlyphTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GlyphTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GlyphTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.GlyphTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GlyphTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.poolAddress != null && message.hasOwnProperty("poolAddress"))
                    if (!$util.isString(message.poolAddress))
                        return "poolAddress: string expected";
                if (message.zeroForOne != null && message.hasOwnProperty("zeroForOne"))
                    if (typeof message.zeroForOne !== "boolean")
                        return "zeroForOne: boolean expected";
                return null;
            };

            /**
             * Creates a GlyphTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.GlyphTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.GlyphTask} GlyphTask
             */
            GlyphTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.GlyphTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.GlyphTask();
                if (object.poolAddress != null)
                    message.poolAddress = String(object.poolAddress);
                if (object.zeroForOne != null)
                    message.zeroForOne = Boolean(object.zeroForOne);
                return message;
            };

            /**
             * Creates a plain object from a GlyphTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.GlyphTask
             * @static
             * @param {oracle_job.OracleJob.GlyphTask} message GlyphTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GlyphTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.poolAddress = "";
                    object.zeroForOne = false;
                }
                if (message.poolAddress != null && message.hasOwnProperty("poolAddress"))
                    object.poolAddress = message.poolAddress;
                if (message.zeroForOne != null && message.hasOwnProperty("zeroForOne"))
                    object.zeroForOne = message.zeroForOne;
                return object;
            };

            /**
             * Converts this GlyphTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.GlyphTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GlyphTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GlyphTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.GlyphTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GlyphTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.GlyphTask";
            };

            return GlyphTask;
        })();

        OracleJob.CorexTask = (function() {

            /**
             * Properties of a CorexTask.
             * @memberof oracle_job.OracleJob
             * @interface ICorexTask
             * @property {string|null} [inToken] CorexTask inToken
             * @property {string|null} [outToken] CorexTask outToken
             * @property {number|null} [slippage] CorexTask slippage
             */

            /**
             * Constructs a new CorexTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Represents a CorexTask.
             * @implements ICorexTask
             * @constructor
             * @param {oracle_job.OracleJob.ICorexTask=} [properties] Properties to set
             */
            function CorexTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CorexTask inToken.
             * @member {string} inToken
             * @memberof oracle_job.OracleJob.CorexTask
             * @instance
             */
            CorexTask.prototype.inToken = "";

            /**
             * CorexTask outToken.
             * @member {string} outToken
             * @memberof oracle_job.OracleJob.CorexTask
             * @instance
             */
            CorexTask.prototype.outToken = "";

            /**
             * CorexTask slippage.
             * @member {number} slippage
             * @memberof oracle_job.OracleJob.CorexTask
             * @instance
             */
            CorexTask.prototype.slippage = 0;

            /**
             * Creates a new CorexTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.CorexTask
             * @static
             * @param {oracle_job.OracleJob.ICorexTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.CorexTask} CorexTask instance
             */
            CorexTask.create = function create(properties) {
      return CorexTask.fromObject(properties);
    };

            /**
             * Encodes the specified CorexTask message. Does not implicitly {@link oracle_job.OracleJob.CorexTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.CorexTask
             * @static
             * @param {oracle_job.OracleJob.ICorexTask} message CorexTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CorexTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.inToken != null && Object.hasOwnProperty.call(message, "inToken"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.inToken);
                if (message.outToken != null && Object.hasOwnProperty.call(message, "outToken"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.outToken);
                if (message.slippage != null && Object.hasOwnProperty.call(message, "slippage"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.slippage);
                return writer;
            };

            /**
             * Encodes the specified CorexTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.CorexTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.CorexTask
             * @static
             * @param {oracle_job.OracleJob.ICorexTask} message CorexTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CorexTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CorexTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.CorexTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.CorexTask} CorexTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CorexTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.CorexTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.inToken = reader.string();
                            break;
                        }
                    case 2: {
                            message.outToken = reader.string();
                            break;
                        }
                    case 3: {
                            message.slippage = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CorexTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.CorexTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.CorexTask} CorexTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CorexTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CorexTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.CorexTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CorexTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.inToken != null && message.hasOwnProperty("inToken"))
                    if (!$util.isString(message.inToken))
                        return "inToken: string expected";
                if (message.outToken != null && message.hasOwnProperty("outToken"))
                    if (!$util.isString(message.outToken))
                        return "outToken: string expected";
                if (message.slippage != null && message.hasOwnProperty("slippage"))
                    if (typeof message.slippage !== "number")
                        return "slippage: number expected";
                return null;
            };

            /**
             * Creates a CorexTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.CorexTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.CorexTask} CorexTask
             */
            CorexTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.CorexTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.CorexTask();
                if (object.inToken != null)
                    message.inToken = String(object.inToken);
                if (object.outToken != null)
                    message.outToken = String(object.outToken);
                if (object.slippage != null)
                    message.slippage = Number(object.slippage);
                return message;
            };

            /**
             * Creates a plain object from a CorexTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.CorexTask
             * @static
             * @param {oracle_job.OracleJob.CorexTask} message CorexTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CorexTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.inToken = "";
                    object.outToken = "";
                    object.slippage = 0;
                }
                if (message.inToken != null && message.hasOwnProperty("inToken"))
                    object.inToken = message.inToken;
                if (message.outToken != null && message.hasOwnProperty("outToken"))
                    object.outToken = message.outToken;
                if (message.slippage != null && message.hasOwnProperty("slippage"))
                    object.slippage = options.json && !isFinite(message.slippage) ? String(message.slippage) : message.slippage;
                return object;
            };

            /**
             * Converts this CorexTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.CorexTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CorexTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CorexTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.CorexTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CorexTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.CorexTask";
            };

            return CorexTask;
        })();

        OracleJob.AftermathTask = (function() {

            /**
             * Properties of an AftermathTask.
             * @memberof oracle_job.OracleJob
             * @interface IAftermathTask
             * @property {string|null} [poolAddress] AftermathTask poolAddress
             * @property {number|null} [inAmount] AftermathTask inAmount
             * @property {string|null} [inCoinType] AftermathTask inCoinType
             * @property {string|null} [outCoinType] AftermathTask outCoinType
             */

            /**
             * Constructs a new AftermathTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Represents an AftermathTask.
             * @implements IAftermathTask
             * @constructor
             * @param {oracle_job.OracleJob.IAftermathTask=} [properties] Properties to set
             */
            function AftermathTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AftermathTask poolAddress.
             * @member {string} poolAddress
             * @memberof oracle_job.OracleJob.AftermathTask
             * @instance
             */
            AftermathTask.prototype.poolAddress = "";

            /**
             * AftermathTask inAmount.
             * @member {number} inAmount
             * @memberof oracle_job.OracleJob.AftermathTask
             * @instance
             */
            AftermathTask.prototype.inAmount = 0;

            /**
             * AftermathTask inCoinType.
             * @member {string} inCoinType
             * @memberof oracle_job.OracleJob.AftermathTask
             * @instance
             */
            AftermathTask.prototype.inCoinType = "";

            /**
             * AftermathTask outCoinType.
             * @member {string} outCoinType
             * @memberof oracle_job.OracleJob.AftermathTask
             * @instance
             */
            AftermathTask.prototype.outCoinType = "";

            /**
             * Creates a new AftermathTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.AftermathTask
             * @static
             * @param {oracle_job.OracleJob.IAftermathTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.AftermathTask} AftermathTask instance
             */
            AftermathTask.create = function create(properties) {
      return AftermathTask.fromObject(properties);
    };

            /**
             * Encodes the specified AftermathTask message. Does not implicitly {@link oracle_job.OracleJob.AftermathTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.AftermathTask
             * @static
             * @param {oracle_job.OracleJob.IAftermathTask} message AftermathTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AftermathTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.poolAddress != null && Object.hasOwnProperty.call(message, "poolAddress"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.poolAddress);
                if (message.inAmount != null && Object.hasOwnProperty.call(message, "inAmount"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.inAmount);
                if (message.inCoinType != null && Object.hasOwnProperty.call(message, "inCoinType"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.inCoinType);
                if (message.outCoinType != null && Object.hasOwnProperty.call(message, "outCoinType"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.outCoinType);
                return writer;
            };

            /**
             * Encodes the specified AftermathTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.AftermathTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.AftermathTask
             * @static
             * @param {oracle_job.OracleJob.IAftermathTask} message AftermathTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AftermathTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AftermathTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.AftermathTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.AftermathTask} AftermathTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AftermathTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.AftermathTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.poolAddress = reader.string();
                            break;
                        }
                    case 2: {
                            message.inAmount = reader.double();
                            break;
                        }
                    case 3: {
                            message.inCoinType = reader.string();
                            break;
                        }
                    case 4: {
                            message.outCoinType = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AftermathTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.AftermathTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.AftermathTask} AftermathTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AftermathTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AftermathTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.AftermathTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AftermathTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.poolAddress != null && message.hasOwnProperty("poolAddress"))
                    if (!$util.isString(message.poolAddress))
                        return "poolAddress: string expected";
                if (message.inAmount != null && message.hasOwnProperty("inAmount"))
                    if (typeof message.inAmount !== "number")
                        return "inAmount: number expected";
                if (message.inCoinType != null && message.hasOwnProperty("inCoinType"))
                    if (!$util.isString(message.inCoinType))
                        return "inCoinType: string expected";
                if (message.outCoinType != null && message.hasOwnProperty("outCoinType"))
                    if (!$util.isString(message.outCoinType))
                        return "outCoinType: string expected";
                return null;
            };

            /**
             * Creates an AftermathTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.AftermathTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.AftermathTask} AftermathTask
             */
            AftermathTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.AftermathTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.AftermathTask();
                if (object.poolAddress != null)
                    message.poolAddress = String(object.poolAddress);
                if (object.inAmount != null)
                    message.inAmount = Number(object.inAmount);
                if (object.inCoinType != null)
                    message.inCoinType = String(object.inCoinType);
                if (object.outCoinType != null)
                    message.outCoinType = String(object.outCoinType);
                return message;
            };

            /**
             * Creates a plain object from an AftermathTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.AftermathTask
             * @static
             * @param {oracle_job.OracleJob.AftermathTask} message AftermathTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AftermathTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.poolAddress = "";
                    object.inAmount = 0;
                    object.inCoinType = "";
                    object.outCoinType = "";
                }
                if (message.poolAddress != null && message.hasOwnProperty("poolAddress"))
                    object.poolAddress = message.poolAddress;
                if (message.inAmount != null && message.hasOwnProperty("inAmount"))
                    object.inAmount = options.json && !isFinite(message.inAmount) ? String(message.inAmount) : message.inAmount;
                if (message.inCoinType != null && message.hasOwnProperty("inCoinType"))
                    object.inCoinType = message.inCoinType;
                if (message.outCoinType != null && message.hasOwnProperty("outCoinType"))
                    object.outCoinType = message.outCoinType;
                return object;
            };

            /**
             * Converts this AftermathTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.AftermathTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AftermathTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AftermathTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.AftermathTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AftermathTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.AftermathTask";
            };

            return AftermathTask;
        })();

        OracleJob.LlmTask = (function() {

            /**
             * Properties of a LlmTask.
             * @memberof oracle_job.OracleJob
             * @interface ILlmTask
             * @property {oracle_job.OracleJob.LlmTask.IOpenAIConfig|null} [openai] LlmTask openai
             * @property {oracle_job.OracleJob.LlmTask.IGroqConfig|null} [groq] LlmTask groq
             * @property {oracle_job.OracleJob.LlmTask.IGrokXAIConfig|null} [grokxai] LlmTask grokxai
             */

            /**
             * Constructs a new LlmTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Interacts with a Large Language Model (LLM) to generate a text response based on a user-provided prompt.
             * 
             * _**Input**_: None
             * 
             * _**Returns**_: Text generated by the LLM based on the provided prompt and configuration.
             * 
             * _**Example**_: Using OpenAI's GPT-4 model to generate a joke.
             * 
             * ```json
             * {
             * "llmTask": {
             * "providerConfig": {
             * "openai": {
             * "model": "gpt-4",
             * "userPrompt": "Tell me a joke.",
             * "temperature": 0.7,
             * "secretNameApiKey": "${OPENAI_API_KEY}"
             * }
             * }
             * }
             * }
             * @implements ILlmTask
             * @constructor
             * @param {oracle_job.OracleJob.ILlmTask=} [properties] Properties to set
             */
            function LlmTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LlmTask openai.
             * @member {oracle_job.OracleJob.LlmTask.IOpenAIConfig|null|undefined} openai
             * @memberof oracle_job.OracleJob.LlmTask
             * @instance
             */
            LlmTask.prototype.openai = null;

            /**
             * LlmTask groq.
             * @member {oracle_job.OracleJob.LlmTask.IGroqConfig|null|undefined} groq
             * @memberof oracle_job.OracleJob.LlmTask
             * @instance
             */
            LlmTask.prototype.groq = null;

            /**
             * LlmTask grokxai.
             * @member {oracle_job.OracleJob.LlmTask.IGrokXAIConfig|null|undefined} grokxai
             * @memberof oracle_job.OracleJob.LlmTask
             * @instance
             */
            LlmTask.prototype.grokxai = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * LlmTask providerConfig.
             * @member {"openai"|"groq"|"grokxai"|undefined} providerConfig
             * @memberof oracle_job.OracleJob.LlmTask
             * @instance
             */
            Object.defineProperty(LlmTask.prototype, "providerConfig", {
                get: $util.oneOfGetter($oneOfFields = ["openai", "groq", "grokxai"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new LlmTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.LlmTask
             * @static
             * @param {oracle_job.OracleJob.ILlmTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.LlmTask} LlmTask instance
             */
            LlmTask.create = function create(properties) {
      return LlmTask.fromObject(properties);
    };

            /**
             * Encodes the specified LlmTask message. Does not implicitly {@link oracle_job.OracleJob.LlmTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.LlmTask
             * @static
             * @param {oracle_job.OracleJob.ILlmTask} message LlmTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LlmTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.openai != null && Object.hasOwnProperty.call(message, "openai"))
                    $root.oracle_job.OracleJob.LlmTask.OpenAIConfig.encode(message.openai, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.groq != null && Object.hasOwnProperty.call(message, "groq"))
                    $root.oracle_job.OracleJob.LlmTask.GroqConfig.encode(message.groq, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.grokxai != null && Object.hasOwnProperty.call(message, "grokxai"))
                    $root.oracle_job.OracleJob.LlmTask.GrokXAIConfig.encode(message.grokxai, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified LlmTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.LlmTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.LlmTask
             * @static
             * @param {oracle_job.OracleJob.ILlmTask} message LlmTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LlmTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LlmTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.LlmTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.LlmTask} LlmTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LlmTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.LlmTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.openai = $root.oracle_job.OracleJob.LlmTask.OpenAIConfig.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.groq = $root.oracle_job.OracleJob.LlmTask.GroqConfig.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.grokxai = $root.oracle_job.OracleJob.LlmTask.GrokXAIConfig.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LlmTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.LlmTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.LlmTask} LlmTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LlmTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LlmTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.LlmTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LlmTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.openai != null && message.hasOwnProperty("openai")) {
                    properties.providerConfig = 1;
                    {
                        let error = $root.oracle_job.OracleJob.LlmTask.OpenAIConfig.verify(message.openai);
                        if (error)
                            return "openai." + error;
                    }
                }
                if (message.groq != null && message.hasOwnProperty("groq")) {
                    if (properties.providerConfig === 1)
                        return "providerConfig: multiple values";
                    properties.providerConfig = 1;
                    {
                        let error = $root.oracle_job.OracleJob.LlmTask.GroqConfig.verify(message.groq);
                        if (error)
                            return "groq." + error;
                    }
                }
                if (message.grokxai != null && message.hasOwnProperty("grokxai")) {
                    if (properties.providerConfig === 1)
                        return "providerConfig: multiple values";
                    properties.providerConfig = 1;
                    {
                        let error = $root.oracle_job.OracleJob.LlmTask.GrokXAIConfig.verify(message.grokxai);
                        if (error)
                            return "grokxai." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a LlmTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.LlmTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.LlmTask} LlmTask
             */
            LlmTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.LlmTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.LlmTask();
                if (object.openai != null) {
                    if (typeof object.openai !== "object")
                        throw TypeError(".oracle_job.OracleJob.LlmTask.openai: object expected");
                    message.openai = $root.oracle_job.OracleJob.LlmTask.OpenAIConfig.fromObject(object.openai);
                }
                if (object.groq != null) {
                    if (typeof object.groq !== "object")
                        throw TypeError(".oracle_job.OracleJob.LlmTask.groq: object expected");
                    message.groq = $root.oracle_job.OracleJob.LlmTask.GroqConfig.fromObject(object.groq);
                }
                if (object.grokxai != null) {
                    if (typeof object.grokxai !== "object")
                        throw TypeError(".oracle_job.OracleJob.LlmTask.grokxai: object expected");
                    message.grokxai = $root.oracle_job.OracleJob.LlmTask.GrokXAIConfig.fromObject(object.grokxai);
                }
                return message;
            };

            /**
             * Creates a plain object from a LlmTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.LlmTask
             * @static
             * @param {oracle_job.OracleJob.LlmTask} message LlmTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LlmTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.openai != null && message.hasOwnProperty("openai")) {
                    object.openai = $root.oracle_job.OracleJob.LlmTask.OpenAIConfig.toObject(message.openai, options);
                    if (options.oneofs)
                        object.providerConfig = "openai";
                }
                if (message.groq != null && message.hasOwnProperty("groq")) {
                    object.groq = $root.oracle_job.OracleJob.LlmTask.GroqConfig.toObject(message.groq, options);
                    if (options.oneofs)
                        object.providerConfig = "groq";
                }
                if (message.grokxai != null && message.hasOwnProperty("grokxai")) {
                    object.grokxai = $root.oracle_job.OracleJob.LlmTask.GrokXAIConfig.toObject(message.grokxai, options);
                    if (options.oneofs)
                        object.providerConfig = "grokxai";
                }
                return object;
            };

            /**
             * Converts this LlmTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.LlmTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LlmTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LlmTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.LlmTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LlmTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.LlmTask";
            };

            LlmTask.OpenAIConfig = (function() {

                /**
                 * Properties of an OpenAIConfig.
                 * @memberof oracle_job.OracleJob.LlmTask
                 * @interface IOpenAIConfig
                 * @property {string|null} [model] OpenAIConfig model
                 * @property {string|null} [userPrompt] OpenAIConfig userPrompt
                 * @property {number|null} [temperature] OpenAIConfig temperature
                 * @property {string|null} [secretNameApiKey] OpenAIConfig secretNameApiKey
                 */

                /**
                 * Constructs a new OpenAIConfig.
                 * @memberof oracle_job.OracleJob.LlmTask
                 * @classdesc Represents an OpenAIConfig.
                 * @implements IOpenAIConfig
                 * @constructor
                 * @param {oracle_job.OracleJob.LlmTask.IOpenAIConfig=} [properties] Properties to set
                 */
                function OpenAIConfig(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * OpenAIConfig model.
                 * @member {string} model
                 * @memberof oracle_job.OracleJob.LlmTask.OpenAIConfig
                 * @instance
                 */
                OpenAIConfig.prototype.model = "";

                /**
                 * OpenAIConfig userPrompt.
                 * @member {string} userPrompt
                 * @memberof oracle_job.OracleJob.LlmTask.OpenAIConfig
                 * @instance
                 */
                OpenAIConfig.prototype.userPrompt = "";

                /**
                 * OpenAIConfig temperature.
                 * @member {number} temperature
                 * @memberof oracle_job.OracleJob.LlmTask.OpenAIConfig
                 * @instance
                 */
                OpenAIConfig.prototype.temperature = 0;

                /**
                 * OpenAIConfig secretNameApiKey.
                 * @member {string} secretNameApiKey
                 * @memberof oracle_job.OracleJob.LlmTask.OpenAIConfig
                 * @instance
                 */
                OpenAIConfig.prototype.secretNameApiKey = "";

                /**
                 * Creates a new OpenAIConfig instance using the specified properties.
                 * @function create
                 * @memberof oracle_job.OracleJob.LlmTask.OpenAIConfig
                 * @static
                 * @param {oracle_job.OracleJob.LlmTask.IOpenAIConfig=} [properties] Properties to set
                 * @returns {oracle_job.OracleJob.LlmTask.OpenAIConfig} OpenAIConfig instance
                 */
                OpenAIConfig.create = function create(properties) {
      return OpenAIConfig.fromObject(properties);
    };

                /**
                 * Encodes the specified OpenAIConfig message. Does not implicitly {@link oracle_job.OracleJob.LlmTask.OpenAIConfig.verify|verify} messages.
                 * @function encode
                 * @memberof oracle_job.OracleJob.LlmTask.OpenAIConfig
                 * @static
                 * @param {oracle_job.OracleJob.LlmTask.IOpenAIConfig} message OpenAIConfig message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OpenAIConfig.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.model != null && Object.hasOwnProperty.call(message, "model"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.model);
                    if (message.userPrompt != null && Object.hasOwnProperty.call(message, "userPrompt"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.userPrompt);
                    if (message.temperature != null && Object.hasOwnProperty.call(message, "temperature"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.temperature);
                    if (message.secretNameApiKey != null && Object.hasOwnProperty.call(message, "secretNameApiKey"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.secretNameApiKey);
                    return writer;
                };

                /**
                 * Encodes the specified OpenAIConfig message, length delimited. Does not implicitly {@link oracle_job.OracleJob.LlmTask.OpenAIConfig.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof oracle_job.OracleJob.LlmTask.OpenAIConfig
                 * @static
                 * @param {oracle_job.OracleJob.LlmTask.IOpenAIConfig} message OpenAIConfig message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OpenAIConfig.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an OpenAIConfig message from the specified reader or buffer.
                 * @function decode
                 * @memberof oracle_job.OracleJob.LlmTask.OpenAIConfig
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {oracle_job.OracleJob.LlmTask.OpenAIConfig} OpenAIConfig
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OpenAIConfig.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.LlmTask.OpenAIConfig();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.model = reader.string();
                                break;
                            }
                        case 2: {
                                message.userPrompt = reader.string();
                                break;
                            }
                        case 3: {
                                message.temperature = reader.double();
                                break;
                            }
                        case 4: {
                                message.secretNameApiKey = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an OpenAIConfig message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof oracle_job.OracleJob.LlmTask.OpenAIConfig
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {oracle_job.OracleJob.LlmTask.OpenAIConfig} OpenAIConfig
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OpenAIConfig.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an OpenAIConfig message.
                 * @function verify
                 * @memberof oracle_job.OracleJob.LlmTask.OpenAIConfig
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                OpenAIConfig.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.model != null && message.hasOwnProperty("model"))
                        if (!$util.isString(message.model))
                            return "model: string expected";
                    if (message.userPrompt != null && message.hasOwnProperty("userPrompt"))
                        if (!$util.isString(message.userPrompt))
                            return "userPrompt: string expected";
                    if (message.temperature != null && message.hasOwnProperty("temperature"))
                        if (typeof message.temperature !== "number")
                            return "temperature: number expected";
                    if (message.secretNameApiKey != null && message.hasOwnProperty("secretNameApiKey"))
                        if (!$util.isString(message.secretNameApiKey))
                            return "secretNameApiKey: string expected";
                    return null;
                };

                /**
                 * Creates an OpenAIConfig message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof oracle_job.OracleJob.LlmTask.OpenAIConfig
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {oracle_job.OracleJob.LlmTask.OpenAIConfig} OpenAIConfig
                 */
                OpenAIConfig.fromObject = function fromObject(object) {
                    if (object instanceof $root.oracle_job.OracleJob.LlmTask.OpenAIConfig)
                        return object;
                    let message = new $root.oracle_job.OracleJob.LlmTask.OpenAIConfig();
                    if (object.model != null)
                        message.model = String(object.model);
                    if (object.userPrompt != null)
                        message.userPrompt = String(object.userPrompt);
                    if (object.temperature != null)
                        message.temperature = Number(object.temperature);
                    if (object.secretNameApiKey != null)
                        message.secretNameApiKey = String(object.secretNameApiKey);
                    return message;
                };

                /**
                 * Creates a plain object from an OpenAIConfig message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof oracle_job.OracleJob.LlmTask.OpenAIConfig
                 * @static
                 * @param {oracle_job.OracleJob.LlmTask.OpenAIConfig} message OpenAIConfig
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                OpenAIConfig.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.model = "";
                        object.userPrompt = "";
                        object.temperature = 0;
                        object.secretNameApiKey = "";
                    }
                    if (message.model != null && message.hasOwnProperty("model"))
                        object.model = message.model;
                    if (message.userPrompt != null && message.hasOwnProperty("userPrompt"))
                        object.userPrompt = message.userPrompt;
                    if (message.temperature != null && message.hasOwnProperty("temperature"))
                        object.temperature = options.json && !isFinite(message.temperature) ? String(message.temperature) : message.temperature;
                    if (message.secretNameApiKey != null && message.hasOwnProperty("secretNameApiKey"))
                        object.secretNameApiKey = message.secretNameApiKey;
                    return object;
                };

                /**
                 * Converts this OpenAIConfig to JSON.
                 * @function toJSON
                 * @memberof oracle_job.OracleJob.LlmTask.OpenAIConfig
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                OpenAIConfig.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for OpenAIConfig
                 * @function getTypeUrl
                 * @memberof oracle_job.OracleJob.LlmTask.OpenAIConfig
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                OpenAIConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/oracle_job.OracleJob.LlmTask.OpenAIConfig";
                };

                return OpenAIConfig;
            })();

            LlmTask.GroqConfig = (function() {

                /**
                 * Properties of a GroqConfig.
                 * @memberof oracle_job.OracleJob.LlmTask
                 * @interface IGroqConfig
                 * @property {string|null} [model] GroqConfig model
                 * @property {string|null} [userPrompt] GroqConfig userPrompt
                 * @property {number|null} [temperature] GroqConfig temperature
                 * @property {string|null} [secretNameApiKey] GroqConfig secretNameApiKey
                 */

                /**
                 * Constructs a new GroqConfig.
                 * @memberof oracle_job.OracleJob.LlmTask
                 * @classdesc Represents a GroqConfig.
                 * @implements IGroqConfig
                 * @constructor
                 * @param {oracle_job.OracleJob.LlmTask.IGroqConfig=} [properties] Properties to set
                 */
                function GroqConfig(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GroqConfig model.
                 * @member {string} model
                 * @memberof oracle_job.OracleJob.LlmTask.GroqConfig
                 * @instance
                 */
                GroqConfig.prototype.model = "";

                /**
                 * GroqConfig userPrompt.
                 * @member {string} userPrompt
                 * @memberof oracle_job.OracleJob.LlmTask.GroqConfig
                 * @instance
                 */
                GroqConfig.prototype.userPrompt = "";

                /**
                 * GroqConfig temperature.
                 * @member {number} temperature
                 * @memberof oracle_job.OracleJob.LlmTask.GroqConfig
                 * @instance
                 */
                GroqConfig.prototype.temperature = 0;

                /**
                 * GroqConfig secretNameApiKey.
                 * @member {string} secretNameApiKey
                 * @memberof oracle_job.OracleJob.LlmTask.GroqConfig
                 * @instance
                 */
                GroqConfig.prototype.secretNameApiKey = "";

                /**
                 * Creates a new GroqConfig instance using the specified properties.
                 * @function create
                 * @memberof oracle_job.OracleJob.LlmTask.GroqConfig
                 * @static
                 * @param {oracle_job.OracleJob.LlmTask.IGroqConfig=} [properties] Properties to set
                 * @returns {oracle_job.OracleJob.LlmTask.GroqConfig} GroqConfig instance
                 */
                GroqConfig.create = function create(properties) {
      return GroqConfig.fromObject(properties);
    };

                /**
                 * Encodes the specified GroqConfig message. Does not implicitly {@link oracle_job.OracleJob.LlmTask.GroqConfig.verify|verify} messages.
                 * @function encode
                 * @memberof oracle_job.OracleJob.LlmTask.GroqConfig
                 * @static
                 * @param {oracle_job.OracleJob.LlmTask.IGroqConfig} message GroqConfig message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GroqConfig.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.model != null && Object.hasOwnProperty.call(message, "model"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.model);
                    if (message.userPrompt != null && Object.hasOwnProperty.call(message, "userPrompt"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.userPrompt);
                    if (message.temperature != null && Object.hasOwnProperty.call(message, "temperature"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.temperature);
                    if (message.secretNameApiKey != null && Object.hasOwnProperty.call(message, "secretNameApiKey"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.secretNameApiKey);
                    return writer;
                };

                /**
                 * Encodes the specified GroqConfig message, length delimited. Does not implicitly {@link oracle_job.OracleJob.LlmTask.GroqConfig.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof oracle_job.OracleJob.LlmTask.GroqConfig
                 * @static
                 * @param {oracle_job.OracleJob.LlmTask.IGroqConfig} message GroqConfig message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GroqConfig.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GroqConfig message from the specified reader or buffer.
                 * @function decode
                 * @memberof oracle_job.OracleJob.LlmTask.GroqConfig
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {oracle_job.OracleJob.LlmTask.GroqConfig} GroqConfig
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GroqConfig.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.LlmTask.GroqConfig();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.model = reader.string();
                                break;
                            }
                        case 2: {
                                message.userPrompt = reader.string();
                                break;
                            }
                        case 3: {
                                message.temperature = reader.double();
                                break;
                            }
                        case 4: {
                                message.secretNameApiKey = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GroqConfig message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof oracle_job.OracleJob.LlmTask.GroqConfig
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {oracle_job.OracleJob.LlmTask.GroqConfig} GroqConfig
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GroqConfig.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GroqConfig message.
                 * @function verify
                 * @memberof oracle_job.OracleJob.LlmTask.GroqConfig
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GroqConfig.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.model != null && message.hasOwnProperty("model"))
                        if (!$util.isString(message.model))
                            return "model: string expected";
                    if (message.userPrompt != null && message.hasOwnProperty("userPrompt"))
                        if (!$util.isString(message.userPrompt))
                            return "userPrompt: string expected";
                    if (message.temperature != null && message.hasOwnProperty("temperature"))
                        if (typeof message.temperature !== "number")
                            return "temperature: number expected";
                    if (message.secretNameApiKey != null && message.hasOwnProperty("secretNameApiKey"))
                        if (!$util.isString(message.secretNameApiKey))
                            return "secretNameApiKey: string expected";
                    return null;
                };

                /**
                 * Creates a GroqConfig message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof oracle_job.OracleJob.LlmTask.GroqConfig
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {oracle_job.OracleJob.LlmTask.GroqConfig} GroqConfig
                 */
                GroqConfig.fromObject = function fromObject(object) {
                    if (object instanceof $root.oracle_job.OracleJob.LlmTask.GroqConfig)
                        return object;
                    let message = new $root.oracle_job.OracleJob.LlmTask.GroqConfig();
                    if (object.model != null)
                        message.model = String(object.model);
                    if (object.userPrompt != null)
                        message.userPrompt = String(object.userPrompt);
                    if (object.temperature != null)
                        message.temperature = Number(object.temperature);
                    if (object.secretNameApiKey != null)
                        message.secretNameApiKey = String(object.secretNameApiKey);
                    return message;
                };

                /**
                 * Creates a plain object from a GroqConfig message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof oracle_job.OracleJob.LlmTask.GroqConfig
                 * @static
                 * @param {oracle_job.OracleJob.LlmTask.GroqConfig} message GroqConfig
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GroqConfig.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.model = "";
                        object.userPrompt = "";
                        object.temperature = 0;
                        object.secretNameApiKey = "";
                    }
                    if (message.model != null && message.hasOwnProperty("model"))
                        object.model = message.model;
                    if (message.userPrompt != null && message.hasOwnProperty("userPrompt"))
                        object.userPrompt = message.userPrompt;
                    if (message.temperature != null && message.hasOwnProperty("temperature"))
                        object.temperature = options.json && !isFinite(message.temperature) ? String(message.temperature) : message.temperature;
                    if (message.secretNameApiKey != null && message.hasOwnProperty("secretNameApiKey"))
                        object.secretNameApiKey = message.secretNameApiKey;
                    return object;
                };

                /**
                 * Converts this GroqConfig to JSON.
                 * @function toJSON
                 * @memberof oracle_job.OracleJob.LlmTask.GroqConfig
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GroqConfig.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for GroqConfig
                 * @function getTypeUrl
                 * @memberof oracle_job.OracleJob.LlmTask.GroqConfig
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                GroqConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/oracle_job.OracleJob.LlmTask.GroqConfig";
                };

                return GroqConfig;
            })();

            LlmTask.GrokXAIConfig = (function() {

                /**
                 * Properties of a GrokXAIConfig.
                 * @memberof oracle_job.OracleJob.LlmTask
                 * @interface IGrokXAIConfig
                 * @property {string|null} [model] GrokXAIConfig model
                 * @property {string|null} [userPrompt] GrokXAIConfig userPrompt
                 * @property {number|null} [temperature] GrokXAIConfig temperature
                 * @property {string|null} [secretNameApiKey] GrokXAIConfig secretNameApiKey
                 */

                /**
                 * Constructs a new GrokXAIConfig.
                 * @memberof oracle_job.OracleJob.LlmTask
                 * @classdesc Represents a GrokXAIConfig.
                 * @implements IGrokXAIConfig
                 * @constructor
                 * @param {oracle_job.OracleJob.LlmTask.IGrokXAIConfig=} [properties] Properties to set
                 */
                function GrokXAIConfig(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GrokXAIConfig model.
                 * @member {string} model
                 * @memberof oracle_job.OracleJob.LlmTask.GrokXAIConfig
                 * @instance
                 */
                GrokXAIConfig.prototype.model = "";

                /**
                 * GrokXAIConfig userPrompt.
                 * @member {string} userPrompt
                 * @memberof oracle_job.OracleJob.LlmTask.GrokXAIConfig
                 * @instance
                 */
                GrokXAIConfig.prototype.userPrompt = "";

                /**
                 * GrokXAIConfig temperature.
                 * @member {number} temperature
                 * @memberof oracle_job.OracleJob.LlmTask.GrokXAIConfig
                 * @instance
                 */
                GrokXAIConfig.prototype.temperature = 0;

                /**
                 * GrokXAIConfig secretNameApiKey.
                 * @member {string} secretNameApiKey
                 * @memberof oracle_job.OracleJob.LlmTask.GrokXAIConfig
                 * @instance
                 */
                GrokXAIConfig.prototype.secretNameApiKey = "";

                /**
                 * Creates a new GrokXAIConfig instance using the specified properties.
                 * @function create
                 * @memberof oracle_job.OracleJob.LlmTask.GrokXAIConfig
                 * @static
                 * @param {oracle_job.OracleJob.LlmTask.IGrokXAIConfig=} [properties] Properties to set
                 * @returns {oracle_job.OracleJob.LlmTask.GrokXAIConfig} GrokXAIConfig instance
                 */
                GrokXAIConfig.create = function create(properties) {
      return GrokXAIConfig.fromObject(properties);
    };

                /**
                 * Encodes the specified GrokXAIConfig message. Does not implicitly {@link oracle_job.OracleJob.LlmTask.GrokXAIConfig.verify|verify} messages.
                 * @function encode
                 * @memberof oracle_job.OracleJob.LlmTask.GrokXAIConfig
                 * @static
                 * @param {oracle_job.OracleJob.LlmTask.IGrokXAIConfig} message GrokXAIConfig message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GrokXAIConfig.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.model != null && Object.hasOwnProperty.call(message, "model"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.model);
                    if (message.userPrompt != null && Object.hasOwnProperty.call(message, "userPrompt"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.userPrompt);
                    if (message.temperature != null && Object.hasOwnProperty.call(message, "temperature"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.temperature);
                    if (message.secretNameApiKey != null && Object.hasOwnProperty.call(message, "secretNameApiKey"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.secretNameApiKey);
                    return writer;
                };

                /**
                 * Encodes the specified GrokXAIConfig message, length delimited. Does not implicitly {@link oracle_job.OracleJob.LlmTask.GrokXAIConfig.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof oracle_job.OracleJob.LlmTask.GrokXAIConfig
                 * @static
                 * @param {oracle_job.OracleJob.LlmTask.IGrokXAIConfig} message GrokXAIConfig message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GrokXAIConfig.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GrokXAIConfig message from the specified reader or buffer.
                 * @function decode
                 * @memberof oracle_job.OracleJob.LlmTask.GrokXAIConfig
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {oracle_job.OracleJob.LlmTask.GrokXAIConfig} GrokXAIConfig
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GrokXAIConfig.decode = function decode(reader, length, error) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.LlmTask.GrokXAIConfig();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        if (tag === error)
                            break;
                        switch (tag >>> 3) {
                        case 1: {
                                message.model = reader.string();
                                break;
                            }
                        case 2: {
                                message.userPrompt = reader.string();
                                break;
                            }
                        case 3: {
                                message.temperature = reader.double();
                                break;
                            }
                        case 4: {
                                message.secretNameApiKey = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GrokXAIConfig message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof oracle_job.OracleJob.LlmTask.GrokXAIConfig
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {oracle_job.OracleJob.LlmTask.GrokXAIConfig} GrokXAIConfig
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GrokXAIConfig.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GrokXAIConfig message.
                 * @function verify
                 * @memberof oracle_job.OracleJob.LlmTask.GrokXAIConfig
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GrokXAIConfig.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.model != null && message.hasOwnProperty("model"))
                        if (!$util.isString(message.model))
                            return "model: string expected";
                    if (message.userPrompt != null && message.hasOwnProperty("userPrompt"))
                        if (!$util.isString(message.userPrompt))
                            return "userPrompt: string expected";
                    if (message.temperature != null && message.hasOwnProperty("temperature"))
                        if (typeof message.temperature !== "number")
                            return "temperature: number expected";
                    if (message.secretNameApiKey != null && message.hasOwnProperty("secretNameApiKey"))
                        if (!$util.isString(message.secretNameApiKey))
                            return "secretNameApiKey: string expected";
                    return null;
                };

                /**
                 * Creates a GrokXAIConfig message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof oracle_job.OracleJob.LlmTask.GrokXAIConfig
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {oracle_job.OracleJob.LlmTask.GrokXAIConfig} GrokXAIConfig
                 */
                GrokXAIConfig.fromObject = function fromObject(object) {
                    if (object instanceof $root.oracle_job.OracleJob.LlmTask.GrokXAIConfig)
                        return object;
                    let message = new $root.oracle_job.OracleJob.LlmTask.GrokXAIConfig();
                    if (object.model != null)
                        message.model = String(object.model);
                    if (object.userPrompt != null)
                        message.userPrompt = String(object.userPrompt);
                    if (object.temperature != null)
                        message.temperature = Number(object.temperature);
                    if (object.secretNameApiKey != null)
                        message.secretNameApiKey = String(object.secretNameApiKey);
                    return message;
                };

                /**
                 * Creates a plain object from a GrokXAIConfig message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof oracle_job.OracleJob.LlmTask.GrokXAIConfig
                 * @static
                 * @param {oracle_job.OracleJob.LlmTask.GrokXAIConfig} message GrokXAIConfig
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GrokXAIConfig.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.model = "";
                        object.userPrompt = "";
                        object.temperature = 0;
                        object.secretNameApiKey = "";
                    }
                    if (message.model != null && message.hasOwnProperty("model"))
                        object.model = message.model;
                    if (message.userPrompt != null && message.hasOwnProperty("userPrompt"))
                        object.userPrompt = message.userPrompt;
                    if (message.temperature != null && message.hasOwnProperty("temperature"))
                        object.temperature = options.json && !isFinite(message.temperature) ? String(message.temperature) : message.temperature;
                    if (message.secretNameApiKey != null && message.hasOwnProperty("secretNameApiKey"))
                        object.secretNameApiKey = message.secretNameApiKey;
                    return object;
                };

                /**
                 * Converts this GrokXAIConfig to JSON.
                 * @function toJSON
                 * @memberof oracle_job.OracleJob.LlmTask.GrokXAIConfig
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GrokXAIConfig.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for GrokXAIConfig
                 * @function getTypeUrl
                 * @memberof oracle_job.OracleJob.LlmTask.GrokXAIConfig
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                GrokXAIConfig.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/oracle_job.OracleJob.LlmTask.GrokXAIConfig";
                };

                return GrokXAIConfig;
            })();

            return LlmTask;
        })();

        OracleJob.SolayerSusdTask = (function() {

            /**
             * Properties of a SolayerSusdTask.
             * @memberof oracle_job.OracleJob
             * @interface ISolayerSusdTask
             */

            /**
             * Constructs a new SolayerSusdTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Fetch the current price of Solayer's sUSD stablecoin by reading its interest-bearing mint configuration.
             * 
             * _**Input**_: None
             * 
             * _**Returns**_: The current price of sUSD relative to USD (1.0 = $1.00)
             * 
             * _**Example**_: Fetch the current sUSD price
             * 
             * ```json
             * { "solayerSusdTask": {} }
             * ```
             * @implements ISolayerSusdTask
             * @constructor
             * @param {oracle_job.OracleJob.ISolayerSusdTask=} [properties] Properties to set
             */
            function SolayerSusdTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SolayerSusdTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.SolayerSusdTask
             * @static
             * @param {oracle_job.OracleJob.ISolayerSusdTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.SolayerSusdTask} SolayerSusdTask instance
             */
            SolayerSusdTask.create = function create(properties) {
      return SolayerSusdTask.fromObject(properties);
    };

            /**
             * Encodes the specified SolayerSusdTask message. Does not implicitly {@link oracle_job.OracleJob.SolayerSusdTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.SolayerSusdTask
             * @static
             * @param {oracle_job.OracleJob.ISolayerSusdTask} message SolayerSusdTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SolayerSusdTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SolayerSusdTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.SolayerSusdTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.SolayerSusdTask
             * @static
             * @param {oracle_job.OracleJob.ISolayerSusdTask} message SolayerSusdTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SolayerSusdTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SolayerSusdTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.SolayerSusdTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.SolayerSusdTask} SolayerSusdTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SolayerSusdTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.SolayerSusdTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SolayerSusdTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.SolayerSusdTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.SolayerSusdTask} SolayerSusdTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SolayerSusdTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SolayerSusdTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.SolayerSusdTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SolayerSusdTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SolayerSusdTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.SolayerSusdTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.SolayerSusdTask} SolayerSusdTask
             */
            SolayerSusdTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.SolayerSusdTask)
                    return object;
                return new $root.oracle_job.OracleJob.SolayerSusdTask();
            };

            /**
             * Creates a plain object from a SolayerSusdTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.SolayerSusdTask
             * @static
             * @param {oracle_job.OracleJob.SolayerSusdTask} message SolayerSusdTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SolayerSusdTask.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SolayerSusdTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.SolayerSusdTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SolayerSusdTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SolayerSusdTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.SolayerSusdTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SolayerSusdTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.SolayerSusdTask";
            };

            return SolayerSusdTask;
        })();

        OracleJob.CurveFinanceTask = (function() {

            /**
             * Properties of a CurveFinanceTask.
             * @memberof oracle_job.OracleJob
             * @interface ICurveFinanceTask
             * @property {oracle_job.OracleJob.CurveFinanceTask.Chain|null} [chain] Required. Specifies which blockchain to use when reading information from Curve Finance.
             * @property {string|null} [provider] Optional. The RPC endpoint to use for blockchain requests. If not specified, a default RPC will be used which may have rate limits.
             * @property {string|null} [poolAddress] The on-chain address of the Curve Finance pool to fetch pricing data from.
             * @property {number|null} [outDecimals] The number of decimal places to include in the returned price value.
             */

            /**
             * Constructs a new CurveFinanceTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Fetch pricing information from Curve Finance pools.
             * 
             * _**Input**_: None
             * 
             * _**Returns**_: The current price/exchange rate from the specified Curve pool.
             * 
             * _**Example**_: Fetch the price from a Curve pool on Ethereum
             * 
             * ```json
             * {
             * "curveFinanceTask": {
             * "chain": "CHAIN_ETHEREUM",
             * "poolAddress": "0xbebc44782c7db0a1a60cb6fe97d0b483032ff1c7",
             * "outDecimals": 18
             * }
             * }
             * ```
             * 
             * _**Example**_: Fetch the price using a custom RPC provider
             * 
             * ```json
             * {
             * "curveFinanceTask": {
             * "chain": "CHAIN_ETHEREUM",
             * "provider": "https://eth-mainnet.g.alchemy.com/v2/YOUR-API-KEY",
             * "poolAddress": "0xbebc44782c7db0a1a60cb6fe97d0b483032ff1c7",
             * "outDecimals": 18
             * }
             * }
             * ```
             * @implements ICurveFinanceTask
             * @constructor
             * @param {oracle_job.OracleJob.ICurveFinanceTask=} [properties] Properties to set
             */
            function CurveFinanceTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Required. Specifies which blockchain to use when reading information from Curve Finance.
             * @member {oracle_job.OracleJob.CurveFinanceTask.Chain} chain
             * @memberof oracle_job.OracleJob.CurveFinanceTask
             * @instance
             */
            CurveFinanceTask.prototype.chain = 0;

            /**
             * Optional. The RPC endpoint to use for blockchain requests. If not specified, a default RPC will be used which may have rate limits.
             * @member {string} provider
             * @memberof oracle_job.OracleJob.CurveFinanceTask
             * @instance
             */
            CurveFinanceTask.prototype.provider = "";

            /**
             * The on-chain address of the Curve Finance pool to fetch pricing data from.
             * @member {string} poolAddress
             * @memberof oracle_job.OracleJob.CurveFinanceTask
             * @instance
             */
            CurveFinanceTask.prototype.poolAddress = "";

            /**
             * The number of decimal places to include in the returned price value.
             * @member {number} outDecimals
             * @memberof oracle_job.OracleJob.CurveFinanceTask
             * @instance
             */
            CurveFinanceTask.prototype.outDecimals = 0;

            /**
             * Creates a new CurveFinanceTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.CurveFinanceTask
             * @static
             * @param {oracle_job.OracleJob.ICurveFinanceTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.CurveFinanceTask} CurveFinanceTask instance
             */
            CurveFinanceTask.create = function create(properties) {
      return CurveFinanceTask.fromObject(properties);
    };

            /**
             * Encodes the specified CurveFinanceTask message. Does not implicitly {@link oracle_job.OracleJob.CurveFinanceTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.CurveFinanceTask
             * @static
             * @param {oracle_job.OracleJob.ICurveFinanceTask} message CurveFinanceTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CurveFinanceTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.chain != null && Object.hasOwnProperty.call(message, "chain"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.chain);
                if (message.provider != null && Object.hasOwnProperty.call(message, "provider"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.provider);
                if (message.poolAddress != null && Object.hasOwnProperty.call(message, "poolAddress"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.poolAddress);
                if (message.outDecimals != null && Object.hasOwnProperty.call(message, "outDecimals"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.outDecimals);
                return writer;
            };

            /**
             * Encodes the specified CurveFinanceTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.CurveFinanceTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.CurveFinanceTask
             * @static
             * @param {oracle_job.OracleJob.ICurveFinanceTask} message CurveFinanceTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CurveFinanceTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CurveFinanceTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.CurveFinanceTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.CurveFinanceTask} CurveFinanceTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CurveFinanceTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.CurveFinanceTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.chain = reader.int32();
                            break;
                        }
                    case 2: {
                            message.provider = reader.string();
                            break;
                        }
                    case 3: {
                            message.poolAddress = reader.string();
                            break;
                        }
                    case 4: {
                            message.outDecimals = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CurveFinanceTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.CurveFinanceTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.CurveFinanceTask} CurveFinanceTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CurveFinanceTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CurveFinanceTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.CurveFinanceTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CurveFinanceTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.chain != null && message.hasOwnProperty("chain"))
                    switch (message.chain) {
                    default:
                        return "chain: enum value expected";
                    case 0:
                        break;
                    }
                if (message.provider != null && message.hasOwnProperty("provider"))
                    if (!$util.isString(message.provider))
                        return "provider: string expected";
                if (message.poolAddress != null && message.hasOwnProperty("poolAddress"))
                    if (!$util.isString(message.poolAddress))
                        return "poolAddress: string expected";
                if (message.outDecimals != null && message.hasOwnProperty("outDecimals"))
                    if (!$util.isInteger(message.outDecimals))
                        return "outDecimals: integer expected";
                return null;
            };

            /**
             * Creates a CurveFinanceTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.CurveFinanceTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.CurveFinanceTask} CurveFinanceTask
             */
            CurveFinanceTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.CurveFinanceTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.CurveFinanceTask();
                switch (object.chain) {
                default:
                    if (typeof object.chain === "number") {
                        message.chain = object.chain;
                        break;
                    }
                    break;
                case "CHAIN_ETHEREUM":
                case 0:
                    message.chain = 0;
                    break;
                }
                if (object.provider != null)
                    message.provider = String(object.provider);
                if (object.poolAddress != null)
                    message.poolAddress = String(object.poolAddress);
                if (object.outDecimals != null)
                    message.outDecimals = object.outDecimals >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a CurveFinanceTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.CurveFinanceTask
             * @static
             * @param {oracle_job.OracleJob.CurveFinanceTask} message CurveFinanceTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CurveFinanceTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.chain = options.enums === String ? "CHAIN_ETHEREUM" : 0;
                    object.provider = "";
                    object.poolAddress = "";
                    object.outDecimals = 0;
                }
                if (message.chain != null && message.hasOwnProperty("chain"))
                    object.chain = options.enums === String ? $root.oracle_job.OracleJob.CurveFinanceTask.Chain[message.chain] === undefined ? message.chain : $root.oracle_job.OracleJob.CurveFinanceTask.Chain[message.chain] : message.chain;
                if (message.provider != null && message.hasOwnProperty("provider"))
                    object.provider = message.provider;
                if (message.poolAddress != null && message.hasOwnProperty("poolAddress"))
                    object.poolAddress = message.poolAddress;
                if (message.outDecimals != null && message.hasOwnProperty("outDecimals"))
                    object.outDecimals = message.outDecimals;
                return object;
            };

            /**
             * Converts this CurveFinanceTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.CurveFinanceTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CurveFinanceTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CurveFinanceTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.CurveFinanceTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CurveFinanceTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.CurveFinanceTask";
            };

            /**
             * Chain enum.
             * @name oracle_job.OracleJob.CurveFinanceTask.Chain
             * @enum {number}
             * @property {number} CHAIN_ETHEREUM=0 Use the Ethereum blockchain for fetching Curve Finance data
             */
            CurveFinanceTask.Chain = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "CHAIN_ETHEREUM"] = 0;
                return values;
            })();

            return CurveFinanceTask;
        })();

        OracleJob.TurboEthRedemptionRateTask = (function() {

            /**
             * Properties of a TurboEthRedemptionRateTask.
             * @memberof oracle_job.OracleJob
             * @interface ITurboEthRedemptionRateTask
             * @property {string|null} [provider] TurboEthRedemptionRateTask provider
             */

            /**
             * Constructs a new TurboEthRedemptionRateTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Fetches tETH/WETH redemption rate
             * @implements ITurboEthRedemptionRateTask
             * @constructor
             * @param {oracle_job.OracleJob.ITurboEthRedemptionRateTask=} [properties] Properties to set
             */
            function TurboEthRedemptionRateTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TurboEthRedemptionRateTask provider.
             * @member {string} provider
             * @memberof oracle_job.OracleJob.TurboEthRedemptionRateTask
             * @instance
             */
            TurboEthRedemptionRateTask.prototype.provider = "";

            /**
             * Creates a new TurboEthRedemptionRateTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.TurboEthRedemptionRateTask
             * @static
             * @param {oracle_job.OracleJob.ITurboEthRedemptionRateTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.TurboEthRedemptionRateTask} TurboEthRedemptionRateTask instance
             */
            TurboEthRedemptionRateTask.create = function create(properties) {
      return TurboEthRedemptionRateTask.fromObject(properties);
    };

            /**
             * Encodes the specified TurboEthRedemptionRateTask message. Does not implicitly {@link oracle_job.OracleJob.TurboEthRedemptionRateTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.TurboEthRedemptionRateTask
             * @static
             * @param {oracle_job.OracleJob.ITurboEthRedemptionRateTask} message TurboEthRedemptionRateTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TurboEthRedemptionRateTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.provider != null && Object.hasOwnProperty.call(message, "provider"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.provider);
                return writer;
            };

            /**
             * Encodes the specified TurboEthRedemptionRateTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.TurboEthRedemptionRateTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.TurboEthRedemptionRateTask
             * @static
             * @param {oracle_job.OracleJob.ITurboEthRedemptionRateTask} message TurboEthRedemptionRateTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TurboEthRedemptionRateTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TurboEthRedemptionRateTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.TurboEthRedemptionRateTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.TurboEthRedemptionRateTask} TurboEthRedemptionRateTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TurboEthRedemptionRateTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.TurboEthRedemptionRateTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.provider = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TurboEthRedemptionRateTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.TurboEthRedemptionRateTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.TurboEthRedemptionRateTask} TurboEthRedemptionRateTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TurboEthRedemptionRateTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TurboEthRedemptionRateTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.TurboEthRedemptionRateTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TurboEthRedemptionRateTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.provider != null && message.hasOwnProperty("provider"))
                    if (!$util.isString(message.provider))
                        return "provider: string expected";
                return null;
            };

            /**
             * Creates a TurboEthRedemptionRateTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.TurboEthRedemptionRateTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.TurboEthRedemptionRateTask} TurboEthRedemptionRateTask
             */
            TurboEthRedemptionRateTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.TurboEthRedemptionRateTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.TurboEthRedemptionRateTask();
                if (object.provider != null)
                    message.provider = String(object.provider);
                return message;
            };

            /**
             * Creates a plain object from a TurboEthRedemptionRateTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.TurboEthRedemptionRateTask
             * @static
             * @param {oracle_job.OracleJob.TurboEthRedemptionRateTask} message TurboEthRedemptionRateTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TurboEthRedemptionRateTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.provider = "";
                if (message.provider != null && message.hasOwnProperty("provider"))
                    object.provider = message.provider;
                return object;
            };

            /**
             * Converts this TurboEthRedemptionRateTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.TurboEthRedemptionRateTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TurboEthRedemptionRateTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TurboEthRedemptionRateTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.TurboEthRedemptionRateTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TurboEthRedemptionRateTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.TurboEthRedemptionRateTask";
            };

            return TurboEthRedemptionRateTask;
        })();

        OracleJob.BitFluxTask = (function() {

            /**
             * Properties of a BitFluxTask.
             * @memberof oracle_job.OracleJob
             * @interface IBitFluxTask
             * @property {string|null} [provider] Optional. The RPC endpoint to use for requests. If not specified, a default RPC will be used.
             * @property {string|null} [poolAddress] The address of the BitFlux pool.
             * @property {string|null} [inToken] The address of the input token.
             * @property {string|null} [outToken] The address of the output token.
             */

            /**
             * Constructs a new BitFluxTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Fetch the current swap price from a BitFlux pool.
             * 
             * _**Input**_: None
             * 
             * _**Returns**_: The swap price between the specified input and output tokens.
             * 
             * _**Example**_: Fetch the swap price using a custom RPC provider
             * 
             * ```json
             * {
             * "bitFluxTask": {
             * "provider": "https://my-custom-rpc.example.com",
             * "poolAddress": "0x0000000000000000000000000000000000000000",
             * "inToken": "0x0000000000000000000000000000000000000000",
             * "outToken": "0x0000000000000000000000000000000000000000"
             * }
             * }
             * ```
             * @implements IBitFluxTask
             * @constructor
             * @param {oracle_job.OracleJob.IBitFluxTask=} [properties] Properties to set
             */
            function BitFluxTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Optional. The RPC endpoint to use for requests. If not specified, a default RPC will be used.
             * @member {string} provider
             * @memberof oracle_job.OracleJob.BitFluxTask
             * @instance
             */
            BitFluxTask.prototype.provider = "";

            /**
             * The address of the BitFlux pool.
             * @member {string} poolAddress
             * @memberof oracle_job.OracleJob.BitFluxTask
             * @instance
             */
            BitFluxTask.prototype.poolAddress = "";

            /**
             * The address of the input token.
             * @member {string} inToken
             * @memberof oracle_job.OracleJob.BitFluxTask
             * @instance
             */
            BitFluxTask.prototype.inToken = "";

            /**
             * The address of the output token.
             * @member {string} outToken
             * @memberof oracle_job.OracleJob.BitFluxTask
             * @instance
             */
            BitFluxTask.prototype.outToken = "";

            /**
             * Creates a new BitFluxTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.BitFluxTask
             * @static
             * @param {oracle_job.OracleJob.IBitFluxTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.BitFluxTask} BitFluxTask instance
             */
            BitFluxTask.create = function create(properties) {
      return BitFluxTask.fromObject(properties);
    };

            /**
             * Encodes the specified BitFluxTask message. Does not implicitly {@link oracle_job.OracleJob.BitFluxTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.BitFluxTask
             * @static
             * @param {oracle_job.OracleJob.IBitFluxTask} message BitFluxTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BitFluxTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.provider != null && Object.hasOwnProperty.call(message, "provider"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.provider);
                if (message.poolAddress != null && Object.hasOwnProperty.call(message, "poolAddress"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.poolAddress);
                if (message.inToken != null && Object.hasOwnProperty.call(message, "inToken"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.inToken);
                if (message.outToken != null && Object.hasOwnProperty.call(message, "outToken"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.outToken);
                return writer;
            };

            /**
             * Encodes the specified BitFluxTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.BitFluxTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.BitFluxTask
             * @static
             * @param {oracle_job.OracleJob.IBitFluxTask} message BitFluxTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BitFluxTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BitFluxTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.BitFluxTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.BitFluxTask} BitFluxTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BitFluxTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.BitFluxTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.provider = reader.string();
                            break;
                        }
                    case 2: {
                            message.poolAddress = reader.string();
                            break;
                        }
                    case 3: {
                            message.inToken = reader.string();
                            break;
                        }
                    case 4: {
                            message.outToken = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BitFluxTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.BitFluxTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.BitFluxTask} BitFluxTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BitFluxTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BitFluxTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.BitFluxTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BitFluxTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.provider != null && message.hasOwnProperty("provider"))
                    if (!$util.isString(message.provider))
                        return "provider: string expected";
                if (message.poolAddress != null && message.hasOwnProperty("poolAddress"))
                    if (!$util.isString(message.poolAddress))
                        return "poolAddress: string expected";
                if (message.inToken != null && message.hasOwnProperty("inToken"))
                    if (!$util.isString(message.inToken))
                        return "inToken: string expected";
                if (message.outToken != null && message.hasOwnProperty("outToken"))
                    if (!$util.isString(message.outToken))
                        return "outToken: string expected";
                return null;
            };

            /**
             * Creates a BitFluxTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.BitFluxTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.BitFluxTask} BitFluxTask
             */
            BitFluxTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.BitFluxTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.BitFluxTask();
                if (object.provider != null)
                    message.provider = String(object.provider);
                if (object.poolAddress != null)
                    message.poolAddress = String(object.poolAddress);
                if (object.inToken != null)
                    message.inToken = String(object.inToken);
                if (object.outToken != null)
                    message.outToken = String(object.outToken);
                return message;
            };

            /**
             * Creates a plain object from a BitFluxTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.BitFluxTask
             * @static
             * @param {oracle_job.OracleJob.BitFluxTask} message BitFluxTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BitFluxTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.provider = "";
                    object.poolAddress = "";
                    object.inToken = "";
                    object.outToken = "";
                }
                if (message.provider != null && message.hasOwnProperty("provider"))
                    object.provider = message.provider;
                if (message.poolAddress != null && message.hasOwnProperty("poolAddress"))
                    object.poolAddress = message.poolAddress;
                if (message.inToken != null && message.hasOwnProperty("inToken"))
                    object.inToken = message.inToken;
                if (message.outToken != null && message.hasOwnProperty("outToken"))
                    object.outToken = message.outToken;
                return object;
            };

            /**
             * Converts this BitFluxTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.BitFluxTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BitFluxTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BitFluxTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.BitFluxTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BitFluxTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.BitFluxTask";
            };

            return BitFluxTask;
        })();

        OracleJob.FragmetricTask = (function() {

            /**
             * Properties of a FragmetricTask.
             * @memberof oracle_job.OracleJob
             * @interface IFragmetricTask
             * @property {oracle_job.OracleJob.FragmetricTask.Token|null} [token] The Fragmetric token to fetch the price for
             */

            /**
             * Constructs a new FragmetricTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Fetch the current price for Fragmetric liquid restaking tokens.
             * 
             * _**Input**_: None
             * 
             * _**Returns**_: The current price of the specified Fragmetric token relative to SOL (1.0 = 1 SOL)
             * 
             * _**Example**_: Fetch the fragSOL token price
             * 
             * ```json
             * { "fragmetricTask": { "token": "TOKEN_FRAG_SOL" } }
             * ```
             * @implements IFragmetricTask
             * @constructor
             * @param {oracle_job.OracleJob.IFragmetricTask=} [properties] Properties to set
             */
            function FragmetricTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The Fragmetric token to fetch the price for
             * @member {oracle_job.OracleJob.FragmetricTask.Token} token
             * @memberof oracle_job.OracleJob.FragmetricTask
             * @instance
             */
            FragmetricTask.prototype.token = 0;

            /**
             * Creates a new FragmetricTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.FragmetricTask
             * @static
             * @param {oracle_job.OracleJob.IFragmetricTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.FragmetricTask} FragmetricTask instance
             */
            FragmetricTask.create = function create(properties) {
      return FragmetricTask.fromObject(properties);
    };

            /**
             * Encodes the specified FragmetricTask message. Does not implicitly {@link oracle_job.OracleJob.FragmetricTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.FragmetricTask
             * @static
             * @param {oracle_job.OracleJob.IFragmetricTask} message FragmetricTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FragmetricTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.token);
                return writer;
            };

            /**
             * Encodes the specified FragmetricTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.FragmetricTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.FragmetricTask
             * @static
             * @param {oracle_job.OracleJob.IFragmetricTask} message FragmetricTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FragmetricTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FragmetricTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.FragmetricTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.FragmetricTask} FragmetricTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FragmetricTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.FragmetricTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.token = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FragmetricTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.FragmetricTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.FragmetricTask} FragmetricTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FragmetricTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FragmetricTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.FragmetricTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FragmetricTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    switch (message.token) {
                    default:
                        return "token: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a FragmetricTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.FragmetricTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.FragmetricTask} FragmetricTask
             */
            FragmetricTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.FragmetricTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.FragmetricTask();
                switch (object.token) {
                default:
                    if (typeof object.token === "number") {
                        message.token = object.token;
                        break;
                    }
                    break;
                case "TOKEN_FRAG_SOL":
                case 0:
                    message.token = 0;
                    break;
                case "TOKEN_N_SOL":
                case 1:
                    message.token = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a FragmetricTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.FragmetricTask
             * @static
             * @param {oracle_job.OracleJob.FragmetricTask} message FragmetricTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FragmetricTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.token = options.enums === String ? "TOKEN_FRAG_SOL" : 0;
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = options.enums === String ? $root.oracle_job.OracleJob.FragmetricTask.Token[message.token] === undefined ? message.token : $root.oracle_job.OracleJob.FragmetricTask.Token[message.token] : message.token;
                return object;
            };

            /**
             * Converts this FragmetricTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.FragmetricTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FragmetricTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FragmetricTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.FragmetricTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FragmetricTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.FragmetricTask";
            };

            /**
             * Token enum.
             * @name oracle_job.OracleJob.FragmetricTask.Token
             * @enum {number}
             * @property {number} TOKEN_FRAG_SOL=0 Fragmetric's liquid restaking token (fragSOL)
             * @property {number} TOKEN_N_SOL=1 Fragmetric's native staking token (nSOL)
             */
            FragmetricTask.Token = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "TOKEN_FRAG_SOL"] = 0;
                values[valuesById[1] = "TOKEN_N_SOL"] = 1;
                return values;
            })();

            return FragmetricTask;
        })();

        OracleJob.EtherfuseTask = (function() {

            /**
             * Properties of an EtherfuseTask.
             * @memberof oracle_job.OracleJob
             * @interface IEtherfuseTask
             * @property {oracle_job.OracleJob.EtherfuseTask.Token|null} [token] EtherfuseTask token
             */

            /**
             * Constructs a new EtherfuseTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Represents an EtherfuseTask.
             * @implements IEtherfuseTask
             * @constructor
             * @param {oracle_job.OracleJob.IEtherfuseTask=} [properties] Properties to set
             */
            function EtherfuseTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EtherfuseTask token.
             * @member {oracle_job.OracleJob.EtherfuseTask.Token} token
             * @memberof oracle_job.OracleJob.EtherfuseTask
             * @instance
             */
            EtherfuseTask.prototype.token = 0;

            /**
             * Creates a new EtherfuseTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.EtherfuseTask
             * @static
             * @param {oracle_job.OracleJob.IEtherfuseTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.EtherfuseTask} EtherfuseTask instance
             */
            EtherfuseTask.create = function create(properties) {
      return EtherfuseTask.fromObject(properties);
    };

            /**
             * Encodes the specified EtherfuseTask message. Does not implicitly {@link oracle_job.OracleJob.EtherfuseTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.EtherfuseTask
             * @static
             * @param {oracle_job.OracleJob.IEtherfuseTask} message EtherfuseTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EtherfuseTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.token != null && Object.hasOwnProperty.call(message, "token"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.token);
                return writer;
            };

            /**
             * Encodes the specified EtherfuseTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.EtherfuseTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.EtherfuseTask
             * @static
             * @param {oracle_job.OracleJob.IEtherfuseTask} message EtherfuseTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EtherfuseTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EtherfuseTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.EtherfuseTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.EtherfuseTask} EtherfuseTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EtherfuseTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.EtherfuseTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.token = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EtherfuseTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.EtherfuseTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.EtherfuseTask} EtherfuseTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EtherfuseTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EtherfuseTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.EtherfuseTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EtherfuseTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.token != null && message.hasOwnProperty("token"))
                    switch (message.token) {
                    default:
                        return "token: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                return null;
            };

            /**
             * Creates an EtherfuseTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.EtherfuseTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.EtherfuseTask} EtherfuseTask
             */
            EtherfuseTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.EtherfuseTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.EtherfuseTask();
                switch (object.token) {
                default:
                    if (typeof object.token === "number") {
                        message.token = object.token;
                        break;
                    }
                    break;
                case "TOKEN_CETES":
                case 0:
                    message.token = 0;
                    break;
                case "TOKEN_USTRY":
                case 1:
                    message.token = 1;
                    break;
                case "TOKEN_EUROB":
                case 2:
                    message.token = 2;
                    break;
                case "TOKEN_TESOURO":
                case 3:
                    message.token = 3;
                    break;
                case "TOKEN_GILTS":
                case 4:
                    message.token = 4;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from an EtherfuseTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.EtherfuseTask
             * @static
             * @param {oracle_job.OracleJob.EtherfuseTask} message EtherfuseTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EtherfuseTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.token = options.enums === String ? "TOKEN_CETES" : 0;
                if (message.token != null && message.hasOwnProperty("token"))
                    object.token = options.enums === String ? $root.oracle_job.OracleJob.EtherfuseTask.Token[message.token] === undefined ? message.token : $root.oracle_job.OracleJob.EtherfuseTask.Token[message.token] : message.token;
                return object;
            };

            /**
             * Converts this EtherfuseTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.EtherfuseTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EtherfuseTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EtherfuseTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.EtherfuseTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EtherfuseTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.EtherfuseTask";
            };

            /**
             * Token enum.
             * @name oracle_job.OracleJob.EtherfuseTask.Token
             * @enum {number}
             * @property {number} TOKEN_CETES=0 TOKEN_CETES value
             * @property {number} TOKEN_USTRY=1 TOKEN_USTRY value
             * @property {number} TOKEN_EUROB=2 TOKEN_EUROB value
             * @property {number} TOKEN_TESOURO=3 TOKEN_TESOURO value
             * @property {number} TOKEN_GILTS=4 TOKEN_GILTS value
             */
            EtherfuseTask.Token = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "TOKEN_CETES"] = 0;
                values[valuesById[1] = "TOKEN_USTRY"] = 1;
                values[valuesById[2] = "TOKEN_EUROB"] = 2;
                values[valuesById[3] = "TOKEN_TESOURO"] = 3;
                values[valuesById[4] = "TOKEN_GILTS"] = 4;
                return values;
            })();

            return EtherfuseTask;
        })();

        OracleJob.LstHistoricalYieldTask = (function() {

            /**
             * Properties of a LstHistoricalYieldTask.
             * @memberof oracle_job.OracleJob
             * @interface ILstHistoricalYieldTask
             * @property {string|null} [lstMint] Required. The LST mint address for which historical yield data is queried.
             * @property {oracle_job.OracleJob.LstHistoricalYieldTask.Operation|null} [operation] Required. The statistical operation to apply to the historical yield dataset.
             * @property {number|null} [epochs] Optional. The number of epochs to sample for the computation.
             * - If `epochs = 0`, all available historical data will be used.
             * - If `epochs > 0`, only the last `epochs` entries will be included.
             */

            /**
             * Constructs a new LstHistoricalYieldTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Query historical yield data for a given Liquid Staking Token (LST)
             * and perform a statistical reduction operation over the dataset.
             * 
             * _**Input**_: LST mint address, reduction operation type, and number of epochs to sample.
             * 
             * _**Returns**_: The computed yield value based on the specified operation.
             * 
             * _**Example**_: Compute the median APY for an LST over the last 100 epochs
             * 
             * ```json
             * {
             * "lstHistoricalYieldTask": {
             * "lstMint": "J1toso1uCk3RLmjorhTtrVwY9HJ7X8V9yYac6Y7kGCPn",
             * "operation": "OPERATION_MEDIAN",
             * "epochs": 100
             * }
             * }
             * @implements ILstHistoricalYieldTask
             * @constructor
             * @param {oracle_job.OracleJob.ILstHistoricalYieldTask=} [properties] Properties to set
             */
            function LstHistoricalYieldTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Required. The LST mint address for which historical yield data is queried.
             * @member {string} lstMint
             * @memberof oracle_job.OracleJob.LstHistoricalYieldTask
             * @instance
             */
            LstHistoricalYieldTask.prototype.lstMint = "";

            /**
             * Required. The statistical operation to apply to the historical yield dataset.
             * @member {oracle_job.OracleJob.LstHistoricalYieldTask.Operation} operation
             * @memberof oracle_job.OracleJob.LstHistoricalYieldTask
             * @instance
             */
            LstHistoricalYieldTask.prototype.operation = 0;

            /**
             * Optional. The number of epochs to sample for the computation.
             * - If `epochs = 0`, all available historical data will be used.
             * - If `epochs > 0`, only the last `epochs` entries will be included.
             * @member {number} epochs
             * @memberof oracle_job.OracleJob.LstHistoricalYieldTask
             * @instance
             */
            LstHistoricalYieldTask.prototype.epochs = 0;

            /**
             * Creates a new LstHistoricalYieldTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.LstHistoricalYieldTask
             * @static
             * @param {oracle_job.OracleJob.ILstHistoricalYieldTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.LstHistoricalYieldTask} LstHistoricalYieldTask instance
             */
            LstHistoricalYieldTask.create = function create(properties) {
      return LstHistoricalYieldTask.fromObject(properties);
    };

            /**
             * Encodes the specified LstHistoricalYieldTask message. Does not implicitly {@link oracle_job.OracleJob.LstHistoricalYieldTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.LstHistoricalYieldTask
             * @static
             * @param {oracle_job.OracleJob.ILstHistoricalYieldTask} message LstHistoricalYieldTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LstHistoricalYieldTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.lstMint != null && Object.hasOwnProperty.call(message, "lstMint"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.lstMint);
                if (message.operation != null && Object.hasOwnProperty.call(message, "operation"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.operation);
                if (message.epochs != null && Object.hasOwnProperty.call(message, "epochs"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.epochs);
                return writer;
            };

            /**
             * Encodes the specified LstHistoricalYieldTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.LstHistoricalYieldTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.LstHistoricalYieldTask
             * @static
             * @param {oracle_job.OracleJob.ILstHistoricalYieldTask} message LstHistoricalYieldTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LstHistoricalYieldTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LstHistoricalYieldTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.LstHistoricalYieldTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.LstHistoricalYieldTask} LstHistoricalYieldTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LstHistoricalYieldTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.LstHistoricalYieldTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.lstMint = reader.string();
                            break;
                        }
                    case 2: {
                            message.operation = reader.int32();
                            break;
                        }
                    case 3: {
                            message.epochs = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LstHistoricalYieldTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.LstHistoricalYieldTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.LstHistoricalYieldTask} LstHistoricalYieldTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LstHistoricalYieldTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LstHistoricalYieldTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.LstHistoricalYieldTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LstHistoricalYieldTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.lstMint != null && message.hasOwnProperty("lstMint"))
                    if (!$util.isString(message.lstMint))
                        return "lstMint: string expected";
                if (message.operation != null && message.hasOwnProperty("operation"))
                    switch (message.operation) {
                    default:
                        return "operation: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.epochs != null && message.hasOwnProperty("epochs"))
                    if (!$util.isInteger(message.epochs))
                        return "epochs: integer expected";
                return null;
            };

            /**
             * Creates a LstHistoricalYieldTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.LstHistoricalYieldTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.LstHistoricalYieldTask} LstHistoricalYieldTask
             */
            LstHistoricalYieldTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.LstHistoricalYieldTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.LstHistoricalYieldTask();
                if (object.lstMint != null)
                    message.lstMint = String(object.lstMint);
                switch (object.operation) {
                default:
                    if (typeof object.operation === "number") {
                        message.operation = object.operation;
                        break;
                    }
                    break;
                case "OPERATION_MEDIAN":
                case 0:
                    message.operation = 0;
                    break;
                case "OPERATION_MEAN":
                case 1:
                    message.operation = 1;
                    break;
                case "OPERATION_MIN":
                case 2:
                    message.operation = 2;
                    break;
                case "OPERATION_MAX":
                case 3:
                    message.operation = 3;
                    break;
                }
                if (object.epochs != null)
                    message.epochs = object.epochs | 0;
                return message;
            };

            /**
             * Creates a plain object from a LstHistoricalYieldTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.LstHistoricalYieldTask
             * @static
             * @param {oracle_job.OracleJob.LstHistoricalYieldTask} message LstHistoricalYieldTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LstHistoricalYieldTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.lstMint = "";
                    object.operation = options.enums === String ? "OPERATION_MEDIAN" : 0;
                    object.epochs = 0;
                }
                if (message.lstMint != null && message.hasOwnProperty("lstMint"))
                    object.lstMint = message.lstMint;
                if (message.operation != null && message.hasOwnProperty("operation"))
                    object.operation = options.enums === String ? $root.oracle_job.OracleJob.LstHistoricalYieldTask.Operation[message.operation] === undefined ? message.operation : $root.oracle_job.OracleJob.LstHistoricalYieldTask.Operation[message.operation] : message.operation;
                if (message.epochs != null && message.hasOwnProperty("epochs"))
                    object.epochs = message.epochs;
                return object;
            };

            /**
             * Converts this LstHistoricalYieldTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.LstHistoricalYieldTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LstHistoricalYieldTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LstHistoricalYieldTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.LstHistoricalYieldTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LstHistoricalYieldTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.LstHistoricalYieldTask";
            };

            /**
             * Operation enum.
             * @name oracle_job.OracleJob.LstHistoricalYieldTask.Operation
             * @enum {number}
             * @property {number} OPERATION_MEDIAN=0 OPERATION_MEDIAN value
             * @property {number} OPERATION_MEAN=1 OPERATION_MEAN value
             * @property {number} OPERATION_MIN=2 OPERATION_MIN value
             * @property {number} OPERATION_MAX=3 OPERATION_MAX value
             */
            LstHistoricalYieldTask.Operation = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "OPERATION_MEDIAN"] = 0;
                values[valuesById[1] = "OPERATION_MEAN"] = 1;
                values[valuesById[2] = "OPERATION_MIN"] = 2;
                values[valuesById[3] = "OPERATION_MAX"] = 3;
                return values;
            })();

            return LstHistoricalYieldTask;
        })();

        OracleJob.PumpAmmTask = (function() {

            /**
             * Properties of a PumpAmmTask.
             * @memberof oracle_job.OracleJob
             * @interface IPumpAmmTask
             * @property {string|null} [poolAddress] Required. The address of the liquidity pool in the Pump AMM.
             * @property {number|null} [inAmount] Optional. The input token amount for the swap.
             * - This value should in full units of the input token.
             * - Default value: `1` (Swap 1 full token).
             * @property {number|null} [maxSlippage] Optional. The maximum allowed slippage for the swap, expressed as a percentage.
             * - Example: `0.5` represents 0.5% slippage tolerance.
             * - Default value: `3` (3% slippage tolerance).
             * @property {boolean|null} [isXForY] Optional. Indicates the swap direction:
             * - `true`: Swapping token X for token Y.
             * - `false`: Swapping token Y for token X.
             * - Default value: `true`.
             */

            /**
             * Constructs a new PumpAmmTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Execute a swap task in the Pump AMM based on the given parameters.
             * 
             * _**Input**_: Pool address, input token amount, max allowed slippage, and swap direction.
             * 
             * _**Returns**_: Executes the swap operation in the Pump AMM with the given parameters.
             * 
             * _**Example**_: Swap 10 tokens from X to Y with a maximum slippage of 0.5%
             * 
             * ```json
             * {
             * "pumpAmmTask": {
             * "pool_address": "Gf7sXMoP8iRw4iiXmJ1nq4vxcRycbGXy5RL8a8LnTd3v",
             * "in_amount": "10",
             * "max_slippage": 0.5,
             * "is_x_for_y": true
             * }
             * }
             * @implements IPumpAmmTask
             * @constructor
             * @param {oracle_job.OracleJob.IPumpAmmTask=} [properties] Properties to set
             */
            function PumpAmmTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Required. The address of the liquidity pool in the Pump AMM.
             * @member {string} poolAddress
             * @memberof oracle_job.OracleJob.PumpAmmTask
             * @instance
             */
            PumpAmmTask.prototype.poolAddress = "";

            /**
             * Optional. The input token amount for the swap.
             * - This value should in full units of the input token.
             * - Default value: `1` (Swap 1 full token).
             * @member {number} inAmount
             * @memberof oracle_job.OracleJob.PumpAmmTask
             * @instance
             */
            PumpAmmTask.prototype.inAmount = 0;

            /**
             * Optional. The maximum allowed slippage for the swap, expressed as a percentage.
             * - Example: `0.5` represents 0.5% slippage tolerance.
             * - Default value: `3` (3% slippage tolerance).
             * @member {number} maxSlippage
             * @memberof oracle_job.OracleJob.PumpAmmTask
             * @instance
             */
            PumpAmmTask.prototype.maxSlippage = 0;

            /**
             * Optional. Indicates the swap direction:
             * - `true`: Swapping token X for token Y.
             * - `false`: Swapping token Y for token X.
             * - Default value: `true`.
             * @member {boolean} isXForY
             * @memberof oracle_job.OracleJob.PumpAmmTask
             * @instance
             */
            PumpAmmTask.prototype.isXForY = false;

            /**
             * Creates a new PumpAmmTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.PumpAmmTask
             * @static
             * @param {oracle_job.OracleJob.IPumpAmmTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.PumpAmmTask} PumpAmmTask instance
             */
            PumpAmmTask.create = function create(properties) {
      return PumpAmmTask.fromObject(properties);
    };

            /**
             * Encodes the specified PumpAmmTask message. Does not implicitly {@link oracle_job.OracleJob.PumpAmmTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.PumpAmmTask
             * @static
             * @param {oracle_job.OracleJob.IPumpAmmTask} message PumpAmmTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PumpAmmTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.poolAddress != null && Object.hasOwnProperty.call(message, "poolAddress"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.poolAddress);
                if (message.inAmount != null && Object.hasOwnProperty.call(message, "inAmount"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.inAmount);
                if (message.maxSlippage != null && Object.hasOwnProperty.call(message, "maxSlippage"))
                    writer.uint32(/* id 3, wireType 1 =*/25).double(message.maxSlippage);
                if (message.isXForY != null && Object.hasOwnProperty.call(message, "isXForY"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isXForY);
                return writer;
            };

            /**
             * Encodes the specified PumpAmmTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.PumpAmmTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.PumpAmmTask
             * @static
             * @param {oracle_job.OracleJob.IPumpAmmTask} message PumpAmmTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PumpAmmTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PumpAmmTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.PumpAmmTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.PumpAmmTask} PumpAmmTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PumpAmmTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.PumpAmmTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.poolAddress = reader.string();
                            break;
                        }
                    case 2: {
                            message.inAmount = reader.double();
                            break;
                        }
                    case 3: {
                            message.maxSlippage = reader.double();
                            break;
                        }
                    case 4: {
                            message.isXForY = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PumpAmmTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.PumpAmmTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.PumpAmmTask} PumpAmmTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PumpAmmTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PumpAmmTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.PumpAmmTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PumpAmmTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.poolAddress != null && message.hasOwnProperty("poolAddress"))
                    if (!$util.isString(message.poolAddress))
                        return "poolAddress: string expected";
                if (message.inAmount != null && message.hasOwnProperty("inAmount"))
                    if (typeof message.inAmount !== "number")
                        return "inAmount: number expected";
                if (message.maxSlippage != null && message.hasOwnProperty("maxSlippage"))
                    if (typeof message.maxSlippage !== "number")
                        return "maxSlippage: number expected";
                if (message.isXForY != null && message.hasOwnProperty("isXForY"))
                    if (typeof message.isXForY !== "boolean")
                        return "isXForY: boolean expected";
                return null;
            };

            /**
             * Creates a PumpAmmTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.PumpAmmTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.PumpAmmTask} PumpAmmTask
             */
            PumpAmmTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.PumpAmmTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.PumpAmmTask();
                if (object.poolAddress != null)
                    message.poolAddress = String(object.poolAddress);
                if (object.inAmount != null)
                    message.inAmount = Number(object.inAmount);
                if (object.maxSlippage != null)
                    message.maxSlippage = Number(object.maxSlippage);
                if (object.isXForY != null)
                    message.isXForY = Boolean(object.isXForY);
                return message;
            };

            /**
             * Creates a plain object from a PumpAmmTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.PumpAmmTask
             * @static
             * @param {oracle_job.OracleJob.PumpAmmTask} message PumpAmmTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PumpAmmTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.poolAddress = "";
                    object.inAmount = 0;
                    object.maxSlippage = 0;
                    object.isXForY = false;
                }
                if (message.poolAddress != null && message.hasOwnProperty("poolAddress"))
                    object.poolAddress = message.poolAddress;
                if (message.inAmount != null && message.hasOwnProperty("inAmount"))
                    object.inAmount = options.json && !isFinite(message.inAmount) ? String(message.inAmount) : message.inAmount;
                if (message.maxSlippage != null && message.hasOwnProperty("maxSlippage"))
                    object.maxSlippage = options.json && !isFinite(message.maxSlippage) ? String(message.maxSlippage) : message.maxSlippage;
                if (message.isXForY != null && message.hasOwnProperty("isXForY"))
                    object.isXForY = message.isXForY;
                return object;
            };

            /**
             * Converts this PumpAmmTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.PumpAmmTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PumpAmmTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PumpAmmTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.PumpAmmTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PumpAmmTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.PumpAmmTask";
            };

            return PumpAmmTask;
        })();

        OracleJob.PumpAmmLpTokenPriceTask = (function() {

            /**
             * Properties of a PumpAmmLpTokenPriceTask.
             * @memberof oracle_job.OracleJob
             * @interface IPumpAmmLpTokenPriceTask
             * @property {string|null} [poolAddress] Required. The address of the liquidity pool in the Pump AMM.
             * @property {oracle_job.IOracleJob|null} [xPriceJob] Required. The job to execute to fetch the price of the pool x token
             * @property {oracle_job.IOracleJob|null} [yPriceJob] Required. The job to execute
             */

            /**
             * Constructs a new PumpAmmLpTokenPriceTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Derive the fair LP token price for a given Pump AMM liquidity pool.
             * 
             * _**Input**_: Pool address, X token price job, Y token price job.
             * _**Returns**_: The fair LP token price for the given Pump AMM liquidity pool.
             * _**Example**_: Derive the fair LP token price for a given Pump AMM liquidity pool.
             * ```json
             * {
             * "pumpAmmLpTokenPriceTask": {
             * "pool_address": "Gf7sXMoP8iRw4iiXmJ1nq4vxcRycbGXy5RL8a8LnTd3v", // USDC/SOL
             * "x_price_job": {
             * "oracleTask": {
             * "switchboardAddress": "..." // USDC/USD
             * }
             * },
             * "y_price_job": {
             * "oracleTask": {
             * "switchboardAddress": "..." // SOL/USD
             * }
             * }
             * }
             * }
             * @implements IPumpAmmLpTokenPriceTask
             * @constructor
             * @param {oracle_job.OracleJob.IPumpAmmLpTokenPriceTask=} [properties] Properties to set
             */
            function PumpAmmLpTokenPriceTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Required. The address of the liquidity pool in the Pump AMM.
             * @member {string} poolAddress
             * @memberof oracle_job.OracleJob.PumpAmmLpTokenPriceTask
             * @instance
             */
            PumpAmmLpTokenPriceTask.prototype.poolAddress = "";

            /**
             * Required. The job to execute to fetch the price of the pool x token
             * @member {oracle_job.IOracleJob|null|undefined} xPriceJob
             * @memberof oracle_job.OracleJob.PumpAmmLpTokenPriceTask
             * @instance
             */
            PumpAmmLpTokenPriceTask.prototype.xPriceJob = null;

            /**
             * Required. The job to execute
             * @member {oracle_job.IOracleJob|null|undefined} yPriceJob
             * @memberof oracle_job.OracleJob.PumpAmmLpTokenPriceTask
             * @instance
             */
            PumpAmmLpTokenPriceTask.prototype.yPriceJob = null;

            /**
             * Creates a new PumpAmmLpTokenPriceTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.PumpAmmLpTokenPriceTask
             * @static
             * @param {oracle_job.OracleJob.IPumpAmmLpTokenPriceTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.PumpAmmLpTokenPriceTask} PumpAmmLpTokenPriceTask instance
             */
            PumpAmmLpTokenPriceTask.create = function create(properties) {
      return PumpAmmLpTokenPriceTask.fromObject(properties);
    };

            /**
             * Encodes the specified PumpAmmLpTokenPriceTask message. Does not implicitly {@link oracle_job.OracleJob.PumpAmmLpTokenPriceTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.PumpAmmLpTokenPriceTask
             * @static
             * @param {oracle_job.OracleJob.IPumpAmmLpTokenPriceTask} message PumpAmmLpTokenPriceTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PumpAmmLpTokenPriceTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.poolAddress != null && Object.hasOwnProperty.call(message, "poolAddress"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.poolAddress);
                if (message.xPriceJob != null && Object.hasOwnProperty.call(message, "xPriceJob"))
                    $root.oracle_job.OracleJob.encode(message.xPriceJob, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.yPriceJob != null && Object.hasOwnProperty.call(message, "yPriceJob"))
                    $root.oracle_job.OracleJob.encode(message.yPriceJob, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PumpAmmLpTokenPriceTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.PumpAmmLpTokenPriceTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.PumpAmmLpTokenPriceTask
             * @static
             * @param {oracle_job.OracleJob.IPumpAmmLpTokenPriceTask} message PumpAmmLpTokenPriceTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PumpAmmLpTokenPriceTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PumpAmmLpTokenPriceTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.PumpAmmLpTokenPriceTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.PumpAmmLpTokenPriceTask} PumpAmmLpTokenPriceTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PumpAmmLpTokenPriceTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.PumpAmmLpTokenPriceTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.poolAddress = reader.string();
                            break;
                        }
                    case 2: {
                            message.xPriceJob = $root.oracle_job.OracleJob.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.yPriceJob = $root.oracle_job.OracleJob.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PumpAmmLpTokenPriceTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.PumpAmmLpTokenPriceTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.PumpAmmLpTokenPriceTask} PumpAmmLpTokenPriceTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PumpAmmLpTokenPriceTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PumpAmmLpTokenPriceTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.PumpAmmLpTokenPriceTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PumpAmmLpTokenPriceTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.poolAddress != null && message.hasOwnProperty("poolAddress"))
                    if (!$util.isString(message.poolAddress))
                        return "poolAddress: string expected";
                if (message.xPriceJob != null && message.hasOwnProperty("xPriceJob")) {
                    let error = $root.oracle_job.OracleJob.verify(message.xPriceJob);
                    if (error)
                        return "xPriceJob." + error;
                }
                if (message.yPriceJob != null && message.hasOwnProperty("yPriceJob")) {
                    let error = $root.oracle_job.OracleJob.verify(message.yPriceJob);
                    if (error)
                        return "yPriceJob." + error;
                }
                return null;
            };

            /**
             * Creates a PumpAmmLpTokenPriceTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.PumpAmmLpTokenPriceTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.PumpAmmLpTokenPriceTask} PumpAmmLpTokenPriceTask
             */
            PumpAmmLpTokenPriceTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.PumpAmmLpTokenPriceTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.PumpAmmLpTokenPriceTask();
                if (object.poolAddress != null)
                    message.poolAddress = String(object.poolAddress);
                if (object.xPriceJob != null) {
                    if (typeof object.xPriceJob !== "object")
                        throw TypeError(".oracle_job.OracleJob.PumpAmmLpTokenPriceTask.xPriceJob: object expected");
                    message.xPriceJob = $root.oracle_job.OracleJob.fromObject(object.xPriceJob);
                }
                if (object.yPriceJob != null) {
                    if (typeof object.yPriceJob !== "object")
                        throw TypeError(".oracle_job.OracleJob.PumpAmmLpTokenPriceTask.yPriceJob: object expected");
                    message.yPriceJob = $root.oracle_job.OracleJob.fromObject(object.yPriceJob);
                }
                return message;
            };

            /**
             * Creates a plain object from a PumpAmmLpTokenPriceTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.PumpAmmLpTokenPriceTask
             * @static
             * @param {oracle_job.OracleJob.PumpAmmLpTokenPriceTask} message PumpAmmLpTokenPriceTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PumpAmmLpTokenPriceTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.poolAddress = "";
                    object.xPriceJob = null;
                    object.yPriceJob = null;
                }
                if (message.poolAddress != null && message.hasOwnProperty("poolAddress"))
                    object.poolAddress = message.poolAddress;
                if (message.xPriceJob != null && message.hasOwnProperty("xPriceJob"))
                    object.xPriceJob = $root.oracle_job.OracleJob.toObject(message.xPriceJob, options);
                if (message.yPriceJob != null && message.hasOwnProperty("yPriceJob"))
                    object.yPriceJob = $root.oracle_job.OracleJob.toObject(message.yPriceJob, options);
                return object;
            };

            /**
             * Converts this PumpAmmLpTokenPriceTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.PumpAmmLpTokenPriceTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PumpAmmLpTokenPriceTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PumpAmmLpTokenPriceTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.PumpAmmLpTokenPriceTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PumpAmmLpTokenPriceTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.PumpAmmLpTokenPriceTask";
            };

            return PumpAmmLpTokenPriceTask;
        })();

        OracleJob.ExponentTask = (function() {

            /**
             * Properties of an ExponentTask.
             * @memberof oracle_job.OracleJob
             * @interface IExponentTask
             * @property {string|null} [vault] ExponentTask vault
             */

            /**
             * Constructs a new ExponentTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Get the exchange rate between and Exponent vault pricipal token and
             * underlying token.
             * _**Input**_: Vault address
             * _**Returns**_: The exchange rate between the vault principal token and
             * underlying token.
             * _**Example**_: Get the exchange rate between the vault principal token and
             * underlying token.
             * ```json
             * {
             * "exponentTask": {
             * "vault": "9YbaicMsXrtupkpD72pdWBfU6R7EJfSByw75sEpDM1uH"
             * }
             * }
             * @implements IExponentTask
             * @constructor
             * @param {oracle_job.OracleJob.IExponentTask=} [properties] Properties to set
             */
            function ExponentTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExponentTask vault.
             * @member {string} vault
             * @memberof oracle_job.OracleJob.ExponentTask
             * @instance
             */
            ExponentTask.prototype.vault = "";

            /**
             * Creates a new ExponentTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.ExponentTask
             * @static
             * @param {oracle_job.OracleJob.IExponentTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.ExponentTask} ExponentTask instance
             */
            ExponentTask.create = function create(properties) {
      return ExponentTask.fromObject(properties);
    };

            /**
             * Encodes the specified ExponentTask message. Does not implicitly {@link oracle_job.OracleJob.ExponentTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.ExponentTask
             * @static
             * @param {oracle_job.OracleJob.IExponentTask} message ExponentTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExponentTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.vault != null && Object.hasOwnProperty.call(message, "vault"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.vault);
                return writer;
            };

            /**
             * Encodes the specified ExponentTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.ExponentTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.ExponentTask
             * @static
             * @param {oracle_job.OracleJob.IExponentTask} message ExponentTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExponentTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExponentTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.ExponentTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.ExponentTask} ExponentTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExponentTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.ExponentTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.vault = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExponentTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.ExponentTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.ExponentTask} ExponentTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExponentTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExponentTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.ExponentTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExponentTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.vault != null && message.hasOwnProperty("vault"))
                    if (!$util.isString(message.vault))
                        return "vault: string expected";
                return null;
            };

            /**
             * Creates an ExponentTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.ExponentTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.ExponentTask} ExponentTask
             */
            ExponentTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.ExponentTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.ExponentTask();
                if (object.vault != null)
                    message.vault = String(object.vault);
                return message;
            };

            /**
             * Creates a plain object from an ExponentTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.ExponentTask
             * @static
             * @param {oracle_job.OracleJob.ExponentTask} message ExponentTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExponentTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.vault = "";
                if (message.vault != null && message.hasOwnProperty("vault"))
                    object.vault = message.vault;
                return object;
            };

            /**
             * Converts this ExponentTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.ExponentTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExponentTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ExponentTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.ExponentTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ExponentTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.ExponentTask";
            };

            return ExponentTask;
        })();

        OracleJob.ExponentPTLinearPricingTask = (function() {

            /**
             * Properties of an ExponentPTLinearPricingTask.
             * @memberof oracle_job.OracleJob
             * @interface IExponentPTLinearPricingTask
             * @property {string|null} [vault] ExponentPTLinearPricingTask vault
             * @property {number|null} [startPrice] ExponentPTLinearPricingTask startPrice
             */

            /**
             * Constructs a new ExponentPTLinearPricingTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Represents an ExponentPTLinearPricingTask.
             * @implements IExponentPTLinearPricingTask
             * @constructor
             * @param {oracle_job.OracleJob.IExponentPTLinearPricingTask=} [properties] Properties to set
             */
            function ExponentPTLinearPricingTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExponentPTLinearPricingTask vault.
             * @member {string} vault
             * @memberof oracle_job.OracleJob.ExponentPTLinearPricingTask
             * @instance
             */
            ExponentPTLinearPricingTask.prototype.vault = "";

            /**
             * ExponentPTLinearPricingTask startPrice.
             * @member {number} startPrice
             * @memberof oracle_job.OracleJob.ExponentPTLinearPricingTask
             * @instance
             */
            ExponentPTLinearPricingTask.prototype.startPrice = 0;

            /**
             * Creates a new ExponentPTLinearPricingTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.ExponentPTLinearPricingTask
             * @static
             * @param {oracle_job.OracleJob.IExponentPTLinearPricingTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.ExponentPTLinearPricingTask} ExponentPTLinearPricingTask instance
             */
            ExponentPTLinearPricingTask.create = function create(properties) {
      return ExponentPTLinearPricingTask.fromObject(properties);
    };

            /**
             * Encodes the specified ExponentPTLinearPricingTask message. Does not implicitly {@link oracle_job.OracleJob.ExponentPTLinearPricingTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.ExponentPTLinearPricingTask
             * @static
             * @param {oracle_job.OracleJob.IExponentPTLinearPricingTask} message ExponentPTLinearPricingTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExponentPTLinearPricingTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.vault != null && Object.hasOwnProperty.call(message, "vault"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.vault);
                if (message.startPrice != null && Object.hasOwnProperty.call(message, "startPrice"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.startPrice);
                return writer;
            };

            /**
             * Encodes the specified ExponentPTLinearPricingTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.ExponentPTLinearPricingTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.ExponentPTLinearPricingTask
             * @static
             * @param {oracle_job.OracleJob.IExponentPTLinearPricingTask} message ExponentPTLinearPricingTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExponentPTLinearPricingTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExponentPTLinearPricingTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.ExponentPTLinearPricingTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.ExponentPTLinearPricingTask} ExponentPTLinearPricingTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExponentPTLinearPricingTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.ExponentPTLinearPricingTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.vault = reader.string();
                            break;
                        }
                    case 2: {
                            message.startPrice = reader.double();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExponentPTLinearPricingTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.ExponentPTLinearPricingTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.ExponentPTLinearPricingTask} ExponentPTLinearPricingTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExponentPTLinearPricingTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExponentPTLinearPricingTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.ExponentPTLinearPricingTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExponentPTLinearPricingTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.vault != null && message.hasOwnProperty("vault"))
                    if (!$util.isString(message.vault))
                        return "vault: string expected";
                if (message.startPrice != null && message.hasOwnProperty("startPrice"))
                    if (typeof message.startPrice !== "number")
                        return "startPrice: number expected";
                return null;
            };

            /**
             * Creates an ExponentPTLinearPricingTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.ExponentPTLinearPricingTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.ExponentPTLinearPricingTask} ExponentPTLinearPricingTask
             */
            ExponentPTLinearPricingTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.ExponentPTLinearPricingTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.ExponentPTLinearPricingTask();
                if (object.vault != null)
                    message.vault = String(object.vault);
                if (object.startPrice != null)
                    message.startPrice = Number(object.startPrice);
                return message;
            };

            /**
             * Creates a plain object from an ExponentPTLinearPricingTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.ExponentPTLinearPricingTask
             * @static
             * @param {oracle_job.OracleJob.ExponentPTLinearPricingTask} message ExponentPTLinearPricingTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExponentPTLinearPricingTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.vault = "";
                    object.startPrice = 0;
                }
                if (message.vault != null && message.hasOwnProperty("vault"))
                    object.vault = message.vault;
                if (message.startPrice != null && message.hasOwnProperty("startPrice"))
                    object.startPrice = options.json && !isFinite(message.startPrice) ? String(message.startPrice) : message.startPrice;
                return object;
            };

            /**
             * Converts this ExponentPTLinearPricingTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.ExponentPTLinearPricingTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExponentPTLinearPricingTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ExponentPTLinearPricingTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.ExponentPTLinearPricingTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ExponentPTLinearPricingTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.ExponentPTLinearPricingTask";
            };

            return ExponentPTLinearPricingTask;
        })();

        OracleJob.SolanaToken2022ExtensionTask = (function() {

            /**
             * Properties of a SolanaToken2022ExtensionTask.
             * @memberof oracle_job.OracleJob
             * @interface ISolanaToken2022ExtensionTask
             * @property {string|null} [mint] The base58 encoded publicKey of the token mint address.
             * @property {oracle_job.OracleJob.SolanaToken2022ExtensionTask.Token2022Extension|null} [extension] SolanaToken2022ExtensionTask extension
             */

            /**
             * Constructs a new SolanaToken2022ExtensionTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Apply Solana Token 2022 extension modifiers to a feed.
             * _**Input**_: Token address and extension type.
             * _**Returns**_: The value associated with the token2022 extension.
             * @implements ISolanaToken2022ExtensionTask
             * @constructor
             * @param {oracle_job.OracleJob.ISolanaToken2022ExtensionTask=} [properties] Properties to set
             */
            function SolanaToken2022ExtensionTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The base58 encoded publicKey of the token mint address.
             * @member {string} mint
             * @memberof oracle_job.OracleJob.SolanaToken2022ExtensionTask
             * @instance
             */
            SolanaToken2022ExtensionTask.prototype.mint = "";

            /**
             * SolanaToken2022ExtensionTask extension.
             * @member {oracle_job.OracleJob.SolanaToken2022ExtensionTask.Token2022Extension} extension
             * @memberof oracle_job.OracleJob.SolanaToken2022ExtensionTask
             * @instance
             */
            SolanaToken2022ExtensionTask.prototype.extension = 0;

            /**
             * Creates a new SolanaToken2022ExtensionTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.SolanaToken2022ExtensionTask
             * @static
             * @param {oracle_job.OracleJob.ISolanaToken2022ExtensionTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.SolanaToken2022ExtensionTask} SolanaToken2022ExtensionTask instance
             */
            SolanaToken2022ExtensionTask.create = function create(properties) {
      return SolanaToken2022ExtensionTask.fromObject(properties);
    };

            /**
             * Encodes the specified SolanaToken2022ExtensionTask message. Does not implicitly {@link oracle_job.OracleJob.SolanaToken2022ExtensionTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.SolanaToken2022ExtensionTask
             * @static
             * @param {oracle_job.OracleJob.ISolanaToken2022ExtensionTask} message SolanaToken2022ExtensionTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SolanaToken2022ExtensionTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.mint != null && Object.hasOwnProperty.call(message, "mint"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.mint);
                if (message.extension != null && Object.hasOwnProperty.call(message, "extension"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.extension);
                return writer;
            };

            /**
             * Encodes the specified SolanaToken2022ExtensionTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.SolanaToken2022ExtensionTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.SolanaToken2022ExtensionTask
             * @static
             * @param {oracle_job.OracleJob.ISolanaToken2022ExtensionTask} message SolanaToken2022ExtensionTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SolanaToken2022ExtensionTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SolanaToken2022ExtensionTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.SolanaToken2022ExtensionTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.SolanaToken2022ExtensionTask} SolanaToken2022ExtensionTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SolanaToken2022ExtensionTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.SolanaToken2022ExtensionTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.mint = reader.string();
                            break;
                        }
                    case 2: {
                            message.extension = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SolanaToken2022ExtensionTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.SolanaToken2022ExtensionTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.SolanaToken2022ExtensionTask} SolanaToken2022ExtensionTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SolanaToken2022ExtensionTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SolanaToken2022ExtensionTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.SolanaToken2022ExtensionTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SolanaToken2022ExtensionTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.mint != null && message.hasOwnProperty("mint"))
                    if (!$util.isString(message.mint))
                        return "mint: string expected";
                if (message.extension != null && message.hasOwnProperty("extension"))
                    switch (message.extension) {
                    default:
                        return "extension: enum value expected";
                    case 0:
                        break;
                    }
                return null;
            };

            /**
             * Creates a SolanaToken2022ExtensionTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.SolanaToken2022ExtensionTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.SolanaToken2022ExtensionTask} SolanaToken2022ExtensionTask
             */
            SolanaToken2022ExtensionTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.SolanaToken2022ExtensionTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.SolanaToken2022ExtensionTask();
                if (object.mint != null)
                    message.mint = String(object.mint);
                switch (object.extension) {
                default:
                    if (typeof object.extension === "number") {
                        message.extension = object.extension;
                        break;
                    }
                    break;
                case "TOKEN_2022_SCALED_AMOUNT_FACTOR":
                case 0:
                    message.extension = 0;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a SolanaToken2022ExtensionTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.SolanaToken2022ExtensionTask
             * @static
             * @param {oracle_job.OracleJob.SolanaToken2022ExtensionTask} message SolanaToken2022ExtensionTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SolanaToken2022ExtensionTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.mint = "";
                    object.extension = options.enums === String ? "TOKEN_2022_SCALED_AMOUNT_FACTOR" : 0;
                }
                if (message.mint != null && message.hasOwnProperty("mint"))
                    object.mint = message.mint;
                if (message.extension != null && message.hasOwnProperty("extension"))
                    object.extension = options.enums === String ? $root.oracle_job.OracleJob.SolanaToken2022ExtensionTask.Token2022Extension[message.extension] === undefined ? message.extension : $root.oracle_job.OracleJob.SolanaToken2022ExtensionTask.Token2022Extension[message.extension] : message.extension;
                return object;
            };

            /**
             * Converts this SolanaToken2022ExtensionTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.SolanaToken2022ExtensionTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SolanaToken2022ExtensionTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SolanaToken2022ExtensionTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.SolanaToken2022ExtensionTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SolanaToken2022ExtensionTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.SolanaToken2022ExtensionTask";
            };

            /**
             * Token2022Extension enum.
             * @name oracle_job.OracleJob.SolanaToken2022ExtensionTask.Token2022Extension
             * @enum {number}
             * @property {number} TOKEN_2022_SCALED_AMOUNT_FACTOR=0 TOKEN_2022_SCALED_AMOUNT_FACTOR value
             */
            SolanaToken2022ExtensionTask.Token2022Extension = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "TOKEN_2022_SCALED_AMOUNT_FACTOR"] = 0;
                return values;
            })();

            return SolanaToken2022ExtensionTask;
        })();

        OracleJob.SwitchboardSurgeTask = (function() {

            /**
             * Properties of a SwitchboardSurgeTask.
             * @memberof oracle_job.OracleJob
             * @interface ISwitchboardSurgeTask
             * @property {oracle_job.OracleJob.SwitchboardSurgeTask.Source|null} [source] Determines which source will be used for pricing.
             * Default: WEIGHTED average across all sources.
             * @property {string|null} [symbol] SwitchboardSurgeTask symbol
             */

            /**
             * Constructs a new SwitchboardSurgeTask.
             * @memberof oracle_job.OracleJob
             * @classdesc Fetch a *live* spot price straight out of the global **Surge** websocket
             * cache  the same cache that powers our high-speed on-chain oracles.
             * 
             * _**Input**_
             *  `symbol`  the trading-pair symbol as it appears on the exchange
             *  `source`  which exchanges stream to read from
             *  `BINANCE`   (weight 3)
             *  `BYBIT`     (weight 2)
             *  `OKX`       (weight 2)
             *  `COINBASE`  (weight 1)
             *  `WEIGHTED`  (default)  use the *weighted median* of all
             * fresh quotes with the weights shown above.
             * 
             * _**Returns**_
             * The most recent price available from the chosen source.
             * The task fails if the cached tick is older than **5 s**.
             * 
             * _**Example**_: Pull the Binance price for BTC / USDT
             * ```json
             * {
             * "switchboardSurgeTask": {
             * "source": "BINANCE",
             * "symbol": "BTC/FDUSD"
             * }
             * }
             * ```
             * 
             * _**Example**_: Use the weighted-median oracle for BTC / USDT
             * ```json
             * {
             * "switchboardSurgeTask": {
             * "source": "WEIGHTED",   // or omit  WEIGHTED is the default
             * "symbol": "BTC/USD"
             * }
             * }
             * ```
             * 
             * _**Notes**_
             *  Symbols are auto-normalised (case-insensitive, punctuation removed).
             *  If a venues price is stale (> 5 s) it is ignored in the WEIGHTED
             * calculation.  The task errors if **no** fresh price remains.
             *  The weighted-median algorithm is the same one Hyperliquid uses in
             * production: cumulative weights 3 / 2 / 2 / 1 / 1 / 1 / 1 / 1 across the
             * eight venues (we currently stream the first four).
             * @implements ISwitchboardSurgeTask
             * @constructor
             * @param {oracle_job.OracleJob.ISwitchboardSurgeTask=} [properties] Properties to set
             */
            function SwitchboardSurgeTask(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Determines which source will be used for pricing.
             * Default: WEIGHTED average across all sources.
             * @member {oracle_job.OracleJob.SwitchboardSurgeTask.Source} source
             * @memberof oracle_job.OracleJob.SwitchboardSurgeTask
             * @instance
             */
            SwitchboardSurgeTask.prototype.source = 0;

            /**
             * SwitchboardSurgeTask symbol.
             * @member {string} symbol
             * @memberof oracle_job.OracleJob.SwitchboardSurgeTask
             * @instance
             */
            SwitchboardSurgeTask.prototype.symbol = "";

            /**
             * Creates a new SwitchboardSurgeTask instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.SwitchboardSurgeTask
             * @static
             * @param {oracle_job.OracleJob.ISwitchboardSurgeTask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.SwitchboardSurgeTask} SwitchboardSurgeTask instance
             */
            SwitchboardSurgeTask.create = function create(properties) {
      return SwitchboardSurgeTask.fromObject(properties);
    };

            /**
             * Encodes the specified SwitchboardSurgeTask message. Does not implicitly {@link oracle_job.OracleJob.SwitchboardSurgeTask.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.SwitchboardSurgeTask
             * @static
             * @param {oracle_job.OracleJob.ISwitchboardSurgeTask} message SwitchboardSurgeTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SwitchboardSurgeTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.source != null && Object.hasOwnProperty.call(message, "source"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.source);
                if (message.symbol != null && Object.hasOwnProperty.call(message, "symbol"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.symbol);
                return writer;
            };

            /**
             * Encodes the specified SwitchboardSurgeTask message, length delimited. Does not implicitly {@link oracle_job.OracleJob.SwitchboardSurgeTask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.SwitchboardSurgeTask
             * @static
             * @param {oracle_job.OracleJob.ISwitchboardSurgeTask} message SwitchboardSurgeTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SwitchboardSurgeTask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SwitchboardSurgeTask message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.SwitchboardSurgeTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.SwitchboardSurgeTask} SwitchboardSurgeTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SwitchboardSurgeTask.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.SwitchboardSurgeTask();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.source = reader.int32();
                            break;
                        }
                    case 2: {
                            message.symbol = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SwitchboardSurgeTask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.SwitchboardSurgeTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.SwitchboardSurgeTask} SwitchboardSurgeTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SwitchboardSurgeTask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SwitchboardSurgeTask message.
             * @function verify
             * @memberof oracle_job.OracleJob.SwitchboardSurgeTask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SwitchboardSurgeTask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.source != null && message.hasOwnProperty("source"))
                    switch (message.source) {
                    default:
                        return "source: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                        break;
                    }
                if (message.symbol != null && message.hasOwnProperty("symbol"))
                    if (!$util.isString(message.symbol))
                        return "symbol: string expected";
                return null;
            };

            /**
             * Creates a SwitchboardSurgeTask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.SwitchboardSurgeTask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.SwitchboardSurgeTask} SwitchboardSurgeTask
             */
            SwitchboardSurgeTask.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.SwitchboardSurgeTask)
                    return object;
                let message = new $root.oracle_job.OracleJob.SwitchboardSurgeTask();
                switch (object.source) {
                default:
                    if (typeof object.source === "number") {
                        message.source = object.source;
                        break;
                    }
                    break;
                case "WEIGHTED":
                case 0:
                    message.source = 0;
                    break;
                case "BINANCE":
                case 1:
                    message.source = 1;
                    break;
                case "OKX":
                case 2:
                    message.source = 2;
                    break;
                case "BYBIT":
                case 3:
                    message.source = 3;
                    break;
                case "COINBASE":
                case 4:
                    message.source = 4;
                    break;
                case "BITGET":
                case 5:
                    message.source = 5;
                    break;
                case "AUTO":
                case 6:
                    message.source = 6;
                    break;
                }
                if (object.symbol != null)
                    message.symbol = String(object.symbol);
                return message;
            };

            /**
             * Creates a plain object from a SwitchboardSurgeTask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.SwitchboardSurgeTask
             * @static
             * @param {oracle_job.OracleJob.SwitchboardSurgeTask} message SwitchboardSurgeTask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SwitchboardSurgeTask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.source = options.enums === String ? "WEIGHTED" : 0;
                    object.symbol = "";
                }
                if (message.source != null && message.hasOwnProperty("source"))
                    object.source = options.enums === String ? $root.oracle_job.OracleJob.SwitchboardSurgeTask.Source[message.source] === undefined ? message.source : $root.oracle_job.OracleJob.SwitchboardSurgeTask.Source[message.source] : message.source;
                if (message.symbol != null && message.hasOwnProperty("symbol"))
                    object.symbol = message.symbol;
                return object;
            };

            /**
             * Converts this SwitchboardSurgeTask to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.SwitchboardSurgeTask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SwitchboardSurgeTask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SwitchboardSurgeTask
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.SwitchboardSurgeTask
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SwitchboardSurgeTask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.SwitchboardSurgeTask";
            };

            /**
             * Source enum.
             * @name oracle_job.OracleJob.SwitchboardSurgeTask.Source
             * @enum {number}
             * @property {number} WEIGHTED=0 DEPRECATED - backwards compatibility
             * @property {number} BINANCE=1 BINANCE value
             * @property {number} OKX=2 OKX value
             * @property {number} BYBIT=3 BYBIT value
             * @property {number} COINBASE=4 COINBASE value
             * @property {number} BITGET=5 BITGET value
             * @property {number} AUTO=6 AUTO value
             */
            SwitchboardSurgeTask.Source = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "WEIGHTED"] = 0;
                values[valuesById[1] = "BINANCE"] = 1;
                values[valuesById[2] = "OKX"] = 2;
                values[valuesById[3] = "BYBIT"] = 3;
                values[valuesById[4] = "COINBASE"] = 4;
                values[valuesById[5] = "BITGET"] = 5;
                values[valuesById[6] = "AUTO"] = 6;
                return values;
            })();

            return SwitchboardSurgeTask;
        })();

        OracleJob.Task = (function() {

            /**
             * Properties of a Task.
             * @memberof oracle_job.OracleJob
             * @interface ITask
             * @property {oracle_job.OracleJob.IHttpTask|null} [httpTask] Task httpTask
             * @property {oracle_job.OracleJob.IJsonParseTask|null} [jsonParseTask] Task jsonParseTask
             * @property {oracle_job.OracleJob.IMedianTask|null} [medianTask] Task medianTask
             * @property {oracle_job.OracleJob.IMeanTask|null} [meanTask] Task meanTask
             * @property {oracle_job.OracleJob.IDivideTask|null} [divideTask] Task divideTask
             * @property {oracle_job.OracleJob.IMultiplyTask|null} [multiplyTask] Task multiplyTask
             * @property {oracle_job.OracleJob.ILpTokenPriceTask|null} [lpTokenPriceTask] Task lpTokenPriceTask
             * @property {oracle_job.OracleJob.ILpExchangeRateTask|null} [lpExchangeRateTask] Task lpExchangeRateTask
             * @property {oracle_job.OracleJob.IConditionalTask|null} [conditionalTask] Task conditionalTask
             * @property {oracle_job.OracleJob.IValueTask|null} [valueTask] Task valueTask
             * @property {oracle_job.OracleJob.IMaxTask|null} [maxTask] Task maxTask
             * @property {oracle_job.OracleJob.IRegexExtractTask|null} [regexExtractTask] Task regexExtractTask
             * @property {oracle_job.OracleJob.IXStepPriceTask|null} [xstepPriceTask] Task xstepPriceTask
             * @property {oracle_job.OracleJob.IAddTask|null} [addTask] Task addTask
             * @property {oracle_job.OracleJob.ISubtractTask|null} [subtractTask] Task subtractTask
             * @property {oracle_job.OracleJob.ISerumSwapTask|null} [serumSwapTask] Task serumSwapTask
             * @property {oracle_job.OracleJob.ISerumSwapTask|null} [openbookTask] Task openbookTask
             * @property {oracle_job.OracleJob.IPowTask|null} [powTask] Task powTask
             * @property {oracle_job.OracleJob.ILendingRateTask|null} [lendingRateTask] Task lendingRateTask
             * @property {oracle_job.OracleJob.IJupiterSwapTask|null} [jupiterSwapTask] Task jupiterSwapTask
             * @property {oracle_job.OracleJob.IPerpMarketTask|null} [perpMarketTask] Task perpMarketTask
             * @property {oracle_job.OracleJob.IOracleTask|null} [oracleTask] Task oracleTask
             * @property {oracle_job.OracleJob.IAnchorFetchTask|null} [anchorFetchTask] Task anchorFetchTask
             * @property {oracle_job.OracleJob.ISplStakePoolTask|null} [splStakePoolTask] Task splStakePoolTask
             * @property {oracle_job.OracleJob.ISplTokenParseTask|null} [splTokenParseTask] Task splTokenParseTask
             * @property {oracle_job.OracleJob.IUniswapExchangeRateTask|null} [uniswapExchangeRateTask] Task uniswapExchangeRateTask
             * @property {oracle_job.OracleJob.ISushiswapExchangeRateTask|null} [sushiswapExchangeRateTask] Task sushiswapExchangeRateTask
             * @property {oracle_job.OracleJob.IPancakeswapExchangeRateTask|null} [pancakeswapExchangeRateTask] Task pancakeswapExchangeRateTask
             * @property {oracle_job.OracleJob.ICacheTask|null} [cacheTask] Task cacheTask
             * @property {oracle_job.OracleJob.ISysclockOffsetTask|null} [sysclockOffsetTask] Task sysclockOffsetTask
             * @property {oracle_job.OracleJob.IMarinadeStateTask|null} [marinadeStateTask] Task marinadeStateTask
             * @property {oracle_job.OracleJob.ISolanaAccountDataFetchTask|null} [solanaAccountDataFetchTask] Task solanaAccountDataFetchTask
             * @property {oracle_job.OracleJob.IBufferLayoutParseTask|null} [bufferLayoutParseTask] Task bufferLayoutParseTask
             * @property {oracle_job.OracleJob.ICronParseTask|null} [cronParseTask] Task cronParseTask
             * @property {oracle_job.OracleJob.IMinTask|null} [minTask] Task minTask
             * @property {oracle_job.OracleJob.IComparisonTask|null} [comparisonTask] Task comparisonTask
             * @property {oracle_job.OracleJob.IRoundTask|null} [roundTask] Task roundTask
             * @property {oracle_job.OracleJob.IBoundTask|null} [boundTask] Task boundTask
             * @property {oracle_job.OracleJob.ISecretsTask|null} [secretsTask] Task secretsTask
             * @property {oracle_job.OracleJob.ISanctumLstPriceTask|null} [sanctumLstPriceTask] Task sanctumLstPriceTask
             * @property {oracle_job.OracleJob.IOndoUsdyTask|null} [ondoUsdyTask] Task ondoUsdyTask
             * @property {oracle_job.OracleJob.IMeteoraSwapTask|null} [meteoraSwapTask] Task meteoraSwapTask
             * @property {oracle_job.OracleJob.IUnixTimeTask|null} [unixTimeTask] Task unixTimeTask
             * @property {oracle_job.OracleJob.IMapleFinanceTask|null} [mapleFinanceTask] Task mapleFinanceTask
             * @property {oracle_job.OracleJob.IGlyphTask|null} [glyphTask] Task glyphTask
             * @property {oracle_job.OracleJob.ICorexTask|null} [corexTask] Task corexTask
             * @property {oracle_job.OracleJob.ISolayerSusdTask|null} [solayerSusdTask] Task solayerSusdTask
             * @property {oracle_job.OracleJob.ICurveFinanceTask|null} [curveFinanceTask] Task curveFinanceTask
             * @property {oracle_job.OracleJob.ITurboEthRedemptionRateTask|null} [turboEthRedemptionRateTask] Task turboEthRedemptionRateTask
             * @property {oracle_job.OracleJob.IBitFluxTask|null} [bitFluxTask] Task bitFluxTask
             * @property {oracle_job.OracleJob.IFragmetricTask|null} [fragmetricTask] Task fragmetricTask
             * @property {oracle_job.OracleJob.IAftermathTask|null} [aftermathTask] Task aftermathTask
             * @property {oracle_job.OracleJob.IEtherfuseTask|null} [etherfuseTask] Task etherfuseTask
             * @property {oracle_job.OracleJob.ILstHistoricalYieldTask|null} [lstHistoricalYieldTask] Task lstHistoricalYieldTask
             * @property {oracle_job.OracleJob.IPumpAmmTask|null} [pumpAmmTask] Task pumpAmmTask
             * @property {oracle_job.OracleJob.IPumpAmmLpTokenPriceTask|null} [pumpAmmLpTokenPriceTask] Task pumpAmmLpTokenPriceTask
             * @property {oracle_job.OracleJob.IExponentTask|null} [exponentTask] Task exponentTask
             * @property {oracle_job.OracleJob.IExponentPTLinearPricingTask|null} [exponentPtLinearPricingTask] Task exponentPtLinearPricingTask
             * @property {oracle_job.OracleJob.ISolanaToken2022ExtensionTask|null} [solanaToken_2022ExtensionTask] Task solanaToken_2022ExtensionTask
             * @property {oracle_job.OracleJob.ISwitchboardSurgeTask|null} [switchboardSurgeTask] Task switchboardSurgeTask
             * @property {oracle_job.OracleJob.IKalshiApiTask|null} [kalshiApiTask] Task kalshiApiTask
             * @property {oracle_job.OracleJob.ITitanTask|null} [titanTask] Task titanTask
             */

            /**
             * Constructs a new Task.
             * @memberof oracle_job.OracleJob
             * @classdesc Represents a singular operation performed by an oracle to yield an eventual numerical result.
             * @implements ITask
             * @constructor
             * @param {oracle_job.OracleJob.ITask=} [properties] Properties to set
             */
            function Task(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Task httpTask.
             * @member {oracle_job.OracleJob.IHttpTask|null|undefined} httpTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.httpTask = null;

            /**
             * Task jsonParseTask.
             * @member {oracle_job.OracleJob.IJsonParseTask|null|undefined} jsonParseTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.jsonParseTask = null;

            /**
             * Task medianTask.
             * @member {oracle_job.OracleJob.IMedianTask|null|undefined} medianTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.medianTask = null;

            /**
             * Task meanTask.
             * @member {oracle_job.OracleJob.IMeanTask|null|undefined} meanTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.meanTask = null;

            /**
             * Task divideTask.
             * @member {oracle_job.OracleJob.IDivideTask|null|undefined} divideTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.divideTask = null;

            /**
             * Task multiplyTask.
             * @member {oracle_job.OracleJob.IMultiplyTask|null|undefined} multiplyTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.multiplyTask = null;

            /**
             * Task lpTokenPriceTask.
             * @member {oracle_job.OracleJob.ILpTokenPriceTask|null|undefined} lpTokenPriceTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.lpTokenPriceTask = null;

            /**
             * Task lpExchangeRateTask.
             * @member {oracle_job.OracleJob.ILpExchangeRateTask|null|undefined} lpExchangeRateTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.lpExchangeRateTask = null;

            /**
             * Task conditionalTask.
             * @member {oracle_job.OracleJob.IConditionalTask|null|undefined} conditionalTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.conditionalTask = null;

            /**
             * Task valueTask.
             * @member {oracle_job.OracleJob.IValueTask|null|undefined} valueTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.valueTask = null;

            /**
             * Task maxTask.
             * @member {oracle_job.OracleJob.IMaxTask|null|undefined} maxTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.maxTask = null;

            /**
             * Task regexExtractTask.
             * @member {oracle_job.OracleJob.IRegexExtractTask|null|undefined} regexExtractTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.regexExtractTask = null;

            /**
             * Task xstepPriceTask.
             * @member {oracle_job.OracleJob.IXStepPriceTask|null|undefined} xstepPriceTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.xstepPriceTask = null;

            /**
             * Task addTask.
             * @member {oracle_job.OracleJob.IAddTask|null|undefined} addTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.addTask = null;

            /**
             * Task subtractTask.
             * @member {oracle_job.OracleJob.ISubtractTask|null|undefined} subtractTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.subtractTask = null;

            /**
             * Task serumSwapTask.
             * @member {oracle_job.OracleJob.ISerumSwapTask|null|undefined} serumSwapTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.serumSwapTask = null;

            /**
             * Task openbookTask.
             * @member {oracle_job.OracleJob.ISerumSwapTask|null|undefined} openbookTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.openbookTask = null;

            /**
             * Task powTask.
             * @member {oracle_job.OracleJob.IPowTask|null|undefined} powTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.powTask = null;

            /**
             * Task lendingRateTask.
             * @member {oracle_job.OracleJob.ILendingRateTask|null|undefined} lendingRateTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.lendingRateTask = null;

            /**
             * Task jupiterSwapTask.
             * @member {oracle_job.OracleJob.IJupiterSwapTask|null|undefined} jupiterSwapTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.jupiterSwapTask = null;

            /**
             * Task perpMarketTask.
             * @member {oracle_job.OracleJob.IPerpMarketTask|null|undefined} perpMarketTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.perpMarketTask = null;

            /**
             * Task oracleTask.
             * @member {oracle_job.OracleJob.IOracleTask|null|undefined} oracleTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.oracleTask = null;

            /**
             * Task anchorFetchTask.
             * @member {oracle_job.OracleJob.IAnchorFetchTask|null|undefined} anchorFetchTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.anchorFetchTask = null;

            /**
             * Task splStakePoolTask.
             * @member {oracle_job.OracleJob.ISplStakePoolTask|null|undefined} splStakePoolTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.splStakePoolTask = null;

            /**
             * Task splTokenParseTask.
             * @member {oracle_job.OracleJob.ISplTokenParseTask|null|undefined} splTokenParseTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.splTokenParseTask = null;

            /**
             * Task uniswapExchangeRateTask.
             * @member {oracle_job.OracleJob.IUniswapExchangeRateTask|null|undefined} uniswapExchangeRateTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.uniswapExchangeRateTask = null;

            /**
             * Task sushiswapExchangeRateTask.
             * @member {oracle_job.OracleJob.ISushiswapExchangeRateTask|null|undefined} sushiswapExchangeRateTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.sushiswapExchangeRateTask = null;

            /**
             * Task pancakeswapExchangeRateTask.
             * @member {oracle_job.OracleJob.IPancakeswapExchangeRateTask|null|undefined} pancakeswapExchangeRateTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.pancakeswapExchangeRateTask = null;

            /**
             * Task cacheTask.
             * @member {oracle_job.OracleJob.ICacheTask|null|undefined} cacheTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.cacheTask = null;

            /**
             * Task sysclockOffsetTask.
             * @member {oracle_job.OracleJob.ISysclockOffsetTask|null|undefined} sysclockOffsetTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.sysclockOffsetTask = null;

            /**
             * Task marinadeStateTask.
             * @member {oracle_job.OracleJob.IMarinadeStateTask|null|undefined} marinadeStateTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.marinadeStateTask = null;

            /**
             * Task solanaAccountDataFetchTask.
             * @member {oracle_job.OracleJob.ISolanaAccountDataFetchTask|null|undefined} solanaAccountDataFetchTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.solanaAccountDataFetchTask = null;

            /**
             * Task bufferLayoutParseTask.
             * @member {oracle_job.OracleJob.IBufferLayoutParseTask|null|undefined} bufferLayoutParseTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.bufferLayoutParseTask = null;

            /**
             * Task cronParseTask.
             * @member {oracle_job.OracleJob.ICronParseTask|null|undefined} cronParseTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.cronParseTask = null;

            /**
             * Task minTask.
             * @member {oracle_job.OracleJob.IMinTask|null|undefined} minTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.minTask = null;

            /**
             * Task comparisonTask.
             * @member {oracle_job.OracleJob.IComparisonTask|null|undefined} comparisonTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.comparisonTask = null;

            /**
             * Task roundTask.
             * @member {oracle_job.OracleJob.IRoundTask|null|undefined} roundTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.roundTask = null;

            /**
             * Task boundTask.
             * @member {oracle_job.OracleJob.IBoundTask|null|undefined} boundTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.boundTask = null;

            /**
             * Task secretsTask.
             * @member {oracle_job.OracleJob.ISecretsTask|null|undefined} secretsTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.secretsTask = null;

            /**
             * Task sanctumLstPriceTask.
             * @member {oracle_job.OracleJob.ISanctumLstPriceTask|null|undefined} sanctumLstPriceTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.sanctumLstPriceTask = null;

            /**
             * Task ondoUsdyTask.
             * @member {oracle_job.OracleJob.IOndoUsdyTask|null|undefined} ondoUsdyTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.ondoUsdyTask = null;

            /**
             * Task meteoraSwapTask.
             * @member {oracle_job.OracleJob.IMeteoraSwapTask|null|undefined} meteoraSwapTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.meteoraSwapTask = null;

            /**
             * Task unixTimeTask.
             * @member {oracle_job.OracleJob.IUnixTimeTask|null|undefined} unixTimeTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.unixTimeTask = null;

            /**
             * Task mapleFinanceTask.
             * @member {oracle_job.OracleJob.IMapleFinanceTask|null|undefined} mapleFinanceTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.mapleFinanceTask = null;

            /**
             * Task glyphTask.
             * @member {oracle_job.OracleJob.IGlyphTask|null|undefined} glyphTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.glyphTask = null;

            /**
             * Task corexTask.
             * @member {oracle_job.OracleJob.ICorexTask|null|undefined} corexTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.corexTask = null;

            /**
             * Task solayerSusdTask.
             * @member {oracle_job.OracleJob.ISolayerSusdTask|null|undefined} solayerSusdTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.solayerSusdTask = null;

            /**
             * Task curveFinanceTask.
             * @member {oracle_job.OracleJob.ICurveFinanceTask|null|undefined} curveFinanceTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.curveFinanceTask = null;

            /**
             * Task turboEthRedemptionRateTask.
             * @member {oracle_job.OracleJob.ITurboEthRedemptionRateTask|null|undefined} turboEthRedemptionRateTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.turboEthRedemptionRateTask = null;

            /**
             * Task bitFluxTask.
             * @member {oracle_job.OracleJob.IBitFluxTask|null|undefined} bitFluxTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.bitFluxTask = null;

            /**
             * Task fragmetricTask.
             * @member {oracle_job.OracleJob.IFragmetricTask|null|undefined} fragmetricTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.fragmetricTask = null;

            /**
             * Task aftermathTask.
             * @member {oracle_job.OracleJob.IAftermathTask|null|undefined} aftermathTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.aftermathTask = null;

            /**
             * Task etherfuseTask.
             * @member {oracle_job.OracleJob.IEtherfuseTask|null|undefined} etherfuseTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.etherfuseTask = null;

            /**
             * Task lstHistoricalYieldTask.
             * @member {oracle_job.OracleJob.ILstHistoricalYieldTask|null|undefined} lstHistoricalYieldTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.lstHistoricalYieldTask = null;

            /**
             * Task pumpAmmTask.
             * @member {oracle_job.OracleJob.IPumpAmmTask|null|undefined} pumpAmmTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.pumpAmmTask = null;

            /**
             * Task pumpAmmLpTokenPriceTask.
             * @member {oracle_job.OracleJob.IPumpAmmLpTokenPriceTask|null|undefined} pumpAmmLpTokenPriceTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.pumpAmmLpTokenPriceTask = null;

            /**
             * Task exponentTask.
             * @member {oracle_job.OracleJob.IExponentTask|null|undefined} exponentTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.exponentTask = null;

            /**
             * Task exponentPtLinearPricingTask.
             * @member {oracle_job.OracleJob.IExponentPTLinearPricingTask|null|undefined} exponentPtLinearPricingTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.exponentPtLinearPricingTask = null;

            /**
             * Task solanaToken_2022ExtensionTask.
             * @member {oracle_job.OracleJob.ISolanaToken2022ExtensionTask|null|undefined} solanaToken_2022ExtensionTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.solanaToken_2022ExtensionTask = null;

            /**
             * Task switchboardSurgeTask.
             * @member {oracle_job.OracleJob.ISwitchboardSurgeTask|null|undefined} switchboardSurgeTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.switchboardSurgeTask = null;

            /**
             * Task kalshiApiTask.
             * @member {oracle_job.OracleJob.IKalshiApiTask|null|undefined} kalshiApiTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.kalshiApiTask = null;

            /**
             * Task titanTask.
             * @member {oracle_job.OracleJob.ITitanTask|null|undefined} titanTask
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Task.prototype.titanTask = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Task Task.
             * @member {"httpTask"|"jsonParseTask"|"medianTask"|"meanTask"|"divideTask"|"multiplyTask"|"lpTokenPriceTask"|"lpExchangeRateTask"|"conditionalTask"|"valueTask"|"maxTask"|"regexExtractTask"|"xstepPriceTask"|"addTask"|"subtractTask"|"serumSwapTask"|"openbookTask"|"powTask"|"lendingRateTask"|"jupiterSwapTask"|"perpMarketTask"|"oracleTask"|"anchorFetchTask"|"splStakePoolTask"|"splTokenParseTask"|"uniswapExchangeRateTask"|"sushiswapExchangeRateTask"|"pancakeswapExchangeRateTask"|"cacheTask"|"sysclockOffsetTask"|"marinadeStateTask"|"solanaAccountDataFetchTask"|"bufferLayoutParseTask"|"cronParseTask"|"minTask"|"comparisonTask"|"roundTask"|"boundTask"|"secretsTask"|"sanctumLstPriceTask"|"ondoUsdyTask"|"meteoraSwapTask"|"unixTimeTask"|"mapleFinanceTask"|"glyphTask"|"corexTask"|"solayerSusdTask"|"curveFinanceTask"|"turboEthRedemptionRateTask"|"bitFluxTask"|"fragmetricTask"|"aftermathTask"|"etherfuseTask"|"lstHistoricalYieldTask"|"pumpAmmTask"|"pumpAmmLpTokenPriceTask"|"exponentTask"|"exponentPtLinearPricingTask"|"solanaToken_2022ExtensionTask"|"switchboardSurgeTask"|"kalshiApiTask"|"titanTask"|undefined} Task
             * @memberof oracle_job.OracleJob.Task
             * @instance
             */
            Object.defineProperty(Task.prototype, "Task", {
                get: $util.oneOfGetter($oneOfFields = ["httpTask", "jsonParseTask", "medianTask", "meanTask", "divideTask", "multiplyTask", "lpTokenPriceTask", "lpExchangeRateTask", "conditionalTask", "valueTask", "maxTask", "regexExtractTask", "xstepPriceTask", "addTask", "subtractTask", "serumSwapTask", "openbookTask", "powTask", "lendingRateTask", "jupiterSwapTask", "perpMarketTask", "oracleTask", "anchorFetchTask", "splStakePoolTask", "splTokenParseTask", "uniswapExchangeRateTask", "sushiswapExchangeRateTask", "pancakeswapExchangeRateTask", "cacheTask", "sysclockOffsetTask", "marinadeStateTask", "solanaAccountDataFetchTask", "bufferLayoutParseTask", "cronParseTask", "minTask", "comparisonTask", "roundTask", "boundTask", "secretsTask", "sanctumLstPriceTask", "ondoUsdyTask", "meteoraSwapTask", "unixTimeTask", "mapleFinanceTask", "glyphTask", "corexTask", "solayerSusdTask", "curveFinanceTask", "turboEthRedemptionRateTask", "bitFluxTask", "fragmetricTask", "aftermathTask", "etherfuseTask", "lstHistoricalYieldTask", "pumpAmmTask", "pumpAmmLpTokenPriceTask", "exponentTask", "exponentPtLinearPricingTask", "solanaToken_2022ExtensionTask", "switchboardSurgeTask", "kalshiApiTask", "titanTask"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Task instance using the specified properties.
             * @function create
             * @memberof oracle_job.OracleJob.Task
             * @static
             * @param {oracle_job.OracleJob.ITask=} [properties] Properties to set
             * @returns {oracle_job.OracleJob.Task} Task instance
             */
            Task.create = function create(properties) {
      return Task.fromObject(properties);
    };

            /**
             * Encodes the specified Task message. Does not implicitly {@link oracle_job.OracleJob.Task.verify|verify} messages.
             * @function encode
             * @memberof oracle_job.OracleJob.Task
             * @static
             * @param {oracle_job.OracleJob.ITask} message Task message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Task.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.httpTask != null && Object.hasOwnProperty.call(message, "httpTask"))
                    $root.oracle_job.OracleJob.HttpTask.encode(message.httpTask, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.jsonParseTask != null && Object.hasOwnProperty.call(message, "jsonParseTask"))
                    $root.oracle_job.OracleJob.JsonParseTask.encode(message.jsonParseTask, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.medianTask != null && Object.hasOwnProperty.call(message, "medianTask"))
                    $root.oracle_job.OracleJob.MedianTask.encode(message.medianTask, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.meanTask != null && Object.hasOwnProperty.call(message, "meanTask"))
                    $root.oracle_job.OracleJob.MeanTask.encode(message.meanTask, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.divideTask != null && Object.hasOwnProperty.call(message, "divideTask"))
                    $root.oracle_job.OracleJob.DivideTask.encode(message.divideTask, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.multiplyTask != null && Object.hasOwnProperty.call(message, "multiplyTask"))
                    $root.oracle_job.OracleJob.MultiplyTask.encode(message.multiplyTask, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.lpTokenPriceTask != null && Object.hasOwnProperty.call(message, "lpTokenPriceTask"))
                    $root.oracle_job.OracleJob.LpTokenPriceTask.encode(message.lpTokenPriceTask, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.lpExchangeRateTask != null && Object.hasOwnProperty.call(message, "lpExchangeRateTask"))
                    $root.oracle_job.OracleJob.LpExchangeRateTask.encode(message.lpExchangeRateTask, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.conditionalTask != null && Object.hasOwnProperty.call(message, "conditionalTask"))
                    $root.oracle_job.OracleJob.ConditionalTask.encode(message.conditionalTask, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.valueTask != null && Object.hasOwnProperty.call(message, "valueTask"))
                    $root.oracle_job.OracleJob.ValueTask.encode(message.valueTask, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.maxTask != null && Object.hasOwnProperty.call(message, "maxTask"))
                    $root.oracle_job.OracleJob.MaxTask.encode(message.maxTask, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.regexExtractTask != null && Object.hasOwnProperty.call(message, "regexExtractTask"))
                    $root.oracle_job.OracleJob.RegexExtractTask.encode(message.regexExtractTask, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.xstepPriceTask != null && Object.hasOwnProperty.call(message, "xstepPriceTask"))
                    $root.oracle_job.OracleJob.XStepPriceTask.encode(message.xstepPriceTask, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                if (message.addTask != null && Object.hasOwnProperty.call(message, "addTask"))
                    $root.oracle_job.OracleJob.AddTask.encode(message.addTask, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                if (message.subtractTask != null && Object.hasOwnProperty.call(message, "subtractTask"))
                    $root.oracle_job.OracleJob.SubtractTask.encode(message.subtractTask, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.serumSwapTask != null && Object.hasOwnProperty.call(message, "serumSwapTask"))
                    $root.oracle_job.OracleJob.SerumSwapTask.encode(message.serumSwapTask, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                if (message.powTask != null && Object.hasOwnProperty.call(message, "powTask"))
                    $root.oracle_job.OracleJob.PowTask.encode(message.powTask, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                if (message.lendingRateTask != null && Object.hasOwnProperty.call(message, "lendingRateTask"))
                    $root.oracle_job.OracleJob.LendingRateTask.encode(message.lendingRateTask, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                if (message.jupiterSwapTask != null && Object.hasOwnProperty.call(message, "jupiterSwapTask"))
                    $root.oracle_job.OracleJob.JupiterSwapTask.encode(message.jupiterSwapTask, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
                if (message.perpMarketTask != null && Object.hasOwnProperty.call(message, "perpMarketTask"))
                    $root.oracle_job.OracleJob.PerpMarketTask.encode(message.perpMarketTask, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
                if (message.oracleTask != null && Object.hasOwnProperty.call(message, "oracleTask"))
                    $root.oracle_job.OracleJob.OracleTask.encode(message.oracleTask, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
                if (message.anchorFetchTask != null && Object.hasOwnProperty.call(message, "anchorFetchTask"))
                    $root.oracle_job.OracleJob.AnchorFetchTask.encode(message.anchorFetchTask, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
                if (message.splStakePoolTask != null && Object.hasOwnProperty.call(message, "splStakePoolTask"))
                    $root.oracle_job.OracleJob.SplStakePoolTask.encode(message.splStakePoolTask, writer.uint32(/* id 29, wireType 2 =*/234).fork()).ldelim();
                if (message.splTokenParseTask != null && Object.hasOwnProperty.call(message, "splTokenParseTask"))
                    $root.oracle_job.OracleJob.SplTokenParseTask.encode(message.splTokenParseTask, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
                if (message.uniswapExchangeRateTask != null && Object.hasOwnProperty.call(message, "uniswapExchangeRateTask"))
                    $root.oracle_job.OracleJob.UniswapExchangeRateTask.encode(message.uniswapExchangeRateTask, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
                if (message.sushiswapExchangeRateTask != null && Object.hasOwnProperty.call(message, "sushiswapExchangeRateTask"))
                    $root.oracle_job.OracleJob.SushiswapExchangeRateTask.encode(message.sushiswapExchangeRateTask, writer.uint32(/* id 32, wireType 2 =*/258).fork()).ldelim();
                if (message.pancakeswapExchangeRateTask != null && Object.hasOwnProperty.call(message, "pancakeswapExchangeRateTask"))
                    $root.oracle_job.OracleJob.PancakeswapExchangeRateTask.encode(message.pancakeswapExchangeRateTask, writer.uint32(/* id 33, wireType 2 =*/266).fork()).ldelim();
                if (message.cacheTask != null && Object.hasOwnProperty.call(message, "cacheTask"))
                    $root.oracle_job.OracleJob.CacheTask.encode(message.cacheTask, writer.uint32(/* id 34, wireType 2 =*/274).fork()).ldelim();
                if (message.sysclockOffsetTask != null && Object.hasOwnProperty.call(message, "sysclockOffsetTask"))
                    $root.oracle_job.OracleJob.SysclockOffsetTask.encode(message.sysclockOffsetTask, writer.uint32(/* id 35, wireType 2 =*/282).fork()).ldelim();
                if (message.marinadeStateTask != null && Object.hasOwnProperty.call(message, "marinadeStateTask"))
                    $root.oracle_job.OracleJob.MarinadeStateTask.encode(message.marinadeStateTask, writer.uint32(/* id 36, wireType 2 =*/290).fork()).ldelim();
                if (message.solanaAccountDataFetchTask != null && Object.hasOwnProperty.call(message, "solanaAccountDataFetchTask"))
                    $root.oracle_job.OracleJob.SolanaAccountDataFetchTask.encode(message.solanaAccountDataFetchTask, writer.uint32(/* id 37, wireType 2 =*/298).fork()).ldelim();
                if (message.bufferLayoutParseTask != null && Object.hasOwnProperty.call(message, "bufferLayoutParseTask"))
                    $root.oracle_job.OracleJob.BufferLayoutParseTask.encode(message.bufferLayoutParseTask, writer.uint32(/* id 38, wireType 2 =*/306).fork()).ldelim();
                if (message.cronParseTask != null && Object.hasOwnProperty.call(message, "cronParseTask"))
                    $root.oracle_job.OracleJob.CronParseTask.encode(message.cronParseTask, writer.uint32(/* id 39, wireType 2 =*/314).fork()).ldelim();
                if (message.minTask != null && Object.hasOwnProperty.call(message, "minTask"))
                    $root.oracle_job.OracleJob.MinTask.encode(message.minTask, writer.uint32(/* id 40, wireType 2 =*/322).fork()).ldelim();
                if (message.comparisonTask != null && Object.hasOwnProperty.call(message, "comparisonTask"))
                    $root.oracle_job.OracleJob.ComparisonTask.encode(message.comparisonTask, writer.uint32(/* id 44, wireType 2 =*/354).fork()).ldelim();
                if (message.roundTask != null && Object.hasOwnProperty.call(message, "roundTask"))
                    $root.oracle_job.OracleJob.RoundTask.encode(message.roundTask, writer.uint32(/* id 45, wireType 2 =*/362).fork()).ldelim();
                if (message.boundTask != null && Object.hasOwnProperty.call(message, "boundTask"))
                    $root.oracle_job.OracleJob.BoundTask.encode(message.boundTask, writer.uint32(/* id 46, wireType 2 =*/370).fork()).ldelim();
                if (message.secretsTask != null && Object.hasOwnProperty.call(message, "secretsTask"))
                    $root.oracle_job.OracleJob.SecretsTask.encode(message.secretsTask, writer.uint32(/* id 47, wireType 2 =*/378).fork()).ldelim();
                if (message.sanctumLstPriceTask != null && Object.hasOwnProperty.call(message, "sanctumLstPriceTask"))
                    $root.oracle_job.OracleJob.SanctumLstPriceTask.encode(message.sanctumLstPriceTask, writer.uint32(/* id 48, wireType 2 =*/386).fork()).ldelim();
                if (message.ondoUsdyTask != null && Object.hasOwnProperty.call(message, "ondoUsdyTask"))
                    $root.oracle_job.OracleJob.OndoUsdyTask.encode(message.ondoUsdyTask, writer.uint32(/* id 49, wireType 2 =*/394).fork()).ldelim();
                if (message.meteoraSwapTask != null && Object.hasOwnProperty.call(message, "meteoraSwapTask"))
                    $root.oracle_job.OracleJob.MeteoraSwapTask.encode(message.meteoraSwapTask, writer.uint32(/* id 50, wireType 2 =*/402).fork()).ldelim();
                if (message.unixTimeTask != null && Object.hasOwnProperty.call(message, "unixTimeTask"))
                    $root.oracle_job.OracleJob.UnixTimeTask.encode(message.unixTimeTask, writer.uint32(/* id 51, wireType 2 =*/410).fork()).ldelim();
                if (message.mapleFinanceTask != null && Object.hasOwnProperty.call(message, "mapleFinanceTask"))
                    $root.oracle_job.OracleJob.MapleFinanceTask.encode(message.mapleFinanceTask, writer.uint32(/* id 52, wireType 2 =*/418).fork()).ldelim();
                if (message.glyphTask != null && Object.hasOwnProperty.call(message, "glyphTask"))
                    $root.oracle_job.OracleJob.GlyphTask.encode(message.glyphTask, writer.uint32(/* id 53, wireType 2 =*/426).fork()).ldelim();
                if (message.corexTask != null && Object.hasOwnProperty.call(message, "corexTask"))
                    $root.oracle_job.OracleJob.CorexTask.encode(message.corexTask, writer.uint32(/* id 54, wireType 2 =*/434).fork()).ldelim();
                if (message.solayerSusdTask != null && Object.hasOwnProperty.call(message, "solayerSusdTask"))
                    $root.oracle_job.OracleJob.SolayerSusdTask.encode(message.solayerSusdTask, writer.uint32(/* id 56, wireType 2 =*/450).fork()).ldelim();
                if (message.curveFinanceTask != null && Object.hasOwnProperty.call(message, "curveFinanceTask"))
                    $root.oracle_job.OracleJob.CurveFinanceTask.encode(message.curveFinanceTask, writer.uint32(/* id 57, wireType 2 =*/458).fork()).ldelim();
                if (message.turboEthRedemptionRateTask != null && Object.hasOwnProperty.call(message, "turboEthRedemptionRateTask"))
                    $root.oracle_job.OracleJob.TurboEthRedemptionRateTask.encode(message.turboEthRedemptionRateTask, writer.uint32(/* id 58, wireType 2 =*/466).fork()).ldelim();
                if (message.bitFluxTask != null && Object.hasOwnProperty.call(message, "bitFluxTask"))
                    $root.oracle_job.OracleJob.BitFluxTask.encode(message.bitFluxTask, writer.uint32(/* id 59, wireType 2 =*/474).fork()).ldelim();
                if (message.fragmetricTask != null && Object.hasOwnProperty.call(message, "fragmetricTask"))
                    $root.oracle_job.OracleJob.FragmetricTask.encode(message.fragmetricTask, writer.uint32(/* id 60, wireType 2 =*/482).fork()).ldelim();
                if (message.aftermathTask != null && Object.hasOwnProperty.call(message, "aftermathTask"))
                    $root.oracle_job.OracleJob.AftermathTask.encode(message.aftermathTask, writer.uint32(/* id 61, wireType 2 =*/490).fork()).ldelim();
                if (message.etherfuseTask != null && Object.hasOwnProperty.call(message, "etherfuseTask"))
                    $root.oracle_job.OracleJob.EtherfuseTask.encode(message.etherfuseTask, writer.uint32(/* id 63, wireType 2 =*/506).fork()).ldelim();
                if (message.lstHistoricalYieldTask != null && Object.hasOwnProperty.call(message, "lstHistoricalYieldTask"))
                    $root.oracle_job.OracleJob.LstHistoricalYieldTask.encode(message.lstHistoricalYieldTask, writer.uint32(/* id 64, wireType 2 =*/514).fork()).ldelim();
                if (message.pumpAmmTask != null && Object.hasOwnProperty.call(message, "pumpAmmTask"))
                    $root.oracle_job.OracleJob.PumpAmmTask.encode(message.pumpAmmTask, writer.uint32(/* id 65, wireType 2 =*/522).fork()).ldelim();
                if (message.pumpAmmLpTokenPriceTask != null && Object.hasOwnProperty.call(message, "pumpAmmLpTokenPriceTask"))
                    $root.oracle_job.OracleJob.PumpAmmLpTokenPriceTask.encode(message.pumpAmmLpTokenPriceTask, writer.uint32(/* id 66, wireType 2 =*/530).fork()).ldelim();
                if (message.exponentTask != null && Object.hasOwnProperty.call(message, "exponentTask"))
                    $root.oracle_job.OracleJob.ExponentTask.encode(message.exponentTask, writer.uint32(/* id 67, wireType 2 =*/538).fork()).ldelim();
                if (message.exponentPtLinearPricingTask != null && Object.hasOwnProperty.call(message, "exponentPtLinearPricingTask"))
                    $root.oracle_job.OracleJob.ExponentPTLinearPricingTask.encode(message.exponentPtLinearPricingTask, writer.uint32(/* id 68, wireType 2 =*/546).fork()).ldelim();
                if (message.solanaToken_2022ExtensionTask != null && Object.hasOwnProperty.call(message, "solanaToken_2022ExtensionTask"))
                    $root.oracle_job.OracleJob.SolanaToken2022ExtensionTask.encode(message.solanaToken_2022ExtensionTask, writer.uint32(/* id 69, wireType 2 =*/554).fork()).ldelim();
                if (message.switchboardSurgeTask != null && Object.hasOwnProperty.call(message, "switchboardSurgeTask"))
                    $root.oracle_job.OracleJob.SwitchboardSurgeTask.encode(message.switchboardSurgeTask, writer.uint32(/* id 70, wireType 2 =*/562).fork()).ldelim();
                if (message.openbookTask != null && Object.hasOwnProperty.call(message, "openbookTask"))
                    $root.oracle_job.OracleJob.SerumSwapTask.encode(message.openbookTask, writer.uint32(/* id 71, wireType 2 =*/570).fork()).ldelim();
                if (message.kalshiApiTask != null && Object.hasOwnProperty.call(message, "kalshiApiTask"))
                    $root.oracle_job.OracleJob.KalshiApiTask.encode(message.kalshiApiTask, writer.uint32(/* id 72, wireType 2 =*/578).fork()).ldelim();
                if (message.titanTask != null && Object.hasOwnProperty.call(message, "titanTask"))
                    $root.oracle_job.OracleJob.TitanTask.encode(message.titanTask, writer.uint32(/* id 73, wireType 2 =*/586).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Task message, length delimited. Does not implicitly {@link oracle_job.OracleJob.Task.verify|verify} messages.
             * @function encodeDelimited
             * @memberof oracle_job.OracleJob.Task
             * @static
             * @param {oracle_job.OracleJob.ITask} message Task message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Task.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Task message from the specified reader or buffer.
             * @function decode
             * @memberof oracle_job.OracleJob.Task
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {oracle_job.OracleJob.Task} Task
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Task.decode = function decode(reader, length, error) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.oracle_job.OracleJob.Task();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    if (tag === error)
                        break;
                    switch (tag >>> 3) {
                    case 1: {
                            message.httpTask = $root.oracle_job.OracleJob.HttpTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.jsonParseTask = $root.oracle_job.OracleJob.JsonParseTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.medianTask = $root.oracle_job.OracleJob.MedianTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.meanTask = $root.oracle_job.OracleJob.MeanTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 7: {
                            message.divideTask = $root.oracle_job.OracleJob.DivideTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 8: {
                            message.multiplyTask = $root.oracle_job.OracleJob.MultiplyTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 9: {
                            message.lpTokenPriceTask = $root.oracle_job.OracleJob.LpTokenPriceTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 10: {
                            message.lpExchangeRateTask = $root.oracle_job.OracleJob.LpExchangeRateTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message.conditionalTask = $root.oracle_job.OracleJob.ConditionalTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 12: {
                            message.valueTask = $root.oracle_job.OracleJob.ValueTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 13: {
                            message.maxTask = $root.oracle_job.OracleJob.MaxTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 14: {
                            message.regexExtractTask = $root.oracle_job.OracleJob.RegexExtractTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 15: {
                            message.xstepPriceTask = $root.oracle_job.OracleJob.XStepPriceTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 16: {
                            message.addTask = $root.oracle_job.OracleJob.AddTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 17: {
                            message.subtractTask = $root.oracle_job.OracleJob.SubtractTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 19: {
                            message.serumSwapTask = $root.oracle_job.OracleJob.SerumSwapTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 71: {
                            message.openbookTask = $root.oracle_job.OracleJob.SerumSwapTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 20: {
                            message.powTask = $root.oracle_job.OracleJob.PowTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 21: {
                            message.lendingRateTask = $root.oracle_job.OracleJob.LendingRateTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 23: {
                            message.jupiterSwapTask = $root.oracle_job.OracleJob.JupiterSwapTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 24: {
                            message.perpMarketTask = $root.oracle_job.OracleJob.PerpMarketTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 25: {
                            message.oracleTask = $root.oracle_job.OracleJob.OracleTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 26: {
                            message.anchorFetchTask = $root.oracle_job.OracleJob.AnchorFetchTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 29: {
                            message.splStakePoolTask = $root.oracle_job.OracleJob.SplStakePoolTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 30: {
                            message.splTokenParseTask = $root.oracle_job.OracleJob.SplTokenParseTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 31: {
                            message.uniswapExchangeRateTask = $root.oracle_job.OracleJob.UniswapExchangeRateTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 32: {
                            message.sushiswapExchangeRateTask = $root.oracle_job.OracleJob.SushiswapExchangeRateTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 33: {
                            message.pancakeswapExchangeRateTask = $root.oracle_job.OracleJob.PancakeswapExchangeRateTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 34: {
                            message.cacheTask = $root.oracle_job.OracleJob.CacheTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 35: {
                            message.sysclockOffsetTask = $root.oracle_job.OracleJob.SysclockOffsetTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 36: {
                            message.marinadeStateTask = $root.oracle_job.OracleJob.MarinadeStateTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 37: {
                            message.solanaAccountDataFetchTask = $root.oracle_job.OracleJob.SolanaAccountDataFetchTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 38: {
                            message.bufferLayoutParseTask = $root.oracle_job.OracleJob.BufferLayoutParseTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 39: {
                            message.cronParseTask = $root.oracle_job.OracleJob.CronParseTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 40: {
                            message.minTask = $root.oracle_job.OracleJob.MinTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 44: {
                            message.comparisonTask = $root.oracle_job.OracleJob.ComparisonTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 45: {
                            message.roundTask = $root.oracle_job.OracleJob.RoundTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 46: {
                            message.boundTask = $root.oracle_job.OracleJob.BoundTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 47: {
                            message.secretsTask = $root.oracle_job.OracleJob.SecretsTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 48: {
                            message.sanctumLstPriceTask = $root.oracle_job.OracleJob.SanctumLstPriceTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 49: {
                            message.ondoUsdyTask = $root.oracle_job.OracleJob.OndoUsdyTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 50: {
                            message.meteoraSwapTask = $root.oracle_job.OracleJob.MeteoraSwapTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 51: {
                            message.unixTimeTask = $root.oracle_job.OracleJob.UnixTimeTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 52: {
                            message.mapleFinanceTask = $root.oracle_job.OracleJob.MapleFinanceTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 53: {
                            message.glyphTask = $root.oracle_job.OracleJob.GlyphTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 54: {
                            message.corexTask = $root.oracle_job.OracleJob.CorexTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 56: {
                            message.solayerSusdTask = $root.oracle_job.OracleJob.SolayerSusdTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 57: {
                            message.curveFinanceTask = $root.oracle_job.OracleJob.CurveFinanceTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 58: {
                            message.turboEthRedemptionRateTask = $root.oracle_job.OracleJob.TurboEthRedemptionRateTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 59: {
                            message.bitFluxTask = $root.oracle_job.OracleJob.BitFluxTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 60: {
                            message.fragmetricTask = $root.oracle_job.OracleJob.FragmetricTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 61: {
                            message.aftermathTask = $root.oracle_job.OracleJob.AftermathTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 63: {
                            message.etherfuseTask = $root.oracle_job.OracleJob.EtherfuseTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 64: {
                            message.lstHistoricalYieldTask = $root.oracle_job.OracleJob.LstHistoricalYieldTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 65: {
                            message.pumpAmmTask = $root.oracle_job.OracleJob.PumpAmmTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 66: {
                            message.pumpAmmLpTokenPriceTask = $root.oracle_job.OracleJob.PumpAmmLpTokenPriceTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 67: {
                            message.exponentTask = $root.oracle_job.OracleJob.ExponentTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 68: {
                            message.exponentPtLinearPricingTask = $root.oracle_job.OracleJob.ExponentPTLinearPricingTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 69: {
                            message.solanaToken_2022ExtensionTask = $root.oracle_job.OracleJob.SolanaToken2022ExtensionTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 70: {
                            message.switchboardSurgeTask = $root.oracle_job.OracleJob.SwitchboardSurgeTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 72: {
                            message.kalshiApiTask = $root.oracle_job.OracleJob.KalshiApiTask.decode(reader, reader.uint32());
                            break;
                        }
                    case 73: {
                            message.titanTask = $root.oracle_job.OracleJob.TitanTask.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Task message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof oracle_job.OracleJob.Task
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {oracle_job.OracleJob.Task} Task
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Task.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Task message.
             * @function verify
             * @memberof oracle_job.OracleJob.Task
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Task.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.httpTask != null && message.hasOwnProperty("httpTask")) {
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.HttpTask.verify(message.httpTask);
                        if (error)
                            return "httpTask." + error;
                    }
                }
                if (message.jsonParseTask != null && message.hasOwnProperty("jsonParseTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.JsonParseTask.verify(message.jsonParseTask);
                        if (error)
                            return "jsonParseTask." + error;
                    }
                }
                if (message.medianTask != null && message.hasOwnProperty("medianTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.MedianTask.verify(message.medianTask);
                        if (error)
                            return "medianTask." + error;
                    }
                }
                if (message.meanTask != null && message.hasOwnProperty("meanTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.MeanTask.verify(message.meanTask);
                        if (error)
                            return "meanTask." + error;
                    }
                }
                if (message.divideTask != null && message.hasOwnProperty("divideTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.DivideTask.verify(message.divideTask);
                        if (error)
                            return "divideTask." + error;
                    }
                }
                if (message.multiplyTask != null && message.hasOwnProperty("multiplyTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.MultiplyTask.verify(message.multiplyTask);
                        if (error)
                            return "multiplyTask." + error;
                    }
                }
                if (message.lpTokenPriceTask != null && message.hasOwnProperty("lpTokenPriceTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.LpTokenPriceTask.verify(message.lpTokenPriceTask);
                        if (error)
                            return "lpTokenPriceTask." + error;
                    }
                }
                if (message.lpExchangeRateTask != null && message.hasOwnProperty("lpExchangeRateTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.LpExchangeRateTask.verify(message.lpExchangeRateTask);
                        if (error)
                            return "lpExchangeRateTask." + error;
                    }
                }
                if (message.conditionalTask != null && message.hasOwnProperty("conditionalTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.ConditionalTask.verify(message.conditionalTask);
                        if (error)
                            return "conditionalTask." + error;
                    }
                }
                if (message.valueTask != null && message.hasOwnProperty("valueTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.ValueTask.verify(message.valueTask);
                        if (error)
                            return "valueTask." + error;
                    }
                }
                if (message.maxTask != null && message.hasOwnProperty("maxTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.MaxTask.verify(message.maxTask);
                        if (error)
                            return "maxTask." + error;
                    }
                }
                if (message.regexExtractTask != null && message.hasOwnProperty("regexExtractTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.RegexExtractTask.verify(message.regexExtractTask);
                        if (error)
                            return "regexExtractTask." + error;
                    }
                }
                if (message.xstepPriceTask != null && message.hasOwnProperty("xstepPriceTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.XStepPriceTask.verify(message.xstepPriceTask);
                        if (error)
                            return "xstepPriceTask." + error;
                    }
                }
                if (message.addTask != null && message.hasOwnProperty("addTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.AddTask.verify(message.addTask);
                        if (error)
                            return "addTask." + error;
                    }
                }
                if (message.subtractTask != null && message.hasOwnProperty("subtractTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.SubtractTask.verify(message.subtractTask);
                        if (error)
                            return "subtractTask." + error;
                    }
                }
                if (message.serumSwapTask != null && message.hasOwnProperty("serumSwapTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.SerumSwapTask.verify(message.serumSwapTask);
                        if (error)
                            return "serumSwapTask." + error;
                    }
                }
                if (message.openbookTask != null && message.hasOwnProperty("openbookTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.SerumSwapTask.verify(message.openbookTask);
                        if (error)
                            return "openbookTask." + error;
                    }
                }
                if (message.powTask != null && message.hasOwnProperty("powTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.PowTask.verify(message.powTask);
                        if (error)
                            return "powTask." + error;
                    }
                }
                if (message.lendingRateTask != null && message.hasOwnProperty("lendingRateTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.LendingRateTask.verify(message.lendingRateTask);
                        if (error)
                            return "lendingRateTask." + error;
                    }
                }
                if (message.jupiterSwapTask != null && message.hasOwnProperty("jupiterSwapTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.JupiterSwapTask.verify(message.jupiterSwapTask);
                        if (error)
                            return "jupiterSwapTask." + error;
                    }
                }
                if (message.perpMarketTask != null && message.hasOwnProperty("perpMarketTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.PerpMarketTask.verify(message.perpMarketTask);
                        if (error)
                            return "perpMarketTask." + error;
                    }
                }
                if (message.oracleTask != null && message.hasOwnProperty("oracleTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.OracleTask.verify(message.oracleTask);
                        if (error)
                            return "oracleTask." + error;
                    }
                }
                if (message.anchorFetchTask != null && message.hasOwnProperty("anchorFetchTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.AnchorFetchTask.verify(message.anchorFetchTask);
                        if (error)
                            return "anchorFetchTask." + error;
                    }
                }
                if (message.splStakePoolTask != null && message.hasOwnProperty("splStakePoolTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.SplStakePoolTask.verify(message.splStakePoolTask);
                        if (error)
                            return "splStakePoolTask." + error;
                    }
                }
                if (message.splTokenParseTask != null && message.hasOwnProperty("splTokenParseTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.SplTokenParseTask.verify(message.splTokenParseTask);
                        if (error)
                            return "splTokenParseTask." + error;
                    }
                }
                if (message.uniswapExchangeRateTask != null && message.hasOwnProperty("uniswapExchangeRateTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.UniswapExchangeRateTask.verify(message.uniswapExchangeRateTask);
                        if (error)
                            return "uniswapExchangeRateTask." + error;
                    }
                }
                if (message.sushiswapExchangeRateTask != null && message.hasOwnProperty("sushiswapExchangeRateTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.SushiswapExchangeRateTask.verify(message.sushiswapExchangeRateTask);
                        if (error)
                            return "sushiswapExchangeRateTask." + error;
                    }
                }
                if (message.pancakeswapExchangeRateTask != null && message.hasOwnProperty("pancakeswapExchangeRateTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.PancakeswapExchangeRateTask.verify(message.pancakeswapExchangeRateTask);
                        if (error)
                            return "pancakeswapExchangeRateTask." + error;
                    }
                }
                if (message.cacheTask != null && message.hasOwnProperty("cacheTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.CacheTask.verify(message.cacheTask);
                        if (error)
                            return "cacheTask." + error;
                    }
                }
                if (message.sysclockOffsetTask != null && message.hasOwnProperty("sysclockOffsetTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.SysclockOffsetTask.verify(message.sysclockOffsetTask);
                        if (error)
                            return "sysclockOffsetTask." + error;
                    }
                }
                if (message.marinadeStateTask != null && message.hasOwnProperty("marinadeStateTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.MarinadeStateTask.verify(message.marinadeStateTask);
                        if (error)
                            return "marinadeStateTask." + error;
                    }
                }
                if (message.solanaAccountDataFetchTask != null && message.hasOwnProperty("solanaAccountDataFetchTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.SolanaAccountDataFetchTask.verify(message.solanaAccountDataFetchTask);
                        if (error)
                            return "solanaAccountDataFetchTask." + error;
                    }
                }
                if (message.bufferLayoutParseTask != null && message.hasOwnProperty("bufferLayoutParseTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.BufferLayoutParseTask.verify(message.bufferLayoutParseTask);
                        if (error)
                            return "bufferLayoutParseTask." + error;
                    }
                }
                if (message.cronParseTask != null && message.hasOwnProperty("cronParseTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.CronParseTask.verify(message.cronParseTask);
                        if (error)
                            return "cronParseTask." + error;
                    }
                }
                if (message.minTask != null && message.hasOwnProperty("minTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.MinTask.verify(message.minTask);
                        if (error)
                            return "minTask." + error;
                    }
                }
                if (message.comparisonTask != null && message.hasOwnProperty("comparisonTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.ComparisonTask.verify(message.comparisonTask);
                        if (error)
                            return "comparisonTask." + error;
                    }
                }
                if (message.roundTask != null && message.hasOwnProperty("roundTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.RoundTask.verify(message.roundTask);
                        if (error)
                            return "roundTask." + error;
                    }
                }
                if (message.boundTask != null && message.hasOwnProperty("boundTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.BoundTask.verify(message.boundTask);
                        if (error)
                            return "boundTask." + error;
                    }
                }
                if (message.secretsTask != null && message.hasOwnProperty("secretsTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.SecretsTask.verify(message.secretsTask);
                        if (error)
                            return "secretsTask." + error;
                    }
                }
                if (message.sanctumLstPriceTask != null && message.hasOwnProperty("sanctumLstPriceTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.SanctumLstPriceTask.verify(message.sanctumLstPriceTask);
                        if (error)
                            return "sanctumLstPriceTask." + error;
                    }
                }
                if (message.ondoUsdyTask != null && message.hasOwnProperty("ondoUsdyTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.OndoUsdyTask.verify(message.ondoUsdyTask);
                        if (error)
                            return "ondoUsdyTask." + error;
                    }
                }
                if (message.meteoraSwapTask != null && message.hasOwnProperty("meteoraSwapTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.MeteoraSwapTask.verify(message.meteoraSwapTask);
                        if (error)
                            return "meteoraSwapTask." + error;
                    }
                }
                if (message.unixTimeTask != null && message.hasOwnProperty("unixTimeTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.UnixTimeTask.verify(message.unixTimeTask);
                        if (error)
                            return "unixTimeTask." + error;
                    }
                }
                if (message.mapleFinanceTask != null && message.hasOwnProperty("mapleFinanceTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.MapleFinanceTask.verify(message.mapleFinanceTask);
                        if (error)
                            return "mapleFinanceTask." + error;
                    }
                }
                if (message.glyphTask != null && message.hasOwnProperty("glyphTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.GlyphTask.verify(message.glyphTask);
                        if (error)
                            return "glyphTask." + error;
                    }
                }
                if (message.corexTask != null && message.hasOwnProperty("corexTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.CorexTask.verify(message.corexTask);
                        if (error)
                            return "corexTask." + error;
                    }
                }
                if (message.solayerSusdTask != null && message.hasOwnProperty("solayerSusdTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.SolayerSusdTask.verify(message.solayerSusdTask);
                        if (error)
                            return "solayerSusdTask." + error;
                    }
                }
                if (message.curveFinanceTask != null && message.hasOwnProperty("curveFinanceTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.CurveFinanceTask.verify(message.curveFinanceTask);
                        if (error)
                            return "curveFinanceTask." + error;
                    }
                }
                if (message.turboEthRedemptionRateTask != null && message.hasOwnProperty("turboEthRedemptionRateTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.TurboEthRedemptionRateTask.verify(message.turboEthRedemptionRateTask);
                        if (error)
                            return "turboEthRedemptionRateTask." + error;
                    }
                }
                if (message.bitFluxTask != null && message.hasOwnProperty("bitFluxTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.BitFluxTask.verify(message.bitFluxTask);
                        if (error)
                            return "bitFluxTask." + error;
                    }
                }
                if (message.fragmetricTask != null && message.hasOwnProperty("fragmetricTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.FragmetricTask.verify(message.fragmetricTask);
                        if (error)
                            return "fragmetricTask." + error;
                    }
                }
                if (message.aftermathTask != null && message.hasOwnProperty("aftermathTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.AftermathTask.verify(message.aftermathTask);
                        if (error)
                            return "aftermathTask." + error;
                    }
                }
                if (message.etherfuseTask != null && message.hasOwnProperty("etherfuseTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.EtherfuseTask.verify(message.etherfuseTask);
                        if (error)
                            return "etherfuseTask." + error;
                    }
                }
                if (message.lstHistoricalYieldTask != null && message.hasOwnProperty("lstHistoricalYieldTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.LstHistoricalYieldTask.verify(message.lstHistoricalYieldTask);
                        if (error)
                            return "lstHistoricalYieldTask." + error;
                    }
                }
                if (message.pumpAmmTask != null && message.hasOwnProperty("pumpAmmTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.PumpAmmTask.verify(message.pumpAmmTask);
                        if (error)
                            return "pumpAmmTask." + error;
                    }
                }
                if (message.pumpAmmLpTokenPriceTask != null && message.hasOwnProperty("pumpAmmLpTokenPriceTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.PumpAmmLpTokenPriceTask.verify(message.pumpAmmLpTokenPriceTask);
                        if (error)
                            return "pumpAmmLpTokenPriceTask." + error;
                    }
                }
                if (message.exponentTask != null && message.hasOwnProperty("exponentTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.ExponentTask.verify(message.exponentTask);
                        if (error)
                            return "exponentTask." + error;
                    }
                }
                if (message.exponentPtLinearPricingTask != null && message.hasOwnProperty("exponentPtLinearPricingTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.ExponentPTLinearPricingTask.verify(message.exponentPtLinearPricingTask);
                        if (error)
                            return "exponentPtLinearPricingTask." + error;
                    }
                }
                if (message.solanaToken_2022ExtensionTask != null && message.hasOwnProperty("solanaToken_2022ExtensionTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.SolanaToken2022ExtensionTask.verify(message.solanaToken_2022ExtensionTask);
                        if (error)
                            return "solanaToken_2022ExtensionTask." + error;
                    }
                }
                if (message.switchboardSurgeTask != null && message.hasOwnProperty("switchboardSurgeTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.SwitchboardSurgeTask.verify(message.switchboardSurgeTask);
                        if (error)
                            return "switchboardSurgeTask." + error;
                    }
                }
                if (message.kalshiApiTask != null && message.hasOwnProperty("kalshiApiTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.KalshiApiTask.verify(message.kalshiApiTask);
                        if (error)
                            return "kalshiApiTask." + error;
                    }
                }
                if (message.titanTask != null && message.hasOwnProperty("titanTask")) {
                    if (properties.Task === 1)
                        return "Task: multiple values";
                    properties.Task = 1;
                    {
                        let error = $root.oracle_job.OracleJob.TitanTask.verify(message.titanTask);
                        if (error)
                            return "titanTask." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Task message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof oracle_job.OracleJob.Task
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {oracle_job.OracleJob.Task} Task
             */
            Task.fromObject = function fromObject(object) {
                if (object instanceof $root.oracle_job.OracleJob.Task)
                    return object;
                let message = new $root.oracle_job.OracleJob.Task();
                if (object.httpTask != null) {
                    if (typeof object.httpTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.httpTask: object expected");
                    message.httpTask = $root.oracle_job.OracleJob.HttpTask.fromObject(object.httpTask);
                }
                if (object.jsonParseTask != null) {
                    if (typeof object.jsonParseTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.jsonParseTask: object expected");
                    message.jsonParseTask = $root.oracle_job.OracleJob.JsonParseTask.fromObject(object.jsonParseTask);
                }
                if (object.medianTask != null) {
                    if (typeof object.medianTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.medianTask: object expected");
                    message.medianTask = $root.oracle_job.OracleJob.MedianTask.fromObject(object.medianTask);
                }
                if (object.meanTask != null) {
                    if (typeof object.meanTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.meanTask: object expected");
                    message.meanTask = $root.oracle_job.OracleJob.MeanTask.fromObject(object.meanTask);
                }
                if (object.divideTask != null) {
                    if (typeof object.divideTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.divideTask: object expected");
                    message.divideTask = $root.oracle_job.OracleJob.DivideTask.fromObject(object.divideTask);
                }
                if (object.multiplyTask != null) {
                    if (typeof object.multiplyTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.multiplyTask: object expected");
                    message.multiplyTask = $root.oracle_job.OracleJob.MultiplyTask.fromObject(object.multiplyTask);
                }
                if (object.lpTokenPriceTask != null) {
                    if (typeof object.lpTokenPriceTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.lpTokenPriceTask: object expected");
                    message.lpTokenPriceTask = $root.oracle_job.OracleJob.LpTokenPriceTask.fromObject(object.lpTokenPriceTask);
                }
                if (object.lpExchangeRateTask != null) {
                    if (typeof object.lpExchangeRateTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.lpExchangeRateTask: object expected");
                    message.lpExchangeRateTask = $root.oracle_job.OracleJob.LpExchangeRateTask.fromObject(object.lpExchangeRateTask);
                }
                if (object.conditionalTask != null) {
                    if (typeof object.conditionalTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.conditionalTask: object expected");
                    message.conditionalTask = $root.oracle_job.OracleJob.ConditionalTask.fromObject(object.conditionalTask);
                }
                if (object.valueTask != null) {
                    if (typeof object.valueTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.valueTask: object expected");
                    message.valueTask = $root.oracle_job.OracleJob.ValueTask.fromObject(object.valueTask);
                }
                if (object.maxTask != null) {
                    if (typeof object.maxTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.maxTask: object expected");
                    message.maxTask = $root.oracle_job.OracleJob.MaxTask.fromObject(object.maxTask);
                }
                if (object.regexExtractTask != null) {
                    if (typeof object.regexExtractTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.regexExtractTask: object expected");
                    message.regexExtractTask = $root.oracle_job.OracleJob.RegexExtractTask.fromObject(object.regexExtractTask);
                }
                if (object.xstepPriceTask != null) {
                    if (typeof object.xstepPriceTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.xstepPriceTask: object expected");
                    message.xstepPriceTask = $root.oracle_job.OracleJob.XStepPriceTask.fromObject(object.xstepPriceTask);
                }
                if (object.addTask != null) {
                    if (typeof object.addTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.addTask: object expected");
                    message.addTask = $root.oracle_job.OracleJob.AddTask.fromObject(object.addTask);
                }
                if (object.subtractTask != null) {
                    if (typeof object.subtractTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.subtractTask: object expected");
                    message.subtractTask = $root.oracle_job.OracleJob.SubtractTask.fromObject(object.subtractTask);
                }
                if (object.serumSwapTask != null) {
                    if (typeof object.serumSwapTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.serumSwapTask: object expected");
                    message.serumSwapTask = $root.oracle_job.OracleJob.SerumSwapTask.fromObject(object.serumSwapTask);
                }
                if (object.openbookTask != null) {
                    if (typeof object.openbookTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.openbookTask: object expected");
                    message.openbookTask = $root.oracle_job.OracleJob.SerumSwapTask.fromObject(object.openbookTask);
                }
                if (object.powTask != null) {
                    if (typeof object.powTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.powTask: object expected");
                    message.powTask = $root.oracle_job.OracleJob.PowTask.fromObject(object.powTask);
                }
                if (object.lendingRateTask != null) {
                    if (typeof object.lendingRateTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.lendingRateTask: object expected");
                    message.lendingRateTask = $root.oracle_job.OracleJob.LendingRateTask.fromObject(object.lendingRateTask);
                }
                if (object.jupiterSwapTask != null) {
                    if (typeof object.jupiterSwapTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.jupiterSwapTask: object expected");
                    message.jupiterSwapTask = $root.oracle_job.OracleJob.JupiterSwapTask.fromObject(object.jupiterSwapTask);
                }
                if (object.perpMarketTask != null) {
                    if (typeof object.perpMarketTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.perpMarketTask: object expected");
                    message.perpMarketTask = $root.oracle_job.OracleJob.PerpMarketTask.fromObject(object.perpMarketTask);
                }
                if (object.oracleTask != null) {
                    if (typeof object.oracleTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.oracleTask: object expected");
                    message.oracleTask = $root.oracle_job.OracleJob.OracleTask.fromObject(object.oracleTask);
                }
                if (object.anchorFetchTask != null) {
                    if (typeof object.anchorFetchTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.anchorFetchTask: object expected");
                    message.anchorFetchTask = $root.oracle_job.OracleJob.AnchorFetchTask.fromObject(object.anchorFetchTask);
                }
                if (object.splStakePoolTask != null) {
                    if (typeof object.splStakePoolTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.splStakePoolTask: object expected");
                    message.splStakePoolTask = $root.oracle_job.OracleJob.SplStakePoolTask.fromObject(object.splStakePoolTask);
                }
                if (object.splTokenParseTask != null) {
                    if (typeof object.splTokenParseTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.splTokenParseTask: object expected");
                    message.splTokenParseTask = $root.oracle_job.OracleJob.SplTokenParseTask.fromObject(object.splTokenParseTask);
                }
                if (object.uniswapExchangeRateTask != null) {
                    if (typeof object.uniswapExchangeRateTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.uniswapExchangeRateTask: object expected");
                    message.uniswapExchangeRateTask = $root.oracle_job.OracleJob.UniswapExchangeRateTask.fromObject(object.uniswapExchangeRateTask);
                }
                if (object.sushiswapExchangeRateTask != null) {
                    if (typeof object.sushiswapExchangeRateTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.sushiswapExchangeRateTask: object expected");
                    message.sushiswapExchangeRateTask = $root.oracle_job.OracleJob.SushiswapExchangeRateTask.fromObject(object.sushiswapExchangeRateTask);
                }
                if (object.pancakeswapExchangeRateTask != null) {
                    if (typeof object.pancakeswapExchangeRateTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.pancakeswapExchangeRateTask: object expected");
                    message.pancakeswapExchangeRateTask = $root.oracle_job.OracleJob.PancakeswapExchangeRateTask.fromObject(object.pancakeswapExchangeRateTask);
                }
                if (object.cacheTask != null) {
                    if (typeof object.cacheTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.cacheTask: object expected");
                    message.cacheTask = $root.oracle_job.OracleJob.CacheTask.fromObject(object.cacheTask);
                }
                if (object.sysclockOffsetTask != null) {
                    if (typeof object.sysclockOffsetTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.sysclockOffsetTask: object expected");
                    message.sysclockOffsetTask = $root.oracle_job.OracleJob.SysclockOffsetTask.fromObject(object.sysclockOffsetTask);
                }
                if (object.marinadeStateTask != null) {
                    if (typeof object.marinadeStateTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.marinadeStateTask: object expected");
                    message.marinadeStateTask = $root.oracle_job.OracleJob.MarinadeStateTask.fromObject(object.marinadeStateTask);
                }
                if (object.solanaAccountDataFetchTask != null) {
                    if (typeof object.solanaAccountDataFetchTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.solanaAccountDataFetchTask: object expected");
                    message.solanaAccountDataFetchTask = $root.oracle_job.OracleJob.SolanaAccountDataFetchTask.fromObject(object.solanaAccountDataFetchTask);
                }
                if (object.bufferLayoutParseTask != null) {
                    if (typeof object.bufferLayoutParseTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.bufferLayoutParseTask: object expected");
                    message.bufferLayoutParseTask = $root.oracle_job.OracleJob.BufferLayoutParseTask.fromObject(object.bufferLayoutParseTask);
                }
                if (object.cronParseTask != null) {
                    if (typeof object.cronParseTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.cronParseTask: object expected");
                    message.cronParseTask = $root.oracle_job.OracleJob.CronParseTask.fromObject(object.cronParseTask);
                }
                if (object.minTask != null) {
                    if (typeof object.minTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.minTask: object expected");
                    message.minTask = $root.oracle_job.OracleJob.MinTask.fromObject(object.minTask);
                }
                if (object.comparisonTask != null) {
                    if (typeof object.comparisonTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.comparisonTask: object expected");
                    message.comparisonTask = $root.oracle_job.OracleJob.ComparisonTask.fromObject(object.comparisonTask);
                }
                if (object.roundTask != null) {
                    if (typeof object.roundTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.roundTask: object expected");
                    message.roundTask = $root.oracle_job.OracleJob.RoundTask.fromObject(object.roundTask);
                }
                if (object.boundTask != null) {
                    if (typeof object.boundTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.boundTask: object expected");
                    message.boundTask = $root.oracle_job.OracleJob.BoundTask.fromObject(object.boundTask);
                }
                if (object.secretsTask != null) {
                    if (typeof object.secretsTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.secretsTask: object expected");
                    message.secretsTask = $root.oracle_job.OracleJob.SecretsTask.fromObject(object.secretsTask);
                }
                if (object.sanctumLstPriceTask != null) {
                    if (typeof object.sanctumLstPriceTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.sanctumLstPriceTask: object expected");
                    message.sanctumLstPriceTask = $root.oracle_job.OracleJob.SanctumLstPriceTask.fromObject(object.sanctumLstPriceTask);
                }
                if (object.ondoUsdyTask != null) {
                    if (typeof object.ondoUsdyTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.ondoUsdyTask: object expected");
                    message.ondoUsdyTask = $root.oracle_job.OracleJob.OndoUsdyTask.fromObject(object.ondoUsdyTask);
                }
                if (object.meteoraSwapTask != null) {
                    if (typeof object.meteoraSwapTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.meteoraSwapTask: object expected");
                    message.meteoraSwapTask = $root.oracle_job.OracleJob.MeteoraSwapTask.fromObject(object.meteoraSwapTask);
                }
                if (object.unixTimeTask != null) {
                    if (typeof object.unixTimeTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.unixTimeTask: object expected");
                    message.unixTimeTask = $root.oracle_job.OracleJob.UnixTimeTask.fromObject(object.unixTimeTask);
                }
                if (object.mapleFinanceTask != null) {
                    if (typeof object.mapleFinanceTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.mapleFinanceTask: object expected");
                    message.mapleFinanceTask = $root.oracle_job.OracleJob.MapleFinanceTask.fromObject(object.mapleFinanceTask);
                }
                if (object.glyphTask != null) {
                    if (typeof object.glyphTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.glyphTask: object expected");
                    message.glyphTask = $root.oracle_job.OracleJob.GlyphTask.fromObject(object.glyphTask);
                }
                if (object.corexTask != null) {
                    if (typeof object.corexTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.corexTask: object expected");
                    message.corexTask = $root.oracle_job.OracleJob.CorexTask.fromObject(object.corexTask);
                }
                if (object.solayerSusdTask != null) {
                    if (typeof object.solayerSusdTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.solayerSusdTask: object expected");
                    message.solayerSusdTask = $root.oracle_job.OracleJob.SolayerSusdTask.fromObject(object.solayerSusdTask);
                }
                if (object.curveFinanceTask != null) {
                    if (typeof object.curveFinanceTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.curveFinanceTask: object expected");
                    message.curveFinanceTask = $root.oracle_job.OracleJob.CurveFinanceTask.fromObject(object.curveFinanceTask);
                }
                if (object.turboEthRedemptionRateTask != null) {
                    if (typeof object.turboEthRedemptionRateTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.turboEthRedemptionRateTask: object expected");
                    message.turboEthRedemptionRateTask = $root.oracle_job.OracleJob.TurboEthRedemptionRateTask.fromObject(object.turboEthRedemptionRateTask);
                }
                if (object.bitFluxTask != null) {
                    if (typeof object.bitFluxTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.bitFluxTask: object expected");
                    message.bitFluxTask = $root.oracle_job.OracleJob.BitFluxTask.fromObject(object.bitFluxTask);
                }
                if (object.fragmetricTask != null) {
                    if (typeof object.fragmetricTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.fragmetricTask: object expected");
                    message.fragmetricTask = $root.oracle_job.OracleJob.FragmetricTask.fromObject(object.fragmetricTask);
                }
                if (object.aftermathTask != null) {
                    if (typeof object.aftermathTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.aftermathTask: object expected");
                    message.aftermathTask = $root.oracle_job.OracleJob.AftermathTask.fromObject(object.aftermathTask);
                }
                if (object.etherfuseTask != null) {
                    if (typeof object.etherfuseTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.etherfuseTask: object expected");
                    message.etherfuseTask = $root.oracle_job.OracleJob.EtherfuseTask.fromObject(object.etherfuseTask);
                }
                if (object.lstHistoricalYieldTask != null) {
                    if (typeof object.lstHistoricalYieldTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.lstHistoricalYieldTask: object expected");
                    message.lstHistoricalYieldTask = $root.oracle_job.OracleJob.LstHistoricalYieldTask.fromObject(object.lstHistoricalYieldTask);
                }
                if (object.pumpAmmTask != null) {
                    if (typeof object.pumpAmmTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.pumpAmmTask: object expected");
                    message.pumpAmmTask = $root.oracle_job.OracleJob.PumpAmmTask.fromObject(object.pumpAmmTask);
                }
                if (object.pumpAmmLpTokenPriceTask != null) {
                    if (typeof object.pumpAmmLpTokenPriceTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.pumpAmmLpTokenPriceTask: object expected");
                    message.pumpAmmLpTokenPriceTask = $root.oracle_job.OracleJob.PumpAmmLpTokenPriceTask.fromObject(object.pumpAmmLpTokenPriceTask);
                }
                if (object.exponentTask != null) {
                    if (typeof object.exponentTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.exponentTask: object expected");
                    message.exponentTask = $root.oracle_job.OracleJob.ExponentTask.fromObject(object.exponentTask);
                }
                if (object.exponentPtLinearPricingTask != null) {
                    if (typeof object.exponentPtLinearPricingTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.exponentPtLinearPricingTask: object expected");
                    message.exponentPtLinearPricingTask = $root.oracle_job.OracleJob.ExponentPTLinearPricingTask.fromObject(object.exponentPtLinearPricingTask);
                }
                if (object.solanaToken_2022ExtensionTask != null) {
                    if (typeof object.solanaToken_2022ExtensionTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.solanaToken_2022ExtensionTask: object expected");
                    message.solanaToken_2022ExtensionTask = $root.oracle_job.OracleJob.SolanaToken2022ExtensionTask.fromObject(object.solanaToken_2022ExtensionTask);
                }
                if (object.switchboardSurgeTask != null) {
                    if (typeof object.switchboardSurgeTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.switchboardSurgeTask: object expected");
                    message.switchboardSurgeTask = $root.oracle_job.OracleJob.SwitchboardSurgeTask.fromObject(object.switchboardSurgeTask);
                }
                if (object.kalshiApiTask != null) {
                    if (typeof object.kalshiApiTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.kalshiApiTask: object expected");
                    message.kalshiApiTask = $root.oracle_job.OracleJob.KalshiApiTask.fromObject(object.kalshiApiTask);
                }
                if (object.titanTask != null) {
                    if (typeof object.titanTask !== "object")
                        throw TypeError(".oracle_job.OracleJob.Task.titanTask: object expected");
                    message.titanTask = $root.oracle_job.OracleJob.TitanTask.fromObject(object.titanTask);
                }
                return message;
            };

            /**
             * Creates a plain object from a Task message. Also converts values to other types if specified.
             * @function toObject
             * @memberof oracle_job.OracleJob.Task
             * @static
             * @param {oracle_job.OracleJob.Task} message Task
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Task.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.httpTask != null && message.hasOwnProperty("httpTask")) {
                    object.httpTask = $root.oracle_job.OracleJob.HttpTask.toObject(message.httpTask, options);
                    if (options.oneofs)
                        object.Task = "httpTask";
                }
                if (message.jsonParseTask != null && message.hasOwnProperty("jsonParseTask")) {
                    object.jsonParseTask = $root.oracle_job.OracleJob.JsonParseTask.toObject(message.jsonParseTask, options);
                    if (options.oneofs)
                        object.Task = "jsonParseTask";
                }
                if (message.medianTask != null && message.hasOwnProperty("medianTask")) {
                    object.medianTask = $root.oracle_job.OracleJob.MedianTask.toObject(message.medianTask, options);
                    if (options.oneofs)
                        object.Task = "medianTask";
                }
                if (message.meanTask != null && message.hasOwnProperty("meanTask")) {
                    object.meanTask = $root.oracle_job.OracleJob.MeanTask.toObject(message.meanTask, options);
                    if (options.oneofs)
                        object.Task = "meanTask";
                }
                if (message.divideTask != null && message.hasOwnProperty("divideTask")) {
                    object.divideTask = $root.oracle_job.OracleJob.DivideTask.toObject(message.divideTask, options);
                    if (options.oneofs)
                        object.Task = "divideTask";
                }
                if (message.multiplyTask != null && message.hasOwnProperty("multiplyTask")) {
                    object.multiplyTask = $root.oracle_job.OracleJob.MultiplyTask.toObject(message.multiplyTask, options);
                    if (options.oneofs)
                        object.Task = "multiplyTask";
                }
                if (message.lpTokenPriceTask != null && message.hasOwnProperty("lpTokenPriceTask")) {
                    object.lpTokenPriceTask = $root.oracle_job.OracleJob.LpTokenPriceTask.toObject(message.lpTokenPriceTask, options);
                    if (options.oneofs)
                        object.Task = "lpTokenPriceTask";
                }
                if (message.lpExchangeRateTask != null && message.hasOwnProperty("lpExchangeRateTask")) {
                    object.lpExchangeRateTask = $root.oracle_job.OracleJob.LpExchangeRateTask.toObject(message.lpExchangeRateTask, options);
                    if (options.oneofs)
                        object.Task = "lpExchangeRateTask";
                }
                if (message.conditionalTask != null && message.hasOwnProperty("conditionalTask")) {
                    object.conditionalTask = $root.oracle_job.OracleJob.ConditionalTask.toObject(message.conditionalTask, options);
                    if (options.oneofs)
                        object.Task = "conditionalTask";
                }
                if (message.valueTask != null && message.hasOwnProperty("valueTask")) {
                    object.valueTask = $root.oracle_job.OracleJob.ValueTask.toObject(message.valueTask, options);
                    if (options.oneofs)
                        object.Task = "valueTask";
                }
                if (message.maxTask != null && message.hasOwnProperty("maxTask")) {
                    object.maxTask = $root.oracle_job.OracleJob.MaxTask.toObject(message.maxTask, options);
                    if (options.oneofs)
                        object.Task = "maxTask";
                }
                if (message.regexExtractTask != null && message.hasOwnProperty("regexExtractTask")) {
                    object.regexExtractTask = $root.oracle_job.OracleJob.RegexExtractTask.toObject(message.regexExtractTask, options);
                    if (options.oneofs)
                        object.Task = "regexExtractTask";
                }
                if (message.xstepPriceTask != null && message.hasOwnProperty("xstepPriceTask")) {
                    object.xstepPriceTask = $root.oracle_job.OracleJob.XStepPriceTask.toObject(message.xstepPriceTask, options);
                    if (options.oneofs)
                        object.Task = "xstepPriceTask";
                }
                if (message.addTask != null && message.hasOwnProperty("addTask")) {
                    object.addTask = $root.oracle_job.OracleJob.AddTask.toObject(message.addTask, options);
                    if (options.oneofs)
                        object.Task = "addTask";
                }
                if (message.subtractTask != null && message.hasOwnProperty("subtractTask")) {
                    object.subtractTask = $root.oracle_job.OracleJob.SubtractTask.toObject(message.subtractTask, options);
                    if (options.oneofs)
                        object.Task = "subtractTask";
                }
                if (message.serumSwapTask != null && message.hasOwnProperty("serumSwapTask")) {
                    object.serumSwapTask = $root.oracle_job.OracleJob.SerumSwapTask.toObject(message.serumSwapTask, options);
                    if (options.oneofs)
                        object.Task = "serumSwapTask";
                }
                if (message.powTask != null && message.hasOwnProperty("powTask")) {
                    object.powTask = $root.oracle_job.OracleJob.PowTask.toObject(message.powTask, options);
                    if (options.oneofs)
                        object.Task = "powTask";
                }
                if (message.lendingRateTask != null && message.hasOwnProperty("lendingRateTask")) {
                    object.lendingRateTask = $root.oracle_job.OracleJob.LendingRateTask.toObject(message.lendingRateTask, options);
                    if (options.oneofs)
                        object.Task = "lendingRateTask";
                }
                if (message.jupiterSwapTask != null && message.hasOwnProperty("jupiterSwapTask")) {
                    object.jupiterSwapTask = $root.oracle_job.OracleJob.JupiterSwapTask.toObject(message.jupiterSwapTask, options);
                    if (options.oneofs)
                        object.Task = "jupiterSwapTask";
                }
                if (message.perpMarketTask != null && message.hasOwnProperty("perpMarketTask")) {
                    object.perpMarketTask = $root.oracle_job.OracleJob.PerpMarketTask.toObject(message.perpMarketTask, options);
                    if (options.oneofs)
                        object.Task = "perpMarketTask";
                }
                if (message.oracleTask != null && message.hasOwnProperty("oracleTask")) {
                    object.oracleTask = $root.oracle_job.OracleJob.OracleTask.toObject(message.oracleTask, options);
                    if (options.oneofs)
                        object.Task = "oracleTask";
                }
                if (message.anchorFetchTask != null && message.hasOwnProperty("anchorFetchTask")) {
                    object.anchorFetchTask = $root.oracle_job.OracleJob.AnchorFetchTask.toObject(message.anchorFetchTask, options);
                    if (options.oneofs)
                        object.Task = "anchorFetchTask";
                }
                if (message.splStakePoolTask != null && message.hasOwnProperty("splStakePoolTask")) {
                    object.splStakePoolTask = $root.oracle_job.OracleJob.SplStakePoolTask.toObject(message.splStakePoolTask, options);
                    if (options.oneofs)
                        object.Task = "splStakePoolTask";
                }
                if (message.splTokenParseTask != null && message.hasOwnProperty("splTokenParseTask")) {
                    object.splTokenParseTask = $root.oracle_job.OracleJob.SplTokenParseTask.toObject(message.splTokenParseTask, options);
                    if (options.oneofs)
                        object.Task = "splTokenParseTask";
                }
                if (message.uniswapExchangeRateTask != null && message.hasOwnProperty("uniswapExchangeRateTask")) {
                    object.uniswapExchangeRateTask = $root.oracle_job.OracleJob.UniswapExchangeRateTask.toObject(message.uniswapExchangeRateTask, options);
                    if (options.oneofs)
                        object.Task = "uniswapExchangeRateTask";
                }
                if (message.sushiswapExchangeRateTask != null && message.hasOwnProperty("sushiswapExchangeRateTask")) {
                    object.sushiswapExchangeRateTask = $root.oracle_job.OracleJob.SushiswapExchangeRateTask.toObject(message.sushiswapExchangeRateTask, options);
                    if (options.oneofs)
                        object.Task = "sushiswapExchangeRateTask";
                }
                if (message.pancakeswapExchangeRateTask != null && message.hasOwnProperty("pancakeswapExchangeRateTask")) {
                    object.pancakeswapExchangeRateTask = $root.oracle_job.OracleJob.PancakeswapExchangeRateTask.toObject(message.pancakeswapExchangeRateTask, options);
                    if (options.oneofs)
                        object.Task = "pancakeswapExchangeRateTask";
                }
                if (message.cacheTask != null && message.hasOwnProperty("cacheTask")) {
                    object.cacheTask = $root.oracle_job.OracleJob.CacheTask.toObject(message.cacheTask, options);
                    if (options.oneofs)
                        object.Task = "cacheTask";
                }
                if (message.sysclockOffsetTask != null && message.hasOwnProperty("sysclockOffsetTask")) {
                    object.sysclockOffsetTask = $root.oracle_job.OracleJob.SysclockOffsetTask.toObject(message.sysclockOffsetTask, options);
                    if (options.oneofs)
                        object.Task = "sysclockOffsetTask";
                }
                if (message.marinadeStateTask != null && message.hasOwnProperty("marinadeStateTask")) {
                    object.marinadeStateTask = $root.oracle_job.OracleJob.MarinadeStateTask.toObject(message.marinadeStateTask, options);
                    if (options.oneofs)
                        object.Task = "marinadeStateTask";
                }
                if (message.solanaAccountDataFetchTask != null && message.hasOwnProperty("solanaAccountDataFetchTask")) {
                    object.solanaAccountDataFetchTask = $root.oracle_job.OracleJob.SolanaAccountDataFetchTask.toObject(message.solanaAccountDataFetchTask, options);
                    if (options.oneofs)
                        object.Task = "solanaAccountDataFetchTask";
                }
                if (message.bufferLayoutParseTask != null && message.hasOwnProperty("bufferLayoutParseTask")) {
                    object.bufferLayoutParseTask = $root.oracle_job.OracleJob.BufferLayoutParseTask.toObject(message.bufferLayoutParseTask, options);
                    if (options.oneofs)
                        object.Task = "bufferLayoutParseTask";
                }
                if (message.cronParseTask != null && message.hasOwnProperty("cronParseTask")) {
                    object.cronParseTask = $root.oracle_job.OracleJob.CronParseTask.toObject(message.cronParseTask, options);
                    if (options.oneofs)
                        object.Task = "cronParseTask";
                }
                if (message.minTask != null && message.hasOwnProperty("minTask")) {
                    object.minTask = $root.oracle_job.OracleJob.MinTask.toObject(message.minTask, options);
                    if (options.oneofs)
                        object.Task = "minTask";
                }
                if (message.comparisonTask != null && message.hasOwnProperty("comparisonTask")) {
                    object.comparisonTask = $root.oracle_job.OracleJob.ComparisonTask.toObject(message.comparisonTask, options);
                    if (options.oneofs)
                        object.Task = "comparisonTask";
                }
                if (message.roundTask != null && message.hasOwnProperty("roundTask")) {
                    object.roundTask = $root.oracle_job.OracleJob.RoundTask.toObject(message.roundTask, options);
                    if (options.oneofs)
                        object.Task = "roundTask";
                }
                if (message.boundTask != null && message.hasOwnProperty("boundTask")) {
                    object.boundTask = $root.oracle_job.OracleJob.BoundTask.toObject(message.boundTask, options);
                    if (options.oneofs)
                        object.Task = "boundTask";
                }
                if (message.secretsTask != null && message.hasOwnProperty("secretsTask")) {
                    object.secretsTask = $root.oracle_job.OracleJob.SecretsTask.toObject(message.secretsTask, options);
                    if (options.oneofs)
                        object.Task = "secretsTask";
                }
                if (message.sanctumLstPriceTask != null && message.hasOwnProperty("sanctumLstPriceTask")) {
                    object.sanctumLstPriceTask = $root.oracle_job.OracleJob.SanctumLstPriceTask.toObject(message.sanctumLstPriceTask, options);
                    if (options.oneofs)
                        object.Task = "sanctumLstPriceTask";
                }
                if (message.ondoUsdyTask != null && message.hasOwnProperty("ondoUsdyTask")) {
                    object.ondoUsdyTask = $root.oracle_job.OracleJob.OndoUsdyTask.toObject(message.ondoUsdyTask, options);
                    if (options.oneofs)
                        object.Task = "ondoUsdyTask";
                }
                if (message.meteoraSwapTask != null && message.hasOwnProperty("meteoraSwapTask")) {
                    object.meteoraSwapTask = $root.oracle_job.OracleJob.MeteoraSwapTask.toObject(message.meteoraSwapTask, options);
                    if (options.oneofs)
                        object.Task = "meteoraSwapTask";
                }
                if (message.unixTimeTask != null && message.hasOwnProperty("unixTimeTask")) {
                    object.unixTimeTask = $root.oracle_job.OracleJob.UnixTimeTask.toObject(message.unixTimeTask, options);
                    if (options.oneofs)
                        object.Task = "unixTimeTask";
                }
                if (message.mapleFinanceTask != null && message.hasOwnProperty("mapleFinanceTask")) {
                    object.mapleFinanceTask = $root.oracle_job.OracleJob.MapleFinanceTask.toObject(message.mapleFinanceTask, options);
                    if (options.oneofs)
                        object.Task = "mapleFinanceTask";
                }
                if (message.glyphTask != null && message.hasOwnProperty("glyphTask")) {
                    object.glyphTask = $root.oracle_job.OracleJob.GlyphTask.toObject(message.glyphTask, options);
                    if (options.oneofs)
                        object.Task = "glyphTask";
                }
                if (message.corexTask != null && message.hasOwnProperty("corexTask")) {
                    object.corexTask = $root.oracle_job.OracleJob.CorexTask.toObject(message.corexTask, options);
                    if (options.oneofs)
                        object.Task = "corexTask";
                }
                if (message.solayerSusdTask != null && message.hasOwnProperty("solayerSusdTask")) {
                    object.solayerSusdTask = $root.oracle_job.OracleJob.SolayerSusdTask.toObject(message.solayerSusdTask, options);
                    if (options.oneofs)
                        object.Task = "solayerSusdTask";
                }
                if (message.curveFinanceTask != null && message.hasOwnProperty("curveFinanceTask")) {
                    object.curveFinanceTask = $root.oracle_job.OracleJob.CurveFinanceTask.toObject(message.curveFinanceTask, options);
                    if (options.oneofs)
                        object.Task = "curveFinanceTask";
                }
                if (message.turboEthRedemptionRateTask != null && message.hasOwnProperty("turboEthRedemptionRateTask")) {
                    object.turboEthRedemptionRateTask = $root.oracle_job.OracleJob.TurboEthRedemptionRateTask.toObject(message.turboEthRedemptionRateTask, options);
                    if (options.oneofs)
                        object.Task = "turboEthRedemptionRateTask";
                }
                if (message.bitFluxTask != null && message.hasOwnProperty("bitFluxTask")) {
                    object.bitFluxTask = $root.oracle_job.OracleJob.BitFluxTask.toObject(message.bitFluxTask, options);
                    if (options.oneofs)
                        object.Task = "bitFluxTask";
                }
                if (message.fragmetricTask != null && message.hasOwnProperty("fragmetricTask")) {
                    object.fragmetricTask = $root.oracle_job.OracleJob.FragmetricTask.toObject(message.fragmetricTask, options);
                    if (options.oneofs)
                        object.Task = "fragmetricTask";
                }
                if (message.aftermathTask != null && message.hasOwnProperty("aftermathTask")) {
                    object.aftermathTask = $root.oracle_job.OracleJob.AftermathTask.toObject(message.aftermathTask, options);
                    if (options.oneofs)
                        object.Task = "aftermathTask";
                }
                if (message.etherfuseTask != null && message.hasOwnProperty("etherfuseTask")) {
                    object.etherfuseTask = $root.oracle_job.OracleJob.EtherfuseTask.toObject(message.etherfuseTask, options);
                    if (options.oneofs)
                        object.Task = "etherfuseTask";
                }
                if (message.lstHistoricalYieldTask != null && message.hasOwnProperty("lstHistoricalYieldTask")) {
                    object.lstHistoricalYieldTask = $root.oracle_job.OracleJob.LstHistoricalYieldTask.toObject(message.lstHistoricalYieldTask, options);
                    if (options.oneofs)
                        object.Task = "lstHistoricalYieldTask";
                }
                if (message.pumpAmmTask != null && message.hasOwnProperty("pumpAmmTask")) {
                    object.pumpAmmTask = $root.oracle_job.OracleJob.PumpAmmTask.toObject(message.pumpAmmTask, options);
                    if (options.oneofs)
                        object.Task = "pumpAmmTask";
                }
                if (message.pumpAmmLpTokenPriceTask != null && message.hasOwnProperty("pumpAmmLpTokenPriceTask")) {
                    object.pumpAmmLpTokenPriceTask = $root.oracle_job.OracleJob.PumpAmmLpTokenPriceTask.toObject(message.pumpAmmLpTokenPriceTask, options);
                    if (options.oneofs)
                        object.Task = "pumpAmmLpTokenPriceTask";
                }
                if (message.exponentTask != null && message.hasOwnProperty("exponentTask")) {
                    object.exponentTask = $root.oracle_job.OracleJob.ExponentTask.toObject(message.exponentTask, options);
                    if (options.oneofs)
                        object.Task = "exponentTask";
                }
                if (message.exponentPtLinearPricingTask != null && message.hasOwnProperty("exponentPtLinearPricingTask")) {
                    object.exponentPtLinearPricingTask = $root.oracle_job.OracleJob.ExponentPTLinearPricingTask.toObject(message.exponentPtLinearPricingTask, options);
                    if (options.oneofs)
                        object.Task = "exponentPtLinearPricingTask";
                }
                if (message.solanaToken_2022ExtensionTask != null && message.hasOwnProperty("solanaToken_2022ExtensionTask")) {
                    object.solanaToken_2022ExtensionTask = $root.oracle_job.OracleJob.SolanaToken2022ExtensionTask.toObject(message.solanaToken_2022ExtensionTask, options);
                    if (options.oneofs)
                        object.Task = "solanaToken_2022ExtensionTask";
                }
                if (message.switchboardSurgeTask != null && message.hasOwnProperty("switchboardSurgeTask")) {
                    object.switchboardSurgeTask = $root.oracle_job.OracleJob.SwitchboardSurgeTask.toObject(message.switchboardSurgeTask, options);
                    if (options.oneofs)
                        object.Task = "switchboardSurgeTask";
                }
                if (message.openbookTask != null && message.hasOwnProperty("openbookTask")) {
                    object.openbookTask = $root.oracle_job.OracleJob.SerumSwapTask.toObject(message.openbookTask, options);
                    if (options.oneofs)
                        object.Task = "openbookTask";
                }
                if (message.kalshiApiTask != null && message.hasOwnProperty("kalshiApiTask")) {
                    object.kalshiApiTask = $root.oracle_job.OracleJob.KalshiApiTask.toObject(message.kalshiApiTask, options);
                    if (options.oneofs)
                        object.Task = "kalshiApiTask";
                }
                if (message.titanTask != null && message.hasOwnProperty("titanTask")) {
                    object.titanTask = $root.oracle_job.OracleJob.TitanTask.toObject(message.titanTask, options);
                    if (options.oneofs)
                        object.Task = "titanTask";
                }
                return object;
            };

            /**
             * Converts this Task to JSON.
             * @function toJSON
             * @memberof oracle_job.OracleJob.Task
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Task.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Task
             * @function getTypeUrl
             * @memberof oracle_job.OracleJob.Task
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Task.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/oracle_job.OracleJob.Task";
            };

            return Task;
        })();

        return OracleJob;
    })();

    return oracle_job;
})();

export { $root as default };

"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeString = exports.isBase64 = exports.toHex = exports.isHex = exports.isKeypairString = exports.isBytes = exports.isBase58 = exports.toUtf8 = exports.buf2String = void 0;
exports.parseMrEnclave = parseMrEnclave;
exports.parseRawMrEnclave = parseRawMrEnclave;
const bs58_1 = __importDefault(require("bs58"));
const buffer_1 = require("buffer");
const assertPositiveInteger = (int) => {
    if (int && (!Number.isInteger(int) || int < 0)) {
        throw new Error('parameter expects a positive integer.');
    }
};
/**
 * Converts to utf-8 encoding and removes null characters.
 *
 * @param buf - the buffer, byte array, or string to convert to utf-8 encoding
 *
 * @returns utf-8 encoded string
 */
const buf2String = (buf) => (buffer_1.Buffer.isBuffer(buf) ? buf : buffer_1.Buffer.from(buf))
    .toString('utf8')
    .split('\0')
    .join('');
exports.buf2String = buf2String;
/**
 * Converts to utf-8 encoding and removes null characters.
 *
 * @param buf - the buffer, byte array, or string to convert to utf-8 encoding
 *
 * @returns utf-8 encoded string
 */
exports.toUtf8 = exports.buf2String;
/**
 * Determine whether a given string contains only base58 characters
 * @param value - the string to verify
 * @returns boolean indicating if a value is base58 encoded
 */
const isBase58 = (value) => /^[A-HJ-NP-Za-km-z1-9]*$/.test(value);
exports.isBase58 = isBase58;
/**
 * Determine whether a given string contains a secretKey Uint8Array
 * @param value - the string to verify
 * @param length - the minimum number of bytes enclosed in square brackets
 * @returns boolean indicating if a value contains a secretKey in byte array format
 */
const isBytes = (value, length) => {
    assertPositiveInteger(length);
    const lengthPattern = length ? `{${length},}` : '*';
    const bytesRegexPattern = new RegExp(`^\\[\\s*(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)((\\s*,\\s*(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))${lengthPattern})?\\s*\\]$`);
    return bytesRegexPattern.test(value);
};
exports.isBytes = isBytes;
/**
 * Determine whether a given string contains a secretKey Uint8Array
 * @param value - the string to verify
 * @param length - the minimum number of bytes enclosed in square brackets
 * @returns boolean indicating if a value contains a secretKey in byte array format
 */
exports.isKeypairString = exports.isBytes;
/**
 * Determine whether a given string is hex encoded
 * @param value - the string to verify
 * @param length - the minimum number of characters following the 0x prefix
 * @returns boolean indicating if a value is a hex encoded string
 */
const isHex = (value, length) => {
    assertPositiveInteger(length);
    const hexRegexPattern = length
        ? new RegExp(`^(0x|0X)?[a-fA-F0-9]{${length}}$`)
        : new RegExp('^(0x|0X)?[a-fA-F0-9]+$');
    return hexRegexPattern.test(value);
};
exports.isHex = isHex;
/**
 * Converts a string to a hex string with 0x prefix.
 *
 * Supported input formats:
 * - Byte array string: "[1, 2, 3, ...]"
 * - Hex string: "0xabc123..." or "abc123..."
 * - Base64 string: "VGhpcyBpcyBhIHRlc3Qgc3RyaW5nLg=="
 * - Base58 string: "12DsSDs23..."
 *
 * @param value - The string to convert to hex
 * @returns A hex string with 0x prefix
 * @throws Error if the input cannot be decoded into a valid format
 *
 * @example
 * toHex("[1, 2, 3]") // returns "0x010203"
 * toHex("0xabc123") // returns "0xabc123"
 */
const toHex = (value) => {
    if (!value)
        throw new Error('Input string cannot be empty');
    const decoded = (0, exports.decodeString)(value);
    if (decoded)
        return `0x${decoded.toString('hex')}`;
    throw new Error('Failed to decode string');
};
exports.toHex = toHex;
/**
 * Determine whether a given string is base64 encoded
 * @param value - the string to verify
 * @returns boolean indicating if a value is a base64 encoded string
 */
const isBase64 = (value, length) => {
    assertPositiveInteger(length);
    const base64RegexPattern = length
        ? new RegExp(`^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4}){${length},}$`)
        : new RegExp('^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$');
    return base64RegexPattern.test(value);
};
exports.isBase64 = isBase64;
/**
 * Attempt to parse a string into a valid a buffer format.
 *
 * Accepted formats:
 *  - byte array "[1, 2, 3, ...]"
 *  - hex string "0xabc123..."
 *  - base64 string "VGhpcyBpcyBhIHRlc3Qgc3RyaW5nLg=="
 *  - base58 string "12DsSDs23..."
 *
 * @returns the parsed string in Buffer format or undefined if no regex matches found
 */
const decodeString = (data) => {
    const trimmed = data.trim();
    if ((0, exports.isBytes)(trimmed)) {
        return buffer_1.Buffer.from(new Uint8Array(JSON.parse(trimmed)));
    }
    else if ((0, exports.isHex)(trimmed)) {
        return buffer_1.Buffer.from(trimmed.toLowerCase().replace(/^0x/, ''), 'hex');
    }
    else if ((0, exports.isBase58)(trimmed)) {
        return buffer_1.Buffer.from(bs58_1.default.decode(trimmed));
    }
    else if ((0, exports.isBase64)(trimmed)) {
        return buffer_1.Buffer.from(trimmed, 'base64');
    }
    return undefined;
};
exports.decodeString = decodeString;
function parseMrEnclave(hexString) {
    if (!(0, exports.isHex)(hexString, 64)) {
        throw new Error('Not a valid hex string representation of a MRENCLAVE measurement');
    }
    const myUint8Array = new Uint8Array(buffer_1.Buffer.from(hexString.replaceAll(/0x|0X/g, ''), 'hex'));
    if (myUint8Array.byteLength !== 32) {
        throw new Error('Not a valid hex string representation of a MRENCLAVE measurement');
    }
    return myUint8Array;
}
function parseRawMrEnclave(rawBuffer, addMissingBytes = false) {
    let myUint8Array;
    if (typeof rawBuffer === 'string') {
        if ((0, exports.isBytes)(rawBuffer, 32)) {
            // check if its a string of bytes '[1,2,3]'
            myUint8Array = new Uint8Array(JSON.parse(rawBuffer));
        }
        else if ((0, exports.isHex)(rawBuffer, 64)) {
            // check if its a hex string '0x1A'
            myUint8Array = new Uint8Array(buffer_1.Buffer.from(rawBuffer.replaceAll(/0x|0X/g, ''), 'hex'));
        }
        else if ((0, exports.isBase64)(rawBuffer, 32)) {
            // check if its a base64 string
            myUint8Array = new Uint8Array(buffer_1.Buffer.from(rawBuffer, 'base64'));
        }
        else {
            // assume utf-8
            myUint8Array = new Uint8Array(buffer_1.Buffer.from(rawBuffer, 'utf-8'));
        }
    }
    else if (rawBuffer instanceof buffer_1.Buffer) {
        myUint8Array = new Uint8Array(rawBuffer);
    }
    else if (rawBuffer instanceof Uint8Array) {
        myUint8Array = rawBuffer;
    }
    else {
        // Assume input is number[]
        myUint8Array = new Uint8Array(rawBuffer);
    }
    if (addMissingBytes) {
        // make sure its always 32 bytes
        return new Uint8Array(Array.from(myUint8Array).concat(Array(32).fill(0)).slice(0, 32));
    }
    if (myUint8Array.byteLength !== 32) {
        throw new Error('Not a valid hex string representation of a MRENCLAVE measurement');
    }
    return myUint8Array;
}

"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetch = fetch;
const axios_1 = __importDefault(require("axios"));
const https_1 = require("https");
const AXIOS = axios_1.default.create({
    httpsAgent: new https_1.Agent({ maxSockets: 100 }),
});
class Headers {
    constructor(init) {
        this.headers = new Map();
        if (init) {
            if (Array.isArray(init)) {
                init.forEach(([key, value]) => this.append(key, value));
            }
            else {
                Object.entries(init).forEach(([key, value]) => this.append(key, value));
            }
        }
    }
    append(name, value) {
        this.headers.set(name.toLowerCase(), value);
    }
    delete(name) {
        this.headers.delete(name.toLowerCase());
    }
    get(name) {
        var _a;
        return (_a = this.headers.get(name.toLowerCase())) !== null && _a !== void 0 ? _a : null;
    }
    has(name) {
        return this.headers.has(name.toLowerCase());
    }
    set(name, value) {
        this.headers.set(name.toLowerCase(), value);
    }
    forEach(callback) {
        this.headers.forEach((value, key) => callback(value, key));
    }
}
class Response {
    constructor(body, init) {
        this.body = body;
        this.init = init;
    }
    get ok() {
        return this.init.status >= 200 && this.init.status < 300;
    }
    get status() {
        return this.init.status;
    }
    get statusText() {
        return this.init.statusText;
    }
    get headers() {
        return this.init.headers;
    }
    async json() {
        return JSON.parse(this.body);
    }
    async text() {
        return this.body;
    }
}
/**
 * Convert headers to axios headers
 * @param headers NodeJS Headers object or Fetch Headers object
 * @returns Axios Headers object
 */
function convertHeaders(headers) {
    const axiosHeaders = {};
    if (headers instanceof Headers) {
        // Convert Headers object to plain object
        headers.forEach((value, key) => (axiosHeaders[key] = value));
    }
    else if (Array.isArray(headers)) {
        // Convert array of tuples to plain object
        headers.forEach(([key, value]) => (axiosHeaders[key] = value));
    }
    else {
        // Assume it's already a plain object
        Object.entries(headers !== null && headers !== void 0 ? headers : {}).forEach(
        // Convert value to string as Axios expects
        ([key, value]) => (axiosHeaders[key] = String(value)));
    }
    return axiosHeaders;
}
async function fetch(input, init) {
    const url = input.toString();
    // Adding default headers
    const axiosInit = !init || !init.headers ? { ...init } : init;
    const requestConfig = {
        method: axiosInit.method,
        headers: convertHeaders(axiosInit.headers),
        data: axiosInit.body,
        baseURL: url,
        validateStatus: () => true,
    };
    // Retry the request up to 3 timesif it fails with ECONNABORTED error
    const getAxiosResponse = async (attempt = 0) => {
        return await AXIOS.request(requestConfig).catch(async (error) => {
            if (error.code === 'ECONNABORTED' && attempt < 2) {
                await new Promise(res => setTimeout(res, Math.pow(2, attempt) * 100));
                return getAxiosResponse(attempt + 1);
            }
            else
                throw error;
        });
    };
    const axiosResponse = await getAxiosResponse();
    const { data, status, statusText, headers } = axiosResponse;
    // Mapping headers from axios to fetch format
    const response = new Response(JSON.stringify(data), {
        status,
        statusText,
        headers: new Headers(Object.entries(headers).map(([key, value]) => {
            return [key, value.toString()];
        })),
    });
    return Promise.resolve(response);
}

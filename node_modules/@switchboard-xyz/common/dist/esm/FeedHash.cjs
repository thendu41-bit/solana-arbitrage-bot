"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FeedHash = void 0;
const index_js_1 = require("./index.cjs");
const protos_js_1 = require("./protos.cjs");
const buffer_1 = require("buffer");
const js_sha256_1 = require("js-sha256");
class FeedHash {
    /**
     *  Disable object instantiation.
     */
    constructor() { }
    /**
     *  Validate that a provided string is indeed a valid feed hash.
     *
     *  To be a valid feed hash, the string should be a hex string that is 64 characters in length.
     *
     *  @returns the transformed feed hash (hex value) if valid.
     */
    static validate(feedHash) {
        // Make the feed hash lower case and remove the optional '0x' prefix if necessary.
        const transformed = (() => {
            const lowerCase = feedHash.toLowerCase();
            return lowerCase.startsWith('0x') ? lowerCase.substring(2) : lowerCase;
        })();
        // Validate that the result is 64 characters long and lower-case hex.
        if ((0, index_js_1.isHex)(transformed, 64))
            return transformed;
        throw new Error(`FeedHash.validate failed: ${feedHash}`);
    }
    /**
     *  After validating {@linkcode feedHash}, return it as a {@linkcode Buffer}.
     *
     *  @returns Buffer
     */
    static serialize(feedHash) {
        const validated = FeedHash.validate(feedHash);
        return buffer_1.Buffer.from(validated, 'hex');
    }
    /**
     *  Given a feed definition (a list of jobs), produce the associated feed hash and return it as a
     *  buffer.
     */
    static compute(queue, jobs) {
        const hasher = js_sha256_1.sha256.create();
        hasher.update(queue);
        jobs.forEach((job) => {
            hasher.update(index_js_1.OracleJob.encodeDelimited(job).finish());
        });
        return buffer_1.Buffer.from(hasher.digest());
    }
    /**
     *  Given an {@linkcode IOracleFeed}, produce the associated feed hash and return it as a buffer.
     */
    static computeOracleFeedId(feed) {
        const hasher = js_sha256_1.sha256.create();
        hasher.update(protos_js_1.OracleFeed.encodeDelimited(feed).finish());
        return buffer_1.Buffer.from(hasher.digest());
    }
    /**
     *  Validate that {@linkcode feedHash} is ok and try to fetch a verified feed definition for it.
     *
     *  @returns VerifiedFeed
     *  @throws If {@linkcode feedHash} is invalid or if there is no associated verified feed data.
     */
    static async fetchVerified(feedHash) {
        const validated = FeedHash.validate(feedHash);
        if (!validated)
            throw new Error('`feedHash` parameter is invalid.');
        // TODO: implement this function when we have a centralized place to load verified feeds from.
        throw new Error('NotImplemented');
    }
}
exports.FeedHash = FeedHash;

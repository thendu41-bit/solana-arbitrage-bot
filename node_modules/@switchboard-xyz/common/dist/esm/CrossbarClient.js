import { IxFromHex } from './utils/instructions.js';
import { decodeString } from './utils/string.js';
import { OracleFeed } from './protos.js';
import axios from 'axios';
import bs58 from 'bs58';
export class CrossbarClient {
    /**
     * Create a FeedRequestV1 object
     * @param {string[]} jobsB64Encoded - Base64 encoded oracle jobs
     * @param {number} maxVariance - Maximum variance allowed for the feed
     * @param {number} minResponses - Minimum number of oracle responses required
     * @returns {FeedRequest} - A FeedRequestV1 object
     */
    static createFeedRequestV1(jobsB64Encoded, maxVariance, minResponses) {
        return {
            jobsB64Encoded,
            maxVariance,
            minResponses,
        };
    }
    /**
     * Create a FeedRequestV2 object
     * @param {string} feedProtoB64 - Base64 encoded feed protobuf
     * @returns {FeedRequest} - A FeedRequestV2 object
     */
    static createFeedRequestV2(feedProtoB64) {
        return {
            feedProtoB64,
        };
    }
    static default(verbose) {
        if (!CrossbarClient._instance) {
            CrossbarClient._instance = new CrossbarClient('https://crossbar.switchboard.xyz', verbose);
        }
        return CrossbarClient._instance;
    }
    constructor(crossbarUrl, verbose) {
        // feed hash -> crossbar response
        this.feedCache = new Map();
        this.oracleFeedCache = new Map();
        this.crossbarUrl = new URL(crossbarUrl).origin;
        this.verbose = !!verbose;
    }
    /**
     * GET /fetch/:feedHash
     * Fetch data from the crossbar using the provided feedHash
     * @param {string} feedHash - The hash of the feed to fetch data for
     * @returns {Promise<CrossbarFetchResponse>} - The data fetched from the crossbar
     */
    async fetch(feedHash) {
        const v2CachedValue = this.oracleFeedCache.get(feedHash);
        if (v2CachedValue) {
            throw new Error('V2 cached value found, use fetchOracleFeed instead.');
        }
        try {
            // Check if the feedHash is already in the cache
            const cached = this.feedCache.get(feedHash);
            if (cached)
                return cached;
            // Fetch the data from the crossbar
            const response = await axios
                .get(`${this.crossbarUrl}/fetch/${feedHash}`)
                .then(resp => resp.data);
            // Cache the response on the crossbar instance
            this.feedCache.set(feedHash, response);
            return response;
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            // If response is outside of the 200 range, log the status and throw an error.
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar fetch status: ${response.status}`);
        }
    }
    /**
     * GET /v2/fetch/:feedHash
     * Fetch OracleFeed data from a crossbar server using the provided feedId
     * @param {string} feedId - The identifier of the OracleFeed to fetch
     * @returns {Promise<CrossbarOracleFeedFetchResponse>} - The data fetched from the crossbar
     */
    async fetchOracleFeed(feedId) {
        const legacyProtoCachedValue = this.feedCache.get(feedId);
        if (legacyProtoCachedValue) {
            throw new Error('Legacy proto cached value found, use fetch instead.');
        }
        try {
            // Check if the feedId is already in the cache
            const cached = this.oracleFeedCache.get(feedId);
            if (cached)
                return cached;
            const url = `${this.crossbarUrl}/v2/fetch/${feedId}`;
            // Fetch the data from the crossbar
            const response = await axios.get(url).then(resp => resp.data);
            // Cache the response on the crossbar instance
            this.oracleFeedCache.set(feedId, response);
            return response;
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            // If response is outside of the 200 range, log the status and throw an error.
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar /v2/fetch status: ${response.status}`);
        }
    }
    /**
     * POST /store
     * Store oracle jobs on the crossbar, associated with a queue address
     * @param {string} queueAddress - The address of the queue
     * @param {IOracleJob[]} jobs - The oracle jobs to store
     * @returns {Promise<{ cid: string; feedHash: string; queueHex: string }>} - The stored data information
     */
    async store(queueAddress, jobs) {
        try {
            // Try to decode the queueAddress to a Buffer so that we can send it in the expected format,
            // base58, to the Crossbar node.
            const queue = decodeString(queueAddress);
            if (!queue)
                throw new Error(`Unable to parse queue: ${queueAddress}`);
            return await axios
                .post(`${this.crossbarUrl}/store`, { queue: bs58.encode(queue), jobs }, { headers: { 'Content-Type': 'application/json' } })
                .then(resp => {
                if (resp.status === 200)
                    return resp.data;
                throw new Error(`Bad Crossbar store response: ${resp.status}`);
            });
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar store response: ${response.status}`);
        }
    }
    /**
     * POST /v2/store
     * Store an OracleFeed on IPFS using crossbar.
     * @param {IOracleFeed} feed - The OracleFeed to store
     * @returns {Promise<{ cid: string; feedHash: string; queueHex: string }>} - The stored data information
     */
    async storeOracleFeed(feed) {
        try {
            return await axios
                .post(`${this.crossbarUrl}/v2/store`, { feed }, { headers: { 'Content-Type': 'application/json' } })
                .then(resp => {
                if (resp.status === 200)
                    return resp.data;
                throw new Error(`Bad Crossbar v2/store response: ${resp.status}`);
            });
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar v2/store response: ${response.status}`);
        }
    }
    /**
     * GET /simulate/:feedHashes
     * Simulate fetching feed results from the crossbar using feed hashes
     * @param {string[]} feedHashes - The hashes of the feeds to simulate
     * @param {boolean} [includeReceipts] - Whether to include receipts in the response
     * @returns {Promise<CrossbarSimulateResponse[]>} - The simulated feed results
     */
    async simulateFeeds(feedHashes, includeReceipts) {
        try {
            if (!feedHashes || feedHashes.length === 0)
                throw new Error('At least one feed is required');
            const feedsParam = feedHashes.join(',');
            return await axios
                .get(`${this.crossbarUrl}/simulate/${feedsParam}`, {
                params: { includeReceipts },
            })
                .then(resp => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar simulateFeed response: ${response.status}`);
        }
    }
    /**
     * GET /v2/simulate/:feedHashes
     * Simulate V2 oracle feeds with variable overrides and network selection
     * @param {string[]} feedHashes - The hashes of the V2 feeds to simulate
     * @param {boolean} [includeReceipts] - Whether to include receipts in the response
     * @param {Record<string, string>} [variableOverrides] - Variable overrides for the simulation
     * @param {string} [network] - Network to use for simulation (defaults to "mainnet")
     * @returns {Promise<CrossbarSimulateV2Response[]>} - The simulated V2 feed results
     */
    async simulateOracleFeeds(feedHashes, includeReceipts, variableOverrides, network) {
        try {
            if (!feedHashes || feedHashes.length === 0)
                throw new Error('At least one feed is required');
            const feedsParam = feedHashes.join(',');
            const params = {};
            if (includeReceipts !== undefined) {
                params.includeReceipts = includeReceipts;
            }
            if (network !== undefined) {
                params.network = network;
            }
            // Add variable overrides as query parameters
            if (variableOverrides) {
                Object.assign(params, variableOverrides);
            }
            return await axios
                .get(`${this.crossbarUrl}/v2/simulate/${feedsParam}`, {
                params,
            })
                .then(resp => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar simulateOracleFeeds response: ${response.status}`);
        }
    }
    /**
     * GET /updates/solana/:network/:feedpubkeys
     * Fetch updates for Solana network feeds from the crossbar
     * @param {string} network - The Solana network to fetch updates for
     * @param {string[]} feedpubkeys - The public keys of the feeds to fetch updates for
     * @param {number} [numSignatures] - The number of signatures to fetch (optional)
     * @returns {Promise<{ success: boolean; pullIx: TransactionInstruction; responses: { oracle: string; result: number | null; errors: string }[]; lookupTables: string[] }[]>} - The updates for the specified feeds
     */
    async fetchSolanaUpdates(network, feedpubkeys, payer, numSignatures) {
        try {
            if (!network)
                throw new Error('Network is required');
            if (!feedpubkeys || feedpubkeys.length === 0)
                throw new Error('At least one feed is required');
            const feedsParam = feedpubkeys.join(',');
            const response = await axios
                .get(`${this.crossbarUrl}/updates/solana/${network}/${feedsParam}`, {
                params: { numSignatures, payer },
            })
                .then(resp => resp.data);
            // Convert pullIx from hex to TransactionInstruction using IxFromHex
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const updates = response.map((update) => ({
                ...update,
                pullIxns: update.pullIxns.map(IxFromHex),
            }));
            return updates;
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar fetchSolanaUpdates response: ${response.status}`);
        }
    }
    /**
     * GET /simulate/solana/:network/:feedpubkeys
     * Simulate fetching Solana feed results from the crossbar
     * @param {string} network - The Solana network to simulate
     * @param {string[]} feedpubkeys - The public keys of the feeds to simulate
     * @returns {Promise<{ feed: string; feedHash: string; results: number[] }[]>} - The simulated feed results
     */
    async simulateSolanaFeeds(network, feedpubkeys) {
        try {
            if (!network)
                throw new Error('Network is required');
            if (!feedpubkeys || feedpubkeys.length === 0)
                throw new Error('At least one feed is required');
            const feedsParam = feedpubkeys.join(',');
            return await axios
                .get(`${this.crossbarUrl}/simulate/solana/${network}/${feedsParam}`)
                .then(resp => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar simulateSolanaFeeds response: ${response.status}`);
        }
    }
    /**
     * GET /updates/evm/:chainId/:aggregatorIds
     * Fetch updates for EVM network feeds from the crossbar
     * @param param0 - The chain ID and aggregator IDs to fetch updates for
     * @returns Promise<{ results: EVMResult[]; encoded: string[] }> - The updates for the specified feeds
     */
    async fetchEVMResults({ chainId, aggregatorIds, }) {
        try {
            if (!chainId)
                throw new Error('Chain ID is required');
            if (!aggregatorIds || aggregatorIds.length === 0)
                throw new Error('At least one feed is required');
            const feedsParam = aggregatorIds.join(',');
            return await axios
                .get(`${this.crossbarUrl}/updates/evm/${chainId}/${feedsParam}`)
                .then(resp => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar fetchEVMUpdates response: ${response.status}`);
        }
    }
    /**
     * GET /simulate/evm/:network/:aggregatorIds
     * Simulate fetching Solana feed results from the crossbar
     * @param {string} network - The Solana network to simulate
     * @param {string[]} aggregatorIds - The public keys of the feeds to simulate
     * @returns {Promise<{ feed: string; feedHash: string; results: number[] }[]>} - The simulated feed results
     */
    async simulateEVMFeeds(network, aggregatorIds) {
        try {
            if (!network)
                throw new Error('Network is required');
            if (!aggregatorIds || aggregatorIds.length === 0)
                throw new Error('At least one feed is required');
            const feedsParam = aggregatorIds.join(',');
            return await axios
                .get(`${this.crossbarUrl}/simulate/evm/${network}/${feedsParam}`)
                .then(resp => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar simulateEVMFeeds response: ${response.status}`);
        }
    }
    /**
     * GET /randomness/evm/:chainId/:randomnessId
     * @param param0 - The chain ID and randomness ID to resolve
     */
    async resolveEVMRandomness({ chainId, randomnessId, }) {
        try {
            return await axios
                .get(`${this.crossbarUrl}/randomness/evm/${chainId}/${randomnessId}`)
                .then(resp => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar resolveEVMRandomness response: ${response.status}`);
        }
    }
    /**
     * GET /updates/sui/:network/:aggregatorAddresses
     * Fetch updates for Sui network feeds from the crossbar
     * @param {string} network - The Sui network to fetch updates for (mainnet / testnet)
     * @param {string[]} aggregatorAddresses - The addresses of the aggregators to fetch updates for
     * @returns {Promise<{ responses: SuiAggregatorResponse[]; failures: string[] }>} - The updates and any failures for the specified feeds
     */
    async fetchSuiUpdates(network, aggregatorAddresses) {
        try {
            if (!network)
                throw new Error('Network is required');
            if (!aggregatorAddresses || aggregatorAddresses.length === 0)
                throw new Error('At least one aggregator address is required');
            const addressesParam = aggregatorAddresses.join(',');
            return await axios
                .get(`${this.crossbarUrl}/updates/sui/${network}/${addressesParam}`)
                .then(resp => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar fetchSuiUpdates response: ${response.status}`);
        }
    }
    /**
     * GET /simulate/sui/:network/:aggregatorAddresses
     * Simulate fetching Sui feed results from the crossbar
     * @param {string} network - The Sui network to simulate (mainnet / testnet)
     * @param {string[]} aggregatorAddresses - The feed IDs to simulate
     * @param {boolean} [includeReceipts] - Whether to include receipts in the response
     * @returns {Promise<SuiSimulationResult[]>} - The simulated feed results
     */
    async simulateSuiFeeds(network, aggregatorAddresses, includeReceipts) {
        try {
            if (!network)
                throw new Error('Network is required');
            if (!aggregatorAddresses || aggregatorAddresses.length === 0)
                throw new Error('At least one feed ID is required');
            const feedsParam = aggregatorAddresses.join(',');
            return await axios
                .get(`${this.crossbarUrl}/simulate/sui/${network}/${feedsParam}`, {
                params: { includeReceipts },
            })
                .then(resp => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar simulateSuiFeeds response: ${response.status}`);
        }
    }
    /**
     * GET /updates/iota/:network/:aggregatorAddresses
     * Fetch updates for Iota network feeds from the crossbar
     * @param {string} network - The Iota network to fetch updates for (mainnet / testnet)
     * @param {string[]} aggregatorAddresses - The addresses of the aggregators to fetch updates for
     * @returns {Promise<{ responses: IotaAggregatorResponse[]; failures: string[] }>} - The updates and any failures for the specified feeds
     */
    async fetchIotaUpdates(network, aggregatorAddresses) {
        try {
            if (!network)
                throw new Error('Network is required');
            if (!aggregatorAddresses || aggregatorAddresses.length === 0)
                throw new Error('At least one aggregator address is required');
            const addressesParam = aggregatorAddresses.join(',');
            return await axios
                .get(`${this.crossbarUrl}/updates/iota/${network}/${addressesParam}`)
                .then(resp => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar fetchIotaUpdates response: ${response.status}`);
        }
    }
    /**
     * GET /simulate/iota/:network/:aggregatorAddresses
     * Simulate fetching Iota feed results from the crossbar
     * @param {string} network - The Iota network to simulate (mainnet / testnet)
     * @param {string[]} aggregatorAddresses - The feed IDs to simulate
     * @param {boolean} [includeReceipts] - Whether to include receipts in the response
     * @returns {Promise<IotaSimulationResult[]>} - The simulated feed results
     */
    async simulateIotaFeeds(network, aggregatorAddresses, includeReceipts) {
        try {
            if (!network)
                throw new Error('Network is required');
            if (!aggregatorAddresses || aggregatorAddresses.length === 0)
                throw new Error('At least one feed ID is required');
            const feedsParam = aggregatorAddresses.join(',');
            return await axios
                .get(`${this.crossbarUrl}/simulate/iota/${network}/${feedsParam}`, {
                params: { includeReceipts },
            })
                .then(resp => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar simulateIotaFeeds response: ${response.status}`);
        }
    }
    /**
     * GET /gateways
     * Fetch all gateways from the crossbar
     * @param {string} [network] - Optional network parameter (devnet/testnet/mainnet). Defaults to mainnet.
     * @returns {Promise<string[]>} - The gateways response containing an array of Gateway urls
     */
    async fetchGateways(network = 'mainnet') {
        try {
            const gateways = await axios
                .get(`${this.crossbarUrl}/gateways?network=${network}`)
                .then(resp => resp.data);
            return gateways;
        }
        catch (err) {
            console.error('Error fetching gateways:', err);
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar fetchGateways response: ${response.status}`);
        }
    }
    /**
     * GET /oracles
     * Fetch all oracles for a given network
     * @param {string} [network] - Optional network parameter (devnet/mainnet). Defaults to mainnet.
     * @returns {Promise<Oracle[]>} - Array of oracle information
     */
    async fetchOracles(network) {
        try {
            return await axios
                .get(`${this.crossbarUrl}/oracles`, {
                params: { network },
            })
                .then(resp => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar fetchOracles response: ${response.status}`);
        }
    }
    /**
     * POST /gateways/fetch_signatures
     * Fetch signatures from oracles for a given set of jobs
     * @param {FetchSignaturesRequest} request - The request parameters
     * @param {string} [network] - Optional network parameter (devnet/mainnet). Defaults to mainnet.
     * @returns {Promise<FeedEvalResponse[]>} - Array of oracle signatures and results
     */
    async fetchSignatures(request, network) {
        try {
            return await axios
                .post(`${this.crossbarUrl}/gateways/fetch_signatures`, request, {
                params: { network },
            })
                .then(resp => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar fetchOracleSignatures response: ${response.status}`);
        }
    }
    /**
     * POST /gateways/fetch_signatures_consensus
     * Fetch consensus signatures from oracles for a given set of feed requests
     * @param {FetchSignaturesConsensusRequest} request - The request parameters with camelCase fields
     * @param {string} [network] - Optional network parameter (devnet/mainnet). Defaults to mainnet.
     * @returns {Promise<FetchSignaturesConsensusResponse>} - Consensus signatures and median responses in camelCase
     *
     * @example
     * // Using FeedRequestV1
     * const feedRequestV1 = CrossbarClient.createFeedRequestV1(
     *   ['base64EncodedJob1', 'base64EncodedJob2'],
     *   1000000, // maxVariance
     *   3        // minResponses
     * );
     *
     * // Using FeedRequestV2
     * const feedRequestV2 = CrossbarClient.createFeedRequestV2('base64EncodedProtoBuf');
     *
     * const response = await client.fetchSignaturesConsensus({
     *   apiVersion: '1.0',
     *   recentHash: 'someRecentHash',
     *   signatureScheme: 'ed25519',
     *   hashScheme: 'sha256',
     *   feedRequests: [feedRequestV1, feedRequestV2],
     *   numOracles: 3,
     *   useTimestamp: false
     * });
     */
    async fetchSignaturesConsensus(request, network) {
        try {
            return await axios
                .post(`${this.crossbarUrl}/gateways/fetch_signatures_consensus`, request, {
                params: { network },
                headers: { 'Content-Type': 'application/json' },
            })
                .then(resp => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar fetchSignaturesConsensus response: ${response.status}`);
        }
    }
    /**
     * POST /simulate/jobs
     * Simulate oracle jobs execution without storing them
     * @param {SimulateJobsRequest} request - The simulation request containing jobs and optional parameters
     * @returns {Promise<SimulateJobsResponse>} - The simulation results
     *
     * @example
     * const response = await client.simulateJobs({
     *   jobs: [
     *     {
     *       tasks: [
     *         {
     *           httpTask: {
     *             url: "https://api.coinbase.com/v2/prices/BTC-USD/spot"
     *           }
     *         },
     *         {
     *           jsonParseTask: {
     *             path: "$.data.amount"
     *           }
     *         }
     *       ]
     *     }
     *   ],
     *   includeReceipts: true,
     *   variableOverrides: {
     *     MY_VARIABLE: "custom_value"
     *   }
     * });
     */
    async simulateJobs(request) {
        try {
            return await axios
                .post(`${this.crossbarUrl}/simulate/jobs`, request, {
                headers: { 'Content-Type': 'application/json' },
            })
                .then(resp => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar simulateJobs response: ${response.status}`);
        }
    }
    /**
     * GET /v2/update/{feedHashes}
     * Fetch V2 oracle consensus updates for feed hashes with enhanced chain support
     * @param {string[]} feedHashes - Array of feed hashes to fetch updates for
     * @param {V2UpdateQuery} [options] - Optional query parameters for the request
     * @returns {Promise<V2UpdateResponse>} - The V2 update response with oracle consensus data
     *
     * @example
     * // Basic usage with single feed hash
     * const response = await client.fetchV2Update(
     *   ['0x7418dc6408f5e0eb4724dabd81922ee7b0814a43abc2b30ea7a08222cd1e23ee']
     * );
     *
     * @example
     * // With chain-specific options for Sui mainnet
     * const response = await client.fetchV2Update(
     *   ['0x7418dc6408f5e0eb4724dabd81922ee7b0814a43abc2b30ea7a08222cd1e23ee'],
     *   {
     *     chain: 'sui',
     *     network: 'mainnet',
     *     use_timestamp: true,
     *     num_oracles: 5
     *   }
     * );
     *
     * @example
     * // Multiple feed hashes with custom gateway
     * const response = await client.fetchV2Update(
     *   [
     *     '0x7418dc6408f5e0eb4724dabd81922ee7b0814a43abc2b30ea7a08222cd1e23ee',
     *     '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef'
     *   ],
     *   {
     *     network: 'testnet',
     *     gateway: 'https://custom-gateway.example.com',
     *     signature_scheme: 'Secp256k1'
     *   }
     * );
     */
    async fetchV2Update(feedHashes, options) {
        try {
            if (!feedHashes || feedHashes.length === 0) {
                throw new Error('At least one feed hash is required');
            }
            // Join feed hashes with commas for the URL path
            const feedHashesParam = feedHashes.join(',');
            // Build query parameters from options
            const params = {};
            if (options) {
                Object.entries(options).forEach(([key, value]) => {
                    if (value !== undefined) {
                        params[key] = value;
                    }
                });
            }
            const response = await axios
                .get(`${this.crossbarUrl}/v2/update/${feedHashesParam}`, {
                params,
            })
                .then(resp => resp.data);
            return response;
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar fetchV2Update response: ${response.status}`);
        }
    }
    /**
     * POST /v2/simulate/proto
     * Simulate an OracleFeed from a protobuf object
     * @param {IOracleFeed} feed - The OracleFeed protobuf object to simulate
     * @param {boolean} [includeReceipts] - Whether to include receipts in the response
     * @param {Record<string, string>} [variableOverrides] - Variable overrides for the simulation
     * @param {string} [network] - Network to use for simulation (defaults to "mainnet")
     * @returns {Promise<CrossbarSimulateProtoResponse>} - The simulation results
     *
     * @example
     * const feed = OracleFeed.create({
     *   name: "BTC/USD",
     *   jobs: [
     *     {
     *       tasks: [
     *         {
     *           httpTask: {
     *             url: "https://api.coinbase.com/v2/prices/BTC-USD/spot"
     *           }
     *         },
     *         {
     *           jsonParseTask: {
     *             path: "$.data.amount"
     *           }
     *         }
     *       ]
     *     }
     *   ]
     * });
     *
     * const response = await client.simulateFeed(
     *   feed,
     *   true,
     *   { MY_VAR: "value" },
     *   "mainnet"
     * );
     */
    async simulateFeed(feed, includeReceipts, variableOverrides, network) {
        try {
            // Encode the OracleFeed proto to bytes
            const protoBytes = OracleFeed.encode(feed).finish();
            // Convert to base64
            const oracleFeedB64 = Buffer.from(protoBytes).toString('base64');
            return await axios
                .post(`${this.crossbarUrl}/v2/simulate/proto`, {
                oracleFeed: oracleFeedB64,
                includeReceipts,
                variableOverrides,
                network,
            }, { headers: { 'Content-Type': 'application/json' } })
                .then(resp => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar simulateFeed response: ${response.status}`);
        }
    }
}
CrossbarClient._instance = null;

"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.median = median;
exports.weightedAverage = weightedAverage;
exports.weightedMedian = weightedMedian;
exports.min = min;
exports.max = max;
exports.variance = variance;
exports.safeDiv = safeDiv;
exports.safeMul = safeMul;
exports.fromBN = fromBN;
exports.fromBigint = fromBigint;
exports.toDecimal = toDecimal;
exports.fromDecimal = fromDecimal;
const big_js_1 = require("big.js");
const bn_js_1 = __importDefault(require("bn.js"));
const decimal_js_1 = require("decimal.js");
function comparator(a, b) {
    if (a.gt(b))
        return 1;
    if (a.lt(b))
        return -1;
    return 0;
}
function median(results) {
    if (!(results === null || results === void 0 ? void 0 : results.length))
        throw new Error('Cannot take median of empty array.');
    const arrSort = results.slice().sort(comparator);
    const mid = Math.ceil(arrSort.length / 2);
    if (arrSort.length % 2 === 0) {
        const addition = arrSort[mid].add(arrSort[mid - 1]);
        return safeDiv(addition, new big_js_1.Big(2.0));
    }
    return arrSort[mid - 1];
}
function weightedAverage(v1, w1, v2, w2) {
    return safeDiv(safeMul(v1, w1).add(safeMul(v2, w2)), w1.add(w2));
}
function weightedMedian(results) {
    if (!(results === null || results === void 0 ? void 0 : results.length))
        throw new Error('Cannot take median of empty array.');
    for (let i = 0; i < results.length; ++i) {
        if (results[i].weight === 0) {
            results[i].weight = 1;
        }
    }
    const arrSort = results.slice().sort((a, b) => comparator(a.value, b.value));
    const halfWeight = arrSort.reduce((sum, { weight }) => weight + sum, 0) / 2;
    let i = 0;
    let w = 0;
    // get the index (i) and total weight (w) of item just above half
    for (; w < halfWeight; ++i) {
        w = w + arrSort[i].weight;
    }
    // if it actually is exactly the half, we need to take the average
    if (w === halfWeight) {
        return weightedAverage(arrSort[i - 1].value, new big_js_1.Big(arrSort[i - 1].weight), arrSort[i].value, new big_js_1.Big(arrSort[i].weight));
    }
    // otherwise we return the value
    return arrSort[i - 1].value;
}
function min(results) {
    if (results.length === 0) {
        throw new Error('Cannot reduce empty array.');
    }
    return results.reduce((val, current) => (val.lt(current) ? val : current), results[0]);
}
function max(results) {
    if (results.length === 0) {
        throw new Error('Cannot reduce empty array.');
    }
    return results.reduce((val, current) => (val.gt(current) ? val : current), results[0]);
}
// This export function returns the ratio between the max value and the min value.
// If we pull data that may be negative, this information is not entirely relevant.
function variance(results) {
    if ((results === null || results === void 0 ? void 0 : results.length) === 0) {
        throw new Error('Cannot take variance of empty array');
    }
    const arrSort = results
        .slice()
        .sort((n1, n2) => n1.minus(n2).toNumber());
    const min = arrSort[0];
    const max = arrSort[arrSort.length - 1];
    return max.minus(min);
}
////// BIG.JS UTILS
function safeDiv(number_, denominator, decimals = 20) {
    const oldDp = big_js_1.Big.DP;
    big_js_1.Big.DP = decimals;
    const result = number_.div(denominator);
    big_js_1.Big.DP = oldDp;
    return result;
}
function safeMul(...n) {
    if (n.length === 0) {
        throw new Error(`need to provide elements to multiply ${n}`);
    }
    let result = new big_js_1.Big(1);
    for (const x of n) {
        result = result.mul(x);
    }
    return result;
}
/**
 * Convert a BN.js to a Big.js
 * @param n - the BN.js object to convert
 * @param decimals - the number of decimal places to scale the BN.js
 *
 * @returns Big.js
 */
function fromBN(n, decimals = 0) {
    let mantissa = new bn_js_1.default(n, 10);
    let s = 1;
    const c = [];
    const ZERO = new bn_js_1.default(0, 10);
    const TEN = new bn_js_1.default(10, 10);
    if (mantissa.lt(ZERO)) {
        s = -1;
        mantissa = mantissa.abs();
    }
    while (mantissa.gt(ZERO)) {
        c.unshift(mantissa.mod(TEN).toNumber());
        mantissa = mantissa.div(TEN);
    }
    const e = c.length - decimals - 1;
    const result = new big_js_1.Big(0);
    if (c.length === 0) {
        return result;
    }
    result.s = s;
    result.c = c;
    result.e = e;
    return result;
}
/**
 * Convert a BigInt to a Big.js
 * @param n - the BigInt to convert
 *
 * @returns Big.js
 */
function fromBigint(n) {
    const big = new big_js_1.Big(n.toString(10));
    return big;
}
/**
 * Convert a Big.js to a Decimal.js
 * @param big - the Big.js object to convert
 * @param decimals - the number of decimal places
 *
 * @returns Decimal.js
 */
function toDecimal(big, decimals = 20) {
    const oldPrecision = decimal_js_1.Decimal.precision;
    decimal_js_1.Decimal.set({ precision: decimals });
    const decimal = new decimal_js_1.Decimal(big.toFixed(decimals, 0));
    decimal_js_1.Decimal.set({ precision: oldPrecision });
    return decimal;
}
/**
 * Convert a Decimal.js to a Big.js
 * @param decimal - the Decimal.js object to convert
 * @param decimals - the number of decimal places
 *
 * @returns Big.js
 */
function fromDecimal(decimal, decimals = 20) {
    if (decimal.isNaN()) {
        throw new TypeError('cannot convert NaN decimal.js to Big.js');
    }
    if (!decimal.isFinite()) {
        throw new TypeError('cannot convert INF decimal.js to Big.js');
    }
    const big = new big_js_1.Big(decimal.toFixed(decimals, 0));
    return big;
}

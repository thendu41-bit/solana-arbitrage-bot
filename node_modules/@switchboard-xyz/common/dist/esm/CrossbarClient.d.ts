import type { IOracleFeed, IOracleJob } from './protos.js';
import type { TransactionInstruction } from '@solana/web3.js';
/**
 *  The response from the gateway after fetching signatures.
 *  Variables are snake_case for serialization.
 */
export type FeedEvalResponse = {
    /**
     *  Hex encoded oracle pubkey
     */
    oracle_pubkey: string;
    /**
     *  Hex encoded queue pubkey
     */
    queue_pubkey: string;
    /**
     *  Hex encoded oracle signing pubkey
     */
    oracle_signing_pubkey: string;
    /**
     *  Hex encoded feed id
     */
    feed_hash: string;
    /**
     *  Hex encoded blockhash/slothash the response was signed with.
     */
    recent_hash: string;
    /**
     *  Errors encountered while fetching feed value
     */
    failure_error: string;
    /**
     *  Feed values derived
     */
    success_value: string;
    /**
     *  Signed message of the result and blockhash
     */
    msg: string;
    /**
     *  Oracle signature of the result and blockhash
     *
     *  Sha256(success_feed_hashes || results || slothash)
     */
    signature: string;
    recovery_id: number;
    /**
     *  If the feed fetch failed, get other recent successes
     */
    recent_successes_if_failed: Array<FeedEvalResponse>;
    /**
     * Timestamp marking when the result was fetched
     */
    timestamp?: number;
    /**
     * Minimum number of oracle samples required
     */
    min_oracle_samples?: number;
    /**
     * Receipts from oracle job execution
     */
    receipts?: unknown[];
};
export type CrossbarFetchResponse = {
    feedHash: string;
    queueHex: string;
    jobs: IOracleJob[];
};
export type CrossbarOracleFeedFetchResponse = {
    cid: string;
    data: string;
    size: number;
    version: string;
};
export type CrossbarSimulateResponse = {
    feedHash: string;
    results: (number | string)[] | null;
    receipts: unknown[] | null;
    error?: string;
};
export type CrossbarSimulateV2Response = {
    feedHash: string;
    feedName?: string;
    results: unknown[] | null;
    receipts: unknown[] | null;
    error?: string;
    variableOverrides?: Record<string, string>;
    network?: string;
};
export type CrossbarSimulateProtoResponse = {
    feedId: string;
    feedName?: string;
    results: unknown[] | null;
    receipts: unknown[] | null;
    error?: string;
    variableOverrides?: Record<string, string>;
    network?: string;
};
export type SimulateJobsRequest = {
    jobs: IOracleJob[];
    includeReceipts?: boolean;
    variableOverrides?: Record<string, string>;
};
export type SimulateJobsResponse = {
    results: unknown[] | null;
    receipts?: unknown[] | null;
    error?: string;
};
export type OracleInfo = {
    pubkey: string;
    secp256k1Key: string;
    authority: string;
    queue: string;
    mrEnclave: string;
    expirationTime: number;
};
export type FetchSignaturesRequest = {
    feedHash: string;
    numSignatures: number;
    maxVariance: number;
    minResponses: number;
    useTimestamp?: boolean;
    gateway?: string;
    recentHash?: string;
};
export type FeedRequest = {
    jobsB64Encoded?: string[];
    maxVariance?: number;
    minResponses?: number;
    feedProtoB64?: string;
};
export type FetchSignaturesConsensusRequest = {
    apiVersion: string;
    recentHash?: string;
    signatureScheme: string;
    hashScheme: string;
    feedRequests: FeedRequest[];
    numOracles: number;
    useTimestamp?: boolean;
};
export type FetchSignaturesConsensusResponse = {
    medianResponses: {
        value: string;
        feedHash: string;
        numOracles: number;
    }[];
    oracleResponses: {
        oraclePublickey: string;
        ethAddress: string;
        signature: string;
        checksum: string;
        recoveryId: number;
        feedResponses: FeedEvalResponse[];
        errors: (string | null)[];
    }[];
    timestamp?: number;
};
/**
 * The response from the gateway after fetching signatures.
 */
export type EVMResult = FeedEvalResponse & {
    /**
     *  The result of the feed evaluation
     */
    result: number;
};
interface SuiResult {
    successValue: string;
    isNegative: boolean;
    timestamp: number;
    signature: string;
    oracleId: string;
}
/**
 * Interface for Sui Aggregator response
 */
export interface SuiAggregatorResponse {
    results: SuiResult[];
    feedConfigs: {
        feedHash: string;
        maxVariance: number;
        minResponses: number;
        minSampleSize: number;
    };
    failures: string[];
    fee: number;
    queue: string;
    gateway: string;
}
/**
 * Interface for Sui simulation result
 */
export interface SuiSimulationResult {
    feed: string;
    feedHash: string;
    results: number[];
    receipts?: unknown[];
    result: number;
    stdev: number;
    variance: number;
}
export type IotaResult = SuiResult;
export interface IotaAggregatorResponse {
    results: IotaResult[];
    feedConfigs: {
        feedHash: string;
        maxVariance: number;
        minResponses: number;
        minSampleSize: number;
    };
    failures: string[];
    fee: number;
    queue: string;
    gateway: string;
}
export type IotaSimulationResult = SuiSimulationResult;
/**
 * Query parameters for V2 update endpoint
 */
export interface V2UpdateQuery {
    network?: string;
    signature_scheme?: string;
    hash_scheme?: string;
    num_oracles?: number;
    use_timestamp?: boolean;
    recent_hash?: string;
    gateway?: string;
    chain?: string;
}
/**
 * Response structure for V2 update endpoint
 */
export interface V2UpdateResponse {
    medianResponses: V2MedianResponse[];
    oracleResponses: V2ConsensusOracleResponse[];
    timestamp: number;
    slot: number;
    recentHash: string;
    queue?: string;
}
/**
 * Median response structure for V2 update
 */
export interface V2MedianResponse {
    value: string;
    feedHash: string;
    numOracles: number;
}
/**
 * Oracle response structure for V2 update with consensus
 */
export interface V2ConsensusOracleResponse {
    oraclePubkey: string;
    ethAddress: string;
    signature: string;
    checksum: string;
    recoveryId?: number;
    oracleId?: string;
    feedResponses: FeedEvalResponse[];
    errors: (string | null)[];
}
export declare class CrossbarClient {
    private static _instance;
    readonly crossbarUrl: string;
    readonly verbose: boolean;
    readonly feedCache: Map<string, CrossbarFetchResponse>;
    readonly oracleFeedCache: Map<string, CrossbarOracleFeedFetchResponse>;
    /**
     * Create a FeedRequestV1 object
     * @param {string[]} jobsB64Encoded - Base64 encoded oracle jobs
     * @param {number} maxVariance - Maximum variance allowed for the feed
     * @param {number} minResponses - Minimum number of oracle responses required
     * @returns {FeedRequest} - A FeedRequestV1 object
     */
    static createFeedRequestV1(jobsB64Encoded: string[], maxVariance: number, minResponses: number): FeedRequest;
    /**
     * Create a FeedRequestV2 object
     * @param {string} feedProtoB64 - Base64 encoded feed protobuf
     * @returns {FeedRequest} - A FeedRequestV2 object
     */
    static createFeedRequestV2(feedProtoB64: string): FeedRequest;
    static default(verbose?: boolean): CrossbarClient;
    constructor(crossbarUrl: string, verbose?: boolean);
    /**
     * GET /fetch/:feedHash
     * Fetch data from the crossbar using the provided feedHash
     * @param {string} feedHash - The hash of the feed to fetch data for
     * @returns {Promise<CrossbarFetchResponse>} - The data fetched from the crossbar
     */
    fetch(feedHash: string): Promise<CrossbarFetchResponse>;
    /**
     * GET /v2/fetch/:feedHash
     * Fetch OracleFeed data from a crossbar server using the provided feedId
     * @param {string} feedId - The identifier of the OracleFeed to fetch
     * @returns {Promise<CrossbarOracleFeedFetchResponse>} - The data fetched from the crossbar
     */
    fetchOracleFeed(feedId: string): Promise<CrossbarOracleFeedFetchResponse>;
    /**
     * POST /store
     * Store oracle jobs on the crossbar, associated with a queue address
     * @param {string} queueAddress - The address of the queue
     * @param {IOracleJob[]} jobs - The oracle jobs to store
     * @returns {Promise<{ cid: string; feedHash: string; queueHex: string }>} - The stored data information
     */
    store(queueAddress: string, jobs: IOracleJob[]): Promise<{
        cid: string;
        feedHash: string;
        queueHex: string;
    }>;
    /**
     * POST /v2/store
     * Store an OracleFeed on IPFS using crossbar.
     * @param {IOracleFeed} feed - The OracleFeed to store
     * @returns {Promise<{ cid: string; feedHash: string; queueHex: string }>} - The stored data information
     */
    storeOracleFeed(feed: IOracleFeed): Promise<{
        cid: string;
        feedId: string;
    }>;
    /**
     * GET /simulate/:feedHashes
     * Simulate fetching feed results from the crossbar using feed hashes
     * @param {string[]} feedHashes - The hashes of the feeds to simulate
     * @param {boolean} [includeReceipts] - Whether to include receipts in the response
     * @returns {Promise<CrossbarSimulateResponse[]>} - The simulated feed results
     */
    simulateFeeds(feedHashes: string[], includeReceipts?: boolean): Promise<CrossbarSimulateResponse[]>;
    /**
     * GET /v2/simulate/:feedHashes
     * Simulate V2 oracle feeds with variable overrides and network selection
     * @param {string[]} feedHashes - The hashes of the V2 feeds to simulate
     * @param {boolean} [includeReceipts] - Whether to include receipts in the response
     * @param {Record<string, string>} [variableOverrides] - Variable overrides for the simulation
     * @param {string} [network] - Network to use for simulation (defaults to "mainnet")
     * @returns {Promise<CrossbarSimulateV2Response[]>} - The simulated V2 feed results
     */
    simulateOracleFeeds(feedHashes: string[], includeReceipts?: boolean, variableOverrides?: Record<string, string>, network?: string): Promise<CrossbarSimulateV2Response[]>;
    /**
     * GET /updates/solana/:network/:feedpubkeys
     * Fetch updates for Solana network feeds from the crossbar
     * @param {string} network - The Solana network to fetch updates for
     * @param {string[]} feedpubkeys - The public keys of the feeds to fetch updates for
     * @param {number} [numSignatures] - The number of signatures to fetch (optional)
     * @returns {Promise<{ success: boolean; pullIx: TransactionInstruction; responses: { oracle: string; result: number | null; errors: string }[]; lookupTables: string[] }[]>} - The updates for the specified feeds
     */
    fetchSolanaUpdates(network: string, feedpubkeys: string[], payer: string, numSignatures?: number): Promise<{
        success: boolean;
        pullIxns: TransactionInstruction[];
        responses: {
            oracle: string;
            result: number | null;
            errors: string;
        }[];
        lookupTables: string[];
    }[]>;
    /**
     * GET /simulate/solana/:network/:feedpubkeys
     * Simulate fetching Solana feed results from the crossbar
     * @param {string} network - The Solana network to simulate
     * @param {string[]} feedpubkeys - The public keys of the feeds to simulate
     * @returns {Promise<{ feed: string; feedHash: string; results: number[] }[]>} - The simulated feed results
     */
    simulateSolanaFeeds(network: string, feedpubkeys: string[]): Promise<{
        feed: string;
        feedHash: string;
        results: number[];
    }[]>;
    /**
     * GET /updates/evm/:chainId/:aggregatorIds
     * Fetch updates for EVM network feeds from the crossbar
     * @param param0 - The chain ID and aggregator IDs to fetch updates for
     * @returns Promise<{ results: EVMResult[]; encoded: string[] }> - The updates for the specified feeds
     */
    fetchEVMResults({ chainId, aggregatorIds, }: {
        chainId: number;
        aggregatorIds: string[];
    }): Promise<{
        results: EVMResult[];
        encoded: string[];
    }>;
    /**
     * GET /simulate/evm/:network/:aggregatorIds
     * Simulate fetching Solana feed results from the crossbar
     * @param {string} network - The Solana network to simulate
     * @param {string[]} aggregatorIds - The public keys of the feeds to simulate
     * @returns {Promise<{ feed: string; feedHash: string; results: number[] }[]>} - The simulated feed results
     */
    simulateEVMFeeds(network: number, aggregatorIds: string[]): Promise<{
        aggregatorId: string;
        feedHash: string;
        results: number[];
    }[]>;
    /**
     * GET /randomness/evm/:chainId/:randomnessId
     * @param param0 - The chain ID and randomness ID to resolve
     */
    resolveEVMRandomness({ chainId, randomnessId, }: {
        chainId: number;
        randomnessId: string;
    }): Promise<{
        encoded: string;
        response: {
            signature: string;
            recovery_id: number;
            value: string;
        };
    }>;
    /**
     * GET /updates/sui/:network/:aggregatorAddresses
     * Fetch updates for Sui network feeds from the crossbar
     * @param {string} network - The Sui network to fetch updates for (mainnet / testnet)
     * @param {string[]} aggregatorAddresses - The addresses of the aggregators to fetch updates for
     * @returns {Promise<{ responses: SuiAggregatorResponse[]; failures: string[] }>} - The updates and any failures for the specified feeds
     */
    fetchSuiUpdates(network: string, aggregatorAddresses: string[]): Promise<{
        responses: SuiAggregatorResponse[];
        failures: string[];
    }>;
    /**
     * GET /simulate/sui/:network/:aggregatorAddresses
     * Simulate fetching Sui feed results from the crossbar
     * @param {string} network - The Sui network to simulate (mainnet / testnet)
     * @param {string[]} aggregatorAddresses - The feed IDs to simulate
     * @param {boolean} [includeReceipts] - Whether to include receipts in the response
     * @returns {Promise<SuiSimulationResult[]>} - The simulated feed results
     */
    simulateSuiFeeds(network: string, aggregatorAddresses: string[], includeReceipts?: boolean): Promise<SuiSimulationResult[]>;
    /**
     * GET /updates/iota/:network/:aggregatorAddresses
     * Fetch updates for Iota network feeds from the crossbar
     * @param {string} network - The Iota network to fetch updates for (mainnet / testnet)
     * @param {string[]} aggregatorAddresses - The addresses of the aggregators to fetch updates for
     * @returns {Promise<{ responses: IotaAggregatorResponse[]; failures: string[] }>} - The updates and any failures for the specified feeds
     */
    fetchIotaUpdates(network: string, aggregatorAddresses: string[]): Promise<{
        responses: IotaAggregatorResponse[];
        failures: string[];
    }>;
    /**
     * GET /simulate/iota/:network/:aggregatorAddresses
     * Simulate fetching Iota feed results from the crossbar
     * @param {string} network - The Iota network to simulate (mainnet / testnet)
     * @param {string[]} aggregatorAddresses - The feed IDs to simulate
     * @param {boolean} [includeReceipts] - Whether to include receipts in the response
     * @returns {Promise<IotaSimulationResult[]>} - The simulated feed results
     */
    simulateIotaFeeds(network: string, aggregatorAddresses: string[], includeReceipts?: boolean): Promise<IotaSimulationResult[]>;
    /**
     * GET /gateways
     * Fetch all gateways from the crossbar
     * @param {string} [network] - Optional network parameter (devnet/testnet/mainnet). Defaults to mainnet.
     * @returns {Promise<string[]>} - The gateways response containing an array of Gateway urls
     */
    fetchGateways(network?: string): Promise<string[]>;
    /**
     * GET /oracles
     * Fetch all oracles for a given network
     * @param {string} [network] - Optional network parameter (devnet/mainnet). Defaults to mainnet.
     * @returns {Promise<Oracle[]>} - Array of oracle information
     */
    fetchOracles(network?: string): Promise<OracleInfo[]>;
    /**
     * POST /gateways/fetch_signatures
     * Fetch signatures from oracles for a given set of jobs
     * @param {FetchSignaturesRequest} request - The request parameters
     * @param {string} [network] - Optional network parameter (devnet/mainnet). Defaults to mainnet.
     * @returns {Promise<FeedEvalResponse[]>} - Array of oracle signatures and results
     */
    fetchSignatures(request: FetchSignaturesRequest, network?: string): Promise<{
        responses: FeedEvalResponse[];
        failures: string[];
    }>;
    /**
     * POST /gateways/fetch_signatures_consensus
     * Fetch consensus signatures from oracles for a given set of feed requests
     * @param {FetchSignaturesConsensusRequest} request - The request parameters with camelCase fields
     * @param {string} [network] - Optional network parameter (devnet/mainnet). Defaults to mainnet.
     * @returns {Promise<FetchSignaturesConsensusResponse>} - Consensus signatures and median responses in camelCase
     *
     * @example
     * // Using FeedRequestV1
     * const feedRequestV1 = CrossbarClient.createFeedRequestV1(
     *   ['base64EncodedJob1', 'base64EncodedJob2'],
     *   1000000, // maxVariance
     *   3        // minResponses
     * );
     *
     * // Using FeedRequestV2
     * const feedRequestV2 = CrossbarClient.createFeedRequestV2('base64EncodedProtoBuf');
     *
     * const response = await client.fetchSignaturesConsensus({
     *   apiVersion: '1.0',
     *   recentHash: 'someRecentHash',
     *   signatureScheme: 'ed25519',
     *   hashScheme: 'sha256',
     *   feedRequests: [feedRequestV1, feedRequestV2],
     *   numOracles: 3,
     *   useTimestamp: false
     * });
     */
    fetchSignaturesConsensus(request: FetchSignaturesConsensusRequest, network?: string): Promise<FetchSignaturesConsensusResponse>;
    /**
     * POST /simulate/jobs
     * Simulate oracle jobs execution without storing them
     * @param {SimulateJobsRequest} request - The simulation request containing jobs and optional parameters
     * @returns {Promise<SimulateJobsResponse>} - The simulation results
     *
     * @example
     * const response = await client.simulateJobs({
     *   jobs: [
     *     {
     *       tasks: [
     *         {
     *           httpTask: {
     *             url: "https://api.coinbase.com/v2/prices/BTC-USD/spot"
     *           }
     *         },
     *         {
     *           jsonParseTask: {
     *             path: "$.data.amount"
     *           }
     *         }
     *       ]
     *     }
     *   ],
     *   includeReceipts: true,
     *   variableOverrides: {
     *     MY_VARIABLE: "custom_value"
     *   }
     * });
     */
    simulateJobs(request: SimulateJobsRequest): Promise<SimulateJobsResponse>;
    /**
     * GET /v2/update/{feedHashes}
     * Fetch V2 oracle consensus updates for feed hashes with enhanced chain support
     * @param {string[]} feedHashes - Array of feed hashes to fetch updates for
     * @param {V2UpdateQuery} [options] - Optional query parameters for the request
     * @returns {Promise<V2UpdateResponse>} - The V2 update response with oracle consensus data
     *
     * @example
     * // Basic usage with single feed hash
     * const response = await client.fetchV2Update(
     *   ['0x7418dc6408f5e0eb4724dabd81922ee7b0814a43abc2b30ea7a08222cd1e23ee']
     * );
     *
     * @example
     * // With chain-specific options for Sui mainnet
     * const response = await client.fetchV2Update(
     *   ['0x7418dc6408f5e0eb4724dabd81922ee7b0814a43abc2b30ea7a08222cd1e23ee'],
     *   {
     *     chain: 'sui',
     *     network: 'mainnet',
     *     use_timestamp: true,
     *     num_oracles: 5
     *   }
     * );
     *
     * @example
     * // Multiple feed hashes with custom gateway
     * const response = await client.fetchV2Update(
     *   [
     *     '0x7418dc6408f5e0eb4724dabd81922ee7b0814a43abc2b30ea7a08222cd1e23ee',
     *     '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef'
     *   ],
     *   {
     *     network: 'testnet',
     *     gateway: 'https://custom-gateway.example.com',
     *     signature_scheme: 'Secp256k1'
     *   }
     * );
     */
    fetchV2Update(feedHashes: string[], options?: V2UpdateQuery): Promise<V2UpdateResponse>;
    /**
     * POST /v2/simulate/proto
     * Simulate an OracleFeed from a protobuf object
     * @param {IOracleFeed} feed - The OracleFeed protobuf object to simulate
     * @param {boolean} [includeReceipts] - Whether to include receipts in the response
     * @param {Record<string, string>} [variableOverrides] - Variable overrides for the simulation
     * @param {string} [network] - Network to use for simulation (defaults to "mainnet")
     * @returns {Promise<CrossbarSimulateProtoResponse>} - The simulation results
     *
     * @example
     * const feed = OracleFeed.create({
     *   name: "BTC/USD",
     *   jobs: [
     *     {
     *       tasks: [
     *         {
     *           httpTask: {
     *             url: "https://api.coinbase.com/v2/prices/BTC-USD/spot"
     *           }
     *         },
     *         {
     *           jsonParseTask: {
     *             path: "$.data.amount"
     *           }
     *         }
     *       ]
     *     }
     *   ]
     * });
     *
     * const response = await client.simulateFeed(
     *   feed,
     *   true,
     *   { MY_VAR: "value" },
     *   "mainnet"
     * );
     */
    simulateFeed(feed: IOracleFeed, includeReceipts?: boolean, variableOverrides?: Record<string, string>, network?: string): Promise<CrossbarSimulateProtoResponse>;
}
export {};
//# sourceMappingURL=CrossbarClient.d.ts.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeleteSecretPayload = exports.RemoveMrEnclavePayload = exports.AddMrEnclavePayload = exports.CreateSecretPayload = exports.UpdateUserPayload = exports.SwitchboardSecrets = void 0;
const index_js_1 = require("./utils/index.cjs");
const buffer_1 = require("buffer");
const js_sha256_1 = require("js-sha256");
/**
 *  Default is to expire requests 30 seconds from now.
 */
const getDefaultRequestTimestamp = () => Math.floor(Date.now() / 1000) + 30;
class SwitchboardSecrets {
    constructor(url) {
        this.url = url !== null && url !== void 0 ? url : 'https://api.secrets.switchboard.xyz';
    }
    async getUser(userPubkey, ciphersuite) {
        const url = `${this.url}/user/${userPubkey}/ciphersuite/${ciphersuite}`;
        const response = await index_js_1.AxiosUtils.fetch(url, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'X-Signed-Header': buffer_1.Buffer.from(js_sha256_1.sha256.create().update('test-sig').digest()).toString('hex'),
            },
        });
        if (!response.ok) {
            throw new Error(`getUser failed: ${response.statusText}`);
        }
        const json = await response.json();
        return {
            ciphersuite: json.ciphersuite,
            user_pubkey: json.user_pubkey,
            created_at: new Date(json.created_at),
            updated_at: new Date(json.updated_at),
            contact_info: json.contact_info,
        };
    }
    createOrUpdateUserRequest(
    /**
     *  The address of the user.
     */
    userPubkey, 
    /**
     *  'ed25519' for Solana users, 'ethers' for EVM users.
     */
    ciphersuite, 
    /**
     *  Stringified contact info for the user.
     */
    contactInfo = '', 
    /**
     *  The timestamp that this request expires.
     *
     *  Default: now + 30 seconds.
     */
    expiryTimestamp = getDefaultRequestTimestamp()) {
        return new UpdateUserPayload(userPubkey, ciphersuite, contactInfo, expiryTimestamp);
    }
    async createOrUpdateUser(request, signature) {
        const url = `${this.url}/user`;
        const response = await index_js_1.AxiosUtils.fetch(url, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'X-Signed-Header': signature,
            },
            body: request.toString(),
        });
        if (!response.ok) {
            throw new Error(`createOrUpdateUser failed: ${response.statusText}`);
        }
    }
    async getUserSecrets(userPubkey, ciphersuite) {
        const url = `${this.url}/user/${userPubkey}/ciphersuite/${ciphersuite}/secrets`;
        const response = await index_js_1.AxiosUtils.fetch(url, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'X-Signed-Header': buffer_1.Buffer.from(js_sha256_1.sha256.create().update('test-sig').digest()).toString('hex'),
            },
        });
        if (!response.ok) {
            throw new Error(`getUserSecrets failed: ${response.statusText}`);
        }
        const json = await response.json();
        return Array.isArray(json)
            ? json
                .map(item => ({
                secret: item.secret,
                secret_name: item.secret_name,
                created_at: new Date(item.created_at),
                updated_at: new Date(item.updated_at),
                whitelist: Array.isArray(item.whitelisted_mrenclaves)
                    ? item.whitelisted_mrenclaves.filter((val) => !!val)
                    : [],
            }))
                .sort((a, b) => b.updated_at.getTime() - a.updated_at.getTime())
            : [];
    }
    createSecretRequest(
    /**
     *  The address of the user.
     */
    userPubkey, 
    /**
     *  'ed25519' for Solana users, 'ethers' for EVM users.
     */
    ciphersuite, 
    /**
     *  The key of the secret.
     *
     *  Keys must be unique per user.
     */
    secretName, 
    /**
     *  The value of the secret.
     */
    secretValue, 
    /**
     *  The timestamp that this request expires.
     *
     *  Default: now + 30 seconds.
     */
    expiryTimestamp = getDefaultRequestTimestamp()) {
        return new CreateSecretPayload(userPubkey, ciphersuite, secretName, secretValue, expiryTimestamp);
    }
    async createSecret(request, signature) {
        const url = `${this.url}/secret`;
        const response = await index_js_1.AxiosUtils.fetch(url, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'X-Signed-Header': signature,
            },
            body: request.toString(),
        });
        if (!response.ok) {
            throw new Error(`createSecret failed: ${response.statusText}`);
        }
    }
    createAddMrEnclaveRequest(
    /**
     *  The address of the user.
     */
    userPubkey, 
    /**
     *  'ed25519' for Solana users, 'ethers' for EVM users.
     */
    ciphersuite, 
    /**
     *  The MrEnclave value to add.
     */
    mrEnclave, 
    /**
     *  The names of the secrets to whitelist the MrEnclave value for.
     */
    secretNames, 
    /**
     *  The timestamp that this request expires.
     *
     *  Default: now + 30 seconds.
     */
    expiryTimestamp = getDefaultRequestTimestamp()) {
        return new AddMrEnclavePayload(userPubkey, ciphersuite, mrEnclave, secretNames, expiryTimestamp);
    }
    async addMrEnclave(request, signature) {
        const url = `${this.url}/mrenclave/whitelist`;
        const response = await index_js_1.AxiosUtils.fetch(url, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'X-Signed-Header': signature,
            },
            body: request.toString(),
        });
        if (!response.ok) {
            throw new Error(`addMrEnclave failed: ${response.statusText}`);
        }
    }
    createRemoveMrEnclaveRequest(
    /**
     *  The address of the user.
     */
    userPubkey, 
    /**
     *  'ed25519' for Solana users, 'ethers' for EVM users.
     */
    ciphersuite, 
    /**
     *  The mrEnclave value to remove.
     */
    mrEnclave, 
    /**
     *  The timestamp that this request expires.
     *
     *  Default: now + 30 seconds.
     */
    expiryTimestamp = getDefaultRequestTimestamp()) {
        return new RemoveMrEnclavePayload(userPubkey, ciphersuite, mrEnclave, expiryTimestamp);
    }
    async removeMrEnclave(request, signature) {
        const url = `${this.url}/mrenclave/whitelist`;
        const response = await index_js_1.AxiosUtils.fetch(url, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'X-Signed-Header': signature,
            },
            body: request.toString(),
        });
        if (!response.ok) {
            throw new Error(`removeMrEnclave failed: ${response.statusText}`);
        }
    }
    createDeleteSecretRequest(
    /**
     *  The address of the user.
     */
    userPubkey, 
    /**
     *  'ed25519' for Solana users, 'ethers' for EVM users.
     */
    ciphersuite, 
    /**
     *  The name fo the secret to delete.
     */
    secretName, 
    /**
     *  The timestamp that this request expires.
     *
     *  Default: now + 30 seconds.
     */
    expiryTimestamp = getDefaultRequestTimestamp()) {
        return new DeleteSecretPayload(userPubkey, ciphersuite, secretName, expiryTimestamp);
    }
    async deleteSecret(request, signature) {
        const url = `${this.url}/secret`;
        const response = await index_js_1.AxiosUtils.fetch(url, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
                'X-Signed-Header': signature,
            },
            body: request.toString(),
        });
        if (!response.ok) {
            throw new Error(`deleteSecret failed: ${response.statusText}`);
        }
    }
}
exports.SwitchboardSecrets = SwitchboardSecrets;
class UpdateUserPayload {
    constructor(user_pubkey, ciphersuite, contact_info, timestamp) {
        this.user_pubkey = user_pubkey;
        this.ciphersuite = ciphersuite;
        this.contact_info = contact_info;
        this.timestamp = timestamp;
    }
    static from(obj) {
        return new UpdateUserPayload(obj.user_pubkey, obj.ciphersuite, obj.contact_info, obj.timestamp);
    }
    toJSON() {
        return {
            user_pubkey: this.user_pubkey,
            ciphersuite: this.ciphersuite,
            contact_info: this.contact_info,
            timestamp: this.timestamp,
        };
    }
    toString() {
        return JSON.stringify(this.toJSON());
    }
    toEncodedMessage() {
        return buffer_1.Buffer.from(js_sha256_1.sha256.create().update(this.toString()).digest());
    }
}
exports.UpdateUserPayload = UpdateUserPayload;
class CreateSecretPayload {
    constructor(user_pubkey, ciphersuite, secret_name, secret, timestamp) {
        this.user_pubkey = user_pubkey;
        this.ciphersuite = ciphersuite;
        this.secret_name = secret_name;
        this.secret = secret;
        this.timestamp = timestamp;
    }
    static from(obj) {
        return new CreateSecretPayload(obj.user_pubkey, obj.ciphersuite, obj.secret_name, obj.secret, obj.timestamp);
    }
    toJSON() {
        return {
            user_pubkey: this.user_pubkey,
            ciphersuite: this.ciphersuite,
            secret: this.secret,
            secret_name: this.secret_name,
            timestamp: this.timestamp,
        };
    }
    toString() {
        return JSON.stringify(this.toJSON());
    }
    toEncodedMessage() {
        return buffer_1.Buffer.from(js_sha256_1.sha256.create().update(this.toString()).digest());
    }
}
exports.CreateSecretPayload = CreateSecretPayload;
class AddMrEnclavePayload {
    constructor(user_pubkey, ciphersuite, mr_enclave, secret_names, timestamp) {
        this.user_pubkey = user_pubkey;
        this.ciphersuite = ciphersuite;
        this.mr_enclave = mr_enclave;
        this.secret_names = secret_names;
        this.timestamp = timestamp;
    }
    static from(obj) {
        return new AddMrEnclavePayload(obj.user_pubkey, obj.ciphersuite, obj.mr_enclave, obj.secret_names, obj.timestamp);
    }
    toJSON() {
        return {
            user_pubkey: this.user_pubkey,
            ciphersuite: this.ciphersuite,
            mr_enclave: this.mr_enclave,
            secret_names: this.secret_names,
            timestamp: this.timestamp,
        };
    }
    toString() {
        return JSON.stringify(this.toJSON());
    }
    toEncodedMessage() {
        return buffer_1.Buffer.from(js_sha256_1.sha256.create().update(this.toString()).digest());
    }
}
exports.AddMrEnclavePayload = AddMrEnclavePayload;
class RemoveMrEnclavePayload {
    constructor(user_pubkey, ciphersuite, mr_enclave, timestamp) {
        this.user_pubkey = user_pubkey;
        this.ciphersuite = ciphersuite;
        this.mr_enclave = mr_enclave;
        this.timestamp = timestamp;
    }
    static from(obj) {
        return new RemoveMrEnclavePayload(obj.user_pubkey, obj.ciphersuite, obj.mr_enclave, obj.timestamp);
    }
    toJSON() {
        return {
            user_pubkey: this.user_pubkey,
            ciphersuite: this.ciphersuite,
            mr_enclave: this.mr_enclave,
            timestamp: this.timestamp,
        };
    }
    toString() {
        return JSON.stringify(this.toJSON());
    }
    toEncodedMessage() {
        return buffer_1.Buffer.from(js_sha256_1.sha256.create().update(this.toString()).digest());
    }
}
exports.RemoveMrEnclavePayload = RemoveMrEnclavePayload;
class DeleteSecretPayload {
    constructor(user_pubkey, ciphersuite, secret_name, timestamp) {
        this.user_pubkey = user_pubkey;
        this.ciphersuite = ciphersuite;
        this.secret_name = secret_name;
        this.timestamp = timestamp;
    }
    static from(obj) {
        return new DeleteSecretPayload(obj.user_pubkey, obj.ciphersuite, obj.secret_name, obj.timestamp);
    }
    toJSON() {
        return {
            user_pubkey: this.user_pubkey,
            ciphersuite: this.ciphersuite,
            secret_name: this.secret_name,
            timestamp: this.timestamp,
        };
    }
    toString() {
        return JSON.stringify(this.toJSON());
    }
    toEncodedMessage() {
        return buffer_1.Buffer.from(js_sha256_1.sha256.create().update(this.toString()).digest());
    }
}
exports.DeleteSecretPayload = DeleteSecretPayload;

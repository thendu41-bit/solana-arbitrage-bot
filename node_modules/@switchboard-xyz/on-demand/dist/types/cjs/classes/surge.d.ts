import { Queue } from '../accounts/queue.js';
import { Source } from './source.js';
import { web3 } from '@coral-xyz/anchor-31';
import { CrossbarClient } from '@switchboard-xyz/common';
import { Buffer } from 'buffer';
import { EventEmitter } from 'events';
/**
 * Raw gateway response structure (matches actual BundledFeedUpdate from server)
 */
interface RawGatewayResponse {
    type: string;
    feed_bundle_id?: string;
    feed_values?: Array<{
        value: string;
        feed_hash: string;
    }>;
    oracle_response?: {
        oracle_pubkey: string;
        eth_address: string;
        signature: string;
        checksum: string;
        recovery_id: number;
        oracle_idx: number;
        timestamp: number;
        timestamp_ms?: number;
        recent_hash: string;
        slot: number;
        ed25519_enclave_signer?: string;
    };
    source_ts_ms: number;
    seen_at_ts_ms: number;
    triggered_on_price_change: boolean;
    message?: string;
}
/**
 * Raw unsigned price update structure (matches actual UnsignedPriceUpdate from server)
 */
interface RawUnsignedPriceUpdate {
    type: 'UnsignedPriceUpdate';
    feed_bundle_id: string;
    feed_values: Array<{
        value: string;
        feed_id: string;
        symbol: string;
        source: string;
        source_ts_ms: number;
        seen_at_ts_ms: number;
    }>;
    broadcast_ts_ms: number;
    message?: string;
}
/**
 * Oracle response class that wraps raw gateway responses with convenient methods
 */
export declare class SurgeUpdate {
    private readonly rawResponse;
    constructor(rawResponse: RawGatewayResponse);
    get data(): RawGatewayResponse;
    /**
     * Get array of signed feed hashes
     */
    getSignedFeeds(): string[];
    /**
     * Get array of price values (raw 18-decimal format)
     */
    getValues(): string[];
    /**
     * Get formatted prices as readable dollar amounts
     */
    getFormattedPrices(): Record<string, string>;
    /**
     * Check if this update was triggered by a price change (vs heartbeat)
     */
    isTriggeredByPriceChange(): boolean;
    /**
     * Get the complete raw response from gateway
     */
    getRawResponse(): RawGatewayResponse;
    /**
     * Get detailed latency breakdown for this oracle response
     *
     * Note: For heartbeat updates (triggered_on_price_change=false), the oracleProcessing
     * metric is not meaningful since heartbeats are generated by the oracle itself rather
     * than processing external price data.
     */
    getLatencyMetrics(): {
        exchangeToOracleUpdate: number | string;
        oracleUpdateToClient: number | string;
        endToEnd: number | string;
        isScheduledPriceHeartbeat: boolean;
    };
    /**
     * Convert to Solana bundle instruction supporting both signature schemes
     * - Ed25519 (default): Returns single TransactionInstruction
     * - Secp256k1 (backwards compat): Returns [TransactionInstruction, Buffer] tuple
     *
     * @param instructionIdx - The instruction index (defaults to 0)
     * @returns Transaction instruction or [instruction, bundleData] tuple depending on signature scheme
     */
    toBundleIx(instructionIdx?: number): web3.TransactionInstruction | [web3.TransactionInstruction, Buffer];
}
/**
 * Unsigned price update class that wraps raw unsigned price updates with convenient methods
 */
export declare class UnsignedPriceUpdate {
    private readonly rawResponse;
    constructor(rawResponse: RawUnsignedPriceUpdate);
    get data(): RawUnsignedPriceUpdate;
    /**
     * Get array of feed IDs
     */
    getFeedIds(): string[];
    /**
     * Get array of price values (raw format)
     */
    getPrices(): string[];
    /**
     * Get array of symbols
     */
    getSymbols(): string[];
    /**
     * Get array of sources
     */
    getSources(): string[];
    /**
     * Get formatted prices as readable dollar amounts
     */
    getFormattedPrices(): Record<string, string>;
    /**
     * Get the complete raw response
     */
    getRawResponse(): RawUnsignedPriceUpdate;
    /**
     * Get feed bundle ID
     */
    getFeedBundleId(): string;
    /**
     * Get latency metrics for all feeds in this update
     */
    getLatencyMetrics(): Array<{
        symbol: string;
        source: string;
        exchangeToBroadcast: number | string;
        broadcastToClient: number | string;
        endToEnd: number | string;
    }>;
    /**
     * Get latency metrics for a specific symbol and source
     */
    getLatencyMetricsFor(symbol: string, source: string): {
        exchangeToHub: number | string;
        hubToBroadcast: number | string;
        broadcastToClient: number | string;
        endToEnd: number | string;
    } | null;
}
/**
 * Supported exchange sources for streaming (dynamically fetched from gateway)
 */
export type StreamingSource = Source;
/**
 * Pair structure matching the Rust Pair struct
 */
export interface Pair {
    base: string;
    quote: string;
}
/**
 * Individual feed entry from the gateway
 */
export interface SurgeFeedEntry {
    source: string;
    feed_id: string;
}
/**
 * Symbol group containing feeds from different sources
 */
export interface SurgeSymbolGroup {
    symbol: Pair;
    feeds: SurgeFeedEntry[];
}
/**
 * Response from surge_feeds endpoint (actual API structure)
 */
export interface SurgeFeedsResponse {
    total: number;
    data: SurgeSymbolGroup[];
}
/**
 * Feed subscription input - can be symbol/source pair or feedHash, default source to 'WEIGHTED'
 */
export type SymbolSubscription = {
    symbol: string;
    source?: StreamingSource;
};
export type FeedSubscription = SymbolSubscription | {
    feedHash: string;
};
/**
 * Raw streaming response data from WebSocket
 */
export interface StreamingRawResponse {
    type: 'price_update' | 'bundle_update';
    data: Record<string, unknown>;
    timestamp: number;
}
/**
 * Processed streaming response ready for Solana transactions
 */
export interface StreamingProcessedResponse {
    instruction: web3.TransactionInstruction;
    bundleData: Buffer;
    feedHashes: string[];
    values: string[];
    timestamp: number;
}
/**
 * Combined streaming response with both raw and processed data
 */
export interface StreamingResponse {
    raw: StreamingRawResponse;
    processed: StreamingProcessedResponse;
}
/**
 * Error types for streaming operations
 */
export interface StreamingError {
    type: 'auth' | 'connection' | 'subscription' | 'processing' | 'validation';
    message: string;
    code?: string;
    retryable: boolean;
}
/**
 * Configuration options for Surge
 */
export interface SurgeConfig {
    /** API key for authentication */
    apiKey: string;
    /** Chain identifier (defaults to "solana") */
    chain?: string;
    /** Network identifier */
    network?: 'mainnet' | 'mainnet-beta' | 'testnet' | 'devnet';
    /** Optional queue for gateway discovery */
    queue?: Queue;
    /** Optional gateway URL override */
    gatewayUrl?: string;
    /** Optional crossbar client */
    crossbarClient?: CrossbarClient;
    /** Optional crossbar URL override (used in crossbar mode) */
    crossbarUrl?: string;
    /** Signature scheme to use (defaults to 'ed25519') */
    signatureScheme?: 'secp256k1' | 'ed25519';
    /** Auto-reconnect on connection loss (defaults to true) */
    autoReconnect?: boolean;
    /** Maximum reconnection attempts (defaults to 5) */
    maxReconnectAttempts?: number;
    /** Reconnection delay in ms (defaults to 1000) */
    reconnectDelay?: number;
    /** Verbose flag for added logging */
    verbose?: boolean;
    /** Enable crossbar mode (defaults to false) */
    crossbarMode?: boolean;
}
/**
 * WebSocket connection states
 */
type ConnectionState = 'disconnected' | 'connecting' | 'connected' | 'authenticating' | 'authenticated' | 'error';
/**
 * Surge - WebSocket streaming client for Switchboard On-Demand feeds
 *
 * Provides real-time streaming of price updates with automatic processing into
 * Solana transaction instructions. Supports both direct symbol/source subscriptions
 * and feedHash-based subscriptions with automatic detection and conversion.
 *
 * @example
 * ```typescript
 * const surge = new Surge({
 *   apiKey: "sb_live_...",
 *   network: "mainnet"
 * });
 *
 * // Subscribe to symbol/source pairs
 * await surge.subscribe([
 *   { symbol: "BTCUSDT", source: "BINANCE" },
 *   { symbol: "ETHUSDT", source: "WEIGHTED" }
 * ]);
 *
 * surge.on('update', (response: SwitchboardOracleResponse) => {
 *   console.log('Raw:', response.getRawResponse());
 *   console.log('Formatted prices:', response.getFormattedPrices());
 * });
 * ```
 */
export declare class Surge extends EventEmitter {
    private readonly config;
    private ws;
    private connectionState;
    private sessionToken;
    private subscriptions;
    private bundleIdToFeeds;
    private feedToBundleId;
    private reconnectAttempts;
    private detectedClientIp?;
    private sessionClientIp?;
    private reconnectTimer;
    private gateway;
    private crossbar;
    private authenticationPromise;
    private authenticationResolve;
    private sessionData;
    /**
     * Create a new Surge instance
     */
    constructor(config: SurgeConfig);
    /**
     * Set up internal event emitters
     */
    private setupEventEmitters;
    /**
     * Private logging conditional helper
     */
    private log;
    /**
     * Request a session token from the gateway (following bundle_verbose_test.ts pattern)
     */
    private requestSession;
    /**
     * Single attempt to request session
     */
    private attemptSessionRequest;
    /**
     * Determine if a session error is retryable
     */
    private isRetryableSessionError;
    /**
     * Connect to the gateway and authenticate
     */
    connect(): Promise<void>;
    /**
     * Set up WebSocket event handlers
     */
    private setupWebSocketHandlers;
    /**
     * Handle incoming WebSocket messages
     */
    private handleWebSocketMessage;
    /**
     * Subscribe to feeds
     */
    subscribe(feeds: FeedSubscription[], batchIntervalMs?: number): Promise<void>;
    /**
     * Wait for WebSocket to be in OPEN state before sending messages
     * @param timeoutMs Maximum time to wait in milliseconds
     */
    private waitForWebSocketReady;
    /**
     * Validate that feeds exist and sources are available before attempting to subscribe
     * @param feeds Array of feed subscriptions to validate
     * @param retryCount Internal retry counter (defaults to 0)
     * @throws Error if any feed is invalid with descriptive message after retries
     */
    validateFeeds(feeds: FeedSubscription[], retryCount?: number): Promise<void>;
    /**
     * Connect to gateway and subscribe to feeds in one operation with proper error handling
     * This is the recommended method for most use cases as it validates feeds before any connection attempts
     * @param feeds Array of feed subscriptions
     * @throws Error if validation fails, connection fails, or subscription fails
     */
    connectAndSubscribe(feeds: FeedSubscription[], batchIntervalMs?: number): Promise<void>;
    /**
     * Subscribe to all available feeds with optional source filtering
     */
    subscribeToAll(sources_?: Source[], batchIntervalMs?: number): Promise<void>;
    /**
     * Internal subscribe method that skips validation (assumes feeds are already validated)
     */
    private subscribeWithoutValidation;
    /**
     * Resolve feedHash to symbol/source pair
     */
    private resolveFeedHash;
    /**
     * Get total number of feeds available
     */
    private getTotalFeeds;
    /**
     * Check if a specific feed exists
     * @param symbol The symbol to check (e.g., "BTC/USD")
     * @param source Optional source to check (e.g., Source.WEIGHTED)
     * @returns true if the feed exists
     */
    checkFeedExists(symbol: string, source?: Source | string): Promise<boolean>;
    /**
     * Get available feeds for a specific symbol
     * @param symbol The symbol to query (e.g., "BTC/USD")
     * @returns The feed data for this symbol, or null if not found
     */
    getFeedInfo(symbol: string): Promise<SurgeSymbolGroup | null>;
    /**
     * Get available surge feeds (always fresh)
     * NOTE: Due to API limitations, this may not return all available feeds.
     * Use checkFeedExists() or getFeedInfo() to check specific feeds.
     */
    private getSurgeFeeds;
    /**
     * Unsubscribe from feeds
     */
    unsubscribe(feeds: FeedSubscription[]): Promise<void>;
    /**
     * Disconnect from the gateway
     */
    disconnect(): void;
    /**
     * Schedule automatic reconnection
     */
    private scheduleReconnection;
    /**
     * Get current connection state
     */
    getConnectionState(): ConnectionState;
    /**
     * Get list of active subscriptions
     */
    getSubscriptions(): FeedSubscription[];
    /**
     * Check if a specific feed is subscribed
     */
    isSubscribed(feed: FeedSubscription): boolean;
}
export {};
//# sourceMappingURL=surge.d.ts.map
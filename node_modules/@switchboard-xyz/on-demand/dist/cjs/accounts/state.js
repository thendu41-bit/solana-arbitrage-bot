"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.State = void 0;
const index_js_1 = require("../utils/index.js");
const queue_js_1 = require("./queue.js");
const anchor_31_1 = require("@coral-xyz/anchor-31");
const buffer_1 = require("buffer");
/**
 *  Abstraction around the Switchboard-On-Demand State account
 *
 *  This account is used to store the state data for a given program.
 */
class State {
    /**
     * Derives a state PDA (Program Derived Address) from the program.
     *
     * @param {Program} program - The Anchor program instance.
     * @returns {web3.PublicKey} The derived state account's public key.
     */
    static keyFromSeed(program) {
        const [state] = anchor_31_1.web3.PublicKey.findProgramAddressSync([buffer_1.Buffer.from('STATE')], program.programId);
        return state;
    }
    /**
     * Initializes the state account.
     *
     * @param {Program} program - The Anchor program instance.
     * @returns {Promise<[State, string]>} A promise that resolves to the state account and the transaction signature.
     */
    static create(program) {
        return __awaiter(this, void 0, void 0, function* () {
            const payer = (0, index_js_1.getNodePayer)(program);
            const sig = yield program.rpc.stateInit({}, {
                accounts: {
                    state: State.keyFromSeed(program),
                    payer: payer.publicKey,
                    systemProgram: anchor_31_1.web3.SystemProgram.programId,
                },
                signers: [payer],
            });
            return [new State(program), sig];
        });
    }
    /**
     * Constructs a `State` instance.
     *
     * @param {Program} program - The Anchor program instance.
     */
    constructor(program) {
        this.program = program;
        const pubkey = State.keyFromSeed(program);
        this.pubkey = pubkey;
    }
    /**
     * Set program-wide configurations.
     *
     * @param {object} params - The configuration parameters.
     * @param {web3.PublicKey} [params.guardianQueue] - The guardian queue account.
     * @param {web3.PublicKey} [params.newAuthority] - The new authority account.
     * @param {BN} [params.minQuoteVerifyVotes] - The minimum number of votes required to verify a quote.
     * @param {number} [params.permitAdvisory] - The permit advisory value.
     * @param {number} [params.denyAdvisory] - The deny advisory value.
     * @param {boolean} [params.testOnlyDisableMrEnclaveCheck] - A flag to disable MrEnclave check for testing purposes.
     * @param {web3.PublicKey} [params.switchMint] - The switch mint account.
     * @returns {Promise<web3.TransactionInstruction>} A promise that resolves to the transaction instruction.
     */
    setConfigsIx(params) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            const state = yield this.loadData();
            const queue = (_a = params.guardianQueue) !== null && _a !== void 0 ? _a : state.guardianQueue;
            const payer = (0, index_js_1.getNodePayer)(this.program);
            const testOnlyDisableMrEnclaveCheck = (_b = params.testOnlyDisableMrEnclaveCheck) !== null && _b !== void 0 ? _b : state.testOnlyDisableMrEnclaveCheck;
            const ix = yield this.program.instruction.stateSetConfigs({
                newAuthority: (_c = params.newAuthority) !== null && _c !== void 0 ? _c : state.authority,
                testOnlyDisableMrEnclaveCheck: testOnlyDisableMrEnclaveCheck ? 1 : 0,
                addAdvisory: params.permitAdvisory,
                rmAdvisory: params.denyAdvisory,
                lutSlot: state.lutSlot,
                subsidyAmount: (_d = params.subsidyAmount) !== null && _d !== void 0 ? _d : state.subsidyAmount,
                switchMint: (_e = params.switchMint) !== null && _e !== void 0 ? _e : state.switchMint,
                authority: (_f = params.newAuthority) !== null && _f !== void 0 ? _f : state.authority,
                addCostWl: (_g = params.addCostWl) !== null && _g !== void 0 ? _g : anchor_31_1.web3.PublicKey.default,
                rmCostWl: (_h = params.rmCostWl) !== null && _h !== void 0 ? _h : anchor_31_1.web3.PublicKey.default,
            }, {
                accounts: {
                    state: this.pubkey,
                    authority: state.authority,
                    queue,
                    payer: payer.publicKey,
                    systemProgram: anchor_31_1.web3.SystemProgram.programId,
                },
            });
            return ix;
        });
    }
    /**
     * Register a guardian with the global guardian queue.
     *
     * @param {object} params - The parameters object.
     * @param {PublicKey} params.guardian - The guardian account.
     * @returns {Promise<TransactionInstruction>} A promise that resolves to the transaction instruction.
     */
    registerGuardianIx(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const state = yield this.loadData();
            const payer = (0, index_js_1.getNodePayer)(this.program);
            const ix = yield this.program.instruction.guardianRegister({}, {
                accounts: {
                    oracle: params.guardian,
                    state: this.pubkey,
                    guardianQueue: state.guardianQueue,
                    authority: state.authority,
                },
                signers: [payer],
            });
            return ix;
        });
    }
    /**
     * Unregister a guardian from the global guardian queue.
     *
     * @param {object} params - The parameters object.
     * @param {web3.PublicKey} params.guardian - The guardian account.
     * @returns {Promise<web3.TransactionInstruction>} A promise that resolves to the transaction instruction.
     */
    unregisterGuardianIx(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const state = yield this.loadData();
            const guardianQueue = new queue_js_1.Queue(this.program, state.guardianQueue);
            const queueData = yield guardianQueue.loadData();
            const idx = queueData.oracleKeys.findIndex(key => key.equals(params.guardian));
            const payer = (0, index_js_1.getNodePayer)(this.program);
            const ix = yield this.program.instruction.guardianUnregister({ idx }, {
                accounts: {
                    oracle: params.guardian,
                    state: this.pubkey,
                    guardianQueue: state.guardianQueue,
                    authority: state.authority,
                },
                signers: [payer],
            });
            return ix;
        });
    }
    /**
     *  Loads the state data from on chain.
     *
     *  @returns A promise that resolves to the state data.
     *  @throws if the state account does not exist.
     */
    loadData() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.program.account['state'].fetch(this.pubkey);
        });
    }
    /**
     *  Loads the state data from on chain.
     *
     *  @returns A promise that resolves to the state data.
     *  @throws if the state account does not exist.
     */
    static loadData(program) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield new State(program).loadData();
        });
    }
}
exports.State = State;
//# sourceMappingURL=state.js.map
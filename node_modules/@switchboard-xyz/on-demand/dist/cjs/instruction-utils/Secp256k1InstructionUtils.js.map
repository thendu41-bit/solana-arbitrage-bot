{"version":3,"file":"Secp256k1InstructionUtils.js","sourceRoot":"","sources":["../../../src/instruction-utils/Secp256k1InstructionUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { web3 } from '@coral-xyz/anchor-31';\nimport { NonEmptyArrayUtils } from '@switchboard-xyz/common';\n\n// The serialized size of a secp256k1 signature\nconst SIGNATURE_SERIALIZED_SIZE = 64;\n// The serialized size of a hashed pubkey\nconst HASHED_PUBKEY_SERIALIZED_SIZE = 20;\n// The serialized size of the signature offsets\nconst SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;\n\nexport type Secp256k1Signature = {\n  ethAddress: Buffer;\n  signature: Buffer;\n  message: Buffer;\n  recoveryId: number;\n  oracleIdx: number; // Index of the oracle in the queue\n};\n\nexport class Secp256k1InstructionUtils {\n  /**\n   *  Disable instantiation of the InstructionUtils class\n   */\n  private constructor() {}\n\n  static buildSecp256k1Instruction(\n    signatures: Secp256k1Signature[],\n    instructionIndex: number\n  ): web3.TransactionInstruction {\n    // Add null/undefined check before array validation\n    if (!signatures || !Array.isArray(signatures)) {\n      throw new Error('Invalid `signatures` parameter: must be an array');\n    }\n\n    // Ensure that the `instructionIndex` is both a valid finite number and non-negative\n    if (!Number.isFinite(instructionIndex) || instructionIndex < 0) {\n      throw new Error('Invalid instruction index');\n    } else if (!NonEmptyArrayUtils.safeValidate(signatures)) {\n      // Ensure that the `signatures` array is non-empty and that all signatures share the same\n      // common message\n      throw new Error(\n        'Invalid `signatures` array: cannot be empty. All oracles failed to provide valid signatures.'\n      );\n    }\n\n    // Validate that all signatures have oracleIdx - required for queue order matching\n    for (let i = 0; i < signatures.length; i++) {\n      if (typeof signatures[i].oracleIdx !== 'number') {\n        throw new Error(\n          `Signature at index ${i} missing oracleIdx field - required for queue ordering`\n        );\n      }\n    }\n\n    // Sort signatures by oracleIdx to match queue order - CRITICAL for verification\n    // The Rust verification code expects signatures in the same order as oracle_signing_keys\n    const sortedSignatures = [...signatures].sort(\n      (a, b) => a.oracleIdx - b.oracleIdx\n    );\n\n    const diffIdx = sortedSignatures.findIndex(\n      sig => !sig.message.equals(sortedSignatures[0].message)\n    );\n    if (diffIdx !== -1) {\n      const expectedMessage = sortedSignatures[0].message.toString('base64');\n      const differentMessage =\n        sortedSignatures[diffIdx].message.toString('base64');\n      throw new Error(`\n        All signatures must share the same message. The signed message at #${diffIdx}\n        (${differentMessage}) does not match the expected message (${expectedMessage})\n      `);\n    }\n\n    // We've validated that all signatures share the same message, so we can use the first\n    // signature's message as the common message.\n    const commonMessage = sortedSignatures[0].message;\n    const commonMessageSize = commonMessage.length;\n\n    const signatureBlockSize =\n      SIGNATURE_SERIALIZED_SIZE + 1 + HASHED_PUBKEY_SERIALIZED_SIZE;\n    const numSignatures = sortedSignatures.length;\n    const offsetsAreaSize =\n      1 + numSignatures * SIGNATURE_OFFSETS_SERIALIZED_SIZE;\n    const messageOffset = offsetsAreaSize + numSignatures * signatureBlockSize;\n\n    const signatureOffsets: Uint8Array[] = [];\n    const signatureBuffer: number[] = [];\n\n    for (const sig of sortedSignatures) {\n      // Calculate the offset of the current signature block\n      const currentOffset = offsetsAreaSize + signatureBuffer.length;\n      // Create a new Uint8Array to store the signature offsets\n      const offsetsBytes = new Uint8Array(SIGNATURE_OFFSETS_SERIALIZED_SIZE);\n      let position = 0;\n\n      // Write signature offset (2 bytes LE)\n      const signatureOffset = currentOffset;\n      offsetsBytes.set(writeUInt16LE(signatureOffset), position);\n      position += 2;\n\n      // 1. Write signature instruction index (1 byte)\n      offsetsBytes[position] = instructionIndex;\n      position += 1;\n      // 2. Write eth address offset (2 bytes LE)\n      const ethAddressOffset = currentOffset + SIGNATURE_SERIALIZED_SIZE + 1;\n      offsetsBytes.set(writeUInt16LE(ethAddressOffset), position);\n      position += 2;\n      // 3. Write eth address instruction index (1 byte)\n      offsetsBytes[position] = instructionIndex;\n      position += 1;\n      // 4. Write message offset (2 bytes LE)\n      const messageDataOffset = messageOffset;\n      offsetsBytes.set(writeUInt16LE(messageDataOffset), position);\n      position += 2;\n      // 5. Write message size (2 bytes LE)\n      offsetsBytes.set(writeUInt16LE(commonMessageSize), position);\n      position += 2;\n      // 6. Write message instruction index (1 byte)\n      offsetsBytes[position] = instructionIndex;\n\n      // Append the signature offsets to the list of signature offsets\n      signatureOffsets.push(offsetsBytes);\n\n      // Append the signature block to the signature buffer\n      signatureBuffer.push(...Array.from(sig.signature));\n      signatureBuffer.push(sig.recoveryId);\n      signatureBuffer.push(...Array.from(sig.ethAddress));\n    }\n\n    // Build final instruction data\n    let position = 0;\n    const instrData = new Uint8Array(\n      1 + // count byte\n        signatureOffsets.length * SIGNATURE_OFFSETS_SERIALIZED_SIZE + // offsets area\n        signatureBuffer.length + // signature blocks\n        commonMessage.length // common message\n    );\n    // 1. Write count byte\n    instrData[position] = numSignatures;\n    position += 1;\n    // 2. Write offsets area\n    for (const offs of signatureOffsets) {\n      instrData.set(offs, position);\n      position += SIGNATURE_OFFSETS_SERIALIZED_SIZE;\n    }\n    // 3. Write signature blocks\n    instrData.set(new Uint8Array(signatureBuffer), position);\n    position += signatureBuffer.length;\n    // 4. Write common message\n    instrData.set(commonMessage, position);\n\n    return new web3.TransactionInstruction({\n      programId: web3.Secp256k1Program.programId,\n      data: Buffer.from(instrData),\n      keys: [],\n    });\n  }\n}\n\nfunction writeUInt16LE(value: number): Uint8Array {\n  const buf = Buffer.alloc(2);\n  buf.writeUInt16LE(value, 0);\n  return new Uint8Array(buf);\n}\n"]}
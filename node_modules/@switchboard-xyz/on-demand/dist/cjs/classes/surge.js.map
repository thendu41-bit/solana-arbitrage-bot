{"version":3,"file":"surge.js","sourceRoot":"","sources":["../../../src/classes/surge.ts"],"names":[],"mappings":"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","sourcesContent":["import { Queue } from '../accounts/queue.js';\nimport { Ed25519InstructionUtils } from '../instruction-utils/Ed25519InstructionUtils.js';\nimport type { Secp256k1Signature } from '../instruction-utils/Secp256k1InstructionUtils.js';\nimport { Secp256k1InstructionUtils } from '../instruction-utils/Secp256k1InstructionUtils.js';\nimport { Gateway } from '../oracle-interfaces/gateway.js';\n\nimport { Source } from './source.js';\n\nimport { BN, web3 } from '@coral-xyz/anchor-31';\nimport { CrossbarClient } from '@switchboard-xyz/common';\nimport axios from 'axios';\nimport { Buffer } from 'buffer';\nimport { EventEmitter } from 'events';\nimport WebSocket from 'isomorphic-ws';\n\n/**\n * Raw gateway response structure (matches actual BundledFeedUpdate from server)\n */\ninterface RawGatewayResponse {\n  type: string;\n  feed_bundle_id?: string;\n  feed_values?: Array<{\n    value: string;\n    feed_hash: string;\n  }>;\n  oracle_response?: {\n    oracle_pubkey: string;\n    eth_address: string;\n    signature: string;\n    checksum: string;\n    recovery_id: number;\n    oracle_idx: number;\n    timestamp: number;\n    timestamp_ms?: number;\n    recent_hash: string;\n    slot: number;\n    // Ed25519 enclave signer pubkey (for Ed25519 signature verification)\n    ed25519_enclave_signer?: string;\n  };\n  source_ts_ms: number;\n  seen_at_ts_ms: number;\n  triggered_on_price_change: boolean;\n  message?: string;\n}\n\n/**\n * Raw unsigned price update structure (matches actual UnsignedPriceUpdate from server)\n */\ninterface RawUnsignedPriceUpdate {\n  type: 'UnsignedPriceUpdate';\n  feed_bundle_id: string;\n  feed_values: Array<{\n    value: string;\n    feed_id: string;\n    symbol: string;\n    source: string;\n    source_ts_ms: number;\n    seen_at_ts_ms: number;\n  }>;\n  broadcast_ts_ms: number;\n  message?: string;\n}\n\n/**\n * WebSocket message types for subscription confirmations\n */\ninterface SubscribedMessage {\n  type: 'Subscribed';\n  message?: string;\n  feed_bundles?: Array<{\n    feed_bundle_id: string;\n    feeds: Array<{\n      symbol: string | { base: string; quote: string };\n      source: string;\n    }>;\n  }>;\n}\n\ninterface AuthenticatedMessage {\n  type: 'Authenticated';\n  message?: string;\n}\n\n/**\n * Validation error message type\n */\ninterface ValidationErrorMessage {\n  type: 'ValidationError';\n  message?: string;\n  error?: string;\n  invalid_feeds?: Array<{\n    symbol: {\n      base: string;\n      quote: string;\n    };\n    source: string;\n    error: string;\n  }>;\n  details?: Record<string, unknown>;\n}\n\n/**\n * Union type for all WebSocket message types\n */\ntype WebSocketMessage =\n  | RawGatewayResponse\n  | RawUnsignedPriceUpdate\n  | SubscribedMessage\n  | AuthenticatedMessage\n  | ValidationErrorMessage;\n\n/**\n * Oracle response class that wraps raw gateway responses with convenient methods\n */\nexport class SurgeUpdate {\n  private readonly rawResponse: RawGatewayResponse;\n\n  constructor(rawResponse: RawGatewayResponse) {\n    this.rawResponse = rawResponse;\n  }\n\n  get data(): RawGatewayResponse {\n    return this.rawResponse;\n  }\n\n  /**\n   * Get array of signed feed hashes\n   */\n  getSignedFeeds(): string[] {\n    if (!this.rawResponse.feed_values) return [];\n    return this.rawResponse.feed_values.map(feed => feed.feed_hash);\n  }\n\n  /**\n   * Get array of price values (raw 18-decimal format)\n   */\n  getValues(): string[] {\n    if (!this.rawResponse.feed_values) return [];\n    return this.rawResponse.feed_values.map(feed => feed.value);\n  }\n\n  /**\n   * Get formatted prices as readable dollar amounts\n   */\n  getFormattedPrices(): Record<string, string> {\n    if (!this.rawResponse.feed_values) return {};\n\n    const prices: Record<string, string> = {};\n    this.rawResponse.feed_values.forEach(feed => {\n      const value = BigInt(feed.value);\n      const divisor = BigInt(10 ** 18);\n      const wholePart = value / divisor;\n      const fractionalPart = value % divisor;\n\n      // Convert to full decimal representation without losing precision\n      const fullDecimal = fractionalPart.toString().padStart(18, '0');\n\n      // Remove trailing zeros to show only significant digits\n      const decimals = fullDecimal.replace(/0+$/, '') || '0';\n\n      const wholeStr = wholePart\n        .toString()\n        .replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n\n      // Use full precision instead of truncating to 2 decimals\n      prices[feed.feed_hash] =\n        decimals === '0' ? `$${wholeStr}` : `$${wholeStr}.${decimals}`;\n    });\n\n    return prices;\n  }\n\n  /**\n   * Check if this update was triggered by a price change (vs heartbeat)\n   */\n  isTriggeredByPriceChange(): boolean {\n    return this.rawResponse.triggered_on_price_change === true;\n  }\n\n  /**\n   * Get the complete raw response from gateway\n   */\n  getRawResponse(): RawGatewayResponse {\n    return this.rawResponse;\n  }\n\n  /**\n   * Get detailed latency breakdown for this oracle response\n   *\n   * Note: For heartbeat updates (triggered_on_price_change=false), the oracleProcessing\n   * metric is not meaningful since heartbeats are generated by the oracle itself rather\n   * than processing external price data.\n   */\n  getLatencyMetrics(): {\n    exchangeToOracleUpdate: number | string;\n    oracleUpdateToClient: number | string;\n    endToEnd: number | string;\n    isScheduledPriceHeartbeat: boolean;\n  } {\n    const sourceTimeMs = this.rawResponse.source_ts_ms;\n    const arrivalTimeMs = Date.now();\n    const checksumTimeMs =\n      this.rawResponse.oracle_response?.timestamp_ms ||\n      (this.rawResponse.oracle_response?.timestamp ?? 0) * 1000;\n\n    const isHeartbeat = this.rawResponse.triggered_on_price_change === false;\n    // Calculate raw values\n    const oracleToClientRaw = arrivalTimeMs - checksumTimeMs;\n    const endToEndRaw = arrivalTimeMs - sourceTimeMs;\n    const exchangeToChecksumRaw = checksumTimeMs - sourceTimeMs;\n\n    // Helper function to handle negative values (clock drift)\n    const handleClockDrift = (value: number): number | string => {\n      if (value < 0) {\n        return `${value}ms (clock drift detected)`;\n      }\n      return value;\n    };\n\n    return {\n      exchangeToOracleUpdate: handleClockDrift(exchangeToChecksumRaw),\n      oracleUpdateToClient: handleClockDrift(oracleToClientRaw),\n      endToEnd: handleClockDrift(endToEndRaw),\n      isScheduledPriceHeartbeat: isHeartbeat,\n    };\n  }\n\n  /**\n   * Convert to Solana bundle instruction supporting both signature schemes\n   * - Ed25519 (default): Returns single TransactionInstruction\n   * - Secp256k1 (backwards compat): Returns [TransactionInstruction, Buffer] tuple\n   *\n   * @param instructionIdx - The instruction index (defaults to 0)\n   * @returns Transaction instruction or [instruction, bundleData] tuple depending on signature scheme\n   */\n  toBundleIx(\n    instructionIdx: number = 0\n  ): web3.TransactionInstruction | [web3.TransactionInstruction, Buffer] {\n    const response = this.rawResponse;\n\n    // Check if oracle_response exists\n    if (!response.oracle_response) {\n      throw new Error('No oracle response available for creating signatures');\n    }\n\n    // Check which signature type to use based on available fields\n    if (response.oracle_response.ed25519_enclave_signer) {\n      // Ed25519 path (new default) - matches Ed25519 v0 scheme\n      let pubkeyHex = response.oracle_response.ed25519_enclave_signer;\n\n      // If ed25519_enclave_signer is 64 bytes (128 hex chars), extract the first 32 bytes for Ed25519 pubkey\n      if (pubkeyHex && pubkeyHex.length === 128) {\n        pubkeyHex = pubkeyHex.substring(0, 64); // First 32 bytes (64 hex chars)\n      }\n\n      // Build the Ed25519 signature object\n      const ed25519Signature = {\n        pubkey: Buffer.from(pubkeyHex, 'hex'), // Ed25519 pubkey (32 bytes)\n        signature: Buffer.from(response.oracle_response.signature, 'base64'), // Signature\n        message: Buffer.from(response.oracle_response.checksum, 'base64'), // Message is the checksum for Ed25519\n        oracleIdx: response.oracle_response.oracle_idx, // Oracle index\n      };\n\n      // Build the Ed25519 instruction\n      const ed25519Instruction =\n        Ed25519InstructionUtils.buildEd25519Instruction(\n          [ed25519Signature],\n          instructionIdx,\n          response.oracle_response.slot, // recent_slot from oracle response\n          0 // version 0 for Ed25519 v0 scheme\n        );\n\n      return ed25519Instruction;\n    } else {\n      // Secp256k1 path (backwards compatibility)\n      const oracleResponse = response.oracle_response;\n\n      // Create SECP256k1 signature (following exact fetchUpdateBundleIx pattern)\n      const secpSignatures: Secp256k1Signature[] = [\n        {\n          ethAddress: Buffer.from(oracleResponse.eth_address, 'hex'),\n          signature: Buffer.from(oracleResponse.signature, 'base64'),\n          message: Buffer.from(oracleResponse.checksum, 'base64'),\n          recoveryId: oracleResponse.recovery_id,\n          oracleIdx: oracleResponse.oracle_idx,\n        },\n      ];\n\n      const secpInstruction =\n        Secp256k1InstructionUtils.buildSecp256k1Instruction(\n          secpSignatures,\n          instructionIdx\n        );\n\n      // Prepare the bundle data (simplified version for Surge compatibility)\n      const data = {\n        slotLower: Number(response.oracle_response.slot) & 0xff,\n        feedInfos:\n          response.feed_values?.map(feed => ({\n            value: new BN(feed.value),\n            checksum: Buffer.from(feed.feed_hash, 'hex'),\n            numOracles: 1, // Single oracle response\n          })) || [],\n      };\n\n      // Create a minimal bundle data buffer for compatibility\n      const bundleDataLength = 1 + data.feedInfos.length * (16 + 32 + 1); // slot + (value + checksum + numOracles) per feed\n      const bundleData = Buffer.alloc(bundleDataLength);\n      let offset = 0;\n\n      // Write slot lower byte\n      bundleData.writeUInt8(data.slotLower, offset);\n      offset += 1;\n\n      // Write feed infos\n      for (const feedInfo of data.feedInfos) {\n        // Write value as 16 bytes LE\n        const valueBytes = feedInfo.value.toArrayLike(Buffer, 'le', 16);\n        valueBytes.copy(bundleData, offset);\n        offset += 16;\n\n        // Write checksum (32 bytes)\n        feedInfo.checksum.copy(bundleData, offset);\n        offset += 32;\n\n        // Write numOracles (1 byte)\n        bundleData.writeUInt8(feedInfo.numOracles, offset);\n        offset += 1;\n      }\n\n      return [secpInstruction, bundleData];\n    }\n  }\n}\n\n/**\n * Unsigned price update class that wraps raw unsigned price updates with convenient methods\n */\nexport class UnsignedPriceUpdate {\n  private readonly rawResponse: RawUnsignedPriceUpdate;\n\n  constructor(rawResponse: RawUnsignedPriceUpdate) {\n    this.rawResponse = rawResponse;\n  }\n\n  get data(): RawUnsignedPriceUpdate {\n    return this.rawResponse;\n  }\n\n  /**\n   * Get array of feed IDs\n   */\n  getFeedIds(): string[] {\n    return this.rawResponse.feed_values.map(feed => feed.feed_id);\n  }\n\n  /**\n   * Get array of price values (raw format)\n   */\n  getPrices(): string[] {\n    return this.rawResponse.feed_values.map(feed => feed.value);\n  }\n\n  /**\n   * Get array of symbols\n   */\n  getSymbols(): string[] {\n    return this.rawResponse.feed_values.map(feed => feed.symbol);\n  }\n\n  /**\n   * Get array of sources\n   */\n  getSources(): string[] {\n    return this.rawResponse.feed_values.map(feed => feed.source);\n  }\n\n  /**\n   * Get formatted prices as readable dollar amounts\n   */\n  getFormattedPrices(): Record<string, string> {\n    const prices: Record<string, string> = {};\n    this.rawResponse.feed_values.forEach(feed => {\n      const value = BigInt(feed.value);\n      const divisor = BigInt(10 ** 18);\n      const wholePart = value / divisor;\n      const fractionalPart = value % divisor;\n\n      // Convert to full decimal representation without losing precision\n      const fullDecimal = fractionalPart.toString().padStart(18, '0');\n\n      // Remove trailing zeros to show only significant digits\n      const decimals = fullDecimal.replace(/0+$/, '') || '0';\n\n      const wholeStr = wholePart\n        .toString()\n        .replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n      prices[feed.symbol] = `$${wholeStr}.${decimals}`;\n    });\n\n    return prices;\n  }\n\n  /**\n   * Get the complete raw response\n   */\n  getRawResponse(): RawUnsignedPriceUpdate {\n    return this.rawResponse;\n  }\n\n  /**\n   * Get feed bundle ID\n   */\n  getFeedBundleId(): string {\n    return this.rawResponse.feed_bundle_id;\n  }\n\n  /**\n   * Get latency metrics for all feeds in this update\n   */\n  getLatencyMetrics(): Array<{\n    symbol: string;\n    source: string;\n    exchangeToBroadcast: number | string;\n    broadcastToClient: number | string;\n    endToEnd: number | string;\n  }> {\n    const currentTimeMs = Date.now();\n    const broadcastTs = this.rawResponse.broadcast_ts_ms;\n\n    return this.rawResponse.feed_values.map(feed => {\n      const exchangeToBroadcastRaw = broadcastTs - feed.source_ts_ms;\n      const broadcastToClientRaw = currentTimeMs - broadcastTs;\n      const endToEndRaw = currentTimeMs - feed.source_ts_ms;\n\n      // Helper function to handle negative values (clock drift)\n      const handleClockDrift = (value: number): number | string => {\n        if (value < 0) {\n          return `${value}ms (clock drift detected)`;\n        }\n        return value;\n      };\n\n      return {\n        symbol: feed.symbol,\n        source: feed.source,\n        exchangeToBroadcast: handleClockDrift(exchangeToBroadcastRaw),\n        broadcastToClient: handleClockDrift(broadcastToClientRaw),\n        endToEnd: handleClockDrift(endToEndRaw),\n      };\n    });\n  }\n\n  /**\n   * Get latency metrics for a specific symbol and source\n   */\n  getLatencyMetricsFor(\n    symbol: string,\n    source: string\n  ): {\n    exchangeToHub: number | string;\n    hubToBroadcast: number | string;\n    broadcastToClient: number | string;\n    endToEnd: number | string;\n  } | null {\n    const feed = this.rawResponse.feed_values.find(\n      f => f.symbol === symbol && f.source === source\n    );\n\n    if (!feed) {\n      return null;\n    }\n\n    const currentTimeMs = Date.now();\n    const broadcastTs = this.rawResponse.broadcast_ts_ms;\n\n    const exchangeToHubRaw = feed.seen_at_ts_ms - feed.source_ts_ms;\n    const hubToBroadcastRaw = broadcastTs - feed.seen_at_ts_ms;\n    const broadcastToClientRaw = currentTimeMs - broadcastTs;\n    const endToEndRaw = currentTimeMs - feed.source_ts_ms;\n\n    // Helper function to handle negative values (clock drift)\n    const handleClockDrift = (value: number): number | string => {\n      if (value < 0) {\n        return `${value}ms (clock drift detected)`;\n      }\n      return value;\n    };\n\n    return {\n      exchangeToHub: handleClockDrift(exchangeToHubRaw),\n      hubToBroadcast: handleClockDrift(hubToBroadcastRaw),\n      broadcastToClient: handleClockDrift(broadcastToClientRaw),\n      endToEnd: handleClockDrift(endToEndRaw),\n    };\n  }\n}\n\n/**\n * Supported exchange sources for streaming (dynamically fetched from gateway)\n */\nexport type StreamingSource = Source;\n\n/**\n * Pair structure matching the Rust Pair struct\n */\nexport interface Pair {\n  base: string;\n  quote: string;\n}\n\n/**\n * Utility functions for Pair conversion\n */\nfunction stringToPair(symbol: string): Pair {\n  const [base, quote] = symbol.split('/');\n  if (!base || !quote) {\n    throw new Error(`Invalid symbol format: ${symbol}. Expected BASE/QUOTE`);\n  }\n  return { base: base.toUpperCase(), quote: quote.toUpperCase() };\n}\n\nfunction pairToString(pair: Pair): string {\n  return `${pair.base}/${pair.quote}`;\n}\n\n/**\n * Individual feed entry from the gateway\n */\nexport interface SurgeFeedEntry {\n  source: string;\n  feed_id: string;\n}\n\n/**\n * Symbol group containing feeds from different sources\n */\nexport interface SurgeSymbolGroup {\n  symbol: Pair; // Changed from string to Pair\n  feeds: SurgeFeedEntry[];\n}\n\n/**\n * Response from surge_feeds endpoint (actual API structure)\n */\nexport interface SurgeFeedsResponse {\n  total: number;\n  data: SurgeSymbolGroup[];\n}\n\n/**\n * Feed subscription input - can be symbol/source pair or feedHash, default source to 'WEIGHTED'\n */\nexport type SymbolSubscription = { symbol: string; source?: StreamingSource };\nexport type FeedSubscription = SymbolSubscription | { feedHash: string };\n\n/**\n * Raw streaming response data from WebSocket\n */\nexport interface StreamingRawResponse {\n  type: 'price_update' | 'bundle_update';\n  data: Record<string, unknown>; // Raw WebSocket message\n  timestamp: number;\n}\n\n/**\n * Processed streaming response ready for Solana transactions\n */\nexport interface StreamingProcessedResponse {\n  instruction: web3.TransactionInstruction;\n  bundleData: Buffer;\n  feedHashes: string[];\n  values: string[];\n  timestamp: number;\n}\n\n/**\n * Combined streaming response with both raw and processed data\n */\nexport interface StreamingResponse {\n  raw: StreamingRawResponse;\n  processed: StreamingProcessedResponse;\n}\n\n/**\n * Error types for streaming operations\n */\nexport interface StreamingError {\n  type: 'auth' | 'connection' | 'subscription' | 'processing' | 'validation';\n  message: string;\n  code?: string;\n  retryable: boolean;\n}\n\n/**\n * Configuration options for Surge\n */\nexport interface SurgeConfig {\n  /** API key for authentication */\n  apiKey: string;\n  /** Chain identifier (defaults to \"solana\") */\n  chain?: string;\n  /** Network identifier */\n  network?: 'mainnet' | 'mainnet-beta' | 'testnet' | 'devnet';\n  /** Optional queue for gateway discovery */\n  queue?: Queue;\n  /** Optional gateway URL override */\n  gatewayUrl?: string;\n  /** Optional crossbar client */\n  crossbarClient?: CrossbarClient;\n  /** Optional crossbar URL override (used in crossbar mode) */\n  crossbarUrl?: string;\n  /** Signature scheme to use (defaults to 'ed25519') */\n  signatureScheme?: 'secp256k1' | 'ed25519';\n  /** Auto-reconnect on connection loss (defaults to true) */\n  autoReconnect?: boolean;\n  /** Maximum reconnection attempts (defaults to 5) */\n  maxReconnectAttempts?: number;\n  /** Reconnection delay in ms (defaults to 1000) */\n  reconnectDelay?: number;\n  /** Verbose flag for added logging */\n  verbose?: boolean;\n  /** Enable crossbar mode (defaults to false) */\n  crossbarMode?: boolean; //  Add this flag\n}\n\n/**\n * Internal feed data for processing\n */\ninterface ProcessedFeedData {\n  feedHash?: string; // Optional - only for feedHash subscriptions\n  symbol: string;\n  source: StreamingSource;\n  batchIntervalMs?: number;\n}\n\n/**\n * WebSocket connection states\n */\ntype ConnectionState =\n  | 'disconnected'\n  | 'connecting'\n  | 'connected'\n  | 'authenticating'\n  | 'authenticated'\n  | 'error';\n\n/**\n * Surge - WebSocket streaming client for Switchboard On-Demand feeds\n *\n * Provides real-time streaming of price updates with automatic processing into\n * Solana transaction instructions. Supports both direct symbol/source subscriptions\n * and feedHash-based subscriptions with automatic detection and conversion.\n *\n * @example\n * ```typescript\n * const surge = new Surge({\n *   apiKey: \"sb_live_...\",\n *   network: \"mainnet\"\n * });\n *\n * // Subscribe to symbol/source pairs\n * await surge.subscribe([\n *   { symbol: \"BTCUSDT\", source: \"BINANCE\" },\n *   { symbol: \"ETHUSDT\", source: \"WEIGHTED\" }\n * ]);\n *\n * surge.on('update', (response: SwitchboardOracleResponse) => {\n *   console.log('Raw:', response.getRawResponse());\n *   console.log('Formatted prices:', response.getFormattedPrices());\n * });\n * ```\n */\nexport class Surge extends EventEmitter {\n  private readonly config: SurgeConfig;\n  private ws: WebSocket | null = null;\n  private connectionState: ConnectionState = 'disconnected';\n  private sessionToken: string | null = null;\n  private subscriptions: Map<string, ProcessedFeedData> = new Map();\n  private bundleIdToFeeds: Map<string, FeedSubscription[]> = new Map(); // Track bundle IDs for oracle mode\n  private feedToBundleId: Map<string, string> = new Map(); // Map feed key to bundle ID\n  private reconnectAttempts = 0;\n  private detectedClientIp?: string;\n  private sessionClientIp?: string; // IP actually used for session creation\n  private reconnectTimer: NodeJS.Timeout | null = null;\n  private gateway: Gateway | null = null;\n  private crossbar: CrossbarClient;\n  private authenticationPromise: Promise<void> | null = null;\n  private authenticationResolve: (() => void) | null = null;\n  private sessionData: { session_token: string; ws_url: string } | null = null;\n\n  /**\n   * Create a new Surge instance\n   */\n  constructor(config: SurgeConfig) {\n    super();\n\n    this.config = {\n      chain: 'solana',\n      network: 'mainnet-beta',\n      autoReconnect: true,\n      maxReconnectAttempts: 5,\n      reconnectDelay: 1000,\n      ...config,\n    };\n\n    // Initialize crossbar client with default URL\n    this.crossbar = config.crossbarClient || CrossbarClient.default();\n\n    this.setupEventEmitters();\n  }\n\n  /**\n   * Set up internal event emitters\n   */\n  private setupEventEmitters(): void {\n    this.on('error', (error: StreamingError) => {\n      console.error('Surge Error:', error);\n      if (error.retryable && this.config.autoReconnect) {\n        this.scheduleReconnection();\n      }\n    });\n  }\n  /**\n   * Private logging conditional helper\n   */\n  private log(message: string): void {\n    if (this.config.verbose) {\n      console.log(`[Surge] ${message}`);\n    }\n  }\n\n  /**\n   * Request a session token from the gateway (following bundle_verbose_test.ts pattern)\n   * @param feedHints Optional feeds for oracle selection\n   */\n  private async requestSession(feedHints?: FeedSubscription[]): Promise<{\n    session_token: string;\n    ws_url: string;\n  }> {\n    const maxRetries = 3;\n    const baseDelay = 1000; // 1 second\n\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        return await this.attemptSessionRequest(attempt, maxRetries, feedHints);\n      } catch (error) {\n        const isRetryable = this.isRetryableSessionError(error);\n\n        // If this is the last attempt or not retryable, throw\n        if (attempt === maxRetries || !isRetryable) {\n          throw error;\n        }\n\n        // Wait before retrying with exponential backoff\n        const delay = baseDelay * Math.pow(2, attempt - 1);\n        this.log(` Retrying session request in ${delay}ms...`);\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n\n    throw new Error('Session request failed after all retry attempts');\n  }\n\n  /**\n   * Single attempt to request session\n   * @param feedHints Optional feeds for oracle selection\n   */\n  private async attemptSessionRequest(\n    attempt: number,\n    maxRetries: number,\n    feedHints?: FeedSubscription[]\n  ): Promise<{\n    session_token: string;\n    ws_url: string;\n  }> {\n    let gatewayUrl: string;\n\n    if (this.config.crossbarMode) {\n      // Use CrossbarClient to get the gateway URL for crossbar mode\n      gatewayUrl = this.config.gatewayUrl || this.config.crossbarUrl || '';\n    } else {\n      // Use provided URL or default for oracle mode\n      gatewayUrl = this.config.gatewayUrl || 'https://gateway.switchboard.dev';\n    }\n\n    // Use different endpoints based on mode\n    const requestUrl = this.config.crossbarMode\n      ? `${gatewayUrl}/stream/request_session` //  Crossbar endpoint\n      : `${gatewayUrl}/gateway/api/v1/request_stream`; // Oracle endpoint\n\n    this.log(\n      ` Requesting session from: ${requestUrl} (attempt ${attempt}/${maxRetries})`\n    );\n\n    // Build request body\n    let requestBody: Record<string, unknown> = {};\n\n    // Add feeds for oracle mode (for smart oracle selection)\n    if (!this.config.crossbarMode && feedHints && feedHints.length > 0) {\n      // Convert FeedSubscription to request format\n      const feeds = feedHints\n        .map(feed => {\n          if ('feedHash' in feed) {\n            // Skip feedHash - can't use for oracle selection\n            return null;\n          }\n          // Convert Source enum to string for Rust endpoint (matches subscribe behavior)\n          const sourceStr = Source.toString(feed.source || Source.AUTO);\n\n          return {\n            symbol: feed.symbol,\n            source: sourceStr,\n          };\n        })\n        .filter(f => f !== null);\n\n      if (feeds.length > 0) {\n        requestBody.feeds = feeds;\n        this.log(` Including ${feeds.length} feeds for oracle selection`);\n      }\n    }\n\n    if (this.config.crossbarMode) {\n      // Check if we're not on localhost\n      // const isLocalhost =\n      //   gatewayUrl.includes('localhost') || gatewayUrl.includes('127.0.0.1');\n\n      // if (!isLocalhost) {\n      // if (true) {\n      // Always run IP detection to mimic production behavior\n      try {\n        // Always try to detect current IP first (handles IP changes)\n        const ipResponse = await axios.get(\n          'https://api.ipify.org?format=json',\n          { timeout: 2000 }\n        );\n        const clientIp = ipResponse.data.ip;\n\n        // Log if IP changed\n        if (this.detectedClientIp && this.detectedClientIp !== clientIp) {\n          this.log(\n            ` Client IP changed: ${this.detectedClientIp} -> ${clientIp}`\n          );\n        }\n\n        requestBody = { client_ip: clientIp };\n        this.detectedClientIp = clientIp;\n        this.sessionClientIp = clientIp; // Track IP used for session\n        this.log(` Using client IP: ${clientIp}`);\n      } catch {\n        // Fallback to previously detected IP if available\n        if (this.detectedClientIp) {\n          requestBody = { client_ip: this.detectedClientIp };\n          this.sessionClientIp = this.detectedClientIp; // Track IP used for session\n          this.log(\n            ` IP detection failed, using cached IP: ${this.detectedClientIp}`\n          );\n        } else {\n          this.log(\n            ' Could not detect client IP and no cached IP available, proceeding without it'\n          );\n          this.sessionClientIp = undefined; // No IP sent with session\n        }\n        // }\n      } // End of IP detection block\n    }\n\n    const response = await axios.post(requestUrl, requestBody, {\n      headers: {\n        'Content-Type': 'application/json',\n        'X-API-Key': this.config.apiKey,\n      },\n    });\n\n    const sessionData: { session_token: string; ws_url: string } = this.config\n      .crossbarMode\n      ? {\n          session_token: response.data.session_token,\n          ws_url: response.data.simulator_ws_url,\n        }\n      : {\n          session_token: response.data.session_token,\n          ws_url: response.data.oracle_ws_url,\n        };\n    this.log(\n      ` Session obtained: ${sessionData.session_token?.substring(0, 8)}...`\n    );\n    return sessionData;\n  }\n\n  /**\n   * Determine if a session error is retryable\n   */\n  private isRetryableSessionError(error: unknown): boolean {\n    if (axios.isAxiosError(error)) {\n      const status = error.response?.status;\n      const responseData = error.response?.data;\n      const message =\n        typeof responseData === 'string'\n          ? responseData\n          : responseData?.message || responseData?.error || error.message;\n\n      this.log(` Session request failed (${status}): ${message}`);\n\n      // Retry on server errors (5xx) and some client errors\n      if (status && status >= 500) return true; // Server errors\n      if (status === 429) return true; // Rate limit\n      if (status === 408) return true; // Request timeout\n      if (!status) return true; // Network errors\n\n      // Don't retry on authentication errors or bad requests\n      if (status === 401 || status === 403 || status === 400) return false;\n    } else {\n      this.log(` Session request failed: ${error}`);\n    }\n\n    // Retry on network errors\n    if (\n      error &&\n      typeof error === 'object' &&\n      'code' in error &&\n      (error.code === 'ECONNREFUSED' ||\n        error.code === 'ECONNRESET' ||\n        error.code === 'ETIMEDOUT')\n    ) {\n      return true;\n    }\n\n    return false; // Don't retry by default\n  }\n\n  /**\n   * Connect to the gateway and authenticate\n   * @param feedHints Optional feeds for oracle selection (oracle mode only)\n   */\n  async connect(feedHints?: FeedSubscription[]): Promise<void> {\n    // Clean up existing websocket if it exists\n    if (this.ws) {\n      this.log(' Closing existing websocket before creating new connection');\n      try {\n        this.ws.close(1000, 'Reconnecting');\n      } catch (e) {\n        this.log(` Error closing existing websocket: ${e}`);\n      }\n      this.ws = null;\n    }\n\n    if (\n      this.connectionState === 'connected' ||\n      this.connectionState === 'connecting'\n    ) {\n      return;\n    }\n\n    try {\n      this.connectionState = 'connecting';\n\n      // Step 1: Request session token from gateway\n      const session = await this.requestSession(feedHints);\n      this.sessionData = session; // Store session data for later use\n\n      // Step 2: Connect to the returned WebSocket URL with auth header\n      this.log(` Attempting to connect to: ${session.ws_url}`);\n\n      // Try header-based auth for oracle mode, URL-based for crossbar mode\n      const authToken = `Bearer ${this.config.apiKey}:${session.session_token}`;\n\n      if (this.config.crossbarMode) {\n        // Crossbar mode: Use URL parameters (working)\n        this.log(` Original WebSocket URL from session: ${session.ws_url}`);\n\n        // Create a new variable instead of modifying the original\n        let wsUrl = session.ws_url;\n        if (!wsUrl.includes('localhost') && !wsUrl.includes('127.0.0.1')) {\n          wsUrl = wsUrl.replace('ws://', 'wss://');\n          this.log(` Upgraded to secure WebSocket: ${wsUrl}`);\n        }\n        const url = new URL(wsUrl);\n        url.searchParams.set('authorization', authToken);\n\n        // Use the same IP that was used for session creation\n        if (this.sessionClientIp) {\n          url.searchParams.set('client_ip', this.sessionClientIp);\n          this.log(\n            ` Using session IP for WebSocket: ${this.sessionClientIp}`\n          );\n        } else {\n          this.log(\n            ' No session IP available, letting crossbar detect IP from headers'\n          );\n        }\n\n        const finalUrl = url.toString();\n        this.log(\n          ` Final WebSocket URL (crossbar): ${finalUrl.substring(0, finalUrl.indexOf('?'))}?authorization=[MASKED]`\n        );\n        this.ws = new WebSocket(finalUrl);\n      } else {\n        // Oracle mode: Use headers (might fix the connection issue)\n        this.log(\n          ` Final WebSocket URL (oracle): ${session.ws_url} with header auth`\n        );\n        this.ws = new WebSocket(session.ws_url, {\n          headers: {\n            Authorization: authToken,\n          },\n        });\n      }\n\n      this.sessionToken = session.session_token;\n\n      // Set up authentication promise for later waiting (only in crossbar mode)\n      if (this.config.crossbarMode) {\n        this.authenticationPromise = new Promise(resolve => {\n          this.authenticationResolve = resolve;\n        });\n      }\n\n      this.setupWebSocketHandlers();\n\n      // Wait for connection and authentication\n      return new Promise((resolve, reject) => {\n        const timeout = setTimeout(() => {\n          this.log(` WebSocket connection timeout to: ${session.ws_url}`);\n          reject(new Error(`Connection timeout to ${session.ws_url}`));\n        }, 10000);\n\n        const isBrowser = typeof window !== 'undefined';\n\n        if (isBrowser) {\n          // Browser WebSocket\n          const handleOpen = () => {\n            clearTimeout(timeout);\n            if (this.config.crossbarMode) {\n              // In crossbar mode, wait for explicit 'Authenticated' message\n              this.connectionState = 'connected';\n              this.reconnectAttempts = 0;\n\n              // Wait for authentication before resolving\n              if (!this.authenticationPromise) {\n                this.authenticationPromise = new Promise(resolve => {\n                  this.authenticationResolve = resolve;\n                });\n              }\n\n              this.authenticationPromise\n                .then(() => {\n                  this.log(' Authentication confirmed in connect()');\n                  resolve();\n                })\n                .catch(reject);\n            } else {\n              // In oracle mode, authentication is implicit when WebSocket opens\n              this.connectionState = 'authenticated';\n              this.reconnectAttempts = 0;\n              resolve();\n            }\n          };\n\n          const handleError = () => {\n            clearTimeout(timeout);\n            this.log(' Browser WebSocket connection failed');\n            reject(new Error('WebSocket connection failed'));\n          };\n\n          this.ws!.addEventListener('open', handleOpen, { once: true });\n          this.ws!.addEventListener('error', handleError, { once: true });\n        } else {\n          // Node.js ws\n          this.ws!.once('open', () => {\n            clearTimeout(timeout);\n            if (this.config.crossbarMode) {\n              // In crossbar mode, wait for explicit 'Authenticated' message\n              this.connectionState = 'connected';\n              this.reconnectAttempts = 0;\n\n              // Wait for authentication before resolving\n              if (!this.authenticationPromise) {\n                this.authenticationPromise = new Promise(resolve => {\n                  this.authenticationResolve = resolve;\n                });\n              }\n\n              this.authenticationPromise\n                .then(() => {\n                  this.log(' Authentication confirmed in connect()');\n                  resolve();\n                })\n                .catch(reject);\n            } else {\n              // In oracle mode, authentication is implicit when WebSocket opens\n              this.connectionState = 'authenticated';\n              this.reconnectAttempts = 0;\n              resolve();\n            }\n          });\n\n          this.ws!.once('error', error => {\n            clearTimeout(timeout);\n            this.log(` Node.js WebSocket error: ${error.message || error}`);\n            reject(error);\n          });\n        }\n      });\n    } catch (error) {\n      this.connectionState = 'error';\n      throw error;\n    }\n  }\n\n  /**\n   * Set up WebSocket event handlers\n   */\n  private setupWebSocketHandlers(): void {\n    if (!this.ws) return;\n\n    const isBrowser = typeof window !== 'undefined';\n\n    if (isBrowser) {\n      // Browser WebSocket uses addEventListener\n      this.ws.addEventListener('message', async event => {\n        try {\n          let data: string;\n          if (typeof event.data === 'string') {\n            data = event.data;\n          } else if (event.data instanceof Blob) {\n            data = await event.data.text();\n          } else {\n            data = new TextDecoder().decode(event.data as ArrayBuffer);\n          }\n          const message = JSON.parse(data);\n          this.handleWebSocketMessage(message);\n        } catch {\n          this.emit('error', {\n            type: 'processing',\n            message: 'Failed to parse WebSocket message',\n            retryable: false,\n          } as StreamingError);\n        }\n      });\n\n      this.ws.addEventListener('close', () => {\n        const previousState = this.connectionState;\n        this.connectionState = 'disconnected';\n        this.sessionToken = null;\n\n        // Only schedule reconnection if we weren't already in error state\n        // (error state handles its own reconnection)\n        if (this.config.autoReconnect && previousState !== 'error') {\n          this.scheduleReconnection();\n        }\n      });\n\n      this.ws.addEventListener('error', event => {\n        this.connectionState = 'error';\n        this.log(` WebSocket connection error: ${event}`);\n        this.emit('error', {\n          type: 'connection',\n          message: 'WebSocket connection error',\n          retryable: true,\n        } as StreamingError);\n      });\n    } else {\n      // Node.js ws uses .on()\n      this.ws.on('message', (data: Buffer) => {\n        try {\n          const message = JSON.parse(data.toString());\n\n          this.handleWebSocketMessage(message);\n        } catch {\n          this.emit('error', {\n            type: 'processing',\n            message: 'Failed to parse WebSocket message',\n            retryable: false,\n          } as StreamingError);\n        }\n      });\n\n      this.ws.on('ping', (data: Buffer) => {\n        if (this.config.verbose) {\n          this.log(' Received ping, responding with pong');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (this.ws as any).pong(data);\n      });\n\n      this.ws.on('close', () => {\n        const previousState = this.connectionState;\n        this.connectionState = 'disconnected';\n        this.sessionToken = null;\n\n        // Only schedule reconnection if we weren't already in error state\n        // (error state handles its own reconnection)\n        if (this.config.autoReconnect && previousState !== 'error') {\n          this.scheduleReconnection();\n        }\n      });\n\n      this.ws.on('error', error => {\n        this.connectionState = 'error';\n        this.log(` WebSocket connection error: ${error.message}`);\n        this.emit('error', {\n          type: 'connection',\n          message: error.message,\n          retryable: true,\n        } as StreamingError);\n      });\n    }\n  }\n\n  /**\n   * Handle incoming WebSocket messages\n   */\n  private handleWebSocketMessage(message: WebSocketMessage): void {\n    // Handle different message types based on bundle_verbose_test.ts pattern\n    switch (message.type) {\n      case 'Authenticated':\n        this.log(` ${message.message || 'Authenticated'}`);\n        this.connectionState = 'authenticated';\n        if (this.authenticationResolve) {\n          this.authenticationResolve();\n          this.authenticationResolve = null;\n          this.authenticationPromise = null;\n        }\n        break;\n\n      case 'Subscribed':\n        {\n          const subscribedMsg = message as SubscribedMessage;\n          const bundleCount = subscribedMsg.feed_bundles?.length || 0;\n\n          // Track bundle IDs for oracle mode unsubscribe\n          if (subscribedMsg.feed_bundles && !this.config.crossbarMode) {\n            for (const bundle of subscribedMsg.feed_bundles) {\n              if (bundle.feed_bundle_id) {\n                // Store the feeds associated with this bundle ID\n                const feeds: FeedSubscription[] = bundle.feeds.map(f => {\n                  // Convert Pair object to string format\n                  const symbolStr =\n                    typeof f.symbol === 'string'\n                      ? f.symbol\n                      : `${(f.symbol as { base: string; quote: string }).base}/${(f.symbol as { base: string; quote: string }).quote}`;\n                  return {\n                    symbol: symbolStr,\n                    source: Source.fromString(f.source),\n                  };\n                });\n                this.bundleIdToFeeds.set(bundle.feed_bundle_id, feeds);\n\n                // Map each feed to its bundle ID\n                for (const feed of bundle.feeds) {\n                  // Convert Pair object to string format for key\n                  const symbolStr =\n                    typeof feed.symbol === 'string'\n                      ? feed.symbol\n                      : `${(feed.symbol as { base: string; quote: string }).base}/${(feed.symbol as { base: string; quote: string }).quote}`;\n                  const key = `${feed.source}:${symbolStr}`;\n                  this.feedToBundleId.set(key, bundle.feed_bundle_id);\n                }\n              }\n            }\n          }\n\n          this.log(` Successfully subscribed to ${bundleCount} bundles`);\n        }\n        break;\n\n      case 'Unsubscribed':\n        {\n          const unsubscribedMsg = message as unknown as {\n            type: 'Unsubscribed';\n            feed_bundle_ids: string[];\n          };\n          const bundleCount = unsubscribedMsg.feed_bundle_ids?.length || 0;\n          this.log(` Successfully unsubscribed from ${bundleCount} bundles`);\n        }\n        break;\n\n      case 'Error':\n        {\n          const errorMsg = message as { type: 'Error'; message: string };\n          this.log(` Server error: ${errorMsg.message}`);\n          this.emit('error', {\n            type: 'validation',\n            message: errorMsg.message,\n            retryable: false,\n          } as StreamingError);\n        }\n        break;\n\n      case 'ValidationError':\n        {\n          const validationError = message as ValidationErrorMessage;\n          let errorMessage =\n            validationError.message ||\n            validationError.error ||\n            'Unknown validation error';\n\n          // Extract error from invalid_feeds if present\n          if (\n            validationError.invalid_feeds &&\n            validationError.invalid_feeds.length > 0\n          ) {\n            const invalidFeed = validationError.invalid_feeds[0];\n            errorMessage = `Feed validation failed for ${invalidFeed.symbol.base}/${invalidFeed.symbol.quote} (${invalidFeed.source}): ${invalidFeed.error}`;\n\n            // Log all invalid feeds\n            this.log(' Invalid feeds:');\n            validationError.invalid_feeds.forEach(feed => {\n              this.log(\n                `   - ${feed.symbol.base}/${feed.symbol.quote} (${feed.source}): ${feed.error}`\n              );\n            });\n          }\n\n          this.log(` Validation error: ${errorMessage}`);\n          if (validationError.details) {\n            this.log(` Details: ${JSON.stringify(validationError.details)}`);\n          }\n\n          this.emit('error', {\n            type: 'validation',\n            message: errorMessage,\n            retryable: false,\n          } as StreamingError);\n        }\n        break;\n\n      case 'BundledFeedUpdate':\n        try {\n          // Wrap the raw message in our response class\n          const oracleResponse = new SurgeUpdate(message as RawGatewayResponse);\n          this.emit('signedPriceUpdate', oracleResponse);\n        } catch (error) {\n          this.emit('error', {\n            type: 'processing',\n            message: `Failed to process BundledFeedUpdate: ${error}`,\n            retryable: false,\n          } as StreamingError);\n        }\n        break;\n      case 'UnsignedPriceUpdate':\n        try {\n          // Wrap the raw message in our UnsignedPriceUpdate class\n          const unsignedUpdate = new UnsignedPriceUpdate(\n            message as RawUnsignedPriceUpdate\n          );\n          this.emit('unsignedPriceUpdate', unsignedUpdate);\n        } catch (error) {\n          this.emit('error', {\n            type: 'processing',\n            message: `Failed to process UnsignedPriceUpdate: ${error}`,\n            retryable: false,\n          } as StreamingError);\n        }\n        break;\n\n      default:\n        // Handle legacy format for backward compatibility\n        if (\n          message.type === 'price_update' ||\n          message.type === 'update' ||\n          ('data' in message && message.data)\n        ) {\n          try {\n            const oracleResponse = new SurgeUpdate(\n              message as RawGatewayResponse\n            );\n            this.emit('signedPriceUpdate', oracleResponse);\n          } catch (_error) {\n            this.emit('error', {\n              type: 'processing',\n              message: `Failed to process update: ${_error}`,\n              retryable: false,\n            } as StreamingError);\n          }\n        } else {\n          // Check for potential error messages with different format\n          if ('message' in message && typeof message.message === 'string') {\n            this.log(` Unknown message type with error: ${message.message}`);\n            this.emit('error', {\n              type: 'validation',\n              message: message.message,\n              retryable: false,\n            } as StreamingError);\n          } else {\n            this.log(` Unknown message type: ${message.type}`);\n          }\n        }\n        break;\n    }\n  }\n\n  /**\n   * Subscribe to feeds\n   */\n  async subscribe(\n    feeds: FeedSubscription[],\n    batchIntervalMs?: number\n  ): Promise<void> {\n    // Validate feeds FIRST - before any connection attempts\n    // This will throw an error if any feed is invalid\n    await this.validateFeeds(feeds);\n\n    // Only connect after validation passes\n    if (this.connectionState !== 'authenticated') {\n      await this.connect();\n    }\n\n    // Wait for authentication message to be processed (only in crossbar mode)\n    if (this.config.crossbarMode && this.connectionState !== 'authenticated') {\n      this.log(' Waiting for authentication confirmation...');\n\n      // Create authentication promise if it doesn't exist\n      if (!this.authenticationPromise) {\n        this.authenticationPromise = new Promise(resolve => {\n          this.authenticationResolve = resolve;\n        });\n      }\n\n      // Wait for authentication to complete with timeout\n      const authTimeout = new Promise((_, reject) => {\n        setTimeout(\n          () => reject(new Error('Authentication timeout after 10 seconds')),\n          10000\n        );\n      });\n\n      try {\n        await Promise.race([this.authenticationPromise, authTimeout]);\n        this.log(' Authentication confirmed, proceeding with subscription');\n      } catch (error) {\n        this.log(` Authentication failed: ${error}`);\n        throw error;\n      }\n    } else {\n      this.log(' Already authenticated, proceeding immediately');\n    }\n\n    // Process feed subscriptions (after validation)\n    const processedFeeds: ProcessedFeedData[] = [];\n\n    for (const feed of feeds) {\n      if ('feedHash' in feed) {\n        // For feedHash subscriptions, we need to reverse-lookup the symbol/source\n        const feedData = await this.resolveFeedHash(feed.feedHash);\n        processedFeeds.push(feedData);\n      } else {\n        processedFeeds.push({\n          symbol: feed.symbol,\n          source: feed.source || Source.WEIGHTED, // Default to weighted average\n        });\n      }\n    }\n\n    // Validate batch interval if provided\n    if (batchIntervalMs !== undefined) {\n      if (batchIntervalMs < 10 || batchIntervalMs > 5000) {\n        throw new Error(\n          'batchIntervalMs must be between 10 and 5000 milliseconds'\n        );\n      }\n    }\n    // if batch interval not procided the default is 50ms, implemente below\n    if (batchIntervalMs === undefined) {\n      batchIntervalMs = 50; // Default to 50ms if not specified\n    }\n    // Update local subscriptions map\n    for (const feed of processedFeeds) {\n      const source = Source.toString(feed.source);\n      const key = `${source}:${feed.symbol}`;\n      this.subscriptions.set(key, {\n        ...feed,\n        batchIntervalMs, // Store the batchIntervalMs\n      });\n    }\n\n    // Send subscription message (following bundle_verbose_test.ts format)\n    const subscriptionMessage: {\n      type: 'Subscribe';\n      feed_bundles: Array<{\n        feeds: Array<{\n          symbol: Pair;\n          source: string;\n        }>;\n      }>;\n      batch_interval_ms?: number;\n      signature_scheme?: 'Secp256k1' | 'Ed25519'; // Add signature scheme\n    } = {\n      type: 'Subscribe',\n      feed_bundles: [\n        {\n          feeds: processedFeeds.map(feed => ({\n            symbol: stringToPair(feed.symbol), // Convert string to Pair object\n            source: Source.toString(feed.source || Source.WEIGHTED), // Convert to string\n          })),\n        },\n      ],\n      // Default to Ed25519 if not specified in config\n      signature_scheme:\n        this.config.signatureScheme === 'secp256k1' ? 'Secp256k1' : 'Ed25519',\n    };\n\n    // Add batch_interval_ms if provided\n    if (batchIntervalMs !== undefined) {\n      subscriptionMessage.batch_interval_ms = batchIntervalMs;\n    }\n\n    // Wait for WebSocket to be ready before sending subscription\n    await this.waitForWebSocketReady();\n\n    if (this.ws && this.ws.readyState === 1) {\n      // 1 = OPEN\n      this.ws.send(JSON.stringify(subscriptionMessage));\n      this.log(` Subscribed to ${processedFeeds.length} feeds`);\n    } else {\n      this.log(\n        ` Cannot send subscription - ws: ${!!this.ws}, readyState: ${this.ws?.readyState}`\n      );\n      throw new Error('WebSocket not ready for subscription');\n    }\n  }\n\n  /**\n   * Wait for WebSocket to be in OPEN state before sending messages\n   * @param timeoutMs Maximum time to wait in milliseconds\n   */\n  private async waitForWebSocketReady(timeoutMs: number = 5000): Promise<void> {\n    if (!this.ws) {\n      throw new Error('WebSocket not initialized');\n    }\n\n    if (this.ws.readyState === 1) {\n      // Already OPEN\n      return;\n    }\n\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(\n          new Error(\n            `WebSocket not ready within ${timeoutMs}ms. State: ${this.ws?.readyState}`\n          )\n        );\n      }, timeoutMs);\n\n      const checkReady = () => {\n        if (this.ws && this.ws.readyState === 1) {\n          clearTimeout(timeout);\n          resolve();\n        } else if (\n          this.ws &&\n          (this.ws.readyState === 2 || this.ws.readyState === 3)\n        ) {\n          // CLOSING or CLOSED\n          clearTimeout(timeout);\n          reject(\n            new Error(\n              `WebSocket is closing/closed. State: ${this.ws.readyState}`\n            )\n          );\n        } else {\n          // Still CONNECTING (0), check again in 50ms\n          setTimeout(checkReady, 50);\n        }\n      };\n\n      checkReady();\n    });\n  }\n\n  /**\n   * Validate that feeds exist and sources are available before attempting to subscribe\n   * @param feeds Array of feed subscriptions to validate\n   * @param retryCount Internal retry counter (defaults to 0)\n   * @throws Error if any feed is invalid with descriptive message after retries\n   */\n  async validateFeeds(\n    feeds: FeedSubscription[],\n    retryCount: number = 0\n  ): Promise<void> {\n    try {\n      const surgeFeedsData = await this.getSurgeFeeds();\n\n      this.log(\n        ` Validating feeds against ${surgeFeedsData.data.length} available symbols`\n      );\n\n      for (const feed of feeds) {\n        if ('symbol' in feed) {\n          // Parse the symbol (e.g., \"USDT/USD\" -> base: \"USDT\", quote: \"USD\")\n          const parts = feed.symbol.toUpperCase().split('/');\n          if (parts.length !== 2) {\n            throw new Error(\n              `Invalid symbol format: ${feed.symbol}. Expected format: BASE/QUOTE`\n            );\n          }\n\n          const [base, quote] = parts;\n\n          // Find matching symbol in the data\n          const symbolData = surgeFeedsData.data.find(\n            item => item.symbol.base === base && item.symbol.quote === quote\n          );\n\n          if (!symbolData) {\n            throw new Error(\n              `Symbol ${feed.symbol} not found in available feeds`\n            );\n          }\n\n          // If source is specified, check it exists\n          if (feed.source) {\n            const source = Source.toString(feed.source);\n            const sourceExists = symbolData.feeds.some(\n              f => f.source === source\n            );\n\n            if (!sourceExists) {\n              const availableSources = symbolData.feeds.map(f => f.source);\n              throw new Error(\n                `Source '${source}' not available for ${feed.symbol}. Available sources: ${availableSources.join(', ')}`\n              );\n            }\n          }\n\n          this.log(\n            ` Validated: ${feed.symbol} ${feed.source ? `(${Source.toString(feed.source)})` : ''}`\n          );\n        }\n      }\n    } catch (error) {\n      // Retry logic for validation failures (simulator might be starting up)\n      const maxRetries = 3;\n      const retryDelayMs = 5000; // 5 seconds\n\n      const shouldRetry =\n        retryCount < maxRetries &&\n        error instanceof Error &&\n        (error.message.includes('Unknown symbol') ||\n          error.message.includes('Failed to fetch surge feeds') ||\n          error.message.includes('ECONNREFUSED') ||\n          error.message.includes('Network Error'));\n\n      if (shouldRetry) {\n        this.log(\n          ` Validation failed (attempt ${retryCount + 1}/${maxRetries + 1}): ${error.message}`\n        );\n        this.log(` Retrying validation in ${retryDelayMs}ms...`);\n\n        await new Promise(resolve => setTimeout(resolve, retryDelayMs));\n        return this.validateFeeds(feeds, retryCount + 1);\n      }\n\n      // If we've exhausted retries or it's a different error, throw it\n      throw error;\n    }\n  }\n  /**\n   * Connect to gateway and subscribe to feeds in one operation with proper error handling\n   * This is the recommended method for most use cases as it validates feeds before any connection attempts\n   * @param feeds Array of feed subscriptions\n   * @throws Error if validation fails, connection fails, or subscription fails\n   */\n  async connectAndSubscribe(\n    feeds: FeedSubscription[],\n    batchIntervalMs?: number\n  ): Promise<void> {\n    try {\n      // Step 1: Validate feeds first (before any expensive operations)\n      await this.validateFeeds(feeds);\n\n      // Step 2: Connect if not already connected (pass feeds for oracle selection)\n      if (this.connectionState !== 'authenticated') {\n        await this.connect(feeds);\n      }\n\n      // Wait for authentication message to be processed (only in crossbar mode)\n      if (\n        this.config.crossbarMode &&\n        this.connectionState !== 'authenticated'\n      ) {\n        this.log(' Waiting for authentication confirmation...');\n\n        // Create authentication promise if it doesn't exist\n        if (!this.authenticationPromise) {\n          this.authenticationPromise = new Promise(resolve => {\n            this.authenticationResolve = resolve;\n          });\n        }\n\n        // Wait for authentication to complete with timeout\n        const authTimeout = new Promise((_, reject) => {\n          setTimeout(\n            () => reject(new Error('Authentication timeout after 10 seconds')),\n            10000\n          );\n        });\n\n        try {\n          await Promise.race([this.authenticationPromise, authTimeout]);\n          this.log(' Authentication confirmed, proceeding with subscription');\n        } catch (error) {\n          this.log(` Authentication failed: ${error}`);\n          throw error;\n        }\n      } else {\n        this.log(' Already authenticated, proceeding immediately');\n      }\n\n      // Step 3: Subscribe to the validated feeds (without re-validation)\n      await this.subscribeWithoutValidation(feeds, batchIntervalMs);\n    } catch (error) {\n      // Clean up connection on any failure\n      if (\n        this.connectionState === 'connecting' ||\n        this.connectionState === 'connected'\n      ) {\n        this.disconnect();\n      }\n\n      // Re-throw with context\n      throw new Error(\n        `Failed to connect and subscribe: ${error instanceof Error ? error.message : error}`\n      );\n    }\n  }\n  /**\n   * Subscribe to all available feeds with optional source filtering\n   */\n  async subscribeToAll(\n    sources_?: Source[],\n    batchIntervalMs?: number\n  ): Promise<void> {\n    if ((sources_ ?? []).length === 0) {\n      sources_ = [Source.WEIGHTED];\n    }\n    const sources = sources_?.map(s => Source.toString(s));\n\n    // Validate batchIntervalMs if provided\n    if (batchIntervalMs !== undefined) {\n      if (batchIntervalMs < 10 || batchIntervalMs > 5000) {\n        throw new Error(\n          'batchIntervalMs must be between 10 and 5000 milliseconds'\n        );\n      }\n    }\n\n    this.log(\n      ` subscribeToAll called - connectionState: ${this.connectionState}, batchIntervalMs: ${batchIntervalMs}`\n    );\n    if (this.connectionState !== 'authenticated') {\n      this.log(' Connection not authenticated, connecting...');\n      await this.connect();\n    }\n\n    this.log(\n      ` After connect - connectionState: ${this.connectionState}, ws.readyState: ${this.ws?.readyState}`\n    );\n\n    // Wait for authentication message to be processed (only in crossbar mode)\n    if (this.config.crossbarMode && this.connectionState !== 'authenticated') {\n      this.log(' Waiting for authentication confirmation...');\n\n      // Create authentication promise if it doesn't exist\n      if (!this.authenticationPromise) {\n        this.authenticationPromise = new Promise(resolve => {\n          this.authenticationResolve = resolve;\n        });\n      }\n\n      // Wait for authentication to complete with timeout\n      const authTimeout = new Promise((_, reject) => {\n        setTimeout(\n          () => reject(new Error('Authentication timeout after 10 seconds')),\n          10000\n        );\n      });\n\n      try {\n        await Promise.race([this.authenticationPromise, authTimeout]);\n        this.log(' Authentication confirmed, proceeding with subscription');\n      } catch (error) {\n        this.log(` Authentication failed: ${error}`);\n        throw error;\n      }\n    } else {\n      this.log(' Already authenticated, proceeding immediately');\n    }\n\n    const subscribeAllMessage = {\n      type: 'SubscribeAll',\n      sources: sources || undefined, // Only include if provided\n      batch_interval_ms: batchIntervalMs || undefined, // Only include if provided\n    };\n\n    this.log(\n      ` About to send subscription - ws: ${!!this.ws}, readyState: ${this.ws?.readyState}`\n    );\n\n    // Wait for WebSocket to be ready before sending subscription\n    await this.waitForWebSocketReady();\n\n    if (this.ws && this.ws.readyState === 1) {\n      // 1 = OPEN\n      this.log(\n        ` Sending subscription message: ${JSON.stringify(subscribeAllMessage)}`\n      );\n      this.ws.send(JSON.stringify(subscribeAllMessage));\n      if (sources) {\n        this.log(` Subscribed to prices from sources: ${sources.join(', ')}`);\n      } else {\n        this.log(' Subscribed to ALL available prices');\n      }\n    } else {\n      this.log(\n        ` Cannot send subscription - ws: ${!!this.ws}, readyState: ${this.ws?.readyState}`\n      );\n      throw new Error('WebSocket not ready for subscription');\n    }\n  }\n\n  /**\n   * Internal subscribe method that skips validation (assumes feeds are already validated)\n   */\n  private async subscribeWithoutValidation(\n    feeds: FeedSubscription[],\n    batchIntervalMs?: number\n  ): Promise<void> {\n    // Process feed subscriptions (assuming validation already passed)\n    const processedFeeds: ProcessedFeedData[] = [];\n\n    for (const feed of feeds) {\n      if ('feedHash' in feed) {\n        // For feedHash subscriptions, we need to reverse-lookup the symbol/source\n        const feedData = await this.resolveFeedHash(feed.feedHash);\n        processedFeeds.push(feedData);\n      } else {\n        processedFeeds.push({\n          symbol: feed.symbol,\n          source: feed.source || Source.WEIGHTED, // Default to weighted average\n        });\n      }\n    }\n\n    // Update local subscriptions map\n    for (const feed of processedFeeds) {\n      const source = Source.toString(feed.source);\n      const key = `${source}:${feed.symbol}`;\n      this.subscriptions.set(key, feed);\n    }\n\n    // Send subscription message (following bundle_verbose_test.ts format)\n    const subscriptionMessage: {\n      type: 'Subscribe';\n      feed_bundles: Array<{\n        feeds: Array<{\n          symbol: Pair;\n          source: string;\n        }>;\n      }>;\n      batch_interval_ms?: number;\n      signature_scheme?: 'Secp256k1' | 'Ed25519'; // Add signature scheme\n    } = {\n      type: 'Subscribe',\n      feed_bundles: [\n        {\n          feeds: processedFeeds.map(feed => ({\n            symbol: stringToPair(feed.symbol), // Convert string to Pair object\n            source: Source.toString(feed.source), // Convert enum to string\n          })),\n        },\n      ],\n      // Default to Ed25519 if not specified in config\n      signature_scheme:\n        this.config.signatureScheme === 'secp256k1' ? 'Secp256k1' : 'Ed25519',\n    };\n\n    // Add batch_interval_ms if provided\n    if (batchIntervalMs !== undefined) {\n      subscriptionMessage.batch_interval_ms = batchIntervalMs;\n    }\n\n    if (this.ws && this.ws.readyState === 1) {\n      // 1 = OPEN\n      this.ws.send(JSON.stringify(subscriptionMessage));\n      this.log(` Subscribed to ${processedFeeds.length} feeds`);\n    }\n  }\n  /**\n   * Resolve feedHash to symbol/source pair\n   */\n  private async resolveFeedHash(feedHash: string): Promise<ProcessedFeedData> {\n    // Get surge feeds data\n    const surgeFeedsData = await this.getSurgeFeeds();\n\n    // Search through all feeds to find matching hash\n    for (const symbolGroup of surgeFeedsData.data) {\n      for (const feed of symbolGroup.feeds) {\n        // Note: This is a simplified lookup - in production you'd want to\n        // generate the actual feed hash from the feed data and compare\n        if (feed.feed_id === feedHash) {\n          return {\n            feedHash,\n            symbol: pairToString(symbolGroup.symbol),\n            source: Source.fromString(feed.source),\n          };\n        }\n      }\n    }\n\n    throw new Error(`Feed hash ${feedHash} not found in available feeds`);\n  }\n\n  /**\n   * Get total number of feeds available\n   */\n  private async getTotalFeeds(endpoint: string): Promise<number> {\n    try {\n      const response = await axios.get(`${endpoint}?limit=1`);\n      return response.data.total || 0;\n    } catch {\n      return 0;\n    }\n  }\n\n  /**\n   * Check if a specific feed exists\n   * @param symbol The symbol to check (e.g., \"BTC/USD\")\n   * @param source Optional source to check (e.g., Source.WEIGHTED)\n   * @returns true if the feed exists\n   */\n  async checkFeedExists(\n    symbol: string,\n    source?: Source | string\n  ): Promise<boolean> {\n    try {\n      const feedInfo = await this.getFeedInfo(symbol);\n\n      if (!feedInfo) {\n        return false;\n      }\n\n      // If no source specified, just check symbol exists\n      if (!source) {\n        return true;\n      }\n\n      // Check if specific source exists\n      const sourceStr =\n        typeof source === 'string' ? source : Source.toString(source);\n      return feedInfo.feeds.some(f => f.source === sourceStr);\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get available feeds for a specific symbol\n   * @param symbol The symbol to query (e.g., \"BTC/USD\")\n   * @returns The feed data for this symbol, or null if not found\n   */\n  async getFeedInfo(symbol: string): Promise<SurgeSymbolGroup | null> {\n    try {\n      let endpoint: string;\n\n      if (this.config.crossbarMode) {\n        // Crossbar mode - use crossbar endpoint\n        const baseUrl = this.config.crossbarUrl || '';\n        endpoint = `${baseUrl}/stream/surge_feeds`;\n      } else {\n        // Normal mode - use the oracle that created our session\n        if (this.sessionData?.ws_url) {\n          // Convert ws:// or wss:// back to http:// or https://\n          let oracleUrl = this.sessionData.ws_url\n            .replace('ws://', 'http://')\n            .replace('wss://', 'https://')\n            .replace('/oracle/api/v1/surge_stream', ''); // Remove the WS path\n\n          // If gateway is localhost, use localhost:8081 for oracle\n          if (\n            this.config.gatewayUrl &&\n            (this.config.gatewayUrl.includes('localhost') ||\n              this.config.gatewayUrl.includes('127.0.0.1'))\n          ) {\n            oracleUrl = 'http://localhost:8081';\n          }\n\n          endpoint = `${oracleUrl}/oracle/api/v1/surge_feeds`;\n        } else {\n          // Fallback: if no session yet but gateway is localhost, use port 8081\n          const gatewayUrl =\n            this.config.gatewayUrl || this.gateway?.gatewayUrl || '';\n          if (\n            gatewayUrl.includes('localhost') ||\n            gatewayUrl.includes('127.0.0.1')\n          ) {\n            endpoint = 'http://localhost:8081/oracle/api/v1/surge_feeds';\n            this.log(\n              ' Using localhost oracle (no session yet): http://localhost:8081'\n            );\n          } else {\n            endpoint = `${gatewayUrl}/oracle/api/v1/surge_feeds`;\n          }\n        }\n      }\n\n      const response = await axios.get(\n        `${endpoint}?symbol=${symbol.toUpperCase()}`\n      );\n      const data = response.data as SurgeFeedsResponse;\n\n      if (!data.data || data.data.length === 0) {\n        return null;\n      }\n\n      return data.data[0];\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Get available surge feeds (always fresh)\n   * NOTE: Due to API limitations, this may not return all available feeds.\n   * Use checkFeedExists() or getFeedInfo() to check specific feeds.\n   */\n  private async getSurgeFeeds(): Promise<SurgeFeedsResponse> {\n    try {\n      let endpoint: string;\n\n      if (this.config.crossbarMode) {\n        // Crossbar mode - use crossbar endpoint\n        const baseUrl = this.config.crossbarUrl || '';\n        endpoint = `${baseUrl}/stream/surge_feeds`;\n        this.log(` Fetching surge feeds from crossbar: ${endpoint}`);\n      } else {\n        // Normal mode - use the oracle that created our session\n        if (this.sessionData?.ws_url) {\n          // Convert ws:// or wss:// back to http:// or https://\n          let oracleUrl = this.sessionData.ws_url\n            .replace('ws://', 'http://')\n            .replace('wss://', 'https://')\n            .replace('/oracle/api/v1/surge_stream', ''); // Remove the WS path\n\n          // If gateway is localhost, use localhost:8081 for oracle\n          if (\n            this.config.gatewayUrl &&\n            (this.config.gatewayUrl.includes('localhost') ||\n              this.config.gatewayUrl.includes('127.0.0.1'))\n          ) {\n            oracleUrl = 'http://localhost:8081';\n            this.log(' Using localhost oracle for surge feeds: ' + oracleUrl);\n          }\n\n          endpoint = `${oracleUrl}/oracle/api/v1/surge_feeds`; // Use session endpoint\n        } else {\n          // Fallback: if no session yet but gateway is localhost, use port 8081\n          const gatewayUrl =\n            this.config.gatewayUrl || this.gateway?.gatewayUrl || '';\n          if (\n            gatewayUrl.includes('localhost') ||\n            gatewayUrl.includes('127.0.0.1')\n          ) {\n            endpoint = 'http://localhost:8081/oracle/api/v1/surge_feeds';\n            this.log(\n              ' Using localhost oracle (no session yet): http://localhost:8081'\n            );\n          } else {\n            endpoint = `${gatewayUrl}/oracle/api/v1/surge_feeds`;\n          }\n        }\n      }\n\n      // Fetch surge feeds\n      this.log(` Fetching surge feeds from: ${endpoint}`);\n\n      const response = await axios.get(endpoint, {\n        maxContentLength: 100 * 1024 * 1024, // 100MB\n        maxBodyLength: 100 * 1024 * 1024, // 100MB\n        timeout: 30000, // 30 seconds\n      });\n\n      const responseData = response.data as SurgeFeedsResponse;\n\n      // Count total feeds\n      const totalFeeds =\n        responseData.data?.reduce(\n          (count, symbol) => count + symbol.feeds.length,\n          0\n        ) || 0;\n\n      this.log(\n        ` Got all ${responseData.data?.length || 0} symbols with ${totalFeeds} feeds (total field shows ${responseData.total} feeds)`\n      );\n\n      return responseData;\n    } catch (error) {\n      throw new Error(`Failed to fetch surge feeds: ${error}`);\n    }\n  }\n\n  /**\n   * Unsubscribe from feeds\n   */\n  async unsubscribe(feeds: FeedSubscription[]): Promise<void> {\n    // Collect bundle IDs for oracle mode\n    const bundleIds = new Set<string>();\n\n    // Remove from local subscriptions\n    for (const feed of feeds) {\n      if ('feedHash' in feed) {\n        // Find and remove by feedHash\n        for (const [key, subFeed] of this.subscriptions.entries()) {\n          if (subFeed.feedHash === feed.feedHash) {\n            this.subscriptions.delete(key);\n            break;\n          }\n        }\n      } else {\n        const source = Source.toString(feed.source || Source.WEIGHTED);\n        const key = `${source}:${feed.symbol}`;\n        this.subscriptions.delete(key);\n\n        // In oracle mode, collect the bundle ID for this feed\n        if (!this.config.crossbarMode) {\n          const bundleId = this.feedToBundleId.get(key);\n          if (bundleId) {\n            bundleIds.add(bundleId);\n          }\n        }\n      }\n    }\n\n    // Create appropriate unsubscribe message based on mode\n    let unsubscribeMessage:\n      | {\n          type: string;\n          feed_bundle_ids?: string[];\n          feed_bundles?: Array<{\n            feeds: Array<{ symbol: Pair; source: string }>;\n          }>;\n        }\n      | undefined;\n\n    if (this.config.crossbarMode) {\n      // Crossbar mode: use feed_bundles\n      const symbolFeeds = feeds.filter(feed => !('feedHash' in feed));\n\n      if (symbolFeeds.length > 0) {\n        const feedBundles = [\n          {\n            feeds: symbolFeeds.map(feed => ({\n              symbol: stringToPair((feed as SymbolSubscription).symbol),\n              source: Source.toString(\n                (feed as SymbolSubscription).source || Source.WEIGHTED\n              ),\n            })),\n          },\n        ];\n\n        unsubscribeMessage = {\n          type: 'Unsubscribe',\n          feed_bundles: feedBundles,\n        };\n      }\n    } else {\n      // Oracle mode: use feed_bundle_ids\n      if (bundleIds.size > 0) {\n        unsubscribeMessage = {\n          type: 'Unsubscribe',\n          feed_bundle_ids: Array.from(bundleIds),\n        };\n      }\n    }\n\n    // Only send if we have something to unsubscribe\n    if (unsubscribeMessage && this.ws && this.ws.readyState === 1) {\n      this.ws.send(JSON.stringify(unsubscribeMessage));\n\n      // Clean up bundle ID tracking for oracle mode\n      if (!this.config.crossbarMode) {\n        for (const bundleId of bundleIds) {\n          this.bundleIdToFeeds.delete(bundleId);\n        }\n        for (const feed of feeds) {\n          if (!('feedHash' in feed)) {\n            const source = Source.toString(feed.source || Source.WEIGHTED);\n            const key = `${source}:${feed.symbol}`;\n            this.feedToBundleId.delete(key);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Disconnect from the gateway\n   */\n  disconnect(): void {\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n\n    // Disable auto-reconnect when explicitly disconnecting\n    const originalAutoReconnect = this.config.autoReconnect;\n    this.config.autoReconnect = false;\n\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n\n    this.connectionState = 'disconnected';\n    this.sessionToken = null;\n    this.sessionData = null;\n    this.subscriptions.clear();\n    this.bundleIdToFeeds.clear();\n    this.feedToBundleId.clear();\n\n    // Clear authentication promise to prevent hanging promises\n    this.authenticationPromise = null;\n    this.authenticationResolve = null;\n\n    // Restore auto-reconnect setting for future connections\n    this.config.autoReconnect = originalAutoReconnect;\n  }\n\n  /**\n   * Schedule automatic reconnection\n   */\n  private scheduleReconnection(): void {\n    const timestamp = Date.now();\n    const timeStr = new Date(timestamp).toISOString();\n\n    this.log(` [${timeStr}] scheduleReconnection()\n  called`);\n\n    // Check if already connected or connecting\n    if (\n      this.connectionState === 'authenticated' ||\n      this.connectionState === 'connected' ||\n      this.connectionState === 'connecting'\n    ) {\n      this.log(\n        ` [${timeStr}] Already ${this.connectionState}, skipping reconnection`\n      );\n      return;\n    }\n\n    if (this.reconnectAttempts >= (this.config.maxReconnectAttempts || 5)) {\n      this.emit('error', {\n        type: 'connection',\n        message: 'Maximum reconnection attempts exceeded',\n        retryable: false,\n      } as StreamingError);\n      return;\n    }\n    // Prevent multiple simultaneous reconnection attempts\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.log(\n        ` [${timeStr}] Clearing existing reconnection timer to prevent duplicate attempts`\n      );\n      return;\n    }\n\n    // Calculate delay: first attempt at 300ms, then exponential backoff\n    const baseDelay = this.config.reconnectDelay || 1000;\n    let delay: number;\n\n    if (this.reconnectAttempts === 0) {\n      // First reconnection attempt - try quickly at 300ms\n      delay = 300;\n    } else {\n      // Subsequent attempts - exponential backoff starting from base delay\n      const exponentialDelay =\n        baseDelay * Math.pow(2, this.reconnectAttempts - 1);\n      delay = Math.min(exponentialDelay, 60000); // Max 60s\n    }\n\n    this.reconnectAttempts++;\n    this.log(` [${timeStr}] Scheduling reconnection\n  attempt #${this.reconnectAttempts} with ${delay}ms\n  delay`);\n    this.reconnectTimer = setTimeout(async () => {\n      const reconnectStartTime = Date.now();\n      const reconnectTimeStr = new Date(reconnectStartTime).toISOString();\n      this.log(` [${reconnectTimeStr}] Starting actual\n  reconnection attempt #${this.reconnectAttempts}`);\n\n      // Final check before reconnecting\n      if (\n        this.connectionState === 'authenticated' ||\n        this.connectionState === 'connected'\n      ) {\n        this.log(\n          ` [${reconnectTimeStr}] Already ${this.connectionState} when timer fired, aborting reconnection`\n        );\n        this.reconnectTimer = null;\n        return;\n      }\n\n      try {\n        // Defensive cleanup: ensure any existing connection is closed\n        if (this.ws) {\n          this.log(\n            ` [${reconnectTimeStr}] Closing existing websocket before reconnection`\n          );\n          try {\n            this.ws.close(1000, 'Reconnecting');\n          } catch (e) {\n            this.log(\n              ` [${reconnectTimeStr}] Error closing existing websocket: ${e}`\n            );\n          }\n          this.ws = null;\n        }\n\n        // Clear old session token and authentication state to force fresh session\n        this.sessionToken = null;\n        this.authenticationPromise = null;\n        this.authenticationResolve = null;\n\n        this.log(` [${reconnectTimeStr}] Reconnecting\n  with fresh session token...`);\n        // ... rest of reconnection logic\n        await this.connect();\n        // Extract batchIntervalMs from the first subscription (they should all be the same)\n        const firstFeed = Array.from(this.subscriptions.values())[0];\n        const batchIntervalMs = firstFeed.batchIntervalMs;\n        // Re-subscribe to existing feeds\n        if (this.subscriptions.size > 0) {\n          const feeds = Array.from(this.subscriptions.values()).map(feed =>\n            feed.feedHash\n              ? { feedHash: feed.feedHash }\n              : { symbol: feed.symbol, source: feed.source }\n          );\n\n          this.log(\n            ` [${reconnectTimeStr}] Validating ${feeds.length} feeds before re-subscription...`\n          );\n          try {\n            // Validate feeds are still available before re-subscribing\n            await this.validateFeeds(feeds);\n            this.log(\n              ` [${reconnectTimeStr}] All feeds validated, proceeding with subscription`\n            );\n            await this.subscribe(feeds, batchIntervalMs);\n          } catch (validationError) {\n            this.log(\n              ` [${reconnectTimeStr}] Feed validation failed during reconnection: ${validationError}`\n            );\n            // Continue with valid feeds only, or emit error if all feeds are invalid\n            this.emit('error', {\n              type: 'subscription',\n              message: `Feed validation failed during reconnection: ${validationError}`,\n              retryable: true,\n            } as StreamingError);\n            // Still try to reconnect without feeds for now\n          }\n        }\n        // Clear reconnect timer on successful reconnection\n        this.reconnectTimer = null;\n      } catch {\n        // Clear timer before scheduling new reconnection\n        this.reconnectTimer = null;\n        this.scheduleReconnection();\n      }\n    }, delay);\n  }\n\n  /**\n   * Get current connection state\n   */\n  getConnectionState(): ConnectionState {\n    return this.connectionState;\n  }\n\n  /**\n   * Get list of active subscriptions\n   */\n  getSubscriptions(): FeedSubscription[] {\n    return Array.from(this.subscriptions.values()).map(feed =>\n      feed.feedHash\n        ? { feedHash: feed.feedHash }\n        : { symbol: feed.symbol, source: feed.source }\n    );\n  }\n\n  /**\n   * Check if a specific feed is subscribed\n   */\n  isSubscribed(feed: FeedSubscription): boolean {\n    if ('feedHash' in feed) {\n      return Array.from(this.subscriptions.values()).some(\n        f => f.feedHash === feed.feedHash\n      );\n    } else {\n      const source = Source.toString(feed.source);\n      const key = `${source}:${feed.symbol}`;\n      return this.subscriptions.has(key);\n    }\n  }\n}\n"]}
{"version":3,"file":"Ed25519InstructionUtils.js","sourceRoot":"","sources":["../../../src/instruction-utils/Ed25519InstructionUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { web3 } from '@coral-xyz/anchor-31';\nimport { NonEmptyArrayUtils } from '@switchboard-xyz/common';\n\n// The serialized size of an ED25519 signature\nconst ED25519_SIGNATURE_SERIALIZED_SIZE = 64;\n// The serialized size of an ED25519 pubkey\nconst ED25519_PUBKEY_SERIALIZED_SIZE = 32;\n// The serialized size of the signature offsets\nconst ED25519_SIGNATURE_OFFSETS_SERIALIZED_SIZE = 14;\n\n// Message format constants\nconst OFFSET_FIELD_SIZE = 2; // Each offset field is 2 bytes (LE)\nconst SLOT_SIZE = 8; // Recent slot is 8 bytes (u64 LE)\nconst VERSION_SIZE = 1; // Version is 1 byte (u8)\nconst ORACLE_INDEX_SIZE = 1; // Each oracle index is 1 byte\nconst PADDING_SIZE = 1; // Single padding byte in instruction format\n\nexport type Ed25519Signature = {\n  pubkey: Buffer; // 32-byte ED25519 public key\n  signature: Buffer; // 64-byte ED25519 signature\n  message: Buffer; // Variable length message (no 32-byte constraint!)\n  oracleIdx: number; // Index of the oracle in the queue\n};\n\nexport class Ed25519InstructionUtils {\n  /**\n   *  Disable instantiation of the InstructionUtils class\n   */\n  private constructor() {}\n\n  /**\n   * Build ED25519 instruction for variable length messages\n   * Unlike secp256k1, ED25519 can sign messages of any length safely\n   */\n  static buildEd25519Instruction(\n    signatures: Ed25519Signature[],\n    instructionIndex: number,\n    recentSlot?: number,\n    version?: number\n  ): web3.TransactionInstruction {\n    // Add null/undefined check before array validation\n    if (!signatures || !Array.isArray(signatures)) {\n      throw new Error('Invalid `signatures` parameter: must be an array');\n    }\n\n    // Ensure that the `instructionIndex` is both a valid finite number and non-negative\n    if (!Number.isFinite(instructionIndex) || instructionIndex < 0) {\n      throw new Error('Invalid instruction index');\n    } else if (!NonEmptyArrayUtils.safeValidate(signatures)) {\n      // Ensure that the `signatures` array is non-empty and that all signatures share the same\n      // common message\n      throw new Error(\n        'Invalid `signatures` array: cannot be empty. All oracles failed to provide valid signatures.'\n      );\n    }\n\n    // Validate that all signatures have oracleIdx - required for queue order matching\n    for (let i = 0; i < signatures.length; i++) {\n      if (typeof signatures[i].oracleIdx !== 'number') {\n        throw new Error(\n          `Signature at index ${i} missing oracleIdx field - required for queue ordering`\n        );\n      }\n    }\n\n    // Sort signatures by oracleIdx to match queue order - CRITICAL for verification\n    // The Rust verification code expects signatures in the same order as oracle_keys\n    const sortedSignatures = [...signatures].sort(\n      (a, b) => a.oracleIdx - b.oracleIdx\n    );\n\n    // For ED25519, messages can be different lengths, but we still want to validate\n    // that all signatures are signing the same logical message content\n    // const diffIdx = sortedSignatures.findIndex(\n    // sig => !sig.message.equals(sortedSignatures[0].message)\n    // );\n    // if (diffIdx !== -1) {\n    // const expectedMessage = sortedSignatures[0].message.toString('base64');\n    // const differentMessage =\n    // sortedSignatures[diffIdx].message.toString('base64');\n    // throw new Error(`\n    // All signatures must share the same message. The signed message at #${diffIdx}\n    // (${differentMessage}) does not match the expected message (${expectedMessage})\n    // `);\n    // }\n\n    // We've validated that all signatures share the same message\n    const commonMessage = sortedSignatures[0].message;\n    const commonMessageSize = commonMessage.length;\n\n    // Solana Ed25519 instruction format constants (from working test_correct_format.js)\n    const SIGNATURE_OFFSETS_START = OFFSET_FIELD_SIZE; // Includes padding byte!\n    const DATA_START =\n      ED25519_SIGNATURE_OFFSETS_SERIALIZED_SIZE + SIGNATURE_OFFSETS_START; // 14 + 2 = 16\n\n    const numSignatures = sortedSignatures.length;\n\n    // Correct Solana offsets calculation (from working test_correct_format.js)\n    const signatureOffset = DATA_START; // 16\n    const pubkeyOffset = signatureOffset + ED25519_SIGNATURE_SERIALIZED_SIZE; // 16 + 64 = 80\n    const messageOffset = pubkeyOffset + ED25519_PUBKEY_SERIALIZED_SIZE; // 80 + 32 = 112\n\n    const signatureOffsets: Uint8Array[] = [];\n    const signatureBuffer: number[] = [];\n\n    for (let i = 0; i < sortedSignatures.length; i++) {\n      const sig = sortedSignatures[i];\n\n      // Create a new Uint8Array to store the signature offsets\n      const offsetsBytes = new Uint8Array(\n        ED25519_SIGNATURE_OFFSETS_SERIALIZED_SIZE\n      );\n      let position = 0;\n\n      // Calculate offsets for this signature (for multiple signatures, adjust accordingly)\n      const currentSignatureOffset =\n        signatureOffset + i * ED25519_SIGNATURE_SERIALIZED_SIZE;\n      const currentPubkeyOffset =\n        pubkeyOffset + i * ED25519_PUBKEY_SERIALIZED_SIZE;\n\n      // Write signature offset (2 bytes LE)\n      offsetsBytes.set(writeUInt16LE(currentSignatureOffset), position);\n      position += OFFSET_FIELD_SIZE;\n\n      // Write signature instruction index (2 bytes LE) - changed from 1 byte to 2 bytes!\n      offsetsBytes.set(writeUInt16LE(instructionIndex), position);\n      position += OFFSET_FIELD_SIZE;\n\n      // Write pubkey offset (2 bytes LE)\n      offsetsBytes.set(writeUInt16LE(currentPubkeyOffset), position);\n      position += OFFSET_FIELD_SIZE;\n\n      // Write pubkey instruction index (2 bytes LE) - changed from 1 byte to 2 bytes!\n      offsetsBytes.set(writeUInt16LE(instructionIndex), position);\n      position += OFFSET_FIELD_SIZE;\n\n      // Write message offset (2 bytes LE)\n      offsetsBytes.set(writeUInt16LE(messageOffset), position);\n      position += OFFSET_FIELD_SIZE;\n\n      // Write message size (2 bytes LE)\n      offsetsBytes.set(writeUInt16LE(commonMessageSize), position);\n      position += OFFSET_FIELD_SIZE;\n\n      // Write message instruction index (2 bytes LE) - changed from 1 byte to 2 bytes!\n      offsetsBytes.set(writeUInt16LE(instructionIndex), position);\n\n      // Append the signature offsets to the list of signature offsets\n      signatureOffsets.push(offsetsBytes);\n\n      // Append the signature and pubkey to the buffer\n      signatureBuffer.push(...Array.from(sig.signature));\n      signatureBuffer.push(...Array.from(sig.pubkey));\n    }\n\n    // Build final instruction data with correct Solana format\n    // Add space for appended slot (8 bytes) and version (1 byte) if provided\n    const appendedSize =\n      recentSlot !== undefined && version !== undefined\n        ? SLOT_SIZE + VERSION_SIZE\n        : 0;\n    const totalSize =\n      messageOffset + commonMessage.length + numSignatures + appendedSize;\n    const instrData = new Uint8Array(totalSize + 4);\n    let position = 0;\n\n    // 1. Write count byte\n    instrData[position] = numSignatures;\n    position += ORACLE_INDEX_SIZE;\n\n    // 2. Write padding byte (SIGNATURE_OFFSETS_START - 1 = 1 byte)\n    instrData[position] = 0;\n    position += PADDING_SIZE;\n\n    // 3. Write offsets area\n    for (const offs of signatureOffsets) {\n      instrData.set(offs, position);\n      position += ED25519_SIGNATURE_OFFSETS_SERIALIZED_SIZE;\n    }\n\n    // 4. Write signature blocks at correct offsets\n    for (let i = 0; i < sortedSignatures.length; i++) {\n      const sig = sortedSignatures[i];\n      const currentSignatureOffset =\n        signatureOffset + i * ED25519_SIGNATURE_SERIALIZED_SIZE;\n      const currentPubkeyOffset =\n        pubkeyOffset + i * ED25519_PUBKEY_SERIALIZED_SIZE;\n\n      instrData.set(sig.signature, currentSignatureOffset);\n      instrData.set(sig.pubkey, currentPubkeyOffset);\n    }\n\n    // 5. Write common message at message offset\n    instrData.set(commonMessage, messageOffset);\n\n    // 6. append a list of bytes for all oracle indexes\n    const oracleIndexes = new Uint8Array(numSignatures);\n    for (let i = 0; i < numSignatures; i++) {\n      oracleIndexes[i] = sortedSignatures[i].oracleIdx;\n    }\n    instrData.set(oracleIndexes, messageOffset + commonMessage.length);\n\n    // 7. Append recent_slot and version (NEW FORMAT)\n    if (recentSlot !== undefined && version !== undefined) {\n      const slotOffset = messageOffset + commonMessage.length + numSignatures; // After oracle indexes\n      const versionOffset = slotOffset + SLOT_SIZE;\n\n      // Write recent_slot as little-endian u64 (8 bytes)\n      const slotBuffer = Buffer.alloc(SLOT_SIZE);\n      slotBuffer.writeBigUInt64LE(BigInt(recentSlot), 0);\n      instrData.set(slotBuffer, slotOffset);\n\n      // Write version as u8 (1 byte)\n      instrData[versionOffset] = version;\n\n      const discriminatorOffset = versionOffset + 1;\n      const discriminator = Buffer.from('SBOD');\n      instrData.set(discriminator, discriminatorOffset);\n    }\n\n    return new web3.TransactionInstruction({\n      programId: web3.Ed25519Program.programId,\n      data: Buffer.from(instrData),\n      keys: [],\n    });\n  }\n}\n\nfunction writeUInt16LE(value: number): Uint8Array {\n  const arr = new Uint8Array(OFFSET_FIELD_SIZE);\n  arr[0] = value & 0xff;\n  arr[1] = (value >> 8) & 0xff;\n  return arr;\n}\n"]}
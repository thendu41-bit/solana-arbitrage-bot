"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.BSOL = exports.LaineSOL = exports.SAMO = exports.BONK = exports.RAY = exports.JITOSOL = exports.UXP = exports.RATIO = exports.USDR = exports.DUST = exports.HDG = exports.UXD = exports.SCNSOL = exports.LDO = exports.DAI = exports.USH = exports.JSOL = exports.HBB = exports.MNDE = exports.ORCA = exports.USDT = exports.STSOL = exports.MSOL = exports.BTC = exports.ETH = exports.SOL = exports.USDH = exports.USDC = void 0;
exports.fromDecoded = fromDecoded;
exports.fromJSON = fromJSON;
exports.layout = layout;
const borsh = __importStar(require("@coral-xyz/borsh"));
class USDC {
    static discriminator = 0;
    static kind = "USDC";
    discriminator = 0;
    kind = "USDC";
    toJSON() {
        return {
            kind: "USDC",
        };
    }
    toEncodable() {
        return {
            USDC: {},
        };
    }
}
exports.USDC = USDC;
class USDH {
    static discriminator = 1;
    static kind = "USDH";
    discriminator = 1;
    kind = "USDH";
    toJSON() {
        return {
            kind: "USDH",
        };
    }
    toEncodable() {
        return {
            USDH: {},
        };
    }
}
exports.USDH = USDH;
class SOL {
    static discriminator = 2;
    static kind = "SOL";
    discriminator = 2;
    kind = "SOL";
    toJSON() {
        return {
            kind: "SOL",
        };
    }
    toEncodable() {
        return {
            SOL: {},
        };
    }
}
exports.SOL = SOL;
class ETH {
    static discriminator = 3;
    static kind = "ETH";
    discriminator = 3;
    kind = "ETH";
    toJSON() {
        return {
            kind: "ETH",
        };
    }
    toEncodable() {
        return {
            ETH: {},
        };
    }
}
exports.ETH = ETH;
class BTC {
    static discriminator = 4;
    static kind = "BTC";
    discriminator = 4;
    kind = "BTC";
    toJSON() {
        return {
            kind: "BTC",
        };
    }
    toEncodable() {
        return {
            BTC: {},
        };
    }
}
exports.BTC = BTC;
class MSOL {
    static discriminator = 5;
    static kind = "MSOL";
    discriminator = 5;
    kind = "MSOL";
    toJSON() {
        return {
            kind: "MSOL",
        };
    }
    toEncodable() {
        return {
            MSOL: {},
        };
    }
}
exports.MSOL = MSOL;
class STSOL {
    static discriminator = 6;
    static kind = "STSOL";
    discriminator = 6;
    kind = "STSOL";
    toJSON() {
        return {
            kind: "STSOL",
        };
    }
    toEncodable() {
        return {
            STSOL: {},
        };
    }
}
exports.STSOL = STSOL;
class USDT {
    static discriminator = 7;
    static kind = "USDT";
    discriminator = 7;
    kind = "USDT";
    toJSON() {
        return {
            kind: "USDT",
        };
    }
    toEncodable() {
        return {
            USDT: {},
        };
    }
}
exports.USDT = USDT;
class ORCA {
    static discriminator = 8;
    static kind = "ORCA";
    discriminator = 8;
    kind = "ORCA";
    toJSON() {
        return {
            kind: "ORCA",
        };
    }
    toEncodable() {
        return {
            ORCA: {},
        };
    }
}
exports.ORCA = ORCA;
class MNDE {
    static discriminator = 9;
    static kind = "MNDE";
    discriminator = 9;
    kind = "MNDE";
    toJSON() {
        return {
            kind: "MNDE",
        };
    }
    toEncodable() {
        return {
            MNDE: {},
        };
    }
}
exports.MNDE = MNDE;
class HBB {
    static discriminator = 10;
    static kind = "HBB";
    discriminator = 10;
    kind = "HBB";
    toJSON() {
        return {
            kind: "HBB",
        };
    }
    toEncodable() {
        return {
            HBB: {},
        };
    }
}
exports.HBB = HBB;
class JSOL {
    static discriminator = 11;
    static kind = "JSOL";
    discriminator = 11;
    kind = "JSOL";
    toJSON() {
        return {
            kind: "JSOL",
        };
    }
    toEncodable() {
        return {
            JSOL: {},
        };
    }
}
exports.JSOL = JSOL;
class USH {
    static discriminator = 12;
    static kind = "USH";
    discriminator = 12;
    kind = "USH";
    toJSON() {
        return {
            kind: "USH",
        };
    }
    toEncodable() {
        return {
            USH: {},
        };
    }
}
exports.USH = USH;
class DAI {
    static discriminator = 13;
    static kind = "DAI";
    discriminator = 13;
    kind = "DAI";
    toJSON() {
        return {
            kind: "DAI",
        };
    }
    toEncodable() {
        return {
            DAI: {},
        };
    }
}
exports.DAI = DAI;
class LDO {
    static discriminator = 14;
    static kind = "LDO";
    discriminator = 14;
    kind = "LDO";
    toJSON() {
        return {
            kind: "LDO",
        };
    }
    toEncodable() {
        return {
            LDO: {},
        };
    }
}
exports.LDO = LDO;
class SCNSOL {
    static discriminator = 15;
    static kind = "SCNSOL";
    discriminator = 15;
    kind = "SCNSOL";
    toJSON() {
        return {
            kind: "SCNSOL",
        };
    }
    toEncodable() {
        return {
            SCNSOL: {},
        };
    }
}
exports.SCNSOL = SCNSOL;
class UXD {
    static discriminator = 16;
    static kind = "UXD";
    discriminator = 16;
    kind = "UXD";
    toJSON() {
        return {
            kind: "UXD",
        };
    }
    toEncodable() {
        return {
            UXD: {},
        };
    }
}
exports.UXD = UXD;
class HDG {
    static discriminator = 17;
    static kind = "HDG";
    discriminator = 17;
    kind = "HDG";
    toJSON() {
        return {
            kind: "HDG",
        };
    }
    toEncodable() {
        return {
            HDG: {},
        };
    }
}
exports.HDG = HDG;
class DUST {
    static discriminator = 18;
    static kind = "DUST";
    discriminator = 18;
    kind = "DUST";
    toJSON() {
        return {
            kind: "DUST",
        };
    }
    toEncodable() {
        return {
            DUST: {},
        };
    }
}
exports.DUST = DUST;
class USDR {
    static discriminator = 19;
    static kind = "USDR";
    discriminator = 19;
    kind = "USDR";
    toJSON() {
        return {
            kind: "USDR",
        };
    }
    toEncodable() {
        return {
            USDR: {},
        };
    }
}
exports.USDR = USDR;
class RATIO {
    static discriminator = 20;
    static kind = "RATIO";
    discriminator = 20;
    kind = "RATIO";
    toJSON() {
        return {
            kind: "RATIO",
        };
    }
    toEncodable() {
        return {
            RATIO: {},
        };
    }
}
exports.RATIO = RATIO;
class UXP {
    static discriminator = 21;
    static kind = "UXP";
    discriminator = 21;
    kind = "UXP";
    toJSON() {
        return {
            kind: "UXP",
        };
    }
    toEncodable() {
        return {
            UXP: {},
        };
    }
}
exports.UXP = UXP;
class JITOSOL {
    static discriminator = 22;
    static kind = "JITOSOL";
    discriminator = 22;
    kind = "JITOSOL";
    toJSON() {
        return {
            kind: "JITOSOL",
        };
    }
    toEncodable() {
        return {
            JITOSOL: {},
        };
    }
}
exports.JITOSOL = JITOSOL;
class RAY {
    static discriminator = 23;
    static kind = "RAY";
    discriminator = 23;
    kind = "RAY";
    toJSON() {
        return {
            kind: "RAY",
        };
    }
    toEncodable() {
        return {
            RAY: {},
        };
    }
}
exports.RAY = RAY;
class BONK {
    static discriminator = 24;
    static kind = "BONK";
    discriminator = 24;
    kind = "BONK";
    toJSON() {
        return {
            kind: "BONK",
        };
    }
    toEncodable() {
        return {
            BONK: {},
        };
    }
}
exports.BONK = BONK;
class SAMO {
    static discriminator = 25;
    static kind = "SAMO";
    discriminator = 25;
    kind = "SAMO";
    toJSON() {
        return {
            kind: "SAMO",
        };
    }
    toEncodable() {
        return {
            SAMO: {},
        };
    }
}
exports.SAMO = SAMO;
class LaineSOL {
    static discriminator = 26;
    static kind = "LaineSOL";
    discriminator = 26;
    kind = "LaineSOL";
    toJSON() {
        return {
            kind: "LaineSOL",
        };
    }
    toEncodable() {
        return {
            LaineSOL: {},
        };
    }
}
exports.LaineSOL = LaineSOL;
class BSOL {
    static discriminator = 27;
    static kind = "BSOL";
    discriminator = 27;
    kind = "BSOL";
    toJSON() {
        return {
            kind: "BSOL",
        };
    }
    toEncodable() {
        return {
            BSOL: {},
        };
    }
}
exports.BSOL = BSOL;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function fromDecoded(obj) {
    if (typeof obj !== "object") {
        throw new Error("Invalid enum object");
    }
    if ("USDC" in obj) {
        return new USDC();
    }
    if ("USDH" in obj) {
        return new USDH();
    }
    if ("SOL" in obj) {
        return new SOL();
    }
    if ("ETH" in obj) {
        return new ETH();
    }
    if ("BTC" in obj) {
        return new BTC();
    }
    if ("MSOL" in obj) {
        return new MSOL();
    }
    if ("STSOL" in obj) {
        return new STSOL();
    }
    if ("USDT" in obj) {
        return new USDT();
    }
    if ("ORCA" in obj) {
        return new ORCA();
    }
    if ("MNDE" in obj) {
        return new MNDE();
    }
    if ("HBB" in obj) {
        return new HBB();
    }
    if ("JSOL" in obj) {
        return new JSOL();
    }
    if ("USH" in obj) {
        return new USH();
    }
    if ("DAI" in obj) {
        return new DAI();
    }
    if ("LDO" in obj) {
        return new LDO();
    }
    if ("SCNSOL" in obj) {
        return new SCNSOL();
    }
    if ("UXD" in obj) {
        return new UXD();
    }
    if ("HDG" in obj) {
        return new HDG();
    }
    if ("DUST" in obj) {
        return new DUST();
    }
    if ("USDR" in obj) {
        return new USDR();
    }
    if ("RATIO" in obj) {
        return new RATIO();
    }
    if ("UXP" in obj) {
        return new UXP();
    }
    if ("JITOSOL" in obj) {
        return new JITOSOL();
    }
    if ("RAY" in obj) {
        return new RAY();
    }
    if ("BONK" in obj) {
        return new BONK();
    }
    if ("SAMO" in obj) {
        return new SAMO();
    }
    if ("LaineSOL" in obj) {
        return new LaineSOL();
    }
    if ("BSOL" in obj) {
        return new BSOL();
    }
    throw new Error("Invalid enum object");
}
function fromJSON(obj) {
    switch (obj.kind) {
        case "USDC": {
            return new USDC();
        }
        case "USDH": {
            return new USDH();
        }
        case "SOL": {
            return new SOL();
        }
        case "ETH": {
            return new ETH();
        }
        case "BTC": {
            return new BTC();
        }
        case "MSOL": {
            return new MSOL();
        }
        case "STSOL": {
            return new STSOL();
        }
        case "USDT": {
            return new USDT();
        }
        case "ORCA": {
            return new ORCA();
        }
        case "MNDE": {
            return new MNDE();
        }
        case "HBB": {
            return new HBB();
        }
        case "JSOL": {
            return new JSOL();
        }
        case "USH": {
            return new USH();
        }
        case "DAI": {
            return new DAI();
        }
        case "LDO": {
            return new LDO();
        }
        case "SCNSOL": {
            return new SCNSOL();
        }
        case "UXD": {
            return new UXD();
        }
        case "HDG": {
            return new HDG();
        }
        case "DUST": {
            return new DUST();
        }
        case "USDR": {
            return new USDR();
        }
        case "RATIO": {
            return new RATIO();
        }
        case "UXP": {
            return new UXP();
        }
        case "JITOSOL": {
            return new JITOSOL();
        }
        case "RAY": {
            return new RAY();
        }
        case "BONK": {
            return new BONK();
        }
        case "SAMO": {
            return new SAMO();
        }
        case "LaineSOL": {
            return new LaineSOL();
        }
        case "BSOL": {
            return new BSOL();
        }
    }
}
function layout(property) {
    const ret = borsh.rustEnum([
        borsh.struct([], "USDC"),
        borsh.struct([], "USDH"),
        borsh.struct([], "SOL"),
        borsh.struct([], "ETH"),
        borsh.struct([], "BTC"),
        borsh.struct([], "MSOL"),
        borsh.struct([], "STSOL"),
        borsh.struct([], "USDT"),
        borsh.struct([], "ORCA"),
        borsh.struct([], "MNDE"),
        borsh.struct([], "HBB"),
        borsh.struct([], "JSOL"),
        borsh.struct([], "USH"),
        borsh.struct([], "DAI"),
        borsh.struct([], "LDO"),
        borsh.struct([], "SCNSOL"),
        borsh.struct([], "UXD"),
        borsh.struct([], "HDG"),
        borsh.struct([], "DUST"),
        borsh.struct([], "USDR"),
        borsh.struct([], "RATIO"),
        borsh.struct([], "UXP"),
        borsh.struct([], "JITOSOL"),
        borsh.struct([], "RAY"),
        borsh.struct([], "BONK"),
        borsh.struct([], "SAMO"),
        borsh.struct([], "LaineSOL"),
        borsh.struct([], "BSOL"),
    ]);
    if (property !== undefined) {
        return ret.replicate(property);
    }
    return ret;
}
//# sourceMappingURL=CollateralTestToken.js.map
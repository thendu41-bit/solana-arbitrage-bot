import { Address, GetAccountInfoApi, GetMultipleAccountsApi, Rpc } from "@solana/kit";
import BN from "bn.js";
import * as types from "../types";
export interface PersonalPositionStateFields {
    /** Bump to identify PDA */
    bump: number;
    /** Mint address of the tokenized position */
    nftMint: Address;
    /** The ID of the pool with which this token is connected */
    poolId: Address;
    /** The lower bound tick of the position */
    tickLowerIndex: number;
    /** The upper bound tick of the position */
    tickUpperIndex: number;
    /** The amount of liquidity owned by this position */
    liquidity: BN;
    /** The token_0 fee growth of the aggregate position as of the last action on the individual position */
    feeGrowthInside0LastX64: BN;
    /** The token_1 fee growth of the aggregate position as of the last action on the individual position */
    feeGrowthInside1LastX64: BN;
    /** The fees owed to the position owner in token_0, as of the last computation */
    tokenFeesOwed0: BN;
    /** The fees owed to the position owner in token_1, as of the last computation */
    tokenFeesOwed1: BN;
    rewardInfos: Array<types.PositionRewardInfoFields>;
    padding: Array<BN>;
}
export interface PersonalPositionStateJSON {
    /** Bump to identify PDA */
    bump: number;
    /** Mint address of the tokenized position */
    nftMint: string;
    /** The ID of the pool with which this token is connected */
    poolId: string;
    /** The lower bound tick of the position */
    tickLowerIndex: number;
    /** The upper bound tick of the position */
    tickUpperIndex: number;
    /** The amount of liquidity owned by this position */
    liquidity: string;
    /** The token_0 fee growth of the aggregate position as of the last action on the individual position */
    feeGrowthInside0LastX64: string;
    /** The token_1 fee growth of the aggregate position as of the last action on the individual position */
    feeGrowthInside1LastX64: string;
    /** The fees owed to the position owner in token_0, as of the last computation */
    tokenFeesOwed0: string;
    /** The fees owed to the position owner in token_1, as of the last computation */
    tokenFeesOwed1: string;
    rewardInfos: Array<types.PositionRewardInfoJSON>;
    padding: Array<string>;
}
export declare class PersonalPositionState {
    /** Bump to identify PDA */
    readonly bump: number;
    /** Mint address of the tokenized position */
    readonly nftMint: Address;
    /** The ID of the pool with which this token is connected */
    readonly poolId: Address;
    /** The lower bound tick of the position */
    readonly tickLowerIndex: number;
    /** The upper bound tick of the position */
    readonly tickUpperIndex: number;
    /** The amount of liquidity owned by this position */
    readonly liquidity: BN;
    /** The token_0 fee growth of the aggregate position as of the last action on the individual position */
    readonly feeGrowthInside0LastX64: BN;
    /** The token_1 fee growth of the aggregate position as of the last action on the individual position */
    readonly feeGrowthInside1LastX64: BN;
    /** The fees owed to the position owner in token_0, as of the last computation */
    readonly tokenFeesOwed0: BN;
    /** The fees owed to the position owner in token_1, as of the last computation */
    readonly tokenFeesOwed1: BN;
    readonly rewardInfos: Array<types.PositionRewardInfo>;
    readonly padding: Array<BN>;
    static readonly discriminator: Buffer<ArrayBuffer>;
    static readonly layout: import("buffer-layout").Layout<PersonalPositionState>;
    constructor(fields: PersonalPositionStateFields);
    static fetch(rpc: Rpc<GetAccountInfoApi>, address: Address, programId?: Address): Promise<PersonalPositionState | null>;
    static fetchMultiple(rpc: Rpc<GetMultipleAccountsApi>, addresses: Address[], programId?: Address): Promise<Array<PersonalPositionState | null>>;
    static decode(data: Buffer): PersonalPositionState;
    toJSON(): PersonalPositionStateJSON;
    static fromJSON(obj: PersonalPositionStateJSON): PersonalPositionState;
}
//# sourceMappingURL=PersonalPositionState.d.ts.map
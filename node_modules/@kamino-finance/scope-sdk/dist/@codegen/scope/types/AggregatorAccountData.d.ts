import { Address } from "@solana/kit";
import BN from "bn.js";
import * as types from "../types";
export interface AggregatorAccountDataFields {
    name: Array<number>;
    metadata: Array<number>;
    authorWallet: Address;
    queuePubkey: Address;
    oracleRequestBatchSize: number;
    minOracleResults: number;
    minJobResults: number;
    minUpdateDelaySeconds: number;
    startAfter: BN;
    varianceThreshold: types.SwitchboardDecimalFields;
    forceReportPeriod: BN;
    expiration: BN;
    consecutiveFailureCount: BN;
    nextAllowedUpdateTime: BN;
    isLocked: boolean;
    schedule: Array<number>;
    latestConfirmedRound: types.AggregatorRoundFields;
    currentRound: types.AggregatorRoundFields;
    jobPubkeysData: Array<Address>;
    jobHashes: Array<types.HashFields>;
    jobPubkeysSize: number;
    jobsChecksum: Array<number>;
    authority: Address;
    ebuf: Array<number>;
}
export interface AggregatorAccountDataJSON {
    name: Array<number>;
    metadata: Array<number>;
    authorWallet: string;
    queuePubkey: string;
    oracleRequestBatchSize: number;
    minOracleResults: number;
    minJobResults: number;
    minUpdateDelaySeconds: number;
    startAfter: string;
    varianceThreshold: types.SwitchboardDecimalJSON;
    forceReportPeriod: string;
    expiration: string;
    consecutiveFailureCount: string;
    nextAllowedUpdateTime: string;
    isLocked: boolean;
    schedule: Array<number>;
    latestConfirmedRound: types.AggregatorRoundJSON;
    currentRound: types.AggregatorRoundJSON;
    jobPubkeysData: Array<string>;
    jobHashes: Array<types.HashJSON>;
    jobPubkeysSize: number;
    jobsChecksum: Array<number>;
    authority: string;
    ebuf: Array<number>;
}
export declare class AggregatorAccountData {
    readonly name: Array<number>;
    readonly metadata: Array<number>;
    readonly authorWallet: Address;
    readonly queuePubkey: Address;
    readonly oracleRequestBatchSize: number;
    readonly minOracleResults: number;
    readonly minJobResults: number;
    readonly minUpdateDelaySeconds: number;
    readonly startAfter: BN;
    readonly varianceThreshold: types.SwitchboardDecimal;
    readonly forceReportPeriod: BN;
    readonly expiration: BN;
    readonly consecutiveFailureCount: BN;
    readonly nextAllowedUpdateTime: BN;
    readonly isLocked: boolean;
    readonly schedule: Array<number>;
    readonly latestConfirmedRound: types.AggregatorRound;
    readonly currentRound: types.AggregatorRound;
    readonly jobPubkeysData: Array<Address>;
    readonly jobHashes: Array<types.Hash>;
    readonly jobPubkeysSize: number;
    readonly jobsChecksum: Array<number>;
    readonly authority: Address;
    readonly ebuf: Array<number>;
    constructor(fields: AggregatorAccountDataFields);
    static layout(property?: string): import("buffer-layout").Layout<unknown>;
    static fromDecoded(obj: any): types.AggregatorAccountData;
    static toEncodable(fields: AggregatorAccountDataFields): {
        name: number[];
        metadata: number[];
        authorWallet: Address;
        queuePubkey: Address;
        oracleRequestBatchSize: number;
        minOracleResults: number;
        minJobResults: number;
        minUpdateDelaySeconds: number;
        startAfter: BN;
        varianceThreshold: {
            mantissa: BN;
            scale: number;
        };
        forceReportPeriod: BN;
        expiration: BN;
        consecutiveFailureCount: BN;
        nextAllowedUpdateTime: BN;
        isLocked: boolean;
        schedule: number[];
        latestConfirmedRound: {
            numSuccess: number;
            numError: number;
            isClosed: boolean;
            roundOpenSlot: BN;
            roundOpenTimestamp: BN;
            result: {
                mantissa: BN;
                scale: number;
            };
            stdDeviation: {
                mantissa: BN;
                scale: number;
            };
            minResponse: {
                mantissa: BN;
                scale: number;
            };
            maxResponse: {
                mantissa: BN;
                scale: number;
            };
            oraclePubkeysData: Address[];
            mediansData: {
                mantissa: BN;
                scale: number;
            }[];
            currentPayout: BN[];
            mediansFulfilled: boolean[];
            errorsFulfilled: boolean[];
        };
        currentRound: {
            numSuccess: number;
            numError: number;
            isClosed: boolean;
            roundOpenSlot: BN;
            roundOpenTimestamp: BN;
            result: {
                mantissa: BN;
                scale: number;
            };
            stdDeviation: {
                mantissa: BN;
                scale: number;
            };
            minResponse: {
                mantissa: BN;
                scale: number;
            };
            maxResponse: {
                mantissa: BN;
                scale: number;
            };
            oraclePubkeysData: Address[];
            mediansData: {
                mantissa: BN;
                scale: number;
            }[];
            currentPayout: BN[];
            mediansFulfilled: boolean[];
            errorsFulfilled: boolean[];
        };
        jobPubkeysData: Address[];
        jobHashes: {
            data: number[];
        }[];
        jobPubkeysSize: number;
        jobsChecksum: number[];
        authority: Address;
        ebuf: number[];
    };
    toJSON(): AggregatorAccountDataJSON;
    static fromJSON(obj: AggregatorAccountDataJSON): AggregatorAccountData;
    toEncodable(): {
        name: number[];
        metadata: number[];
        authorWallet: Address;
        queuePubkey: Address;
        oracleRequestBatchSize: number;
        minOracleResults: number;
        minJobResults: number;
        minUpdateDelaySeconds: number;
        startAfter: BN;
        varianceThreshold: {
            mantissa: BN;
            scale: number;
        };
        forceReportPeriod: BN;
        expiration: BN;
        consecutiveFailureCount: BN;
        nextAllowedUpdateTime: BN;
        isLocked: boolean;
        schedule: number[];
        latestConfirmedRound: {
            numSuccess: number;
            numError: number;
            isClosed: boolean;
            roundOpenSlot: BN;
            roundOpenTimestamp: BN;
            result: {
                mantissa: BN;
                scale: number;
            };
            stdDeviation: {
                mantissa: BN;
                scale: number;
            };
            minResponse: {
                mantissa: BN;
                scale: number;
            };
            maxResponse: {
                mantissa: BN;
                scale: number;
            };
            oraclePubkeysData: Address[];
            mediansData: {
                mantissa: BN;
                scale: number;
            }[];
            currentPayout: BN[];
            mediansFulfilled: boolean[];
            errorsFulfilled: boolean[];
        };
        currentRound: {
            numSuccess: number;
            numError: number;
            isClosed: boolean;
            roundOpenSlot: BN;
            roundOpenTimestamp: BN;
            result: {
                mantissa: BN;
                scale: number;
            };
            stdDeviation: {
                mantissa: BN;
                scale: number;
            };
            minResponse: {
                mantissa: BN;
                scale: number;
            };
            maxResponse: {
                mantissa: BN;
                scale: number;
            };
            oraclePubkeysData: Address[];
            mediansData: {
                mantissa: BN;
                scale: number;
            }[];
            currentPayout: BN[];
            mediansFulfilled: boolean[];
            errorsFulfilled: boolean[];
        };
        jobPubkeysData: Address[];
        jobHashes: {
            data: number[];
        }[];
        jobPubkeysSize: number;
        jobsChecksum: number[];
        authority: Address;
        ebuf: number[];
    };
}
//# sourceMappingURL=AggregatorAccountData.d.ts.map
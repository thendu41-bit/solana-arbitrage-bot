{"version":3,"sources":["../src/address.ts","../src/instruction.ts","../src/keypair.ts","../src/transaction.ts"],"names":["AccountRole","createKeyPairFromBytes","SolanaError","SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH"],"mappings":"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","file":"index.browser.cjs","sourcesContent":["import { Address } from '@solana/addresses';\nimport { PublicKey } from '@solana/web3.js';\n\n/**\n * Converts a legacy [PublicKey](https://solana-foundation.github.io/solana-web3.js/classes/PublicKey.html)\n * object to an {@link Address}.\n *\n * @example\n * ```ts\n * import { fromLegacyPublicKey } from '@solana/compat';\n *\n * const legacyPublicKey = new PublicKey('49XBVQsvSW44ULKL9qufS9YqQPbdcps1TQRijx4FQ9sH');\n * const address = fromLegacyPublicKey(legacyPublicKey);\n * ```\n */\nexport function fromLegacyPublicKey<TAddress extends string>(publicKey: PublicKey): Address<TAddress> {\n    return publicKey.toBase58() as Address<TAddress>;\n}\n","import { AccountRole, Instruction } from '@solana/instructions';\nimport { TransactionInstruction } from '@solana/web3.js';\n\nimport { fromLegacyPublicKey } from './address';\n\n/**\n * This can be used to convert a legacy [`TransactionInstruction`](https://solana-foundation.github.io/solana-web3.js/classes/TransactionInstruction.html)\n * object to an {@link Instruction}.\n *\n * @example\n * ```ts\n * import { fromLegacyTransactionInstruction } from '@solana/compat';\n *\n * // Imagine a function that returns a legacy `TransactionInstruction`\n * const legacyInstruction = getMyLegacyInstruction();\n * const instruction = fromLegacyTransactionInstruction(legacyInstruction);\n * ```\n */\nexport function fromLegacyTransactionInstruction(legacyInstruction: TransactionInstruction): Instruction {\n    const data = legacyInstruction.data?.byteLength > 0 ? Uint8Array.from(legacyInstruction.data) : undefined;\n    const accounts = legacyInstruction.keys.map(accountMeta =>\n        Object.freeze({\n            address: fromLegacyPublicKey(accountMeta.pubkey),\n            role: determineRole(accountMeta.isSigner, accountMeta.isWritable),\n        }),\n    );\n    const programAddress = fromLegacyPublicKey(legacyInstruction.programId);\n    return Object.freeze({\n        ...(accounts.length ? { accounts: Object.freeze(accounts) } : null),\n        ...(data ? { data } : null),\n        programAddress,\n    });\n}\n\nfunction determineRole(isSigner: boolean, isWritable: boolean): AccountRole {\n    if (isSigner && isWritable) return AccountRole.WRITABLE_SIGNER;\n    if (isSigner) return AccountRole.READONLY_SIGNER;\n    if (isWritable) return AccountRole.WRITABLE;\n    return AccountRole.READONLY;\n}\n","import { createKeyPairFromBytes } from '@solana/keys';\nimport { Keypair } from '@solana/web3.js';\n\n/**\n * Converts a legacy [Keypair](https://solana-foundation.github.io/solana-web3.js/classes/Keypair.html)\n * object to a native Ed25519 {@link CryptoKeyPair} object.\n *\n * @example\n * ```ts\n * import { fromLegacyKeypair } from '@solana/compat';\n *\n * const legacyKeyPair = Keypair.generate();\n * const { privateKey, publicKey } = await fromLegacyKeypair(legacyKeyPair);\n * ```\n */\nexport async function fromLegacyKeypair(keypair: Keypair, extractable?: boolean): Promise<CryptoKeyPair> {\n    const bytes = new Uint8Array(64);\n    bytes.set(keypair.secretKey);\n    bytes.set(keypair.publicKey.toBytes(), /* offset */ 32);\n    return await createKeyPairFromBytes(bytes, extractable);\n}\n","import { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH, SolanaError } from '@solana/errors';\nimport type { SignatureBytes } from '@solana/keys';\nimport { type SignaturesMap, Transaction, TransactionMessageBytes } from '@solana/transactions';\nimport type { PublicKey, VersionedTransaction } from '@solana/web3.js';\n\nfunction convertSignatures(transaction: VersionedTransaction, staticAccountKeys: PublicKey[]): SignaturesMap {\n    return Object.fromEntries(\n        transaction.signatures.map((sig, index) => {\n            const address = staticAccountKeys[index];\n            if (sig.every(b => b === 0)) {\n                // all-0 signatures are stored as null\n                return [address, null];\n            } else {\n                return [address, sig as ReadonlyUint8Array as SignatureBytes];\n            }\n        }),\n    );\n}\n\n/**\n * This can be used to convert a legacy [VersionedTransaction](https://solana-foundation.github.io/solana-web3.js/classes/VersionedTransaction.html)\n * object to a {@link Transaction}.\n *\n * @example\n * ```ts\n * import { fromVersionedTransaction } from '@solana/compat';\n *\n * // Imagine a function that returns a legacy `VersionedTransaction`\n * const legacyVersionedTransaction = getMyLegacyVersionedTransaction();\n * const transaction = fromVersionedTransaction(legacyVersionedTransaction);\n * ```\n */\nexport function fromVersionedTransaction(transaction: VersionedTransaction): Transaction {\n    const { message } = transaction;\n    const { staticAccountKeys } = message.getAccountKeys();\n\n    const { numRequiredSignatures } = message.header;\n    if (numRequiredSignatures !== transaction.signatures.length) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH, {\n            numRequiredSignatures: transaction.message.header.numRequiredSignatures,\n            signaturesLength: transaction.signatures.length,\n            signerAddresses: staticAccountKeys.slice(0, numRequiredSignatures).map(p => p.toBase58()),\n        });\n    }\n\n    const messageBytes = message.serialize() as ReadonlyUint8Array as TransactionMessageBytes;\n    const signatures = convertSignatures(transaction, staticAccountKeys);\n\n    return {\n        messageBytes,\n        signatures: Object.freeze(signatures),\n    };\n}\n"]}
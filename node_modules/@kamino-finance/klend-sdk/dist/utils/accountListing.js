"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllObligationAccounts = getAllObligationAccounts;
exports.getAllReserveAccounts = getAllReserveAccounts;
exports.getAllLendingMarketAccounts = getAllLendingMarketAccounts;
const kit_1 = require("@solana/kit");
const accounts_1 = require("../@codegen/klend/accounts");
const programId_1 = require("../@codegen/klend/programId");
const base58Decoder = (0, kit_1.getBase58Decoder)();
async function* getAllObligationAccounts(connection) {
    // Poor-man's paging...
    for (let i = 0; i < 256; i++) {
        const obligations = await connection
            .getProgramAccounts(programId_1.PROGRAM_ID, {
            filters: [
                {
                    dataSize: BigInt(accounts_1.Obligation.layout.span + 8),
                },
                {
                    memcmp: {
                        offset: 0n,
                        bytes: base58Decoder.decode(accounts_1.Obligation.discriminator),
                        encoding: 'base58',
                    },
                },
                {
                    memcmp: {
                        offset: 64n,
                        bytes: base58Decoder.decode(Buffer.from([i])), // ...via sharding by userId's first byte (just as a source of randomness)
                        encoding: 'base58',
                    },
                },
            ],
            encoding: 'base64',
        })
            .send();
        for (const obligation of obligations) {
            yield [obligation.pubkey, accounts_1.Obligation.decode(Buffer.from(obligation.account.data[0], 'base64'))];
        }
    }
}
async function* getAllReserveAccounts(rpc) {
    // due to relatively low count of reserves, we technically don't really need a generator, but let's keep it consistent within this file
    const reserves = await rpc
        .getProgramAccounts(programId_1.PROGRAM_ID, {
        filters: [
            {
                dataSize: BigInt(accounts_1.Reserve.layout.span + 8),
            },
            {
                memcmp: {
                    offset: 0n,
                    bytes: base58Decoder.decode(accounts_1.Reserve.discriminator),
                    encoding: 'base58',
                },
            },
        ],
        encoding: 'base64',
    })
        .send();
    for (const reserve of reserves) {
        yield [reserve.pubkey, accounts_1.Reserve.decode(Buffer.from(reserve.account.data[0], 'base64'))];
    }
}
async function* getAllLendingMarketAccounts(connection, programId = programId_1.PROGRAM_ID) {
    // due to relatively very low count of lending markets, we technically don't really need a generator, but let's keep it consistent within this file
    const lendingMarkets = await connection
        .getProgramAccounts(programId, {
        filters: [
            {
                dataSize: BigInt(accounts_1.LendingMarket.layout.span + 8),
            },
            {
                memcmp: {
                    offset: 0n,
                    bytes: base58Decoder.decode(accounts_1.LendingMarket.discriminator),
                    encoding: 'base58',
                },
            },
        ],
        encoding: 'base64',
    })
        .send();
    for (const lendingMarket of lendingMarkets) {
        yield [lendingMarket.pubkey, accounts_1.LendingMarket.decode(Buffer.from(lendingMarket.account.data[0], 'base64'))];
    }
}
//# sourceMappingURL=accountListing.js.map
import { Address, Instruction, Slot, TransactionSigner, Rpc, GetMinimumBalanceForRentExemptionApi, Option, GetProgramAccountsApi, GetAccountInfoApi, GetMultipleAccountsApi } from '@solana/kit';
import Decimal from 'decimal.js';
import { AllOracleAccounts, MarketWithAddress, TokenOracleData } from '../utils';
import { FeeCalculation, Fees, ReserveDataType, ReserveRewardYield } from './shared';
import { Reserve } from '../@codegen/klend/accounts';
import { ReserveConfig, UpdateConfigModeKind } from '../@codegen/klend/types';
import { ConfigUpdater } from './configItems';
import { ActionType } from './action';
import { BorrowCapsAndCounters, KaminoMarket } from './market';
import { KaminoPrices } from '@kamino-finance/kliquidity-sdk';
export type KaminoReserveRpcApi = GetProgramAccountsApi & GetAccountInfoApi & GetMultipleAccountsApi;
export declare const DEFAULT_RECENT_SLOT_DURATION_MS = 450;
export declare class KaminoReserve {
    state: Reserve;
    address: Address;
    symbol: string;
    tokenOraclePrice: TokenOracleData;
    stats: ReserveDataType;
    private farmData;
    private rpc;
    private readonly recentSlotDurationMs;
    private metadata?;
    constructor(state: Reserve, address: Address, tokenOraclePrice: TokenOracleData, connection: Rpc<KaminoReserveRpcApi>, recentSlotDurationMs: number);
    static initialize(address: Address, state: Reserve, tokenOraclePrice: TokenOracleData, rpc: Rpc<KaminoReserveRpcApi>, recentSlotDurationMs: number): KaminoReserve;
    static initializeFromAddress(address: Address, rpc: Rpc<KaminoReserveRpcApi>, recentSlotDurationMs: number, reserveState?: Reserve, oracleAccounts?: AllOracleAccounts): Promise<KaminoReserve>;
    /**
     * @returns the parsed token symbol of the reserve
     */
    getTokenSymbol(): string;
    /**
     * @returns list of logo names and human readable oracle descriptions
     */
    getOracleMetadata(): Promise<[string, string][]>;
    /**
     * @returns the total borrowed amount of the reserve in lamports
     */
    getBorrowedAmount(): Decimal;
    /**
     * @returns the available liquidity amount of the reserve in lamports
     */
    getLiquidityAvailableAmount(): Decimal;
    /**
     *
     * @returns the last cached price stored in the reserve in USD
     */
    getReserveMarketPrice(): Decimal;
    /**
     * @returns the current market price of the reserve in USD
     */
    getOracleMarketPrice(): Decimal;
    /**
     * @returns the total accumulated protocol fees of the reserve
     */
    getAccumulatedProtocolFees(): Decimal;
    /**
     * @returns the total accumulated referrer fees of the reserve
     */
    getAccumulatedReferrerFees(): Decimal;
    /**
     * @returns the total pending referrer fees of the reserve
     */
    getPendingReferrerFees(): Decimal;
    /**
     *
     * @returns the flash loan fee percentage of the reserve
     */
    getFlashLoanFee: () => Decimal;
    /**
     *
     * @returns the origination fee percentage of the reserve
     */
    getBorrowFee: () => Decimal;
    /**
     *
     * @returns the fixed interest rate allocated to the host
     */
    getFixedHostInterestRate: () => Decimal;
    /**
     * Use getEstimatedTotalSupply() for the most accurate value
     * @returns the stale total liquidity supply of the reserve from the last refresh
     */
    getTotalSupply(): Decimal;
    /**
     * Calculates the total liquidity supply of the reserve
     */
    getEstimatedTotalSupply(slot: Slot, referralFeeBps: number): Decimal;
    /**
     * Use getEstimatedCumulativeBorrowRate() for the most accurate value
     * @returns the stale cumulative borrow rate of the reserve from the last refresh
     */
    getCumulativeBorrowRate(): Decimal;
    /**
     * @Returns estimated cumulative borrow rate of the reserve
     */
    getEstimatedCumulativeBorrowRate(currentSlot: Slot, referralFeeBps: number): Decimal;
    /**
     * Use getEstimatedCollateralExchangeRate() for the most accurate value
     * @returns the stale exchange rate between the collateral tokens and the liquidity - this is a decimal number scaled by 1e18
     */
    getCollateralExchangeRate(): Decimal;
    /**
     *
     * @returns the estimated exchange rate between the collateral tokens and the liquidity - this is a decimal number scaled by 1e18
     */
    getEstimatedCollateralExchangeRate(slot: Slot, referralFeeBps: number): Decimal;
    /**
     *
     * @returns the total USD value of the existing collateral in the reserve
     */
    getDepositTvl: () => Decimal;
    /**
     *
     * Get the total USD value of the borrowed assets from the reserve
     */
    getBorrowTvl: () => Decimal;
    /**
     * @returns 10^mint_decimals
     */
    getMintFactor(): Decimal;
    /**
     * @returns mint_decimals of the liquidity token
     */
    getMintDecimals(): number;
    /**
     * @returns the collateral farm address if it is set, otherwise none
     */
    getCollateralFarmAddress(): Option<Address>;
    /**
     * @returns the debt farm address if it is set, otherwise none
     */
    getDebtFarmAddress(): Option<Address>;
    /**
     * @Returns true if the total liquidity supply of the reserve is greater than the deposit limit
     */
    depositLimitCrossed(): boolean;
    /**
     * @Returns true if the total borrowed amount of the reserve is greater than the borrow limit
     */
    borrowLimitCrossed(): boolean;
    /**
     *
     * @returns the max capacity of the daily deposit withdrawal cap
     */
    getDepositWithdrawalCapCapacity(): Decimal;
    /**
     *
     * @returns the current capacity of the daily deposit withdrawal cap
     */
    getDepositWithdrawalCapCurrent(slot: Slot): Decimal;
    /**
     *
     * @returns the max capacity of the daily debt withdrawal cap
     */
    getDebtWithdrawalCapCapacity(): Decimal;
    /**
     *
     * @returns the borrow limit of the reserve outside the elevation group
     */
    getBorrowLimitOutsideElevationGroup(): Decimal;
    /**
     *
     * @returns the borrowed amount of the reserve outside the elevation group
     */
    getBorrowedAmountOutsideElevationGroup(): Decimal;
    /**
     *
     * @returns the borrow limit against the collateral reserve in the elevation group
     */
    getBorrowLimitAgainstCollateralInElevationGroup(elevationGroupIndex: number): Decimal;
    /**
     *
     * @returns the borrowed amount against the collateral reserve in the elevation group
     */
    getBorrowedAmountAgainstCollateralInElevationGroup(elevationGroupIndex: number): Decimal;
    /**
     *
     * @returns the current capacity of the daily debt withdrawal cap
     */
    getDebtWithdrawalCapCurrent(slot: Slot): Decimal;
    getBorrowFactor(): Decimal;
    calculateSupplyAPR(slot: Slot, referralFeeBps: number): number;
    getEstimatedDebtAndSupply(slot: Slot, referralFeeBps: number): {
        totalBorrow: Decimal;
        totalSupply: Decimal;
    };
    getEstimatedAccumulatedProtocolFees(slot: Slot, referralFeeBps: number): {
        accumulatedProtocolFees: Decimal;
        compoundedVariableProtocolFee: Decimal;
        compoundedFixedHostFee: Decimal;
    };
    calculateUtilizationRatio(): number;
    getEstimatedUtilizationRatio(slot: Slot, referralFeeBps: number): number;
    calcSimulatedUtilizationRatio(amount: Decimal, action: ActionType, slot: Slot, referralFeeBps: number, outflowAmount?: Decimal): number;
    getMaxBorrowAmountWithCollReserve(market: KaminoMarket, collReserve: KaminoReserve, slot: Slot): Decimal;
    calcSimulatedBorrowRate(amount: Decimal, action: ActionType, slot: Slot, referralFeeBps: number, outflowAmount?: Decimal): number;
    calcSimulatedBorrowAPR(amount: Decimal, action: ActionType, slot: Slot, referralFeeBps: number, outflowAmount?: Decimal): number;
    calcSimulatedSupplyAPR(amount: Decimal, action: ActionType, slot: Slot, referralFeeBps: number, outflowAmount?: Decimal): number;
    slotAdjustmentFactor(): number;
    calculateBorrowRate(): number;
    calculateEstimatedBorrowRate(slot: Slot, referralFeeBps: number): number;
    calculateBorrowAPR(slot: Slot, referralFeeBps: number): number;
    /**
     * @returns the mint of the reserve liquidity token
     */
    getLiquidityMint(): Address;
    /**
     * @returns the token program of the reserve liquidity mint
     */
    getLiquidityTokenProgram(): Address;
    /**
     * @returns the mint of the reserve collateral token , i.e. the cToken minted for depositing the liquidity token
     */
    getCTokenMint(): Address;
    calculateFees(amountLamports: Decimal, borrowFeeRate: Decimal, feeCalculation: FeeCalculation, referralFeeBps: number, hasReferrer: boolean): Fees;
    calculateFlashLoanFees(flashLoanAmountLamports: Decimal, referralFeeBps: number, hasReferrer: boolean): Fees;
    load(tokenOraclePrice: TokenOracleData): Promise<void>;
    totalSupplyAPY(currentSlot: Slot): number;
    totalBorrowAPY(currentSlot: Slot): number;
    loadFarmStates(): Promise<void>;
    getRewardYields(prices: KaminoPrices): Promise<ReserveRewardYield[]>;
    private calculateRewardYield;
    private formatReserveData;
    /**
     * Compound current borrow rate over elapsed slots
     *
     * This also calculates protocol fees, which are taken for all obligations that have borrowed from current reserve.
     *
     * This also calculates referral fees, which are taken into pendingReferralFees.
     *
     * https://github.com/Kamino-Finance/klend/blob/release/1.3.0/programs/klend/src/state/reserve.rs#L517
     *
     * @param slotsElapsed
     * @param referralFeeBps
     */
    private compoundInterest;
    /**
     * Approximation to match the smart contract calculation
     * https://github.com/Kamino-Finance/klend/blob/release/1.3.0/programs/klend/src/state/reserve.rs#L1026
     * @param rate
     * @param elapsedSlots
     * @private
     */
    private approximateCompoundedInterest;
    getBorrowCapForReserve(market: KaminoMarket): BorrowCapsAndCounters;
    getLiquidityAvailableForDebtReserveGivenCaps(market: KaminoMarket, elevationGroups: number[], collateralReserves?: Address[]): Decimal[];
}
export declare function createReserveIxs(rpc: Rpc<GetMinimumBalanceForRentExemptionApi>, owner: TransactionSigner, ownerLiquiditySource: Address, lendingMarket: Address, liquidityMint: Address, liquidityMintTokenProgram: Address, reserveAddress: TransactionSigner, programId: Address): Promise<Instruction[]>;
export declare function updateReserveConfigIx(signer: TransactionSigner, marketAddress: Address, reserveAddress: Address, mode: UpdateConfigModeKind, value: Uint8Array, programId: Address, skipConfigIntegrityValidation?: boolean): Promise<Instruction>;
export declare const RESERVE_CONFIG_UPDATER: ConfigUpdater<UpdateConfigModeKind, ReserveConfig>;
export declare function updateEntireReserveConfigIx(signer: TransactionSigner, marketAddress: Address, reserveAddress: Address, reserveConfig: ReserveConfig, programId: Address): Promise<Instruction>;
export declare function parseForChangesReserveConfigAndGetIxs(marketWithAddress: MarketWithAddress, reserve: Reserve | undefined, reserveAddress: Address, reserveConfig: ReserveConfig, programId: Address, lendingMarketOwner?: TransactionSigner): Promise<Instruction[]>;
export type ReserveWithAddress = {
    address: Address;
    state: Reserve;
};
//# sourceMappingURL=reserve.d.ts.map
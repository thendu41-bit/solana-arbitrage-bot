import BN from 'bn.js';
import { Address, GetAccountInfoApi, AccountMeta, Instruction, ProgramDerivedAddress, Rpc, Slot, SolanaRpcApi, TransactionSigner } from '@solana/kit';
import { AllOracleAccounts, KaminoMarket, KaminoReserve, Reserve } from '../lib';
import { VaultConfigFieldKind } from '../@codegen/kvault/types';
import { VaultState } from '../@codegen/kvault/accounts';
import Decimal from 'decimal.js';
import { ReserveWithAddress } from './reserve';
import { AcceptVaultOwnershipIxs, APYs, DepositIxs, DisinvestAllReservesIxs, InitVaultIxs, ReserveAllocationOverview, SyncVaultLUTIxs, UpdateReserveAllocationIxs, UpdateVaultConfigIxs, UserSharesForVault, VaultComputedAllocation, WithdrawAndBlockReserveIxs, WithdrawIxs } from './vault_types';
import { FarmIncentives, FarmState } from '@kamino-finance/farms-sdk/dist';
import { Farms } from '@kamino-finance/farms-sdk';
export declare const kaminoVaultId: Address<"KvauGMspG5k6rtzrqqn7WNn3oZdyKqLKwK2XWQ8FLjd">;
export declare const kaminoVaultStagingId: Address<"stKvQfwRsQiKnLtMNVLHKS3exFJmZFsgfzBPWHECUYK">;
export declare const METADATA_SEED = "metadata";
export declare const METADATA_PROGRAM_ID: Address;
export declare const INITIAL_DEPOSIT_LAMPORTS = 1000;
/**
 * KaminoVaultClient is a class that provides a high-level interface to interact with the Kamino Vault program.
 */
export declare class KaminoVaultClient {
    private readonly _rpc;
    private readonly _kaminoVaultProgramId;
    private readonly _kaminoLendProgramId;
    recentSlotDurationMs: number;
    constructor(rpc: Rpc<SolanaRpcApi>, recentSlotDurationMs: number, kaminoVaultprogramId?: Address, kaminoLendProgramId?: Address);
    getConnection(): Rpc<import("@solana/kit").RequestAirdropApi & GetAccountInfoApi & import("@solana/kit").GetBalanceApi & import("@solana/kit").GetBlockApi & import("@solana/kit").GetBlockCommitmentApi & import("@solana/kit").GetBlockHeightApi & import("@solana/kit").GetBlockProductionApi & import("@solana/kit").GetBlocksApi & import("@solana/kit").GetBlocksWithLimitApi & import("@solana/kit").GetBlockTimeApi & import("@solana/kit").GetClusterNodesApi & import("@solana/kit").GetEpochInfoApi & import("@solana/kit").GetEpochScheduleApi & import("@solana/kit").GetFeeForMessageApi & import("@solana/kit").GetFirstAvailableBlockApi & import("@solana/kit").GetGenesisHashApi & import("@solana/kit").GetHealthApi & import("@solana/kit").GetHighestSnapshotSlotApi & import("@solana/kit").GetIdentityApi & import("@solana/kit").GetInflationGovernorApi & import("@solana/kit").GetInflationRateApi & import("@solana/kit").GetInflationRewardApi & import("@solana/kit").GetLargestAccountsApi & import("@solana/kit").GetLatestBlockhashApi & import("@solana/kit").GetLeaderScheduleApi & import("@solana/kit").GetMaxRetransmitSlotApi & import("@solana/kit").GetMaxShredInsertSlotApi & import("@solana/kit").GetMinimumBalanceForRentExemptionApi & import("@solana/kit").GetMultipleAccountsApi & import("@solana/kit").GetProgramAccountsApi & import("@solana/kit").GetRecentPerformanceSamplesApi & import("@solana/kit").GetRecentPrioritizationFeesApi & import("@solana/kit").GetSignaturesForAddressApi & import("@solana/kit").GetSignatureStatusesApi & import("@solana/kit").GetSlotApi & import("@solana/kit").GetSlotLeaderApi & import("@solana/kit").GetSlotLeadersApi & import("@solana/kit").GetStakeMinimumDelegationApi & import("@solana/kit").GetSupplyApi & import("@solana/kit").GetTokenAccountBalanceApi & import("@solana/kit").GetTokenAccountsByDelegateApi & import("@solana/kit").GetTokenAccountsByOwnerApi & import("@solana/kit").GetTokenLargestAccountsApi & import("@solana/kit").GetTokenSupplyApi & import("@solana/kit").GetTransactionApi & import("@solana/kit").GetTransactionCountApi & import("@solana/kit").GetVersionApi & import("@solana/kit").GetVoteAccountsApi & import("@solana/kit").IsBlockhashValidApi & import("@solana/kit").MinimumLedgerSlotApi & import("@solana/kit").SendTransactionApi & import("@solana/kit").SimulateTransactionApi>;
    getProgramID(): Address;
    hasFarm(): void;
    /**
     * Prints a vault in a human readable form
     * @param vaultPubkey - the address of the vault
     * @param [vaultState] - optional parameter to pass the vault state directly; this will save a network call
     * @returns - void; prints the vault to the console
     */
    printVault(vaultPubkey: Address, vaultState?: VaultState): Promise<void>;
    /**
     * This method will create a vault with a given config. The config can be changed later on, but it is recommended to set it up correctly from the start
     * @param vaultConfig - the config object used to create a vault
     * @returns vault: the keypair of the vault, used to sign the initialization transaction; initVaultIxs: a struct with ixs to initialize the vault and its lookup table + populateLUTIxs, a list to populate the lookup table which has to be executed in a separate transaction
     */
    createVaultIxs(vaultConfig: KaminoVaultConfig): Promise<{
        vault: TransactionSigner;
        lut: Address;
        initVaultIxs: InitVaultIxs;
    }>;
    /**
     * This method creates an instruction to set the shares metadata for a vault
     * @param rpc
     * @param vaultAdmin
     * @param vault - the vault to set the shares metadata for
     * @param sharesMint
     * @param baseVaultAuthority
     * @param tokenName - the name of the token in the vault (symbol; e.g. "USDC" which becomes "kVUSDC")
     * @param extraName - the extra string appended to the prefix("Kamino Vault USDC <extraName>")
     * @returns - an instruction to set the shares metadata for the vault
     */
    getSetSharesMetadataIx(rpc: Rpc<SolanaRpcApi>, vaultAdmin: TransactionSigner, vault: Address, sharesMint: Address, baseVaultAuthority: Address, tokenName: string, extraName: string): Promise<Instruction<string, readonly (AccountMeta<string> | import("@solana/kit").AccountLookupMeta<string, string>)[]>>;
    /**
     * This method updates the vault reserve allocation config for an exiting vault reserve, or adds a new reserve to the vault if it does not exist.
     * @param vault - vault to be updated
     * @param reserveAllocationConfig - new reserve allocation config
     * @param [vaultAdminAuthority] - vault admin - a noop vaultAdminAuthority is provided when absent for multisigs
     * @returns - a struct with an instruction to update the reserve allocation and an optional list of instructions to update the lookup table for the allocation changes
     */
    updateReserveAllocationIxs(vault: KaminoVault, reserveAllocationConfig: ReserveAllocationConfig, vaultAdminAuthority?: TransactionSigner): Promise<UpdateReserveAllocationIxs>;
    /**
     * This method updates the unallocated weight and cap of a vault (both are optional, if not provided the current values will be used)
     * @param vault - the vault to update the unallocated weight and cap for
     * @param [vaultAdminAuthority] - vault admin - a noop vaultAdminAuthority is provided when absent for multisigs
     * @param [unallocatedWeight] - the new unallocated weight to set. If not provided, the current unallocated weight will be used
     * @param [unallocatedCap] - the new unallocated cap to set. If not provided, the current unallocated cap will be used
     * @returns - a list of instructions to update the unallocated weight and cap
     */
    updateVaultUnallocatedWeightAndCapIxs(vault: KaminoVault, vaultAdminAuthority?: TransactionSigner, unallocatedWeight?: BN, unallocatedCap?: BN): Promise<Instruction<string, readonly (AccountMeta<string> | import("@solana/kit").AccountLookupMeta<string, string>)[]>[]>;
    /**
     * This method withdraws all the funds from a reserve and blocks it from being invested by setting its weight and ctoken allocation to 0
     * @param vault - the vault to withdraw the funds from
     * @param reserve - the reserve to withdraw the funds from
     * @param [vaultAdminAuthority] - vault admin - a noop vaultAdminAuthority is provided when absent for multisigs
     * @returns - a struct with an instruction to update the reserve allocation and an optional list of instructions to update the lookup table for the allocation changes
     */
    withdrawEverythingAndBlockInvestReserve(vault: KaminoVault, reserve: Address, vaultAdminAuthority?: TransactionSigner): Promise<WithdrawAndBlockReserveIxs>;
    /**
     * This method withdraws all the funds from all the reserves and blocks them from being invested by setting their weight and ctoken allocation to 0
     * @param vault - the vault to withdraw the invested funds from
     * @param [vaultReservesMap] - optional parameter to pass a map of the vault reserves. If not provided, the reserves will be loaded from the vault
     * @param [payer] - optional parameter to pass a different payer for the transaction. If not provided, the admin of the vault will be used; this is the payer for the invest ixs and it should have an ATA and some lamports (2x no_of_reserves) of the token vault
     * @returns - a struct with an instruction to update the reserve allocations (set weight and ctoken allocation to 0) and an a list of instructions to disinvest the funds in the reserves
     */
    withdrawEverythingFromAllReservesAndBlockInvest(vault: KaminoVault, vaultReservesMap?: Map<Address, KaminoReserve>, payer?: TransactionSigner): Promise<WithdrawAndBlockReserveIxs>;
    /**
     * This method disinvests all the funds from all the reserves and set their weight to 0; for vaults that are managed by external bot/crank, the bot can change the weight and invest in the reserves again
     * @param vault - the vault to disinvest the invested funds from
     * @param [vaultReservesMap] - optional parameter to pass a map of the vault reserves. If not provided, the reserves will be loaded from the vault
     * @param [payer] - optional parameter to pass a different payer for the transaction. If not provided, the admin of the vault will be used; this is the payer for the invest ixs and it should have an ATA and some lamports (2x no_of_reserves) of the token vault
     * @returns - a struct with an instruction to update the reserve allocations to 0 weight and a list of instructions to disinvest the funds in the reserves
     */
    disinvestAllReservesIxs(vault: KaminoVault, vaultReservesMap?: Map<Address, KaminoReserve>, payer?: TransactionSigner): Promise<DisinvestAllReservesIxs>;
    /**
     * This method removes a reserve from the vault allocation strategy if already part of the allocation strategy
     * @param vault - vault to remove the reserve from
     * @param reserve - reserve to remove from the vault allocation strategy
     * @param [vaultAdminAuthority] - vault admin - a noop vaultAdminAuthority is provided when absent for multisigs
     * @returns - an instruction to remove the reserve from the vault allocation strategy or undefined if the reserve is not part of the allocation strategy
     */
    removeReserveFromAllocationIx(vault: KaminoVault, reserve: Address, vaultAdminAuthority?: TransactionSigner): Promise<Instruction | undefined>;
    /**
     * Update a field of the vault. If the field is a pubkey it will return an extra instruction to add that account into the lookup table
     * @param vault the vault to update
     * @param mode the field to update (based on VaultConfigFieldKind enum)
     * @param value the value to update the field with
     * @param [vaultAdminAuthority] the signer of the transaction. Optional. If not provided the admin of the vault will be used. It should be used when changing the admin of the vault if we want to build or batch multiple ixs in the same tx
     * @returns a struct that contains the instruction to update the field and an optional list of instructions to update the lookup table
     */
    updateVaultConfigIxs(vault: KaminoVault, mode: VaultConfigFieldKind, value: string, vaultAdminAuthority?: TransactionSigner): Promise<UpdateVaultConfigIxs>;
    /** Sets the farm where the shares can be staked. This is store in vault state and a vault can only have one farm, so the new farm will ovveride the old farm
     * @param vault - vault to set the farm for
     * @param farm - the farm where the vault shares can be staked
     * @param [errorOnOverride] - if true, the function will throw an error if the vault already has a farm. If false, it will override the farm
     * @param [vaultAdminAuthority] - vault admin - a noop vaultAdminAuthority is provided when absent for multisigs
     *
     */
    setVaultFarmIxs(vault: KaminoVault, farm: Address, errorOnOverride?: boolean, vaultAdminAuthority?: TransactionSigner): Promise<UpdateVaultConfigIxs>;
    /**
     * This method updates the vault config for a vault that
     * @param admin - address of vault to be updated
     * @param vault - address of vault to be updated
     * @param mode - the field to be updated
     * @param value - the new value for the field to be updated (number or pubkey)
     * @returns - an instruction to update the vault config
     */
    private updateUninitialisedVaultConfigIx;
    /**
     * This function creates the instruction for the `pendingAdmin` of the vault to accept to become the owner of the vault (step 2/2 of the ownership transfer)
     * @param vault - vault to change the ownership for
     * @param [pendingAdmin] - pending vault admin - a noop vaultAdminAuthority is provided when absent for multisigs
     * @returns - an instruction to accept the ownership of the vault and a list of instructions to update the lookup table
     */
    acceptVaultOwnershipIxs(vault: KaminoVault, pendingAdmin?: TransactionSigner): Promise<AcceptVaultOwnershipIxs>;
    /**
     * This function creates the instruction for the admin to give up a part of the pending fees (which will be accounted as part of the vault)
     * @param vault - vault to give up pending fees for
     * @param maxAmountToGiveUp - the maximum amount of fees to give up, in tokens
     * @param [vaultAdminAuthority] - vault admin - a noop vaultAdminAuthority is provided when absent for multisigs
     * @returns - an instruction to give up the specified pending fees
     */
    giveUpPendingFeesIx(vault: KaminoVault, maxAmountToGiveUp: Decimal, vaultAdminAuthority?: TransactionSigner): Promise<Instruction>;
    /**
     * This method withdraws all the pending fees from the vault to the owner's token ATA
     * @param authority - vault admin
     * @param vault - vault for which the admin withdraws the pending fees
     * @param slot - current slot, used to estimate the interest earned in the different reserves with allocation from the vault
     * @param [vaultReservesMap] - a hashmap from each reserve pubkey to the reserve state. Optional. If provided the function will be significantly faster as it will not have to fetch the reserves
     * @param [vaultAdminAuthority] - vault admin - a noop vaultAdminAuthority is provided when absent for multisigs
     * @returns - list of instructions to withdraw all pending fees, including the ATA creation instructions if needed
     */
    withdrawPendingFeesIxs(vault: KaminoVault, slot: Slot, vaultReservesMap?: Map<Address, KaminoReserve>, vaultAdminAuthority?: TransactionSigner): Promise<Instruction[]>;
    /**
     * This function creates instructions to deposit into a vault. It will also create ATA creation instructions for the vault shares that the user receives in return
     * @param user - user to deposit
     * @param vault - vault to deposit into (if the state is not provided, it will be fetched)
     * @param tokenAmount - token amount to be deposited, in decimals (will be converted in lamports)
     * @param [vaultReservesMap] - optional parameter; a hashmap from each reserve pubkey to the reserve state. Optional. If provided the function will be significantly faster as it will not have to fetch the reserves
     * @param [farmState] - the state of the vault farm, if the vault has a farm. Optional. If not provided, it will be fetched
     * @returns - an instance of DepositIxs which contains the instructions to deposit in vault and the instructions to stake the shares in the farm if the vault has a farm
     */
    depositIxs(user: TransactionSigner, vault: KaminoVault, tokenAmount: Decimal, vaultReservesMap?: Map<Address, KaminoReserve>, farmState?: FarmState): Promise<DepositIxs>;
    /**
     * This function creates instructions to stake the shares in the vault farm if the vault has a farm
     * @param user - user to stake
     * @param vault - vault to deposit into its farm (if the state is not provided, it will be fetched)
     * @param [sharesAmount] - token amount to be deposited, in decimals (will be converted in lamports). Optional. If not provided, the user's share balance will be used
     * @param [farmState] - the state of the vault farm, if the vault has a farm. Optional. If not provided, it will be fetched
     * @returns - a list of instructions for the user to stake shares into the vault's farm, including the creation of prerequisite accounts if needed
     */
    stakeSharesIxs(user: TransactionSigner, vault: KaminoVault, sharesAmount?: Decimal, farmState?: FarmState): Promise<Instruction[]>;
    /**
     * This function will return a struct with the instructions to unstake from the farm if necessary and the instructions for the missing ATA creation instructions, as well as one or multiple withdraw instructions, based on how many reserves it's needed to withdraw from. This might have to be split in multiple transactions
     * @param user - user to withdraw
     * @param vault - vault to withdraw from
     * @param shareAmount - share amount to withdraw (in tokens, not lamports), in order to withdraw everything, any value > user share amount
     * @param slot - current slot, used to estimate the interest earned in the different reserves with allocation from the vault
     * @param [vaultReservesMap] - optional parameter; a hashmap from each reserve pubkey to the reserve state. If provided the function will be significantly faster as it will not have to fetch the reserves
     * @param [farmState] - the state of the vault farm, if the vault has a farm. Optional. If not provided, it will be fetched
     * @returns an array of instructions to create missing ATAs if needed and the withdraw instructions
     */
    withdrawIxs(user: TransactionSigner, vault: KaminoVault, shareAmountToWithdraw: Decimal, slot: Slot, vaultReservesMap?: Map<Address, KaminoReserve>, farmState?: FarmState): Promise<WithdrawIxs>;
    private withdrawFromAvailableIxs;
    private withdrawWithReserveIxs;
    /**
     * This will trigger invest by balancing, based on weights, the reserve allocations of the vault. It can either withdraw or deposit into reserves to balance them. This is a function that should be cranked
     * @param payer wallet that pays the tx
     * @param vault - vault to invest from
     * @param skipComputationChecks - if true, the function will skip the computation checks and will invest all the reserves; it is useful for txs where we update reserve allocations and invest atomically
     * @returns - an array of invest instructions for each invest action required for the vault reserves
     */
    investAllReservesIxs(payer: TransactionSigner, vault: KaminoVault, skipComputationChecks?: boolean): Promise<Instruction[]>;
    /**
     * This will trigger invest by balancing, based on weights, the reserve allocation of the vault. It can either withdraw or deposit into the given reserve to balance it
     * @param payer wallet pubkey - the instruction is permissionless and does not require the vault admin, due to rounding between cTokens and the underlying, the payer may have to contribute 1 or more lamports of the underlying from their token account
     * @param vault - vault to invest from
     * @param reserve - reserve to invest into or disinvest from
     * @param [vaultReservesMap] - optional parameter; a hashmap from each reserve pubkey to the reserve state. If provided the function will be significantly faster as it will not have to fetch the reserves
     * @param [createAtaIfNeeded]
     * @returns - an array of invest instructions for each invest action required for the vault reserves
     */
    investSingleReserveIxs(payer: TransactionSigner, vault: KaminoVault, reserve: ReserveWithAddress, vaultReservesMap?: Map<Address, KaminoReserve>, createAtaIfNeeded?: boolean): Promise<Instruction[]>;
    /** Convert a string to a u8 representation to be stored on chain */
    encodeVaultName(token: string): Uint8Array;
    /**Convert an u8 array to a string */
    decodeVaultName(token: number[]): string;
    private withdrawIx;
    private withdrawFromAvailableIx;
    private withdrawPendingFeesIx;
    /**
     * Sync a vault for lookup table; create and set the LUT for the vault if needed and fill it with all the needed accounts
     * @param authority - vault admin
     * @param vault the vault to sync and set the LUT for if needed
     * @param [vaultReservesMap] - optional parameter; a hashmap from each reserve pubkey to the reserve state. Optional. If provided the function will be significantly faster as it will not have to fetch the reserves
     * @returns a struct that contains a list of ix to create the LUT and assign it to the vault if needed + a list of ixs to insert all the accounts in the LUT
     */
    syncVaultLookupTableIxs(authority: TransactionSigner, vault: KaminoVault, vaultReservesMap?: Map<Address, KaminoReserve>): Promise<SyncVaultLUTIxs>;
    private getReserveAccountsToInsertInLut;
    /** Read the total holdings of a vault and the reserve weights and returns a map from each reserve to how many tokens should be deposited.
     * @param vaultState - the vault state to calculate the allocation for
     * @param [slot] - the slot for which to calculate the allocation. Optional. If not provided the function will fetch the current slot
     * @param [vaultReserves] - a hashmap from each reserve pubkey to the reserve state. Optional. If provided the function will be significantly faster as it will not have to fetch the reserves
     * @param [currentSlot] - the latest confirmed slot. Optional. If provided the function will be  faster as it will not have to fetch the latest slot
     * @returns - a map from each reserve to how many tokens should be invested into
     */
    getVaultComputedReservesAllocation(vaultState: VaultState, slot?: Slot, vaultReserves?: Map<Address, KaminoReserve>, currentSlot?: Slot): Promise<VaultComputedAllocation>;
    private computeReservesAllocation;
    /**
     * This method returns the user shares balance for a given vault
     * @param user - user to calculate the shares balance for
     * @param vault - vault to calculate shares balance for
     * @returns - user share balance in tokens (not lamports)
     */
    getUserSharesBalanceSingleVault(user: Address, vault: KaminoVault): Promise<UserSharesForVault>;
    /**
     * This method returns the user shares balance for all existing vaults
     * @param user - user to calculate the shares balance for
     * @param [vaultsOverride] - the kamino vaults if already fetched, in order to reduce rpc calls.Optional
     * @returns - hash map with keys as vault address and value as user share balance in decimal (not lamports)
     */
    getUserSharesBalanceAllVaults(user: Address, vaultsOverride?: Array<KaminoVault>): Promise<Map<Address, UserSharesForVault>>;
    /**
     * This method returns the management and performance fee percentages
     * @param vaultState - vault to retrieve the fees percentages from
     * @returns - VaultFeesPct containing management and performance fee percentages
     */
    getVaultFeesPct(vaultState: VaultState): VaultFeesPct;
    /**
     * This method calculates the token per share value. This will always change based on interest earned from the vault, but calculating it requires a bunch of rpc requests. Caching this for a short duration would be optimal
     * @param vaultState - vault state to calculate tokensPerShare for
     * @param [slot] - the slot at which we retrieve the tokens per share. Optional. If not provided, the function will fetch the current slot
     * @param [vaultReservesMap] - hashmap from each reserve pubkey to the reserve state. Optional. If provided the function will be significantly faster as it will not have to fetch the reserves
     * @param [currentSlot] - the latest confirmed slot. Optional. If provided the function will be  faster as it will not have to fetch the latest slot
     * @returns - token per share value
     */
    getTokensPerShareSingleVault(vaultOrState: KaminoVault | VaultState, slot?: Slot, vaultReservesMap?: Map<Address, KaminoReserve>, currentSlot?: Slot): Promise<Decimal>;
    /**
     * This method calculates the token per share value. This will always change based on interest earned from the vault, but calculating it requires a bunch of rpc requests. Caching this for a short duration would be optimal
     * @param [vaultsOverride] - a list of vaults to get the tokens per share for; if provided with state it will not fetch the state again. Optional
     * @param [vaultReservesMap] - optional parameter; a hashmap from each reserve pubkey to the reserve state. Optional. If provided the function will be significantly faster as it will not have to fetch the reserves
     * @param slot - current slot, used to estimate the interest earned in the different reserves with allocation from the vault
     * @returns - token per share value
     */
    getTokensPerShareAllVaults(slot: Slot, vaultsOverride?: Array<KaminoVault>, vaultReservesMap?: Map<Address, KaminoReserve>): Promise<Map<Address, Decimal>>;
    /**
     * Get all vaults
     * @returns an array of all vaults
     */
    getAllVaults(): Promise<KaminoVault[]>;
    /**
     * Get all vaults for a given token
     * @param token - the token to get all vaults for
     * @returns an array of all vaults for the given token
     */
    getAllVaultsForToken(token: Address): Promise<Array<KaminoVault>>;
    private getAllVaultsWithFilter;
    /**
     * Get a list of kaminoVaults
     * @param vaults - a list of vaults to get the states for; if not provided, all vaults will be fetched
     * @returns a list of vaults
     */
    getVaults(vaults?: Array<Address>): Promise<Array<KaminoVault | null>>;
    private getVaultsStates;
    /**
     * This will return the amount of token invested from the vault into the given reserve
     * @param vaultState - the kamino vault to get invested amount in reserve for
     * @param slot - current slot
     * @param reserve - the reserve state to get vault invested amount in
     * @returns vault amount supplied in reserve in decimal
     */
    getSuppliedInReserve(vaultState: VaultState, slot: Slot, reserve: KaminoReserve): Decimal;
    /**
     * This will return the a map between reserve pubkey and the pct of the vault invested amount in each reserve
     * @param vaultState - the kamino vault to get reserves distribution for
     * @returns a map between reserve pubkey and the allocation pct for the reserve
     */
    getAllocationsDistribuionPct(vaultState: VaultState): Map<Address, Decimal>;
    /**
     * This will return the a map between reserve pubkey and the allocation overview for the reserve
     * @param vaultState - the kamino vault to get reserves allocation overview for
     * @returns a map between reserve pubkey and the allocation overview for the reserve
     */
    getVaultAllocations(vaultState: VaultState): Map<Address, ReserveAllocationOverview>;
    /**
     * This will return an unsorted hash map of all reserves that the given vault has allocations for, toghether with the amount that can be withdrawn from each of the reserves
     * @param vault - the kamino vault to get available liquidity to withdraw for
     * @param slot - current slot
     *@param [vaultReservesMap] - a hashmap from each reserve pubkey to the reserve state
     * @returns an HashMap of reserves (key) with the amount available to withdraw for each (value)
     */
    private getReserveAllocationAvailableLiquidityToWithdraw;
    /**
     * This will get the list of all reserve pubkeys that the vault has allocations for ex
     * @param vault - the vault state to load reserves for
     * @returns a hashmap from each reserve pubkey to the reserve state
     */
    getVaultReserves(vault: VaultState): Address[];
    /**
     * This will load the onchain state for all the reserves that the vault has allocations for
     * @param vaultState - the vault state to load reserves for
     * @returns a hashmap from each reserve pubkey to the reserve state
     */
    loadVaultReserves(vaultState: VaultState): Promise<Map<Address, KaminoReserve>>;
    private loadReserializedReserves;
    /**
     * This will load the onchain state for all the reserves that the vaults have allocations for, deduplicating the reserves
     * @param vaults - the vault states to load reserves for
     * @param oracleAccounts (optional) all reserve oracle accounts, if not supplied will make an additional rpc call to fetch these accounts
     * @returns a hashmap from each reserve pubkey to the reserve state
     */
    loadVaultsReserves(vaults: VaultState[], oracleAccounts?: AllOracleAccounts): Promise<Map<Address, KaminoReserve>>;
    /**
     * This will retrieve all the tokens that can be used as collateral by the users who borrow the token in the vault alongside details about the min and max loan to value ratio
     * @param vaultState - the vault state to load reserves for
     * @param [slot] - the slot for which to retrieve the vault collaterals for. Optional. If not provided the function will fetch the current slot
     * @param [vaultReservesMap] - hashmap from each reserve pubkey to the reserve state. Optional. If provided the function will be significantly faster as it will not have to fetch the reserves
     * @param [kaminoMarkets] - a list of all the kamino markets. Optional. If provided the function will be significantly faster as it will not have to fetch the markets
     * @param oracleAccounts (optional) all reserve oracle accounts, if not supplied will make an additional rpc call to fetch these accounts
     * @returns a hashmap from each reserve pubkey to the market overview of the collaterals that can be used and the min and max loan to value ratio in that market
     */
    getVaultCollaterals(vaultState: VaultState, slot: Slot, vaultReservesMap?: Map<Address, KaminoReserve>, kaminoMarkets?: KaminoMarket[], oracleAccounts?: AllOracleAccounts): Promise<Map<Address, MarketOverview>>;
    /**
     * This will return an VaultHoldings object which contains the amount available (uninvested) in vault, total amount invested in reseves and a breakdown of the amount invested in each reserve
     * @param vault - the kamino vault to get available liquidity to withdraw for
     * @param [slot] - the slot for which to calculate the holdings. Optional. If not provided the function will fetch the current slot
     * @param [vaultReserves] - a hashmap from each reserve pubkey to the reserve state. Optional. If provided the function will be significantly faster as it will not have to fetch the reserves
     * @param [currentSlot] - the latest confirmed slot. Optional. If provided the function will be  faster as it will not have to fetch the latest slot
     * @returns an VaultHoldings object representing the amount available (uninvested) in vault, total amount invested in reseves and a breakdown of the amount invested in each reserve
     */
    getVaultHoldings(vault: VaultState, slot?: Slot, vaultReserves?: Map<Address, KaminoReserve>, currentSlot?: Slot): Promise<VaultHoldings>;
    /**
     * This will return an VaultOverview object that encapsulates all the information about the vault, including the holdings, reserves details, theoretical APY, utilization ratio and total borrowed amount
     * @param vault - the kamino vault to get available liquidity to withdraw for
     * @param price - the price of the token in the vault (e.g. USDC)
     * @param [slot] - the slot for which to retrieve the vault overview for. Optional. If not provided the function will fetch the current slot
     * @param [vaultReservesMap] - hashmap from each reserve pubkey to the reserve state. Optional. If provided the function will be significantly faster as it will not have to fetch the reserves
     * @param [currentSlot] - the latest confirmed slot. Optional. If provided the function will be  faster as it will not have to fetch the latest slot
     * @returns an VaultOverview object with details about the tokens available and invested in the vault, denominated in tokens and USD
     */
    getVaultHoldingsWithPrice(vault: VaultState, price: Decimal, slot?: Slot, vaultReservesMap?: Map<Address, KaminoReserve>, currentSlot?: Slot): Promise<VaultHoldingsWithUSDValue>;
    /**
     * This will return an VaultOverview object that encapsulates all the information about the vault, including the holdings, reserves details, theoretical APY, utilization ratio and total borrowed amount
     * @param vault - the kamino vault to get available liquidity to withdraw for
     * @param vaultTokenPrice - the price of the token in the vault (e.g. USDC)
     * @param [slot] - the slot for which to retrieve the vault overview for. Optional. If not provided the function will fetch the current slot
     * @param [vaultReservesMap] - hashmap from each reserve pubkey to the reserve state. Optional. If provided the function will be significantly faster as it will not have to fetch the reserves
     * @param [kaminoMarkets] - a list of all kamino markets. Optional. If provided the function will be significantly faster as it will not have to fetch the markets
     * @param [currentSlot] - the latest confirmed slot. Optional. If provided the function will be  faster as it will not have to fetch the latest slot
     * @param [tokensPrices] - a hashmap from a token pubkey to the price of the token in USD. Optional. If some tokens are not in the map, the function will fetch the price
     * @returns an VaultOverview object with details about the tokens available and invested in the vault, denominated in tokens and USD, along sie APYs
     */
    getVaultOverview(vault: VaultState, vaultTokenPrice: Decimal, slot?: Slot, vaultReservesMap?: Map<Address, KaminoReserve>, kaminoMarkets?: KaminoMarket[], currentSlot?: Slot, tokensPrices?: Map<Address, Decimal>): Promise<VaultOverview>;
    /**
     * This will return an aggregation of the current state of the vault with all the invested amounts and the utilization ratio of the vault
     * @param vault - the kamino vault to get available liquidity to withdraw for
     * @param slot - current slot
     * @param [vaultReservesMap] - hashmap from each reserve pubkey to the reserve state. Optional. If provided the function will be significantly faster as it will not have to fetch the reserves
     * @returns an VaultReserveTotalBorrowedAndInvested object with the total invested amount, total borrowed amount and the utilization ratio of the vault
     */
    getTotalBorrowedAndInvested(vault: VaultState, slot: Slot, vaultReservesMap?: Map<Address, KaminoReserve>): Promise<VaultReserveTotalBorrowedAndInvested>;
    /**
     * This will return an overview of each reserve that is part of the vault allocation
     * @param vault - the kamino vault to get available liquidity to withdraw for
     * @param slot - current slot
     * @param [vaultReservesMap] - hashmap from each reserve pubkey to the reserve state. Optional. If provided the function will be significantly faster as it will not have to fetch the reserves
     * @returns a hashmap from vault reserve pubkey to ReserveOverview object
     */
    getVaultReservesDetails(vault: VaultState, slot: Slot, vaultReserves?: Map<Address, KaminoReserve>): Promise<Map<Address, ReserveOverview>>;
    /**
     * This will return the APY of the vault under the assumption that all the available tokens in the vault are all the time invested in the reserves as requested by the weights; for percentage it needs multiplication by 100
     * @param vault - the kamino vault to get APY for
     * @param slot - current slot
     * @param [vaultReservesMap] - hashmap from each reserve pubkey to the reserve state. Optional. If provided the function will be significantly faster as it will not have to fetch the reserves
     * @returns a struct containing estimated gross APY and net APY (gross - vault fees) for the vault
     */
    getVaultTheoreticalAPY(vault: VaultState, slot: Slot, vaultReservesMap?: Map<Address, KaminoReserve>): Promise<APYs>;
    /**
     * This will return the APY of the vault based on the current invested amounts; for percentage it needs multiplication by 100
     * @param vault - the kamino vault to get APY for
     * @param slot - current slot
     * @param [vaultReservesMap] - hashmap from each reserve pubkey to the reserve state. Optional. If provided the function will be significantly faster as it will not have to fetch the reserves
     * @returns a struct containing estimated gross APY and net APY (gross - vault fees) for the vault
     */
    getVaultActualAPY(vault: VaultState, slot: Slot, vaultReservesMap?: Map<Address, KaminoReserve>): Promise<APYs>;
    /**
     * Retrive the total amount of interest earned by the vault since its inception, up to the last interaction with the vault on chain, including what was charged as fees
     * @param vaultState the kamino vault state to get total net yield for
     * @returns a struct containing a Decimal representing the net number of tokens earned by the vault since its inception and the timestamp of the last fee charge
     */
    getVaultCumulativeInterest(vaultState: VaultState): Promise<VaultCumulativeInterestWithTimestamp>;
    /**
     * Simulate the current holdings of the vault and the earned interest
     * @param vaultState the kamino vault state to get simulated holdings and earnings for
     * @param [vaultReservesMap] - hashmap from each reserve pubkey to the reserve state. Optional. If provided the function will be significantly faster as it will not have to fetch the reserves
     * @param [currentSlot] - the current slot. Optional. If not provided it will fetch the current slot
     * @param [previousNetAUM] - the previous AUM of the vault to compute the earned interest relative to this value. Optional. If not provided the function will estimate the total AUM at the slot of the last state update on chain
     * @param [currentSlot] - the latest confirmed slot. Optional. If provided the function will be  faster as it will not have to fetch the latest slot
     * @returns a struct of simulated vault holdings and earned interest
     */
    calculateSimulatedHoldingsWithInterest(vaultState: VaultState, vaultReservesMap?: Map<Address, KaminoReserve>, slot?: Slot, previousNetAUM?: Decimal, currentSlot?: Slot): Promise<SimulatedVaultHoldingsWithEarnedInterest>;
    /**
     * Simulate the current holdings and compute the fees that would be charged
     * @param vaultState the kamino vault state to get simulated fees for
     * @param [simulatedCurrentHoldingsWithInterest] the simulated holdings and interest earned by the vault. Optional
     * @param [currentTimestamp] the current date. Optional. If not provided it will fetch the current unix timestamp
     * @returns a VaultFees struct of simulated management and interest fees
     */
    calculateSimulatedFees(vaultState: VaultState, simulatedCurrentHoldingsWithInterest?: SimulatedVaultHoldingsWithEarnedInterest, currentTimestamp?: Date): Promise<VaultFees>;
    /**
     * This will compute the PDA that is used as delegatee in Farms program to compute the user state PDA for vault depositor investing in vault with reserve having a supply farm
     */
    computeUserFarmStateDelegateePDAForUserInVault(farmsProgramId: Address, vault: Address, reserve: Address, user: Address): Promise<ProgramDerivedAddress>;
    /**
     * Read the APY of the farm built on top of the vault (farm in vaultState.vaultFarm)
     * @param vault - the vault to read the farm APY for
     * @param vaultTokenPrice - the price of the vault token in USD (e.g. 1.0 for USDC)
     * @param [farmsClient] - the farms client to use. Optional. If not provided, the function will create a new one
     * @param [slot] - the slot to read the farm APY for. Optional. If not provided, the function will read the current slot
     * @returns the APY of the farm built on top of the vault
     */
    getVaultRewardsAPY(vaultOrState: KaminoVault | VaultState, vaultTokenPrice: Decimal, farmsClient?: Farms, slot?: Slot, tokensPrices?: Map<Address, Decimal>): Promise<FarmIncentives>;
    /**
     * Get all the token mints of the vault, vault farm rewards and the allocation  rewards
     * @param vaults - the vaults to get the token mints for
     * @param [vaultReservesMap] - the vault reserves map to get the reserves for; if not provided, the function will fetch the reserves
     * @param farmsMap - the farms map to get the farms for
     * @returns a set of token mints
     */
    getAllVaultsTokenMintsIncludingRewards(vaults: KaminoVault[], vaultReservesMap?: Map<Address, KaminoReserve>, farmsMap?: Map<Address, FarmState>): Promise<Set<Address>>;
    getVaultReservesFarmsIncentives(vaultOrState: KaminoVault | VaultState, vaultTokenPrice: Decimal, farmsClient?: Farms, slot?: Slot, vaultReservesMap?: Map<Address, KaminoReserve>, tokensPrices?: Map<Address, Decimal>): Promise<VaultReservesFarmsIncentives>;
    private appendRemainingAccountsForVaultReserves;
}
export declare class KaminoVault {
    readonly address: Address;
    state: VaultState | undefined | null;
    programId: Address;
    constructor(vaultAddress: Address, state?: VaultState, programId?: Address);
    getState(rpc: Rpc<GetAccountInfoApi>): Promise<VaultState>;
    reloadState(rpc: Rpc<GetAccountInfoApi>): Promise<VaultState>;
    hasFarm(rpc: Rpc<GetAccountInfoApi>): Promise<boolean>;
}
/**
 * Used to initialize a Kamino Vault
 */
export declare class KaminoVaultConfig {
    /** The admin of the vault */
    readonly admin: TransactionSigner;
    /** The token mint for the vault */
    readonly tokenMint: Address;
    /** The token mint program id */
    readonly tokenMintProgramId: Address;
    /** The performance fee rate of the vault, as percents, expressed as a decimal */
    readonly performanceFeeRatePercentage: Decimal;
    /** The management fee rate of the vault, as percents, expressed as a decimal */
    readonly managementFeeRatePercentage: Decimal;
    /** The name to be stored on chain for the vault (max 40 characters). */
    readonly name: string;
    /** The symbol of the vault token to be stored (max 5 characters). E.g. USDC for a vault using USDC as token. */
    readonly vaultTokenSymbol: string;
    /** The name of the vault token to be stored (max 10 characters), after the prefix `Kamino Vault <vaultTokenSymbol>`. E.g. USDC Vault for a vault using USDC as token. */
    readonly vaultTokenName: string;
    constructor(args: {
        admin: TransactionSigner;
        tokenMint: Address;
        tokenMintProgramId: Address;
        performanceFeeRatePercentage: Decimal;
        managementFeeRatePercentage: Decimal;
        name: string;
        vaultTokenSymbol: string;
        vaultTokenName: string;
    });
    getPerformanceFeeBps(): number;
    getManagementFeeBps(): number;
}
export declare class ReserveAllocationConfig {
    readonly reserve: ReserveWithAddress;
    readonly targetAllocationWeight: number;
    readonly allocationCapDecimal: Decimal;
    constructor(reserve: ReserveWithAddress, targetAllocationWeight: number, allocationCapDecimal: Decimal);
    getAllocationCapLamports(): Decimal;
    getReserveState(): Reserve;
    getReserveAddress(): Address;
}
export declare function getCTokenVaultPda(vaultAddress: Address, reserveAddress: Address, kaminoVaultProgramId: Address): Promise<Address>;
export declare function getEventAuthorityPda(kaminoVaultProgramId: Address): Promise<Address>;
export type VaultHolder = {
    holderPubkey: Address;
    amount: Decimal;
};
export type VaultHoldings = {
    available: Decimal;
    invested: Decimal;
    investedInReserves: Map<Address, Decimal>;
    pendingFees: Decimal;
    totalAUMIncludingFees: Decimal;
};
/**
 * earnedInterest represents the interest earned from now until the slot provided in the future
 */
export type SimulatedVaultHoldingsWithEarnedInterest = {
    holdings: VaultHoldings;
    earnedInterest: Decimal;
};
export type VaultHoldingsWithUSDValue = {
    holdings: VaultHoldings;
    availableUSD: Decimal;
    investedUSD: Decimal;
    investedInReservesUSD: Map<Address, Decimal>;
    totalUSDIncludingFees: Decimal;
    pendingFeesUSD: Decimal;
};
export type ReserveOverview = {
    supplyAPY: Decimal;
    utilizationRatio: Decimal;
    liquidationThresholdPct: Decimal;
    totalBorrowedAmount: Decimal;
    amountBorrowedFromSupplied: Decimal;
    suppliedAmount: Decimal;
    market: Address;
};
export type VaultReserveTotalBorrowedAndInvested = {
    totalInvested: Decimal;
    totalBorrowed: Decimal;
    utilizationRatio: Decimal;
};
export type MarketOverview = {
    address: Address;
    reservesAsCollateral: ReserveAsCollateral[];
    minLTVPct: Decimal;
    maxLTVPct: Decimal;
};
export type ReserveAsCollateral = {
    mint: Address;
    liquidationLTVPct: Decimal;
    address: Address;
};
export type VaultOverview = {
    holdingsUSD: VaultHoldingsWithUSDValue;
    reservesOverview: Map<Address, ReserveOverview>;
    vaultCollaterals: Map<Address, MarketOverview>;
    theoreticalSupplyAPY: APYs;
    actualSupplyAPY: APYs;
    vaultFarmIncentives: FarmIncentives;
    reservesFarmsIncentives: VaultReservesFarmsIncentives;
    totalBorrowed: Decimal;
    totalBorrowedUSD: Decimal;
    totalSupplied: Decimal;
    totalSuppliedUSD: Decimal;
    utilizationRatio: Decimal;
};
export type VaultReservesFarmsIncentives = {
    reserveFarmsIncentives: Map<Address, FarmIncentives>;
    totalIncentivesAPY: Decimal;
};
export type VaultFeesPct = {
    managementFeePct: Decimal;
    performanceFeePct: Decimal;
};
export type VaultFees = {
    managementFee: Decimal;
    performanceFee: Decimal;
};
export type VaultCumulativeInterestWithTimestamp = {
    cumulativeInterest: Decimal;
    timestamp: number;
};
export declare function printHoldings(holdings: VaultHoldings): void;
//# sourceMappingURL=vault.d.ts.map
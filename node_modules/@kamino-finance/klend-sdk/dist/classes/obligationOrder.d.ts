import { ObligationOrder } from '../@codegen/klend/types';
import Decimal from 'decimal.js';
import { KaminoObligation, Position } from './obligation';
import { TokenAmount } from './shared';
import { KaminoMarket } from './market';
/**
 * A condition "activating" an order.
 *
 * When a {@link KaminoObligationOrder.condition} is met by an obligation, the corresponding
 * {@link KaminoObligationOrder.opportunity} becomes available to liquidators.
 */
export interface OrderCondition {
    /**
     * An abstract parameter of the condition, meaningful in context of the condition's type.
     */
    threshold(): Decimal;
    /**
     * Returns a potential hit on this condition.
     */
    evaluate(obligation: KaminoObligation): ConditionHit | null;
}
/**
 * An "opportunity" of an order - i.e. a type and size of a trade made available by the order (provided that its
 * {@link KaminoObligationOrder.condition} is met).
 */
export interface OrderOpportunity {
    /**
     * An abstract parameter of the condition, meaningful in context of the condition's type.
     */
    parameter(): Decimal;
    /**
     * Returns the highest-valued {@link TokenAmount} that can be repaid (among the given borrows) using this opportunity.
     */
    getMaxRepay(borrows: Array<Position>): TokenAmount;
}
/**
 * A condition met when obligation's overall "User LTV" is strictly higher than the given threshold.
 */
export declare class UserLtvAbove implements OrderCondition {
    readonly minUserLtvExclusive: Decimal;
    constructor(minUserLtvExclusive: Decimal.Value);
    threshold(): Decimal;
    evaluate(obligation: KaminoObligation): ConditionHit | null;
}
/**
 * A condition met when obligation's overall "User LTV" is strictly lower than the given threshold.
 */
export declare class UserLtvBelow implements OrderCondition {
    readonly maxUserLtvExclusive: Decimal;
    constructor(maxUserLtvExclusive: Decimal.Value);
    threshold(): Decimal;
    evaluate(obligation: KaminoObligation): ConditionHit | null;
}
/**
 * A condition met when the obligation's collateral token price (expressed in the debt token) is strictly higher than
 * the given threshold.
 *
 * May only be applied to single-collateral, single-debt obligations.
 */
export declare class DebtCollPriceRatioAbove implements OrderCondition {
    readonly minDebtCollPriceRatioExclusive: Decimal;
    constructor(minDebtCollPriceRatioExclusive: Decimal.Value);
    threshold(): Decimal;
    evaluate(obligation: KaminoObligation): ConditionHit | null;
}
/**
 * A condition met when the obligation's collateral token price (expressed in the debt token) is strictly higher than
 * the given threshold.
 *
 * May only be applied to single-collateral, single-debt obligations.
 */
export declare class DebtCollPriceRatioBelow implements OrderCondition {
    readonly maxDebtCollPriceRatioExclusive: Decimal;
    constructor(maxDebtCollPriceRatioExclusive: Decimal.Value);
    threshold(): Decimal;
    evaluate(obligation: KaminoObligation): ConditionHit | null;
}
/**
 * An opportunity for repaying the given amount of the obligation's debt token.
 *
 * May only be applied to single-debt obligations.
 */
export declare class DeleverageDebtAmount implements OrderOpportunity {
    readonly amount: Decimal;
    constructor(amount: Decimal.Value);
    parameter(): Decimal;
    getMaxRepay(borrows: Array<Position>): TokenAmount;
}
/**
 * An opportunity for repaying all debt(s) of an obligation.
 */
export declare class DeleverageAllDebt implements OrderOpportunity {
    /**
     * The only legal value for the {@link parameter()} of this opportunity type.
     */
    static FRACTION_MAX: Decimal;
    constructor(fixed_parameter?: Decimal.Value);
    parameter(): Decimal;
    getMaxRepay(borrows: Array<Position>): TokenAmount;
}
/**
 * A business wrapper around the on-chain {@link ObligationOrder} account data.
 */
export declare class KaminoObligationOrder {
    /**
     * An on-chain data representing a `null` order.
     */
    static NULL_STATE: ObligationOrder;
    /**
     * The order's condition.
     */
    readonly condition: OrderCondition;
    /**
     * The order's opportunity.
     */
    readonly opportunity: OrderOpportunity;
    /**
     * The minimum bonus rate (e.g. `0.01` meaning "1%") offered to a liquidator executing this order when its condition
     * threshold has been barely crossed.
     */
    readonly minExecutionBonusRate: Decimal;
    /**
     * The maximum bonus rate (e.g. `0.04` meaning "4%") offered to a liquidator executing this order when its condition
     * threshold has already been exceeded by a very large margin (to be specific: maximum possible margin - e.g. for
     * LTV-based stop-loss order, that would be when the obligation's LTV is approaching its liquidation LTV).
     */
    readonly maxExecutionBonusRate: Decimal;
    /**
     * Direct constructor.
     *
     * Please see {@link fromState()} if you are constructing an instance representing existing on-chain data.
     */
    constructor(condition: OrderCondition, opportunity: OrderOpportunity, minExecutionBonusRate: Decimal, maxExecutionBonusRate?: Decimal);
    /**
     * Returns the highest-valued {@link AvailableOrderExecution} currently offered by this order.
     *
     * May return `undefined` when the order's condition is not met.
     */
    findMaxAvailableExecution(kaminoMarket: KaminoMarket, obligation: KaminoObligation): AvailableOrderExecution | undefined;
    /**
     * Constructs an instance based on the given on-chain data.
     *
     * Returns `null` if the input represents just an empty slot in the orders' array.
     */
    static fromState(state: ObligationOrder): KaminoObligationOrder | null;
    /**
     * Returns the on-chain state represented by this instance.
     *
     * See {@link NULL_STATE} for the state of a `null` order.
     */
    toState(): ObligationOrder;
    /**
     * Binds this order to the given slot.
     *
     * This is just a convenience method for easier interaction with {@link KaminoAction#buildSetObligationOrderIxn()}.
     */
    atIndex(index: number): ObligationOrderAtIndex;
    /**
     * Calculates the given order's actual execution bonus rate.
     *
     * The min-max bonus range is configured by the user on a per-order basis, and the actual value is interpolated based
     * on the given obligation's state at the moment of order execution.
     * In short: the minimum bonus applies if the order is executed precisely at the point when the condition is met.
     * Then, as the distance from condition's threshold grows, the bonus approaches the configured maximum.
     *
     * On top of that, similar to regular liquidation, the bonus cannot exceed the ceiled limit of `1.0 - user_no_bf_ltv`
     * (which ensures that order execution improves LTV).
     */
    private calculateExecutionBonusRate;
}
/**
 * A single slot within {@link Obligation.orders} (which may contain an order or not).
 *
 * This is used as an argument to {@link KaminoAction.buildSetObligationOrderIxn()} to easily set or cancel an order.
 */
export declare class ObligationOrderAtIndex {
    index: number;
    order: KaminoObligationOrder | null;
    constructor(index: number, order: KaminoObligationOrder | null);
    /**
     * Creates an empty slot representation (suitable for cancelling an order).
     */
    static empty(index: number): ObligationOrderAtIndex;
    /**
     * Returns the on-chain state of the order (potentially a zeroed account data, if the order is not set).
     */
    orderState(): ObligationOrder;
}
/**
 * Numeric details on why an order's condition was met.
 */
export type ConditionHit = {
    /**
     * The distance between the current value (e.g. "current LTV") and the condition's
     * threshold (e.g. "when LTV > 70%"), normalized with regard to the most extreme value
     * (e.g. "liquidation LTV = 90%").
     *
     *  Following the above example:
     *  - when current LTV = 70% (i.e. at condition threshold), this normalized distance is `0`,
     *  - when current LTV = 90% (i.e. at liquidation point), this normalized distance is `1`,
     *  - when current LTV = 82% (i.e. some number in-between), this normalized distance is `0.6`.
     *
     *  In other words: this is a `[0; 1]` measure of how hard the condition threshold is crossed.
     */
    normalizedDistanceFromThreshold: Decimal;
};
/**
 * A potential exchange of tokens resulting from order execution.
 */
export type AvailableOrderExecution = {
    /**
     * How much (and of what token) to repay.
     */
    repay: TokenAmount;
    /**
     * How much (and of what other token) can be withdrawn in exchange.
     *
     * Note: This amount already *includes* the execution bonus (see `bonusRate` below), but does *not* take the protocol
     * fee into account (see `ReserveConfig.protocolOrderExecutionFeePct`).
     */
    withdraw: TokenAmount;
    /**
     * The bonus rate (e.g. `0.01` meaning 1%), computed based on the configured execution bonus range and the safety
     * ceiling.
     *
     * Note: this bonus is still subject to the protocol fee.
     */
    bonusRate: Decimal;
};
//# sourceMappingURL=obligationOrder.d.ts.map
import { Address, GetAccountInfoApi, GetMultipleAccountsApi, Rpc } from "@solana/kit";
import BN from "bn.js";
import * as types from "../types";
export interface AggregatorAccountDataFields {
    name: Array<number>;
    metadata: Array<number>;
    reserved1: Array<number>;
    queuePubkey: Address;
    oracleRequestBatchSize: number;
    minOracleResults: number;
    minJobResults: number;
    minUpdateDelaySeconds: number;
    startAfter: BN;
    varianceThreshold: types.SwitchboardDecimalFields;
    forceReportPeriod: BN;
    expiration: BN;
    consecutiveFailureCount: BN;
    nextAllowedUpdateTime: BN;
    isLocked: boolean;
    crankPubkey: Address;
    latestConfirmedRound: types.AggregatorRoundFields;
    currentRound: types.AggregatorRoundFields;
    jobPubkeysData: Array<Address>;
    jobHashes: Array<types.HashFields>;
    jobPubkeysSize: number;
    jobsChecksum: Array<number>;
    authority: Address;
    historyBuffer: Address;
    previousConfirmedRoundResult: types.SwitchboardDecimalFields;
    previousConfirmedRoundSlot: BN;
    disableCrank: boolean;
    jobWeights: Array<number>;
    creationTimestamp: BN;
    resolutionMode: types.AggregatorResolutionModeKind;
    basePriorityFee: number;
    priorityFeeBump: number;
    priorityFeeBumpPeriod: number;
    maxPriorityFeeMultiplier: number;
    ebuf: Array<number>;
}
export interface AggregatorAccountDataJSON {
    name: Array<number>;
    metadata: Array<number>;
    reserved1: Array<number>;
    queuePubkey: string;
    oracleRequestBatchSize: number;
    minOracleResults: number;
    minJobResults: number;
    minUpdateDelaySeconds: number;
    startAfter: string;
    varianceThreshold: types.SwitchboardDecimalJSON;
    forceReportPeriod: string;
    expiration: string;
    consecutiveFailureCount: string;
    nextAllowedUpdateTime: string;
    isLocked: boolean;
    crankPubkey: string;
    latestConfirmedRound: types.AggregatorRoundJSON;
    currentRound: types.AggregatorRoundJSON;
    jobPubkeysData: Array<string>;
    jobHashes: Array<types.HashJSON>;
    jobPubkeysSize: number;
    jobsChecksum: Array<number>;
    authority: string;
    historyBuffer: string;
    previousConfirmedRoundResult: types.SwitchboardDecimalJSON;
    previousConfirmedRoundSlot: string;
    disableCrank: boolean;
    jobWeights: Array<number>;
    creationTimestamp: string;
    resolutionMode: types.AggregatorResolutionModeJSON;
    basePriorityFee: number;
    priorityFeeBump: number;
    priorityFeeBumpPeriod: number;
    maxPriorityFeeMultiplier: number;
    ebuf: Array<number>;
}
export declare class AggregatorAccountData {
    readonly name: Array<number>;
    readonly metadata: Array<number>;
    readonly reserved1: Array<number>;
    readonly queuePubkey: Address;
    readonly oracleRequestBatchSize: number;
    readonly minOracleResults: number;
    readonly minJobResults: number;
    readonly minUpdateDelaySeconds: number;
    readonly startAfter: BN;
    readonly varianceThreshold: types.SwitchboardDecimal;
    readonly forceReportPeriod: BN;
    readonly expiration: BN;
    readonly consecutiveFailureCount: BN;
    readonly nextAllowedUpdateTime: BN;
    readonly isLocked: boolean;
    readonly crankPubkey: Address;
    readonly latestConfirmedRound: types.AggregatorRound;
    readonly currentRound: types.AggregatorRound;
    readonly jobPubkeysData: Array<Address>;
    readonly jobHashes: Array<types.Hash>;
    readonly jobPubkeysSize: number;
    readonly jobsChecksum: Array<number>;
    readonly authority: Address;
    readonly historyBuffer: Address;
    readonly previousConfirmedRoundResult: types.SwitchboardDecimal;
    readonly previousConfirmedRoundSlot: BN;
    readonly disableCrank: boolean;
    readonly jobWeights: Array<number>;
    readonly creationTimestamp: BN;
    readonly resolutionMode: types.AggregatorResolutionModeKind;
    readonly basePriorityFee: number;
    readonly priorityFeeBump: number;
    readonly priorityFeeBumpPeriod: number;
    readonly maxPriorityFeeMultiplier: number;
    readonly ebuf: Array<number>;
    static readonly discriminator: Buffer<ArrayBuffer>;
    static readonly layout: import("buffer-layout").Layout<AggregatorAccountData>;
    constructor(fields: AggregatorAccountDataFields);
    static fetch(rpc: Rpc<GetAccountInfoApi>, address: Address, programId?: Address): Promise<AggregatorAccountData | null>;
    static fetchMultiple(rpc: Rpc<GetMultipleAccountsApi>, addresses: Address[], programId?: Address): Promise<Array<AggregatorAccountData | null>>;
    static decode(data: Buffer): AggregatorAccountData;
    toJSON(): AggregatorAccountDataJSON;
    static fromJSON(obj: AggregatorAccountDataJSON): AggregatorAccountData;
}
//# sourceMappingURL=AggregatorAccountData.d.ts.map
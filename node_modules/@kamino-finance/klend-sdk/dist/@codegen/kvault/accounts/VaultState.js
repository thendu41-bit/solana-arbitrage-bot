"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VaultState = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars */
const kit_1 = require("@solana/kit");
/* eslint-enable @typescript-eslint/no-unused-vars */
const bn_js_1 = __importDefault(require("bn.js")); // eslint-disable-line @typescript-eslint/no-unused-vars
const borsh = __importStar(require("@coral-xyz/borsh")); // eslint-disable-line @typescript-eslint/no-unused-vars
const utils_1 = require("../utils"); // eslint-disable-line @typescript-eslint/no-unused-vars
const types = __importStar(require("../types")); // eslint-disable-line @typescript-eslint/no-unused-vars
const programId_1 = require("../programId");
class VaultState {
    vaultAdminAuthority;
    baseVaultAuthority;
    baseVaultAuthorityBump;
    tokenMint;
    tokenMintDecimals;
    tokenVault;
    tokenProgram;
    sharesMint;
    sharesMintDecimals;
    tokenAvailable;
    sharesIssued;
    availableCrankFunds;
    unallocatedWeight;
    performanceFeeBps;
    managementFeeBps;
    lastFeeChargeTimestamp;
    prevAumSf;
    pendingFeesSf;
    vaultAllocationStrategy;
    padding1;
    minDepositAmount;
    minWithdrawAmount;
    minInvestAmount;
    minInvestDelaySlots;
    crankFundFeePerReserve;
    pendingAdmin;
    cumulativeEarnedInterestSf;
    cumulativeMgmtFeesSf;
    cumulativePerfFeesSf;
    name;
    vaultLookupTable;
    vaultFarm;
    creationTimestamp;
    unallocatedTokensCap;
    allocationAdmin;
    padding3;
    static discriminator = Buffer.from([
        228, 196, 82, 165, 98, 210, 235, 152,
    ]);
    static layout = borsh.struct([
        (0, utils_1.borshAddress)("vaultAdminAuthority"),
        (0, utils_1.borshAddress)("baseVaultAuthority"),
        borsh.u64("baseVaultAuthorityBump"),
        (0, utils_1.borshAddress)("tokenMint"),
        borsh.u64("tokenMintDecimals"),
        (0, utils_1.borshAddress)("tokenVault"),
        (0, utils_1.borshAddress)("tokenProgram"),
        (0, utils_1.borshAddress)("sharesMint"),
        borsh.u64("sharesMintDecimals"),
        borsh.u64("tokenAvailable"),
        borsh.u64("sharesIssued"),
        borsh.u64("availableCrankFunds"),
        borsh.u64("unallocatedWeight"),
        borsh.u64("performanceFeeBps"),
        borsh.u64("managementFeeBps"),
        borsh.u64("lastFeeChargeTimestamp"),
        borsh.u128("prevAumSf"),
        borsh.u128("pendingFeesSf"),
        borsh.array(types.VaultAllocation.layout(), 25, "vaultAllocationStrategy"),
        borsh.array(borsh.u128(), 256, "padding1"),
        borsh.u64("minDepositAmount"),
        borsh.u64("minWithdrawAmount"),
        borsh.u64("minInvestAmount"),
        borsh.u64("minInvestDelaySlots"),
        borsh.u64("crankFundFeePerReserve"),
        (0, utils_1.borshAddress)("pendingAdmin"),
        borsh.u128("cumulativeEarnedInterestSf"),
        borsh.u128("cumulativeMgmtFeesSf"),
        borsh.u128("cumulativePerfFeesSf"),
        borsh.array(borsh.u8(), 40, "name"),
        (0, utils_1.borshAddress)("vaultLookupTable"),
        (0, utils_1.borshAddress)("vaultFarm"),
        borsh.u64("creationTimestamp"),
        borsh.u64("unallocatedTokensCap"),
        (0, utils_1.borshAddress)("allocationAdmin"),
        borsh.array(borsh.u128(), 242, "padding3"),
    ]);
    constructor(fields) {
        this.vaultAdminAuthority = fields.vaultAdminAuthority;
        this.baseVaultAuthority = fields.baseVaultAuthority;
        this.baseVaultAuthorityBump = fields.baseVaultAuthorityBump;
        this.tokenMint = fields.tokenMint;
        this.tokenMintDecimals = fields.tokenMintDecimals;
        this.tokenVault = fields.tokenVault;
        this.tokenProgram = fields.tokenProgram;
        this.sharesMint = fields.sharesMint;
        this.sharesMintDecimals = fields.sharesMintDecimals;
        this.tokenAvailable = fields.tokenAvailable;
        this.sharesIssued = fields.sharesIssued;
        this.availableCrankFunds = fields.availableCrankFunds;
        this.unallocatedWeight = fields.unallocatedWeight;
        this.performanceFeeBps = fields.performanceFeeBps;
        this.managementFeeBps = fields.managementFeeBps;
        this.lastFeeChargeTimestamp = fields.lastFeeChargeTimestamp;
        this.prevAumSf = fields.prevAumSf;
        this.pendingFeesSf = fields.pendingFeesSf;
        this.vaultAllocationStrategy = fields.vaultAllocationStrategy.map((item) => new types.VaultAllocation({ ...item }));
        this.padding1 = fields.padding1;
        this.minDepositAmount = fields.minDepositAmount;
        this.minWithdrawAmount = fields.minWithdrawAmount;
        this.minInvestAmount = fields.minInvestAmount;
        this.minInvestDelaySlots = fields.minInvestDelaySlots;
        this.crankFundFeePerReserve = fields.crankFundFeePerReserve;
        this.pendingAdmin = fields.pendingAdmin;
        this.cumulativeEarnedInterestSf = fields.cumulativeEarnedInterestSf;
        this.cumulativeMgmtFeesSf = fields.cumulativeMgmtFeesSf;
        this.cumulativePerfFeesSf = fields.cumulativePerfFeesSf;
        this.name = fields.name;
        this.vaultLookupTable = fields.vaultLookupTable;
        this.vaultFarm = fields.vaultFarm;
        this.creationTimestamp = fields.creationTimestamp;
        this.unallocatedTokensCap = fields.unallocatedTokensCap;
        this.allocationAdmin = fields.allocationAdmin;
        this.padding3 = fields.padding3;
    }
    static async fetch(rpc, address, programId = programId_1.PROGRAM_ID) {
        const info = await (0, kit_1.fetchEncodedAccount)(rpc, address);
        if (!info.exists) {
            return null;
        }
        if (info.programAddress !== programId) {
            throw new Error(`VaultStateFields account ${address} belongs to wrong program ${info.programAddress}, expected ${programId}`);
        }
        return this.decode(Buffer.from(info.data));
    }
    static async fetchMultiple(rpc, addresses, programId = programId_1.PROGRAM_ID) {
        const infos = await (0, kit_1.fetchEncodedAccounts)(rpc, addresses);
        return infos.map((info) => {
            if (!info.exists) {
                return null;
            }
            if (info.programAddress !== programId) {
                throw new Error(`VaultStateFields account ${info.address} belongs to wrong program ${info.programAddress}, expected ${programId}`);
            }
            return this.decode(Buffer.from(info.data));
        });
    }
    static decode(data) {
        if (!data.slice(0, 8).equals(VaultState.discriminator)) {
            throw new Error("invalid account discriminator");
        }
        const dec = VaultState.layout.decode(data.slice(8));
        return new VaultState({
            vaultAdminAuthority: dec.vaultAdminAuthority,
            baseVaultAuthority: dec.baseVaultAuthority,
            baseVaultAuthorityBump: dec.baseVaultAuthorityBump,
            tokenMint: dec.tokenMint,
            tokenMintDecimals: dec.tokenMintDecimals,
            tokenVault: dec.tokenVault,
            tokenProgram: dec.tokenProgram,
            sharesMint: dec.sharesMint,
            sharesMintDecimals: dec.sharesMintDecimals,
            tokenAvailable: dec.tokenAvailable,
            sharesIssued: dec.sharesIssued,
            availableCrankFunds: dec.availableCrankFunds,
            unallocatedWeight: dec.unallocatedWeight,
            performanceFeeBps: dec.performanceFeeBps,
            managementFeeBps: dec.managementFeeBps,
            lastFeeChargeTimestamp: dec.lastFeeChargeTimestamp,
            prevAumSf: dec.prevAumSf,
            pendingFeesSf: dec.pendingFeesSf,
            vaultAllocationStrategy: dec.vaultAllocationStrategy.map((item /* eslint-disable-line @typescript-eslint/no-explicit-any */) => types.VaultAllocation.fromDecoded(item)),
            padding1: dec.padding1,
            minDepositAmount: dec.minDepositAmount,
            minWithdrawAmount: dec.minWithdrawAmount,
            minInvestAmount: dec.minInvestAmount,
            minInvestDelaySlots: dec.minInvestDelaySlots,
            crankFundFeePerReserve: dec.crankFundFeePerReserve,
            pendingAdmin: dec.pendingAdmin,
            cumulativeEarnedInterestSf: dec.cumulativeEarnedInterestSf,
            cumulativeMgmtFeesSf: dec.cumulativeMgmtFeesSf,
            cumulativePerfFeesSf: dec.cumulativePerfFeesSf,
            name: dec.name,
            vaultLookupTable: dec.vaultLookupTable,
            vaultFarm: dec.vaultFarm,
            creationTimestamp: dec.creationTimestamp,
            unallocatedTokensCap: dec.unallocatedTokensCap,
            allocationAdmin: dec.allocationAdmin,
            padding3: dec.padding3,
        });
    }
    toJSON() {
        return {
            vaultAdminAuthority: this.vaultAdminAuthority,
            baseVaultAuthority: this.baseVaultAuthority,
            baseVaultAuthorityBump: this.baseVaultAuthorityBump.toString(),
            tokenMint: this.tokenMint,
            tokenMintDecimals: this.tokenMintDecimals.toString(),
            tokenVault: this.tokenVault,
            tokenProgram: this.tokenProgram,
            sharesMint: this.sharesMint,
            sharesMintDecimals: this.sharesMintDecimals.toString(),
            tokenAvailable: this.tokenAvailable.toString(),
            sharesIssued: this.sharesIssued.toString(),
            availableCrankFunds: this.availableCrankFunds.toString(),
            unallocatedWeight: this.unallocatedWeight.toString(),
            performanceFeeBps: this.performanceFeeBps.toString(),
            managementFeeBps: this.managementFeeBps.toString(),
            lastFeeChargeTimestamp: this.lastFeeChargeTimestamp.toString(),
            prevAumSf: this.prevAumSf.toString(),
            pendingFeesSf: this.pendingFeesSf.toString(),
            vaultAllocationStrategy: this.vaultAllocationStrategy.map((item) => item.toJSON()),
            padding1: this.padding1.map((item) => item.toString()),
            minDepositAmount: this.minDepositAmount.toString(),
            minWithdrawAmount: this.minWithdrawAmount.toString(),
            minInvestAmount: this.minInvestAmount.toString(),
            minInvestDelaySlots: this.minInvestDelaySlots.toString(),
            crankFundFeePerReserve: this.crankFundFeePerReserve.toString(),
            pendingAdmin: this.pendingAdmin,
            cumulativeEarnedInterestSf: this.cumulativeEarnedInterestSf.toString(),
            cumulativeMgmtFeesSf: this.cumulativeMgmtFeesSf.toString(),
            cumulativePerfFeesSf: this.cumulativePerfFeesSf.toString(),
            name: this.name,
            vaultLookupTable: this.vaultLookupTable,
            vaultFarm: this.vaultFarm,
            creationTimestamp: this.creationTimestamp.toString(),
            unallocatedTokensCap: this.unallocatedTokensCap.toString(),
            allocationAdmin: this.allocationAdmin,
            padding3: this.padding3.map((item) => item.toString()),
        };
    }
    static fromJSON(obj) {
        return new VaultState({
            vaultAdminAuthority: (0, kit_1.address)(obj.vaultAdminAuthority),
            baseVaultAuthority: (0, kit_1.address)(obj.baseVaultAuthority),
            baseVaultAuthorityBump: new bn_js_1.default(obj.baseVaultAuthorityBump),
            tokenMint: (0, kit_1.address)(obj.tokenMint),
            tokenMintDecimals: new bn_js_1.default(obj.tokenMintDecimals),
            tokenVault: (0, kit_1.address)(obj.tokenVault),
            tokenProgram: (0, kit_1.address)(obj.tokenProgram),
            sharesMint: (0, kit_1.address)(obj.sharesMint),
            sharesMintDecimals: new bn_js_1.default(obj.sharesMintDecimals),
            tokenAvailable: new bn_js_1.default(obj.tokenAvailable),
            sharesIssued: new bn_js_1.default(obj.sharesIssued),
            availableCrankFunds: new bn_js_1.default(obj.availableCrankFunds),
            unallocatedWeight: new bn_js_1.default(obj.unallocatedWeight),
            performanceFeeBps: new bn_js_1.default(obj.performanceFeeBps),
            managementFeeBps: new bn_js_1.default(obj.managementFeeBps),
            lastFeeChargeTimestamp: new bn_js_1.default(obj.lastFeeChargeTimestamp),
            prevAumSf: new bn_js_1.default(obj.prevAumSf),
            pendingFeesSf: new bn_js_1.default(obj.pendingFeesSf),
            vaultAllocationStrategy: obj.vaultAllocationStrategy.map((item) => types.VaultAllocation.fromJSON(item)),
            padding1: obj.padding1.map((item) => new bn_js_1.default(item)),
            minDepositAmount: new bn_js_1.default(obj.minDepositAmount),
            minWithdrawAmount: new bn_js_1.default(obj.minWithdrawAmount),
            minInvestAmount: new bn_js_1.default(obj.minInvestAmount),
            minInvestDelaySlots: new bn_js_1.default(obj.minInvestDelaySlots),
            crankFundFeePerReserve: new bn_js_1.default(obj.crankFundFeePerReserve),
            pendingAdmin: (0, kit_1.address)(obj.pendingAdmin),
            cumulativeEarnedInterestSf: new bn_js_1.default(obj.cumulativeEarnedInterestSf),
            cumulativeMgmtFeesSf: new bn_js_1.default(obj.cumulativeMgmtFeesSf),
            cumulativePerfFeesSf: new bn_js_1.default(obj.cumulativePerfFeesSf),
            name: obj.name,
            vaultLookupTable: (0, kit_1.address)(obj.vaultLookupTable),
            vaultFarm: (0, kit_1.address)(obj.vaultFarm),
            creationTimestamp: new bn_js_1.default(obj.creationTimestamp),
            unallocatedTokensCap: new bn_js_1.default(obj.unallocatedTokensCap),
            allocationAdmin: (0, kit_1.address)(obj.allocationAdmin),
            padding3: obj.padding3.map((item) => new bn_js_1.default(item)),
        });
    }
}
exports.VaultState = VaultState;
//# sourceMappingURL=VaultState.js.map
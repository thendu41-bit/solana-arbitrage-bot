import { Address, GetAccountInfoApi, GetMultipleAccountsApi, Rpc } from "@solana/kit";
import BN from "bn.js";
import * as types from "../../../@codegen/klend/types";
import { Obligation, ObligationFields } from '../../../@codegen/klend/accounts';
/** Lending market obligation state */
export declare class ObligationZP {
    /** Version of the struct */
    readonly tag: BN;
    /** Last update to collateral, liquidity, or their market values */
    readonly lastUpdate: types.LastUpdate;
    /** Lending market address */
    readonly lendingMarket: Address;
    /** Owner authority which can borrow liquidity */
    readonly owner: Address;
    /** Deposited collateral for the obligation, unique by deposit reserve address */
    readonly deposits: Array<types.ObligationCollateral>;
    /** Worst LTV for the collaterals backing the loan, represented as a percentage */
    readonly lowestReserveDepositLiquidationLtv: BN;
    /** Market value of deposits (scaled fraction) */
    readonly depositedValueSf: BN;
    /** Borrowed liquidity for the obligation, unique by borrow reserve address */
    readonly borrows: Array<types.ObligationLiquidity>;
    /** Risk adjusted market value of borrows/debt (sum of price * borrowed_amount * borrow_factor) (scaled fraction) */
    readonly borrowFactorAdjustedDebtValueSf: BN;
    /** Market value of borrows - used for max_liquidatable_borrowed_amount (scaled fraction) */
    readonly borrowedAssetsMarketValueSf: BN;
    /** The maximum borrow value at the weighted average loan to value ratio (scaled fraction) */
    readonly allowedBorrowValueSf: BN;
    /** The dangerous borrow value at the weighted average liquidation threshold (scaled fraction) */
    readonly unhealthyBorrowValueSf: BN;
    /** The asset tier of the deposits */
    readonly depositsAssetTiers: Array<number>;
    /** The asset tier of the borrows */
    readonly borrowsAssetTiers: Array<number>;
    /** The elevation group id the obligation opted into. */
    readonly elevationGroup: number;
    /** The number of obsolete reserves the obligation has a deposit in */
    readonly numOfObsoleteDepositReserves: number;
    /** Marked = 1 if borrows array is not empty, 0 = borrows empty */
    readonly hasDebt: number;
    /** Wallet address of the referrer */
    readonly referrer: Address;
    /** Marked = 1 if borrowing disabled, 0 = borrowing enabled */
    readonly borrowingDisabled: number;
    /**
     * A target LTV set by the risk council when marking this obligation for deleveraging.
     * Only effective when `deleveraging_margin_call_started_slot != 0`.
     */
    readonly autodeleverageTargetLtvPct: number;
    /** The lowest max LTV found amongst the collateral deposits */
    readonly lowestReserveDepositMaxLtvPct: number;
    /** The number of obsolete reserves the obligation has a borrow in */
    readonly numOfObsoleteBorrowReserves: number;
    readonly reserved: Array<number>;
    readonly highestBorrowFactorPct: BN;
    /**
     * A timestamp at which the risk council most-recently marked this obligation for deleveraging.
     * Zero if not currently subject to deleveraging.
     */
    readonly autodeleverageMarginCallStartedTimestamp: BN;
    /**
     * Owner-defined, liquidator-executed orders applicable to this obligation.
     * Typical use-cases would be a stop-loss and a take-profit (possibly co-existing).
     */
    readonly orders: Array<types.ObligationOrder>;
    readonly padding3: Array<BN>;
    static readonly layout: import("buffer-layout").Layout<ObligationZP>;
    constructor(fields: ObligationFields);
    static fetch(rpc: Rpc<GetAccountInfoApi>, address: Address, programId?: Address): Promise<Obligation | null>;
    static fetchMultiple(rpc: Rpc<GetMultipleAccountsApi>, addresses: Address[], programId?: Address): Promise<Array<Obligation | null>>;
    static decode(data: Buffer): Obligation;
}
//# sourceMappingURL=ObligationZP.d.ts.map
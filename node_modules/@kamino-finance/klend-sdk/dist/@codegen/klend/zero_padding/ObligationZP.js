"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObligationZP = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars */
const kit_1 = require("@solana/kit");
const borsh = __importStar(require("@coral-xyz/borsh")); // eslint-disable-line @typescript-eslint/no-unused-vars
const utils_1 = require("../utils"); // eslint-disable-line @typescript-eslint/no-unused-vars
const types = __importStar(require("../../../@codegen/klend/types")); // eslint-disable-line @typescript-eslint/no-unused-vars
const programId_1 = require("../../../@codegen/klend/programId");
const accounts_1 = require("../../../@codegen/klend/accounts");
/** Lending market obligation state */
class ObligationZP {
    /** Version of the struct */
    tag;
    /** Last update to collateral, liquidity, or their market values */
    lastUpdate;
    /** Lending market address */
    lendingMarket;
    /** Owner authority which can borrow liquidity */
    owner;
    /** Deposited collateral for the obligation, unique by deposit reserve address */
    deposits;
    /** Worst LTV for the collaterals backing the loan, represented as a percentage */
    lowestReserveDepositLiquidationLtv;
    /** Market value of deposits (scaled fraction) */
    depositedValueSf;
    /** Borrowed liquidity for the obligation, unique by borrow reserve address */
    borrows;
    /** Risk adjusted market value of borrows/debt (sum of price * borrowed_amount * borrow_factor) (scaled fraction) */
    borrowFactorAdjustedDebtValueSf;
    /** Market value of borrows - used for max_liquidatable_borrowed_amount (scaled fraction) */
    borrowedAssetsMarketValueSf;
    /** The maximum borrow value at the weighted average loan to value ratio (scaled fraction) */
    allowedBorrowValueSf;
    /** The dangerous borrow value at the weighted average liquidation threshold (scaled fraction) */
    unhealthyBorrowValueSf;
    /** The asset tier of the deposits */
    depositsAssetTiers;
    /** The asset tier of the borrows */
    borrowsAssetTiers;
    /** The elevation group id the obligation opted into. */
    elevationGroup;
    /** The number of obsolete reserves the obligation has a deposit in */
    numOfObsoleteDepositReserves;
    /** Marked = 1 if borrows array is not empty, 0 = borrows empty */
    hasDebt;
    /** Wallet address of the referrer */
    referrer;
    /** Marked = 1 if borrowing disabled, 0 = borrowing enabled */
    borrowingDisabled;
    /**
     * A target LTV set by the risk council when marking this obligation for deleveraging.
     * Only effective when `deleveraging_margin_call_started_slot != 0`.
     */
    autodeleverageTargetLtvPct;
    /** The lowest max LTV found amongst the collateral deposits */
    lowestReserveDepositMaxLtvPct;
    /** The number of obsolete reserves the obligation has a borrow in */
    numOfObsoleteBorrowReserves;
    reserved;
    highestBorrowFactorPct;
    /**
     * A timestamp at which the risk council most-recently marked this obligation for deleveraging.
     * Zero if not currently subject to deleveraging.
     */
    autodeleverageMarginCallStartedTimestamp;
    /**
     * Owner-defined, liquidator-executed orders applicable to this obligation.
     * Typical use-cases would be a stop-loss and a take-profit (possibly co-existing).
     */
    orders;
    padding3 = new Array(0);
    static layout = borsh.struct([
        borsh.u64("tag"),
        types.LastUpdate.layout("lastUpdate"),
        (0, utils_1.borshAddress)("lendingMarket"),
        (0, utils_1.borshAddress)("owner"),
        borsh.array(types.ObligationCollateral.layout(), 8, "deposits"),
        borsh.u64("lowestReserveDepositLiquidationLtv"),
        borsh.u128("depositedValueSf"),
        borsh.array(types.ObligationLiquidity.layout(), 5, "borrows"),
        borsh.u128("borrowFactorAdjustedDebtValueSf"),
        borsh.u128("borrowedAssetsMarketValueSf"),
        borsh.u128("allowedBorrowValueSf"),
        borsh.u128("unhealthyBorrowValueSf"),
        borsh.array(borsh.u8(), 8, "depositsAssetTiers"),
        borsh.array(borsh.u8(), 5, "borrowsAssetTiers"),
        borsh.u8("elevationGroup"),
        borsh.u8("numOfObsoleteDepositReserves"),
        borsh.u8("hasDebt"),
        (0, utils_1.borshAddress)("referrer"),
        borsh.u8("borrowingDisabled"),
        borsh.u8("autodeleverageTargetLtvPct"),
        borsh.u8("lowestReserveDepositMaxLtvPct"),
        borsh.u8("numOfObsoleteBorrowReserves"),
        borsh.array(borsh.u8(), 4, "reserved"),
        borsh.u64("highestBorrowFactorPct"),
        borsh.u64("autodeleverageMarginCallStartedTimestamp"),
        borsh.array(types.ObligationOrder.layout(), 2, "orders"),
    ]);
    constructor(fields) {
        this.tag = fields.tag;
        this.lastUpdate = new types.LastUpdate({ ...fields.lastUpdate });
        this.lendingMarket = fields.lendingMarket;
        this.owner = fields.owner;
        this.deposits = fields.deposits.map((item) => new types.ObligationCollateral({ ...item }));
        this.lowestReserveDepositLiquidationLtv =
            fields.lowestReserveDepositLiquidationLtv;
        this.depositedValueSf = fields.depositedValueSf;
        this.borrows = fields.borrows.map((item) => new types.ObligationLiquidity({ ...item }));
        this.borrowFactorAdjustedDebtValueSf =
            fields.borrowFactorAdjustedDebtValueSf;
        this.borrowedAssetsMarketValueSf = fields.borrowedAssetsMarketValueSf;
        this.allowedBorrowValueSf = fields.allowedBorrowValueSf;
        this.unhealthyBorrowValueSf = fields.unhealthyBorrowValueSf;
        this.depositsAssetTiers = fields.depositsAssetTiers;
        this.borrowsAssetTiers = fields.borrowsAssetTiers;
        this.elevationGroup = fields.elevationGroup;
        this.numOfObsoleteDepositReserves = fields.numOfObsoleteDepositReserves;
        this.hasDebt = fields.hasDebt;
        this.referrer = fields.referrer;
        this.borrowingDisabled = fields.borrowingDisabled;
        this.autodeleverageTargetLtvPct = fields.autodeleverageTargetLtvPct;
        this.lowestReserveDepositMaxLtvPct = fields.lowestReserveDepositMaxLtvPct;
        this.numOfObsoleteBorrowReserves = fields.numOfObsoleteBorrowReserves;
        this.reserved = new Array(0);
        this.highestBorrowFactorPct = fields.highestBorrowFactorPct;
        this.autodeleverageMarginCallStartedTimestamp =
            fields.autodeleverageMarginCallStartedTimestamp;
        this.orders = fields.orders.map((item) => new types.ObligationOrder({ ...item }));
        this.padding3 = new Array(0);
    }
    static async fetch(rpc, address, programId = programId_1.PROGRAM_ID) {
        const info = await (0, kit_1.fetchEncodedAccount)(rpc, address);
        if (!info.exists) {
            return null;
        }
        if (info.programAddress !== programId) {
            throw new Error("account doesn't belong to this program");
        }
        return this.decode(Buffer.from(info.data));
    }
    static async fetchMultiple(rpc, addresses, programId = programId_1.PROGRAM_ID) {
        const infos = await (0, kit_1.fetchEncodedAccounts)(rpc, addresses);
        return infos.map((info) => {
            if (!info.exists) {
                return null;
            }
            if (info.programAddress !== programId) {
                throw new Error("account doesn't belong to this program");
            }
            return this.decode(Buffer.from(info.data));
        });
    }
    static decode(data) {
        if (!data.slice(0, 8).equals(accounts_1.Obligation.discriminator)) {
            throw new Error("invalid account discriminator");
        }
        const dec = ObligationZP.layout.decode(data.slice(8));
        return new accounts_1.Obligation({
            tag: dec.tag,
            lastUpdate: types.LastUpdate.fromDecoded(dec.lastUpdate),
            lendingMarket: dec.lendingMarket,
            owner: dec.owner,
            deposits: dec.deposits.map((item /* eslint-disable-line @typescript-eslint/no-explicit-any */) => types.ObligationCollateral.fromDecoded(item)),
            lowestReserveDepositLiquidationLtv: dec.lowestReserveDepositLiquidationLtv,
            depositedValueSf: dec.depositedValueSf,
            borrows: dec.borrows.map((item /* eslint-disable-line @typescript-eslint/no-explicit-any */) => types.ObligationLiquidity.fromDecoded(item)),
            borrowFactorAdjustedDebtValueSf: dec.borrowFactorAdjustedDebtValueSf,
            borrowedAssetsMarketValueSf: dec.borrowedAssetsMarketValueSf,
            allowedBorrowValueSf: dec.allowedBorrowValueSf,
            unhealthyBorrowValueSf: dec.unhealthyBorrowValueSf,
            depositsAssetTiers: dec.depositsAssetTiers,
            borrowsAssetTiers: dec.borrowsAssetTiers,
            elevationGroup: dec.elevationGroup,
            numOfObsoleteDepositReserves: dec.numOfObsoleteDepositReserves,
            hasDebt: dec.hasDebt,
            referrer: dec.referrer,
            borrowingDisabled: dec.borrowingDisabled,
            autodeleverageTargetLtvPct: dec.autodeleverageTargetLtvPct,
            lowestReserveDepositMaxLtvPct: dec.lowestReserveDepositMaxLtvPct,
            numOfObsoleteBorrowReserves: dec.numOfObsoleteBorrowReserves,
            reserved: dec.reserved,
            highestBorrowFactorPct: dec.highestBorrowFactorPct,
            autodeleverageMarginCallStartedTimestamp: dec.autodeleverageMarginCallStartedTimestamp,
            orders: dec.orders.map((item /* eslint-disable-line @typescript-eslint/no-explicit-any */) => types.ObligationOrder.fromDecoded(item)),
            padding3: [],
        });
    }
}
exports.ObligationZP = ObligationZP;
//# sourceMappingURL=ObligationZP.js.map
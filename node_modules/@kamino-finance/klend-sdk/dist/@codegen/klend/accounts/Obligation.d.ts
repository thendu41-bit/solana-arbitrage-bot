import { Address, GetAccountInfoApi, GetMultipleAccountsApi, Rpc } from "@solana/kit";
import BN from "bn.js";
import * as types from "../types";
export interface ObligationFields {
    /** Version of the struct */
    tag: BN;
    /** Last update to collateral, liquidity, or their market values */
    lastUpdate: types.LastUpdateFields;
    /** Lending market address */
    lendingMarket: Address;
    /** Owner authority which can borrow liquidity */
    owner: Address;
    /** Deposited collateral for the obligation, unique by deposit reserve address */
    deposits: Array<types.ObligationCollateralFields>;
    /** Worst LTV for the collaterals backing the loan, represented as a percentage */
    lowestReserveDepositLiquidationLtv: BN;
    /** Market value of deposits (scaled fraction) */
    depositedValueSf: BN;
    /** Borrowed liquidity for the obligation, unique by borrow reserve address */
    borrows: Array<types.ObligationLiquidityFields>;
    /** Risk adjusted market value of borrows/debt (sum of price * borrowed_amount * borrow_factor) (scaled fraction) */
    borrowFactorAdjustedDebtValueSf: BN;
    /** Market value of borrows - used for max_liquidatable_borrowed_amount (scaled fraction) */
    borrowedAssetsMarketValueSf: BN;
    /** The maximum borrow value at the weighted average loan to value ratio (scaled fraction) */
    allowedBorrowValueSf: BN;
    /** The dangerous borrow value at the weighted average liquidation threshold (scaled fraction) */
    unhealthyBorrowValueSf: BN;
    /** The asset tier of the deposits */
    depositsAssetTiers: Array<number>;
    /** The asset tier of the borrows */
    borrowsAssetTiers: Array<number>;
    /** The elevation group id the obligation opted into. */
    elevationGroup: number;
    /** The number of obsolete reserves the obligation has a deposit in */
    numOfObsoleteDepositReserves: number;
    /** Marked = 1 if borrows array is not empty, 0 = borrows empty */
    hasDebt: number;
    /** Wallet address of the referrer */
    referrer: Address;
    /** Marked = 1 if borrowing disabled, 0 = borrowing enabled */
    borrowingDisabled: number;
    /**
     * A target LTV set by the risk council when marking this obligation for deleveraging.
     * Only effective when `deleveraging_margin_call_started_slot != 0`.
     */
    autodeleverageTargetLtvPct: number;
    /** The lowest max LTV found amongst the collateral deposits */
    lowestReserveDepositMaxLtvPct: number;
    /** The number of obsolete reserves the obligation has a borrow in */
    numOfObsoleteBorrowReserves: number;
    reserved: Array<number>;
    highestBorrowFactorPct: BN;
    /**
     * A timestamp at which the risk council most-recently marked this obligation for deleveraging.
     * Zero if not currently subject to deleveraging.
     */
    autodeleverageMarginCallStartedTimestamp: BN;
    /**
     * Owner-defined, liquidator-executed orders applicable to this obligation.
     * Typical use-cases would be a stop-loss and a take-profit (possibly co-existing).
     */
    orders: Array<types.ObligationOrderFields>;
    padding3: Array<BN>;
}
export interface ObligationJSON {
    /** Version of the struct */
    tag: string;
    /** Last update to collateral, liquidity, or their market values */
    lastUpdate: types.LastUpdateJSON;
    /** Lending market address */
    lendingMarket: string;
    /** Owner authority which can borrow liquidity */
    owner: string;
    /** Deposited collateral for the obligation, unique by deposit reserve address */
    deposits: Array<types.ObligationCollateralJSON>;
    /** Worst LTV for the collaterals backing the loan, represented as a percentage */
    lowestReserveDepositLiquidationLtv: string;
    /** Market value of deposits (scaled fraction) */
    depositedValueSf: string;
    /** Borrowed liquidity for the obligation, unique by borrow reserve address */
    borrows: Array<types.ObligationLiquidityJSON>;
    /** Risk adjusted market value of borrows/debt (sum of price * borrowed_amount * borrow_factor) (scaled fraction) */
    borrowFactorAdjustedDebtValueSf: string;
    /** Market value of borrows - used for max_liquidatable_borrowed_amount (scaled fraction) */
    borrowedAssetsMarketValueSf: string;
    /** The maximum borrow value at the weighted average loan to value ratio (scaled fraction) */
    allowedBorrowValueSf: string;
    /** The dangerous borrow value at the weighted average liquidation threshold (scaled fraction) */
    unhealthyBorrowValueSf: string;
    /** The asset tier of the deposits */
    depositsAssetTiers: Array<number>;
    /** The asset tier of the borrows */
    borrowsAssetTiers: Array<number>;
    /** The elevation group id the obligation opted into. */
    elevationGroup: number;
    /** The number of obsolete reserves the obligation has a deposit in */
    numOfObsoleteDepositReserves: number;
    /** Marked = 1 if borrows array is not empty, 0 = borrows empty */
    hasDebt: number;
    /** Wallet address of the referrer */
    referrer: string;
    /** Marked = 1 if borrowing disabled, 0 = borrowing enabled */
    borrowingDisabled: number;
    /**
     * A target LTV set by the risk council when marking this obligation for deleveraging.
     * Only effective when `deleveraging_margin_call_started_slot != 0`.
     */
    autodeleverageTargetLtvPct: number;
    /** The lowest max LTV found amongst the collateral deposits */
    lowestReserveDepositMaxLtvPct: number;
    /** The number of obsolete reserves the obligation has a borrow in */
    numOfObsoleteBorrowReserves: number;
    reserved: Array<number>;
    highestBorrowFactorPct: string;
    /**
     * A timestamp at which the risk council most-recently marked this obligation for deleveraging.
     * Zero if not currently subject to deleveraging.
     */
    autodeleverageMarginCallStartedTimestamp: string;
    /**
     * Owner-defined, liquidator-executed orders applicable to this obligation.
     * Typical use-cases would be a stop-loss and a take-profit (possibly co-existing).
     */
    orders: Array<types.ObligationOrderJSON>;
    padding3: Array<string>;
}
/** Lending market obligation state */
export declare class Obligation {
    /** Version of the struct */
    readonly tag: BN;
    /** Last update to collateral, liquidity, or their market values */
    readonly lastUpdate: types.LastUpdate;
    /** Lending market address */
    readonly lendingMarket: Address;
    /** Owner authority which can borrow liquidity */
    readonly owner: Address;
    /** Deposited collateral for the obligation, unique by deposit reserve address */
    readonly deposits: Array<types.ObligationCollateral>;
    /** Worst LTV for the collaterals backing the loan, represented as a percentage */
    readonly lowestReserveDepositLiquidationLtv: BN;
    /** Market value of deposits (scaled fraction) */
    readonly depositedValueSf: BN;
    /** Borrowed liquidity for the obligation, unique by borrow reserve address */
    readonly borrows: Array<types.ObligationLiquidity>;
    /** Risk adjusted market value of borrows/debt (sum of price * borrowed_amount * borrow_factor) (scaled fraction) */
    readonly borrowFactorAdjustedDebtValueSf: BN;
    /** Market value of borrows - used for max_liquidatable_borrowed_amount (scaled fraction) */
    readonly borrowedAssetsMarketValueSf: BN;
    /** The maximum borrow value at the weighted average loan to value ratio (scaled fraction) */
    readonly allowedBorrowValueSf: BN;
    /** The dangerous borrow value at the weighted average liquidation threshold (scaled fraction) */
    readonly unhealthyBorrowValueSf: BN;
    /** The asset tier of the deposits */
    readonly depositsAssetTiers: Array<number>;
    /** The asset tier of the borrows */
    readonly borrowsAssetTiers: Array<number>;
    /** The elevation group id the obligation opted into. */
    readonly elevationGroup: number;
    /** The number of obsolete reserves the obligation has a deposit in */
    readonly numOfObsoleteDepositReserves: number;
    /** Marked = 1 if borrows array is not empty, 0 = borrows empty */
    readonly hasDebt: number;
    /** Wallet address of the referrer */
    readonly referrer: Address;
    /** Marked = 1 if borrowing disabled, 0 = borrowing enabled */
    readonly borrowingDisabled: number;
    /**
     * A target LTV set by the risk council when marking this obligation for deleveraging.
     * Only effective when `deleveraging_margin_call_started_slot != 0`.
     */
    readonly autodeleverageTargetLtvPct: number;
    /** The lowest max LTV found amongst the collateral deposits */
    readonly lowestReserveDepositMaxLtvPct: number;
    /** The number of obsolete reserves the obligation has a borrow in */
    readonly numOfObsoleteBorrowReserves: number;
    readonly reserved: Array<number>;
    readonly highestBorrowFactorPct: BN;
    /**
     * A timestamp at which the risk council most-recently marked this obligation for deleveraging.
     * Zero if not currently subject to deleveraging.
     */
    readonly autodeleverageMarginCallStartedTimestamp: BN;
    /**
     * Owner-defined, liquidator-executed orders applicable to this obligation.
     * Typical use-cases would be a stop-loss and a take-profit (possibly co-existing).
     */
    readonly orders: Array<types.ObligationOrder>;
    readonly padding3: Array<BN>;
    static readonly discriminator: Buffer<ArrayBuffer>;
    static readonly layout: import("buffer-layout").Layout<Obligation>;
    constructor(fields: ObligationFields);
    static fetch(rpc: Rpc<GetAccountInfoApi>, address: Address, programId?: Address): Promise<Obligation | null>;
    static fetchMultiple(rpc: Rpc<GetMultipleAccountsApi>, addresses: Address[], programId?: Address): Promise<Array<Obligation | null>>;
    static decode(data: Buffer): Obligation;
    toJSON(): ObligationJSON;
    static fromJSON(obj: ObligationJSON): Obligation;
}
//# sourceMappingURL=Obligation.d.ts.map
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Obligation = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars */
const kit_1 = require("@solana/kit");
/* eslint-enable @typescript-eslint/no-unused-vars */
const bn_js_1 = __importDefault(require("bn.js")); // eslint-disable-line @typescript-eslint/no-unused-vars
const borsh = __importStar(require("@coral-xyz/borsh")); // eslint-disable-line @typescript-eslint/no-unused-vars
const utils_1 = require("../utils"); // eslint-disable-line @typescript-eslint/no-unused-vars
const types = __importStar(require("../types")); // eslint-disable-line @typescript-eslint/no-unused-vars
const programId_1 = require("../programId");
/** Lending market obligation state */
class Obligation {
    /** Version of the struct */
    tag;
    /** Last update to collateral, liquidity, or their market values */
    lastUpdate;
    /** Lending market address */
    lendingMarket;
    /** Owner authority which can borrow liquidity */
    owner;
    /** Deposited collateral for the obligation, unique by deposit reserve address */
    deposits;
    /** Worst LTV for the collaterals backing the loan, represented as a percentage */
    lowestReserveDepositLiquidationLtv;
    /** Market value of deposits (scaled fraction) */
    depositedValueSf;
    /** Borrowed liquidity for the obligation, unique by borrow reserve address */
    borrows;
    /** Risk adjusted market value of borrows/debt (sum of price * borrowed_amount * borrow_factor) (scaled fraction) */
    borrowFactorAdjustedDebtValueSf;
    /** Market value of borrows - used for max_liquidatable_borrowed_amount (scaled fraction) */
    borrowedAssetsMarketValueSf;
    /** The maximum borrow value at the weighted average loan to value ratio (scaled fraction) */
    allowedBorrowValueSf;
    /** The dangerous borrow value at the weighted average liquidation threshold (scaled fraction) */
    unhealthyBorrowValueSf;
    /** The asset tier of the deposits */
    depositsAssetTiers;
    /** The asset tier of the borrows */
    borrowsAssetTiers;
    /** The elevation group id the obligation opted into. */
    elevationGroup;
    /** The number of obsolete reserves the obligation has a deposit in */
    numOfObsoleteDepositReserves;
    /** Marked = 1 if borrows array is not empty, 0 = borrows empty */
    hasDebt;
    /** Wallet address of the referrer */
    referrer;
    /** Marked = 1 if borrowing disabled, 0 = borrowing enabled */
    borrowingDisabled;
    /**
     * A target LTV set by the risk council when marking this obligation for deleveraging.
     * Only effective when `deleveraging_margin_call_started_slot != 0`.
     */
    autodeleverageTargetLtvPct;
    /** The lowest max LTV found amongst the collateral deposits */
    lowestReserveDepositMaxLtvPct;
    /** The number of obsolete reserves the obligation has a borrow in */
    numOfObsoleteBorrowReserves;
    reserved;
    highestBorrowFactorPct;
    /**
     * A timestamp at which the risk council most-recently marked this obligation for deleveraging.
     * Zero if not currently subject to deleveraging.
     */
    autodeleverageMarginCallStartedTimestamp;
    /**
     * Owner-defined, liquidator-executed orders applicable to this obligation.
     * Typical use-cases would be a stop-loss and a take-profit (possibly co-existing).
     */
    orders;
    padding3;
    static discriminator = Buffer.from([
        168, 206, 141, 106, 88, 76, 172, 167,
    ]);
    static layout = borsh.struct([
        borsh.u64("tag"),
        types.LastUpdate.layout("lastUpdate"),
        (0, utils_1.borshAddress)("lendingMarket"),
        (0, utils_1.borshAddress)("owner"),
        borsh.array(types.ObligationCollateral.layout(), 8, "deposits"),
        borsh.u64("lowestReserveDepositLiquidationLtv"),
        borsh.u128("depositedValueSf"),
        borsh.array(types.ObligationLiquidity.layout(), 5, "borrows"),
        borsh.u128("borrowFactorAdjustedDebtValueSf"),
        borsh.u128("borrowedAssetsMarketValueSf"),
        borsh.u128("allowedBorrowValueSf"),
        borsh.u128("unhealthyBorrowValueSf"),
        borsh.array(borsh.u8(), 8, "depositsAssetTiers"),
        borsh.array(borsh.u8(), 5, "borrowsAssetTiers"),
        borsh.u8("elevationGroup"),
        borsh.u8("numOfObsoleteDepositReserves"),
        borsh.u8("hasDebt"),
        (0, utils_1.borshAddress)("referrer"),
        borsh.u8("borrowingDisabled"),
        borsh.u8("autodeleverageTargetLtvPct"),
        borsh.u8("lowestReserveDepositMaxLtvPct"),
        borsh.u8("numOfObsoleteBorrowReserves"),
        borsh.array(borsh.u8(), 4, "reserved"),
        borsh.u64("highestBorrowFactorPct"),
        borsh.u64("autodeleverageMarginCallStartedTimestamp"),
        borsh.array(types.ObligationOrder.layout(), 2, "orders"),
        borsh.array(borsh.u64(), 93, "padding3"),
    ]);
    constructor(fields) {
        this.tag = fields.tag;
        this.lastUpdate = new types.LastUpdate({ ...fields.lastUpdate });
        this.lendingMarket = fields.lendingMarket;
        this.owner = fields.owner;
        this.deposits = fields.deposits.map((item) => new types.ObligationCollateral({ ...item }));
        this.lowestReserveDepositLiquidationLtv =
            fields.lowestReserveDepositLiquidationLtv;
        this.depositedValueSf = fields.depositedValueSf;
        this.borrows = fields.borrows.map((item) => new types.ObligationLiquidity({ ...item }));
        this.borrowFactorAdjustedDebtValueSf =
            fields.borrowFactorAdjustedDebtValueSf;
        this.borrowedAssetsMarketValueSf = fields.borrowedAssetsMarketValueSf;
        this.allowedBorrowValueSf = fields.allowedBorrowValueSf;
        this.unhealthyBorrowValueSf = fields.unhealthyBorrowValueSf;
        this.depositsAssetTiers = fields.depositsAssetTiers;
        this.borrowsAssetTiers = fields.borrowsAssetTiers;
        this.elevationGroup = fields.elevationGroup;
        this.numOfObsoleteDepositReserves = fields.numOfObsoleteDepositReserves;
        this.hasDebt = fields.hasDebt;
        this.referrer = fields.referrer;
        this.borrowingDisabled = fields.borrowingDisabled;
        this.autodeleverageTargetLtvPct = fields.autodeleverageTargetLtvPct;
        this.lowestReserveDepositMaxLtvPct = fields.lowestReserveDepositMaxLtvPct;
        this.numOfObsoleteBorrowReserves = fields.numOfObsoleteBorrowReserves;
        this.reserved = fields.reserved;
        this.highestBorrowFactorPct = fields.highestBorrowFactorPct;
        this.autodeleverageMarginCallStartedTimestamp =
            fields.autodeleverageMarginCallStartedTimestamp;
        this.orders = fields.orders.map((item) => new types.ObligationOrder({ ...item }));
        this.padding3 = fields.padding3;
    }
    static async fetch(rpc, address, programId = programId_1.PROGRAM_ID) {
        const info = await (0, kit_1.fetchEncodedAccount)(rpc, address);
        if (!info.exists) {
            return null;
        }
        if (info.programAddress !== programId) {
            throw new Error(`ObligationFields account ${address} belongs to wrong program ${info.programAddress}, expected ${programId}`);
        }
        return this.decode(Buffer.from(info.data));
    }
    static async fetchMultiple(rpc, addresses, programId = programId_1.PROGRAM_ID) {
        const infos = await (0, kit_1.fetchEncodedAccounts)(rpc, addresses);
        return infos.map((info) => {
            if (!info.exists) {
                return null;
            }
            if (info.programAddress !== programId) {
                throw new Error(`ObligationFields account ${info.address} belongs to wrong program ${info.programAddress}, expected ${programId}`);
            }
            return this.decode(Buffer.from(info.data));
        });
    }
    static decode(data) {
        if (!data.slice(0, 8).equals(Obligation.discriminator)) {
            throw new Error("invalid account discriminator");
        }
        const dec = Obligation.layout.decode(data.slice(8));
        return new Obligation({
            tag: dec.tag,
            lastUpdate: types.LastUpdate.fromDecoded(dec.lastUpdate),
            lendingMarket: dec.lendingMarket,
            owner: dec.owner,
            deposits: dec.deposits.map((item /* eslint-disable-line @typescript-eslint/no-explicit-any */) => types.ObligationCollateral.fromDecoded(item)),
            lowestReserveDepositLiquidationLtv: dec.lowestReserveDepositLiquidationLtv,
            depositedValueSf: dec.depositedValueSf,
            borrows: dec.borrows.map((item /* eslint-disable-line @typescript-eslint/no-explicit-any */) => types.ObligationLiquidity.fromDecoded(item)),
            borrowFactorAdjustedDebtValueSf: dec.borrowFactorAdjustedDebtValueSf,
            borrowedAssetsMarketValueSf: dec.borrowedAssetsMarketValueSf,
            allowedBorrowValueSf: dec.allowedBorrowValueSf,
            unhealthyBorrowValueSf: dec.unhealthyBorrowValueSf,
            depositsAssetTiers: dec.depositsAssetTiers,
            borrowsAssetTiers: dec.borrowsAssetTiers,
            elevationGroup: dec.elevationGroup,
            numOfObsoleteDepositReserves: dec.numOfObsoleteDepositReserves,
            hasDebt: dec.hasDebt,
            referrer: dec.referrer,
            borrowingDisabled: dec.borrowingDisabled,
            autodeleverageTargetLtvPct: dec.autodeleverageTargetLtvPct,
            lowestReserveDepositMaxLtvPct: dec.lowestReserveDepositMaxLtvPct,
            numOfObsoleteBorrowReserves: dec.numOfObsoleteBorrowReserves,
            reserved: dec.reserved,
            highestBorrowFactorPct: dec.highestBorrowFactorPct,
            autodeleverageMarginCallStartedTimestamp: dec.autodeleverageMarginCallStartedTimestamp,
            orders: dec.orders.map((item /* eslint-disable-line @typescript-eslint/no-explicit-any */) => types.ObligationOrder.fromDecoded(item)),
            padding3: dec.padding3,
        });
    }
    toJSON() {
        return {
            tag: this.tag.toString(),
            lastUpdate: this.lastUpdate.toJSON(),
            lendingMarket: this.lendingMarket,
            owner: this.owner,
            deposits: this.deposits.map((item) => item.toJSON()),
            lowestReserveDepositLiquidationLtv: this.lowestReserveDepositLiquidationLtv.toString(),
            depositedValueSf: this.depositedValueSf.toString(),
            borrows: this.borrows.map((item) => item.toJSON()),
            borrowFactorAdjustedDebtValueSf: this.borrowFactorAdjustedDebtValueSf.toString(),
            borrowedAssetsMarketValueSf: this.borrowedAssetsMarketValueSf.toString(),
            allowedBorrowValueSf: this.allowedBorrowValueSf.toString(),
            unhealthyBorrowValueSf: this.unhealthyBorrowValueSf.toString(),
            depositsAssetTiers: this.depositsAssetTiers,
            borrowsAssetTiers: this.borrowsAssetTiers,
            elevationGroup: this.elevationGroup,
            numOfObsoleteDepositReserves: this.numOfObsoleteDepositReserves,
            hasDebt: this.hasDebt,
            referrer: this.referrer,
            borrowingDisabled: this.borrowingDisabled,
            autodeleverageTargetLtvPct: this.autodeleverageTargetLtvPct,
            lowestReserveDepositMaxLtvPct: this.lowestReserveDepositMaxLtvPct,
            numOfObsoleteBorrowReserves: this.numOfObsoleteBorrowReserves,
            reserved: this.reserved,
            highestBorrowFactorPct: this.highestBorrowFactorPct.toString(),
            autodeleverageMarginCallStartedTimestamp: this.autodeleverageMarginCallStartedTimestamp.toString(),
            orders: this.orders.map((item) => item.toJSON()),
            padding3: this.padding3.map((item) => item.toString()),
        };
    }
    static fromJSON(obj) {
        return new Obligation({
            tag: new bn_js_1.default(obj.tag),
            lastUpdate: types.LastUpdate.fromJSON(obj.lastUpdate),
            lendingMarket: (0, kit_1.address)(obj.lendingMarket),
            owner: (0, kit_1.address)(obj.owner),
            deposits: obj.deposits.map((item) => types.ObligationCollateral.fromJSON(item)),
            lowestReserveDepositLiquidationLtv: new bn_js_1.default(obj.lowestReserveDepositLiquidationLtv),
            depositedValueSf: new bn_js_1.default(obj.depositedValueSf),
            borrows: obj.borrows.map((item) => types.ObligationLiquidity.fromJSON(item)),
            borrowFactorAdjustedDebtValueSf: new bn_js_1.default(obj.borrowFactorAdjustedDebtValueSf),
            borrowedAssetsMarketValueSf: new bn_js_1.default(obj.borrowedAssetsMarketValueSf),
            allowedBorrowValueSf: new bn_js_1.default(obj.allowedBorrowValueSf),
            unhealthyBorrowValueSf: new bn_js_1.default(obj.unhealthyBorrowValueSf),
            depositsAssetTiers: obj.depositsAssetTiers,
            borrowsAssetTiers: obj.borrowsAssetTiers,
            elevationGroup: obj.elevationGroup,
            numOfObsoleteDepositReserves: obj.numOfObsoleteDepositReserves,
            hasDebt: obj.hasDebt,
            referrer: (0, kit_1.address)(obj.referrer),
            borrowingDisabled: obj.borrowingDisabled,
            autodeleverageTargetLtvPct: obj.autodeleverageTargetLtvPct,
            lowestReserveDepositMaxLtvPct: obj.lowestReserveDepositMaxLtvPct,
            numOfObsoleteBorrowReserves: obj.numOfObsoleteBorrowReserves,
            reserved: obj.reserved,
            highestBorrowFactorPct: new bn_js_1.default(obj.highestBorrowFactorPct),
            autodeleverageMarginCallStartedTimestamp: new bn_js_1.default(obj.autodeleverageMarginCallStartedTimestamp),
            orders: obj.orders.map((item) => types.ObligationOrder.fromJSON(item)),
            padding3: obj.padding3.map((item) => new bn_js_1.default(item)),
        });
    }
}
exports.Obligation = Obligation;
//# sourceMappingURL=Obligation.js.map
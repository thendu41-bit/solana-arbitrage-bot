import BN from "bn.js";
import { Address, IInstruction, Option, Rpc, Slot, SolanaRpcApi, TransactionSigner, UnixTimestamp } from "@solana/kit";
import { GlobalConfigFlagValueType } from "./utils";
import { FarmIncentives, UserFarm, UserAndKey, FarmAndKey } from "./models";
import { FarmState, UserState } from "./@codegen/farms/accounts";
import Decimal from "decimal.js";
import { FarmConfigOptionKind, GlobalConfigOptionKind, RewardInfo } from "./@codegen/farms/types/index";
import { OraclePrices } from "@kamino-finance/scope-sdk/dist/@codegen/scope/accounts";
export interface UserPointsBreakdown {
    totalPoints: Decimal;
    currentBoost: Decimal;
    currentPointsPerDay: Decimal;
    perPositionBoost: Map<Address, Decimal>;
    perPositionPointsPerDay: Map<Address, Decimal>;
}
export interface RewardCurvePoint {
    startTs: number;
    rps: number;
}
export declare class Farms {
    private readonly _connection;
    private readonly _farmsProgramId;
    constructor(connection: Rpc<SolanaRpcApi>, farmsProgramId?: Address);
    getConnection(): Rpc<import("@solana/kit").RequestAirdropApi & import("@solana/kit").GetAccountInfoApi & import("@solana/kit").GetBalanceApi & import("@solana/kit").GetBlockApi & import("@solana/kit").GetBlockCommitmentApi & import("@solana/kit").GetBlockHeightApi & import("@solana/kit").GetBlockProductionApi & import("@solana/kit").GetBlocksApi & import("@solana/kit").GetBlocksWithLimitApi & import("@solana/kit").GetBlockTimeApi & import("@solana/kit").GetClusterNodesApi & import("@solana/kit").GetEpochInfoApi & import("@solana/kit").GetEpochScheduleApi & import("@solana/kit").GetFeeForMessageApi & import("@solana/kit").GetFirstAvailableBlockApi & import("@solana/kit").GetGenesisHashApi & import("@solana/kit").GetHealthApi & import("@solana/kit").GetHighestSnapshotSlotApi & import("@solana/kit").GetIdentityApi & import("@solana/kit").GetInflationGovernorApi & import("@solana/kit").GetInflationRateApi & import("@solana/kit").GetInflationRewardApi & import("@solana/kit").GetLargestAccountsApi & import("@solana/kit").GetLatestBlockhashApi & import("@solana/kit").GetLeaderScheduleApi & import("@solana/kit").GetMaxRetransmitSlotApi & import("@solana/kit").GetMaxShredInsertSlotApi & import("@solana/kit").GetMinimumBalanceForRentExemptionApi & import("@solana/kit").GetMultipleAccountsApi & import("@solana/kit").GetProgramAccountsApi & import("@solana/kit").GetRecentPerformanceSamplesApi & import("@solana/kit").GetRecentPrioritizationFeesApi & import("@solana/kit").GetSignaturesForAddressApi & import("@solana/kit").GetSignatureStatusesApi & import("@solana/kit").GetSlotApi & import("@solana/kit").GetSlotLeaderApi & import("@solana/kit").GetSlotLeadersApi & import("@solana/kit").GetStakeMinimumDelegationApi & import("@solana/kit").GetSupplyApi & import("@solana/kit").GetTokenAccountBalanceApi & import("@solana/kit").GetTokenAccountsByDelegateApi & import("@solana/kit").GetTokenAccountsByOwnerApi & import("@solana/kit").GetTokenLargestAccountsApi & import("@solana/kit").GetTokenSupplyApi & import("@solana/kit").GetTransactionApi & import("@solana/kit").GetTransactionCountApi & import("@solana/kit").GetVersionApi & import("@solana/kit").GetVoteAccountsApi & import("@solana/kit").IsBlockhashValidApi & import("@solana/kit").MinimumLedgerSlotApi & import("@solana/kit").SendTransactionApi & import("@solana/kit").SimulateTransactionApi>;
    getProgramID(): Address;
    getAllUserStatesForUser(user: Address): Promise<Array<UserAndKey>>;
    getUserStatesForUserAndFarm(user: Address, farm: Address): Promise<Array<UserAndKey>>;
    getAllUserStates(): Promise<UserAndKey[]>;
    getAllUserStatesWithFilter(isFarmDelegated: boolean): Promise<UserAndKey[]>;
    /**
     * Get all farms user states from an async generator filled with batches of max 100 user states each
     * @example
     * const userStateGenerator = farms.batchGetAllUserStates();
     * for await (const userStates of userStateGenerator) {
     *   console.log('got a batch of user states:', userStates.length);
     * }
     * @param isFarmDelegated - Optional filter to get only user states for farms that are delegated or not
     */
    batchGetAllUserStates(isFarmDelegated?: boolean): AsyncGenerator<UserAndKey[], void, unknown>;
    getAllUserStatesForFarm(farm: Address): Promise<UserAndKey[]>;
    getFarmsForMint(mint: Address): Promise<Array<FarmAndKey>>;
    getAllFarmStates(): Promise<FarmAndKey[]>;
    getAllFarmStatesByPubkeys(keys: Address[]): Promise<FarmAndKey[]>;
    getStakedAmountForFarm(farm: Address): Promise<Decimal>;
    getStakedAmountForMintForFarm(_mint: Address, farm: Address): Promise<Decimal>;
    getStakedAmountForMint(mint: Address): Promise<Decimal>;
    getLockupDurationAndExpiry(farm: Address, user: Address, timestampNow: number): Promise<{
        lockupRemainingDuration: number;
        farmLockupOriginalDuration: number;
        farmLockupExpiry: number;
    }>;
    getUserStateKeysForDelegatedFarm(user: Address, farm: Address, delegatees?: Address[]): Promise<Array<UserAndKey>>;
    getUserStateKeysForDelegatedFarmDeterministic(user: Address, farm: Address, delegatees: Address[]): Promise<Array<UserAndKey>>;
    getOraclePrices(farmState: FarmState): Promise<OraclePrices | null>;
    filterFarmsForStrategies(farmStates: FarmAndKey[], strategiesToInclude?: Set<Address>): FarmAndKey[];
    filterFarmsForVaults(farmStates: FarmAndKey[], vaultsToInclude?: Set<Address>): FarmAndKey[];
    getFarmStatesFromUserStates(userStates: UserAndKey[], strategiesToInclude?: Set<Address>, vaultsToInclude?: Set<Address>): Promise<FarmAndKey[]>;
    getUserPendingRewards(userState: UserState, farmState: FarmState, timestamp: Decimal, oraclePrices: OraclePrices | null): {
        userPendingRewardAmounts: Array<Decimal>;
        hasReward: boolean;
    };
    getAllFarmsForUser(user: Address, timestamp: Decimal, strategiesToInclude?: Set<Address>, vaultsToInclude?: Set<Address>): Promise<Map<Address, UserFarm>>;
    getRewardsAPYForStrategy(strategy: Address, rpcEndpoint: string): Promise<FarmIncentives>;
    getAllFarmsForUserMultiState(user: Address, timestamp: Decimal, strategiesToInclude?: Set<Address>, vaultsToInclude?: Set<Address>): Promise<Map<Address, UserFarm[]>>;
    getUserStateKeyForUndelegatedFarm(user: Address, farmAddress: Address): Promise<UserAndKey>;
    getUserTokensInUndelegatedFarm(user: Address, farm: Address, tokenDecimals: number): Promise<Decimal>;
    getUserForUndelegatedFarm(user: Address, farmAddress: Address, timestamp: Decimal): Promise<UserFarm>;
    createNewUserIx(authority: TransactionSigner, farm: Address, user?: Address, delegatee?: Address): Promise<IInstruction>;
    stakeIx(user: TransactionSigner, farm: Address, amountLamports: Decimal, stakeTokenMint: Address, scopePrices: Option<Address>): Promise<IInstruction>;
    unstakeIx(user: TransactionSigner, farm: Address, amountLamports: Decimal, scopePrices: Option<Address>): Promise<IInstruction>;
    withdrawUnstakedDepositIx(user: TransactionSigner, userState: Address, farmState: Address, stakeTokenMint: Address): Promise<IInstruction>;
    claimForUserForFarmRewardIx(user: TransactionSigner, farm: Address, rewardMint: Address, isDelegated: boolean, rewardIndex?: number, delegatees?: Address[]): Promise<[[Address, IInstruction][], IInstruction[]]>;
    claimForUserForFarmAllRewardsIx(user: TransactionSigner, farm: Address, isDelegated: boolean, delegatees?: Address[]): Promise<Array<IInstruction>>;
    transferOwnershipIx(user: TransactionSigner, userState: Address, newUser: Address): Promise<IInstruction>;
    validateFarmStateForTransferOwnership(farmState: FarmState): void;
    transferOwnershipAllUserStatesIx(user: TransactionSigner, newUser: Address): Promise<Array<IInstruction>>;
    createFarmIxs(admin: TransactionSigner, farm: TransactionSigner, globalConfig: Address, stakeTokenMint: Address): Promise<IInstruction[]>;
    createFarmDelegatedIx(admin: TransactionSigner, farm: TransactionSigner, globalConfig: Address, farmDelegate: TransactionSigner): Promise<IInstruction[]>;
    addRewardToFarmIx(admin: TransactionSigner, globalConfig: Address, farm: Address, mint: Address, tokenProgram: Address): Promise<IInstruction>;
    addRewardAmountToFarmIx(payer: TransactionSigner, farm: Address, mint: Address, amount: Decimal, rewardIndexOverride?: number, decimalsOverride?: number, tokenProgramOverride?: Address, scopePricesOverride?: Option<Address>): Promise<IInstruction>;
    withdrawRewardAmountFromFarmIx(payer: TransactionSigner, farm: Address, mint: Address, amount: Decimal, rewardIndexOverride?: number, decimalsOverride?: number, tokenProgramOverride?: Address, scopePricesOverride?: Option<Address>): Promise<IInstruction[]>;
    updateFarmConfigIx(admin: TransactionSigner, farm: Address, mint: Address, mode: FarmConfigOptionKind, value: number | Address | number[] | RewardCurvePoint[] | BN, rewardIndexOverride?: number, scopePricesOverride?: Option<Address>, newFarm?: boolean): Promise<IInstruction>;
    refreshFarmIx(farm: Address, scopePrices: Option<Address>): Promise<IInstruction>;
    refreshUserIx(userState: Address, farmState: Address, scopePrices: Option<Address>): Promise<IInstruction>;
    createGlobalConfigIxs(admin: TransactionSigner, globalConfig: TransactionSigner): Promise<IInstruction[]>;
    updateGlobalConfigIx(admin: TransactionSigner, globalConfig: Address, mode: GlobalConfigOptionKind, flagValue: string, flagValueType: GlobalConfigFlagValueType): Promise<IInstruction>;
    updateGlobalConfigAdminIx(admin: TransactionSigner, globalConfig: Address): Promise<IInstruction>;
    updateSecondDelegatedAuthorityIx(admin: TransactionSigner, globalConfig: Address, farm: Address, newSecondDelegatedAuthority: Address): Promise<IInstruction>;
    updateFarmAdminIx(admin: TransactionSigner, farm: Address): Promise<IInstruction>;
    withdrawTreasuryIx(admin: TransactionSigner, globalConfig: Address, rewardMint: Address, rewardTokenProgram: Address, amount: BN, withdrawAta?: Address): Promise<IInstruction>;
    updateFarmRpsForRewardIx(payer: TransactionSigner, rewardMint: Address, farm: Address, rewardsPerSecond: number): Promise<IInstruction>;
    topUpFarmForRewardIx(payer: TransactionSigner, rewardMint: Address, farm: Address, amountToTopUp: Decimal): Promise<IInstruction>;
    fetchMultipleFarmStatesWithCheckedSize(keys: Address[]): Promise<(FarmState | null)[]>;
    private processRewardInfos;
    calculateFarmIncentivesApy(farm: FarmAndKey, getPriceByTokenMintDecimal: (mint: Address) => Promise<Decimal>, stakedTokenPrice: Decimal, stakedTokenDecimals: number, pricesMap?: Map<Address, Decimal>): Promise<FarmIncentives>;
    /**
     * Simulates the farm incentives APY after a stake or unstake operation.
     * @param farm - The farm to simulate the incentives APY for.
     * @param stakedTokenDelta - The difference between the current staked amount and the new staked amount (if positive, it's a stake, if negative, it's an unstake)
     * @param getPriceByTokenMintDecimal - A function to get the price of a token mint.
     * @param stakedTokenPrice - The price of the staked token.
     * @param stakedTokenDecimals - The decimals of the staked token.
     * @param pricesMap - A map of token mints to their prices.
     * @param verbose - Whether to log verbose information.
     * @returns The farm incentives APY after the stake or unstake operation.
     */
    simulateFarmIncentivesApy(farm: FarmAndKey, stakedTokenDelta: Decimal, getPriceByTokenMintDecimal: (mint: Address) => Promise<Decimal>, stakedTokenPrice: Decimal, stakedTokenDecimals: number, pricesMap?: Map<Address, Decimal>, verbose?: boolean): Promise<FarmIncentives>;
    calculateRewardsForPeriods(reward: RewardInfo, rewardType: number, totalStakedAmount: Decimal, stakedTokenDecimals: number, price: Decimal): {
        dailyRewards: Decimal;
        weeklyRewards: Decimal;
        monthlyRewards: Decimal;
        yearlyRewards: Decimal;
    };
    getRewardPerTimeUnitSecond(reward: RewardInfo): Decimal;
}
export declare function getCurrentTimeUnit(farm: FarmState, slot: Slot, timestamp: UnixTimestamp): Promise<Decimal>;
export declare function getCurrentRps(farm: FarmState, rewardIndex: number, slot: Slot, timestamp: UnixTimestamp): Promise<number>;
export declare const calcAvgBoost: (dollarValueBoosts: [Decimal, Decimal][]) => Decimal;
//# sourceMappingURL=Farms.d.ts.map
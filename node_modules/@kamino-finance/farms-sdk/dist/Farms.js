"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.calcAvgBoost = exports.Farms = void 0;
exports.getCurrentTimeUnit = getCurrentTimeUnit;
exports.getCurrentRps = getCurrentRps;
const bn_js_1 = __importDefault(require("bn.js"));
const kit_1 = require("@solana/kit");
const utils_1 = require("./utils");
const accounts_1 = require("./@codegen/farms/accounts");
const farmOperations = __importStar(require("./utils/operations"));
const decimal_js_1 = __importDefault(require("decimal.js"));
const index_1 = require("./@codegen/farms/types/index");
const programId_1 = require("./@codegen/farms/programId");
const accounts_2 = require("@kamino-finance/scope-sdk/dist/@codegen/scope/accounts");
const arrayUtils_1 = require("./utils/arrayUtils");
const batch_1 = require("./utils/batch");
const token_1 = require("./utils/token");
const consts_1 = require("./consts");
const token_2 = require("@solana-program/token");
const option_1 = require("./utils/option");
const utils_2 = require("./utils");
const web3_js_1 = require("@solana/web3.js");
const consts_2 = require("./utils/consts");
const fzstd_1 = require("fzstd");
const exponential_backoff_1 = require("exponential-backoff");
const kliquidity_sdk_1 = require("@kamino-finance/kliquidity-sdk");
const SOLANA_API_RETRY = {
    maxDelay: 10 * 1000,
    numOfAttempts: 3,
    retry: (e, attemptNumber) => {
        // silent retry
        return true;
    },
};
class Farms {
    _connection;
    _farmsProgramId;
    constructor(connection, farmsProgramId = programId_1.PROGRAM_ID) {
        this._connection = connection;
        this._farmsProgramId = farmsProgramId;
    }
    getConnection() {
        return this._connection;
    }
    getProgramID() {
        return this._farmsProgramId;
    }
    async getAllUserStatesForUser(user) {
        let filters = [];
        filters.push({
            memcmp: {
                bytes: user.toString(),
                offset: 48n,
                encoding: "base58",
            },
        });
        filters.push({ dataSize: BigInt(accounts_1.UserState.layout.span + 8) });
        return (await this._connection
            .getProgramAccounts(this._farmsProgramId, {
            filters,
            encoding: "base64",
        })
            .send()).map((x) => {
            const userAndKey = {
                userState: accounts_1.UserState.decode(Buffer.from(x.account.data[0], "base64")),
                key: x.pubkey,
            };
            return userAndKey;
        });
    }
    async getUserStatesForUserAndFarm(user, farm) {
        let filters = [];
        filters.push({
            memcmp: {
                bytes: user.toString(),
                offset: 48n,
                encoding: "base58",
            },
        });
        filters.push({
            memcmp: {
                bytes: farm.toString(),
                offset: 16n,
                encoding: "base58",
            },
        });
        filters.push({ dataSize: BigInt(accounts_1.UserState.layout.span + 8) });
        return (await this._connection
            .getProgramAccounts(this._farmsProgramId, {
            filters,
            encoding: "base64",
        })
            .send()).map((x) => {
            const userAndKey = {
                userState: accounts_1.UserState.decode(Buffer.from(x.account.data[0], "base64")),
                key: x.pubkey,
            };
            return userAndKey;
        });
    }
    async getAllUserStates() {
        return (await this._connection
            .getProgramAccounts(this._farmsProgramId, {
            filters: [{ dataSize: BigInt(accounts_1.UserState.layout.span + 8) }],
            encoding: "base64",
        })
            .send()).map((x) => {
            const userAndKey = {
                userState: accounts_1.UserState.decode(Buffer.from(x.account.data[0], "base64")),
                key: x.pubkey,
            };
            return userAndKey;
        });
    }
    async getAllUserStatesWithFilter(isFarmDelegated) {
        return (await this._connection
            .getProgramAccounts(this._farmsProgramId, {
            filters: [
                { dataSize: BigInt(accounts_1.UserState.layout.span + 8) },
                {
                    memcmp: {
                        offset: 80n,
                        bytes: (isFarmDelegated ? "2" : "1"),
                        encoding: "base58",
                    },
                },
            ],
            encoding: "base64",
        })
            .send()).map((x) => {
            const userAndKey = {
                userState: accounts_1.UserState.decode(Buffer.from(x.account.data[0], "base64")),
                key: x.pubkey,
            };
            return userAndKey;
        });
    }
    /**
     * Get all farms user states from an async generator filled with batches of max 100 user states each
     * @example
     * const userStateGenerator = farms.batchGetAllUserStates();
     * for await (const userStates of userStateGenerator) {
     *   console.log('got a batch of user states:', userStates.length);
     * }
     * @param isFarmDelegated - Optional filter to get only user states for farms that are delegated or not
     */
    async *batchGetAllUserStates(isFarmDelegated) {
        // Get all farms first and then get user states for each farm
        let farms = await this.getAllFarmStates();
        if (isFarmDelegated !== undefined) {
            farms = farms.filter((farm) => Boolean(farm.farmState.isFarmDelegated) === isFarmDelegated);
        }
        for (const farm of farms) {
            const farmUserStates = await (0, exponential_backoff_1.backOff)(() => this.getAllUserStatesForFarm(farm.key), SOLANA_API_RETRY);
            if (farmUserStates.length > 0) {
                // Process in smaller batches to avoid memory issues
                for (const batch of (0, arrayUtils_1.chunks)(farmUserStates, 100)) {
                    yield batch;
                }
            }
        }
    }
    async getAllUserStatesForFarm(farm) {
        return (await this._connection
            .getProgramAccounts(this._farmsProgramId, {
            filters: [
                { dataSize: BigInt(accounts_1.UserState.layout.span + 8) },
                {
                    memcmp: {
                        offset: 8n + 8n,
                        bytes: farm.toString(),
                        encoding: "base58",
                    },
                },
            ],
            encoding: "base64+zstd",
        })
            .send()).map((x) => {
            const compressedData = Buffer.from(x.account.data[0], "base64");
            const decompressedData = (0, fzstd_1.decompress)(compressedData);
            const userAndKey = {
                userState: accounts_1.UserState.decode(Buffer.from(decompressedData)),
                key: x.pubkey,
            };
            return userAndKey;
        });
    }
    async getFarmsForMint(mint) {
        let filters = [];
        filters.push({
            memcmp: {
                bytes: mint.toString(),
                offset: 72n,
                encoding: "base58",
            },
        });
        filters.push({ dataSize: BigInt(accounts_1.FarmState.layout.span + 8) });
        return (await this._connection
            .getProgramAccounts(this._farmsProgramId, {
            filters,
            encoding: "base64",
        })
            .send()).map((x) => {
            const farmAndKey = {
                farmState: accounts_1.FarmState.decode(Buffer.from(x.account.data[0], "base64")),
                key: x.pubkey,
            };
            return farmAndKey;
        });
    }
    async getAllFarmStates() {
        return (await this._connection
            .getProgramAccounts(this._farmsProgramId, {
            filters: [{ dataSize: BigInt(accounts_1.FarmState.layout.span + 8) }],
            encoding: "base64",
        })
            .send())
            .map((x) => {
            try {
                const farmAndKey = {
                    farmState: accounts_1.FarmState.decode(Buffer.from(x.account.data[0], "base64")),
                    key: x.pubkey,
                };
                return farmAndKey;
            }
            catch (err) {
                return null;
            }
        })
            .filter((x) => x !== null);
    }
    async getAllFarmStatesByPubkeys(keys) {
        const farmAndKeys = [];
        const farmStates = await (0, batch_1.batchFetch)(keys, async (chunk) => await this.fetchMultipleFarmStatesWithCheckedSize(chunk));
        farmStates.forEach((farmState, index) => {
            if (farmState) {
                farmAndKeys.push({ farmState: farmState, key: keys[index] });
            }
        });
        return farmAndKeys;
    }
    async getStakedAmountForFarm(farm) {
        const farmState = await accounts_1.FarmState.fetch(this._connection, farm);
        if (!farmState) {
            throw Error("No Farm found");
        }
        return (0, utils_1.lamportsToCollDecimal)(new decimal_js_1.default((0, utils_1.scaleDownWads)(farmState.totalActiveStakeScaled)), farmState.token.decimals.toNumber());
    }
    async getStakedAmountForMintForFarm(_mint, farm) {
        return this.getStakedAmountForFarm(farm);
    }
    async getStakedAmountForMint(mint) {
        const farms = await this.getFarmsForMint(mint);
        let totalStaked = new decimal_js_1.default(0);
        for (let index = 0; index < farms.length; index++) {
            totalStaked = totalStaked.add((0, utils_1.lamportsToCollDecimal)(new decimal_js_1.default(farms[index].farmState.totalStakedAmount.toString()), farms[index].farmState.token.decimals.toNumber()));
        }
        return totalStaked;
    }
    async getLockupDurationAndExpiry(farm, user, timestampNow) {
        let userStateAddress = await (0, utils_1.getUserStatePDA)(this._farmsProgramId, farm, user);
        let userState = await accounts_1.UserState.fetch(this._connection, userStateAddress);
        let farmState = await accounts_1.FarmState.fetch(this._connection, farm);
        if (!farmState) {
            throw new Error("Error fetching farm state");
        }
        let lockingMode = farmState?.lockingMode.toNumber();
        let lockingDuration = farmState?.lockingDuration.toNumber();
        let penalty = farmState.lockingEarlyWithdrawalPenaltyBps.toNumber();
        if (penalty !== 0 && penalty !== 10000) {
            throw "Early withdrawal penalty is not supported yet";
        }
        if (penalty > 10000) {
            throw "Early withdrawal penalty is too high";
        }
        let lockingStart = 0;
        if (lockingMode == index_1.LockingMode.None.discriminator) {
            return {
                farmLockupOriginalDuration: 0,
                farmLockupExpiry: 0,
                lockupRemainingDuration: 0,
            };
        }
        if (lockingMode == index_1.LockingMode.WithExpiry.discriminator) {
            // Locking starts globally for the entire farm
            lockingStart = farmState?.lockingStartTimestamp.toNumber();
        }
        if (lockingMode == index_1.LockingMode.Continuous.discriminator) {
            // Locking starts for each user individually at each stake
            // if the user has a state, else now
            if (userState === null) {
                lockingStart = timestampNow;
            }
            else {
                if (!userState) {
                    throw new Error("Error fetching user state");
                }
                lockingStart = userState.lastStakeTs.toNumber();
            }
        }
        const timestampBeginning = lockingStart;
        const timestampMaturity = lockingStart + lockingDuration;
        if (timestampNow >= timestampMaturity) {
            // Time has passed, no remaining
            return {
                farmLockupOriginalDuration: farmState.lockingDuration.toNumber(),
                farmLockupExpiry: timestampMaturity,
                lockupRemainingDuration: 0,
            };
        }
        if (timestampNow < timestampBeginning) {
            // Time has not started, no remaining
            return {
                farmLockupOriginalDuration: farmState.lockingDuration.toNumber(),
                farmLockupExpiry: timestampMaturity,
                lockupRemainingDuration: 0,
            };
        }
        const timeRemaining = timestampMaturity - timestampNow;
        const remainingLockedDurationSeconds = Math.max(timeRemaining, 0);
        return {
            farmLockupOriginalDuration: farmState.lockingDuration.toNumber(),
            farmLockupExpiry: timestampMaturity,
            lockupRemainingDuration: remainingLockedDurationSeconds,
        };
    }
    async getUserStateKeysForDelegatedFarm(user, farm, delegatees) {
        if (delegatees) {
            return this.getUserStateKeysForDelegatedFarmDeterministic(user, farm, delegatees);
        }
        const userStates = await this.getUserStatesForUserAndFarm(user, farm);
        const userStateKeysForFarm = [];
        for (let index = 0; index < userStates.length; index++) {
            if (userStates[index].userState.farmState === farm) {
                userStateKeysForFarm.push(userStates[index]);
            }
        }
        if (userStateKeysForFarm.length === 0) {
            throw Error("No user state found for user " + user + " for farm " + farm);
        }
        else {
            return userStateKeysForFarm;
        }
    }
    async getUserStateKeysForDelegatedFarmDeterministic(user, farm, delegatees) {
        const userStateKeysForFarm = [];
        const userStateAddresses = await Promise.all(delegatees.map(async (delegate) => {
            return await (0, utils_1.getUserStatePDA)(this._farmsProgramId, farm, delegate);
        }));
        const userStates = await accounts_1.UserState.fetchMultiple(this._connection, userStateAddresses);
        userStates.forEach((userState, index) => {
            if (userState && userState.farmState === farm) {
                userStateKeysForFarm.push({
                    key: userStateAddresses[index],
                    userState: userState,
                });
            }
        });
        if (userStateKeysForFarm.length === 0) {
            throw Error("No user state found for user " + user + " for farm " + farm);
        }
        else {
            return userStateKeysForFarm;
        }
    }
    async getOraclePrices(farmState) {
        let oraclePrices = null;
        if (farmState.scopePrices !== utils_1.DEFAULT_PUBLIC_KEY) {
            oraclePrices = await accounts_2.OraclePrices.fetch(this._connection, farmState.scopePrices);
            if (!oraclePrices) {
                throw new Error("Error fetching oracle prces");
            }
        }
        return oraclePrices;
    }
    filterFarmsForStrategies(farmStates, strategiesToInclude) {
        if (strategiesToInclude) {
            return farmStates.filter((farmState) => strategiesToInclude.has(farmState.farmState.strategyId));
        }
        return farmStates;
    }
    filterFarmsForVaults(farmStates, vaultsToInclude) {
        if (vaultsToInclude) {
            return farmStates.filter((farmState) => vaultsToInclude.has(farmState.farmState.vaultId));
        }
        return farmStates;
    }
    async getFarmStatesFromUserStates(userStates, strategiesToInclude, vaultsToInclude) {
        const farmPks = new Set();
        for (let i = 0; i < userStates.length; i++) {
            farmPks.add(userStates[i].userState.farmState);
        }
        const farmStates = await (0, batch_1.batchFetch)(Array.from(farmPks), async (chunk) => await this.getAllFarmStatesByPubkeys(chunk));
        if (!farmStates) {
            throw new Error("Error fetching farms");
        }
        let farmStatesFiltered = this.filterFarmsForStrategies(farmStates, strategiesToInclude);
        farmStatesFiltered = this.filterFarmsForVaults(farmStatesFiltered, vaultsToInclude);
        return farmStates;
    }
    getUserPendingRewards(userState, farmState, timestamp, oraclePrices) {
        // calculate userState pending rewards
        const userPendingRewardAmounts = [];
        let hasReward = false;
        for (let indexReward = 0; indexReward < farmState.rewardInfos.length; indexReward++) {
            userPendingRewardAmounts[indexReward] = (0, utils_1.calculatePendingRewards)(farmState, userState, indexReward, timestamp, oraclePrices);
            if (userPendingRewardAmounts[indexReward].gt(0)) {
                hasReward = true;
            }
        }
        return { userPendingRewardAmounts, hasReward };
    }
    async getAllFarmsForUser(user, timestamp, strategiesToInclude, vaultsToInclude) {
        const userStates = await this.getAllUserStatesForUser(user);
        const farmStatesFiltered = await this.getFarmStatesFromUserStates(userStates, strategiesToInclude, vaultsToInclude);
        if (farmStatesFiltered.length === 0) {
            // Return empty if no serializable farm states found
            return new Map();
        }
        const userFarms = new Map();
        for (let userState of userStates) {
            let farmState = farmStatesFiltered.find((farmState) => farmState.key === userState.userState.farmState);
            if (!farmState) {
                // Skip farms that are not serializable anymore
                continue;
            }
            let oraclePrices = await this.getOraclePrices(farmState.farmState);
            const { userPendingRewardAmounts, hasReward } = this.getUserPendingRewards(userState.userState, farmState.farmState, timestamp, oraclePrices);
            // add new userFarm state if non empty (has rewards or stake) and not already present
            if (!userFarms.has(userState.userState.farmState)) {
                const userFarm = {
                    userStateAddress: userState.key,
                    farm: userState.userState.farmState,
                    strategyId: farmState.farmState.strategyId,
                    delegateAuthority: farmState.farmState.delegateAuthority,
                    stakedToken: farmState.farmState.token.mint,
                    userState: userState.userState,
                    activeStakeByDelegatee: new Map(),
                    pendingDepositStakeByDelegatee: new Map(),
                    pendingWithdrawalUnstakeByDelegatee: new Map(),
                    pendingRewards: new Array(farmState.farmState.rewardInfos.length)
                        .fill(undefined)
                        .map(function (value, index) {
                        return {
                            rewardTokenMint: utils_1.DEFAULT_PUBLIC_KEY,
                            rewardTokenProgramId: farmState.farmState.rewardInfos[index].token.tokenProgram,
                            rewardType: farmState?.farmState.rewardInfos[index].rewardType || 0,
                            cumulatedPendingRewards: new decimal_js_1.default(0),
                            pendingRewardsByDelegatee: new Map(),
                        };
                    }),
                };
                if (new decimal_js_1.default((0, utils_1.scaleDownWads)(userState.userState.activeStakeScaled)).gt(0) ||
                    hasReward) {
                    // active stake by delegatee
                    userFarm.activeStakeByDelegatee.set(userState.userState.delegatee, (0, utils_1.lamportsToCollDecimal)(new decimal_js_1.default((0, utils_1.scaleDownWads)(userState.userState.activeStakeScaled)), farmState.farmState.token.decimals.toNumber()));
                    // pendingDepositStake by delegatee
                    userFarm.pendingDepositStakeByDelegatee.set(userState.userState.delegatee, new decimal_js_1.default((0, utils_1.scaleDownWads)(userState.userState.pendingDepositStakeScaled)));
                    // pendingWithdrawalUnstake by delegatee
                    userFarm.pendingWithdrawalUnstakeByDelegatee.set(userState.userState.delegatee, new decimal_js_1.default((0, utils_1.scaleDownWads)(userState.userState.pendingWithdrawalUnstakeScaled)));
                    // cumulating rewards
                    for (let indexReward = 0; indexReward < farmState.farmState.rewardInfos.length; indexReward++) {
                        userFarm.pendingRewards[indexReward].rewardTokenMint =
                            farmState.farmState.rewardInfos[indexReward].token.mint;
                        userFarm.pendingRewards[indexReward].cumulatedPendingRewards =
                            userFarm.pendingRewards[indexReward].cumulatedPendingRewards.add(userPendingRewardAmounts[indexReward]);
                        userFarm.pendingRewards[indexReward].pendingRewardsByDelegatee.set(userState.userState.delegatee, userPendingRewardAmounts[indexReward]);
                    }
                    // set updated userFarm
                    userFarms.set(userState.userState.farmState, userFarm);
                }
                else {
                    // skip as we are not accounting for empty userFarms
                    continue;
                }
            }
        }
        return userFarms;
    }
    async getRewardsAPYForStrategy(strategy, rpcEndpoint) {
        const legacyConnection = new web3_js_1.Connection(rpcEndpoint);
        const farmIncentives = await (0, utils_2.getRewardsApyForStrategy)(this.getConnection(), legacyConnection, strategy);
        return farmIncentives;
    }
    async getAllFarmsForUserMultiState(user, timestamp, strategiesToInclude, vaultsToInclude) {
        const userStates = await this.getAllUserStatesForUser(user);
        const farmStatesFiltered = await this.getFarmStatesFromUserStates(userStates, strategiesToInclude, vaultsToInclude);
        if (farmStatesFiltered.length === 0) {
            // Return empty if no serializable farm states found
            return new Map();
        }
        const userFarmsByFarm = new Map();
        for (let userState of userStates) {
            let farmState = farmStatesFiltered.find((farmState) => farmState.key === userState.userState.farmState);
            if (!farmState) {
                // Skip farms that are not serializable anymore
                continue;
            }
            let oraclePrices = await this.getOraclePrices(farmState.farmState);
            const { userPendingRewardAmounts, hasReward } = this.getUserPendingRewards(userState.userState, farmState.farmState, timestamp, oraclePrices);
            // Only add if there's a reward or active stake
            if (!new decimal_js_1.default((0, utils_1.scaleDownWads)(userState.userState.activeStakeScaled)).gt(0) &&
                !hasReward) {
                continue;
            }
            // Create a new UserFarm instance
            const userFarm = {
                userStateAddress: userState.key,
                farm: userState.userState.farmState,
                strategyId: farmState.farmState.strategyId,
                delegateAuthority: farmState.farmState.delegateAuthority,
                stakedToken: farmState.farmState.token.mint,
                userState: userState.userState,
                activeStakeByDelegatee: new Map(),
                pendingDepositStakeByDelegatee: new Map(),
                pendingWithdrawalUnstakeByDelegatee: new Map(),
                pendingRewards: new Array(farmState.farmState.rewardInfos.length)
                    .fill(undefined)
                    .map(function (value, index) {
                    return {
                        rewardTokenMint: farmState.farmState.rewardInfos[index].token.mint,
                        rewardTokenProgramId: farmState.farmState.rewardInfos[index].token.tokenProgram,
                        rewardType: farmState?.farmState.rewardInfos[index].rewardType || 0,
                        cumulatedPendingRewards: new decimal_js_1.default(0),
                        pendingRewardsByDelegatee: new Map(),
                    };
                }),
            };
            // active stake by delegatee
            userFarm.activeStakeByDelegatee.set(userState.userState.delegatee, (0, utils_1.lamportsToCollDecimal)(new decimal_js_1.default((0, utils_1.scaleDownWads)(userState.userState.activeStakeScaled)), farmState.farmState.token.decimals.toNumber()));
            // pendingDepositStake by delegatee
            userFarm.pendingDepositStakeByDelegatee.set(userState.userState.delegatee, new decimal_js_1.default((0, utils_1.scaleDownWads)(userState.userState.pendingDepositStakeScaled)));
            // pendingWithdrawalUnstake by delegatee
            userFarm.pendingWithdrawalUnstakeByDelegatee.set(userState.userState.delegatee, new decimal_js_1.default((0, utils_1.scaleDownWads)(userState.userState.pendingWithdrawalUnstakeScaled)));
            // cumulating rewards
            for (let indexReward = 0; indexReward < farmState.farmState.rewardInfos.length; indexReward++) {
                userFarm.pendingRewards[indexReward].rewardTokenMint =
                    farmState.farmState.rewardInfos[indexReward].token.mint;
                userFarm.pendingRewards[indexReward].cumulatedPendingRewards =
                    userPendingRewardAmounts[indexReward];
                userFarm.pendingRewards[indexReward].pendingRewardsByDelegatee.set(userState.userState.delegatee, userPendingRewardAmounts[indexReward]);
            }
            // Add the userFarm to the array for the corresponding farm
            if (!userFarmsByFarm.has(userState.userState.farmState)) {
                userFarmsByFarm.set(userState.userState.farmState, [userFarm]);
            }
            else {
                userFarmsByFarm.get(userState.userState.farmState).push(userFarm);
            }
        }
        return userFarmsByFarm;
    }
    async getUserStateKeyForUndelegatedFarm(user, farmAddress) {
        const userStateAddress = await (0, utils_1.getUserStatePDA)(this._farmsProgramId, farmAddress, user);
        const userState = await accounts_1.UserState.fetch(this._connection, userStateAddress);
        if (!userState) {
            throw new Error(`User state not found ${userStateAddress.toString()}`);
        }
        return { key: userStateAddress, userState: userState };
    }
    async getUserTokensInUndelegatedFarm(user, farm, tokenDecimals) {
        const userState = await this.getUserStateKeyForUndelegatedFarm(user, farm);
        return (0, utils_1.lamportsToCollDecimal)(new decimal_js_1.default((0, utils_1.scaleDownWads)(userState.userState.activeStakeScaled)), tokenDecimals);
    }
    async getUserForUndelegatedFarm(user, farmAddress, timestamp) {
        const farmState = await accounts_1.FarmState.fetch(this._connection, farmAddress);
        if (!farmState) {
            throw new Error(`Farm not found ${farmAddress.toString()}`);
        }
        const userStateAddress = await (0, utils_1.getUserStatePDA)(this._farmsProgramId, farmAddress, user);
        const userState = await accounts_1.UserState.fetch(this._connection, userStateAddress);
        if (!userState) {
            throw new Error(`User state not found ${userStateAddress.toString()}`);
        }
        const userFarm = {
            userStateAddress: userStateAddress,
            farm: farmAddress,
            userState,
            strategyId: farmState.strategyId,
            delegateAuthority: farmState.delegateAuthority,
            stakedToken: farmState.token.mint,
            activeStakeByDelegatee: new Map(),
            pendingDepositStakeByDelegatee: new Map(),
            pendingWithdrawalUnstakeByDelegatee: new Map(),
            pendingRewards: new Array(farmState.rewardInfos.length)
                .fill(undefined)
                .map(function (value, index) {
                return {
                    rewardTokenMint: utils_1.DEFAULT_PUBLIC_KEY,
                    rewardTokenProgramId: farmState?.rewardInfos[index].token.tokenProgram,
                    rewardType: farmState?.rewardInfos[index].rewardType || 0,
                    cumulatedPendingRewards: new decimal_js_1.default(0),
                    pendingRewardsByDelegatee: new Map(),
                };
            }),
        };
        // active stake
        userFarm.activeStakeByDelegatee.set(user, (0, utils_1.lamportsToCollDecimal)(new decimal_js_1.default((0, utils_1.scaleDownWads)(userState.activeStakeScaled)), farmState.token.decimals.toNumber()));
        // pendingDepositStake
        userFarm.pendingDepositStakeByDelegatee.set(user, new decimal_js_1.default((0, utils_1.scaleDownWads)(userState.pendingDepositStakeScaled)));
        // pendingWithdrawalUnstake
        userFarm.pendingWithdrawalUnstakeByDelegatee.set(user, new decimal_js_1.default((0, utils_1.scaleDownWads)(userState.pendingWithdrawalUnstakeScaled)));
        // get oraclePrices
        let oraclePrices = null;
        if (farmState.scopePrices !== utils_1.DEFAULT_PUBLIC_KEY) {
            oraclePrices = await accounts_2.OraclePrices.fetch(this._connection, farmState.scopePrices);
            if (!oraclePrices) {
                throw new Error("Error fetching oracle prices");
            }
        }
        const userPendingRewardAmounts = [];
        for (let indexReward = 0; indexReward < farmState.rewardInfos.length; indexReward++) {
            // calculate pending rewards
            userPendingRewardAmounts[indexReward] = (0, utils_1.calculatePendingRewards)(farmState, userState, indexReward, timestamp, oraclePrices);
            userFarm.pendingRewards[indexReward].rewardTokenMint =
                farmState.rewardInfos[indexReward].token.mint;
            userFarm.pendingRewards[indexReward].cumulatedPendingRewards =
                userPendingRewardAmounts[indexReward];
            userFarm.pendingRewards[indexReward].pendingRewardsByDelegatee.set(user, userPendingRewardAmounts[indexReward]);
        }
        return userFarm;
    }
    async createNewUserIx(authority, farm, user = authority.address, delegatee = user) {
        const userState = await (0, utils_1.getUserStatePDA)(this._farmsProgramId, farm, user);
        const ix = farmOperations.initializeUser(farm, user, userState, authority, delegatee);
        return ix;
    }
    async stakeIx(user, farm, amountLamports, stakeTokenMint, scopePrices) {
        const farmVault = await (0, utils_1.getFarmVaultPDA)(this._farmsProgramId, farm, stakeTokenMint);
        const userStatePk = await (0, utils_1.getUserStatePDA)(this._farmsProgramId, farm, user.address);
        const userTokenAta = await (0, token_1.getAssociatedTokenAddress)(user.address, stakeTokenMint, token_2.TOKEN_PROGRAM_ADDRESS);
        const ix = farmOperations.stake(user, userStatePk, userTokenAta, farm, farmVault, stakeTokenMint, scopePrices, (0, utils_1.decimalToBN)(amountLamports));
        return ix;
    }
    async unstakeIx(user, farm, amountLamports, scopePrices) {
        const userStatePk = await (0, utils_1.getUserStatePDA)(this._farmsProgramId, farm, user.address);
        const ix = farmOperations.unstake(user, userStatePk, farm, scopePrices, (0, utils_1.decimalToBN)(amountLamports));
        return ix;
    }
    async withdrawUnstakedDepositIx(user, userState, farmState, stakeTokenMint) {
        const userTokenAta = await (0, token_1.getAssociatedTokenAddress)(user.address, stakeTokenMint, token_2.TOKEN_PROGRAM_ADDRESS);
        const farmVault = await (0, utils_1.getFarmVaultPDA)(this._farmsProgramId, farmState, stakeTokenMint);
        const farmVaultsAuthority = await (0, utils_1.getFarmAuthorityPDA)(this._farmsProgramId, farmState);
        return farmOperations.withdrawUnstakedDeposit(user, userState, farmState, userTokenAta, farmVault, farmVaultsAuthority);
    }
    async claimForUserForFarmRewardIx(user, farm, rewardMint, isDelegated, rewardIndex = -1, delegatees) {
        const ixns = [];
        const ataIxns = [];
        const userStatesAndKeys = isDelegated
            ? await this.getUserStateKeysForDelegatedFarm(user.address, farm, delegatees)
            : [await this.getUserStateKeyForUndelegatedFarm(user.address, farm)];
        const farmState = await accounts_1.FarmState.fetch(this._connection, farm);
        if (!farmState) {
            throw new Error(`Farm not found ${farm.toString()}`);
        }
        const treasuryVault = await (0, utils_1.getTreasuryVaultPDA)(this._farmsProgramId, farmState.globalConfig, rewardMint);
        // find rewardIndex if not defined
        if (rewardIndex === -1) {
            rewardIndex = farmState.rewardInfos.findIndex((r) => r.token.mint === rewardMint);
        }
        const rewardsTokenProgram = farmState.rewardInfos[rewardIndex].token.tokenProgram;
        const userRewardAta = await (0, token_1.getAssociatedTokenAddress)(user.address, rewardMint, rewardsTokenProgram);
        const ataExists = await (0, utils_1.checkIfAccountExists)(this._connection, userRewardAta);
        if (!ataExists) {
            const [, ix] = await (0, token_1.createAssociatedTokenAccountIdempotentInstruction)(user, rewardMint, rewardsTokenProgram, user.address, userRewardAta);
            ataIxns.push([rewardMint, ix]);
        }
        for (let userStateIndex = 0; userStateIndex < userStatesAndKeys.length; userStateIndex++) {
            const ix = farmOperations.harvestReward(user, userStatesAndKeys[userStateIndex].key, userRewardAta, farmState.globalConfig, treasuryVault, farm, rewardMint, farmState.rewardInfos[rewardIndex].rewardsVault, farmState.farmVaultsAuthority, (0, option_1.getScopePricesFromFarm)(farmState), rewardsTokenProgram, rewardIndex);
            ixns.push(ix);
        }
        return [ataIxns, ixns];
    }
    async claimForUserForFarmAllRewardsIx(user, farm, isDelegated, delegatees) {
        const farmState = await accounts_1.FarmState.fetch(this._connection, farm);
        const userStatesAndKeys = isDelegated
            ? await this.getUserStateKeysForDelegatedFarm(user.address, farm, delegatees)
            : [await this.getUserStateKeyForUndelegatedFarm(user.address, farm)];
        const ixs = new Array();
        // hardcoded as a hotfix for JTO release;
        // TODO: replace by proper fix
        const jitoFarm = (0, kit_1.address)("Cik985zLyHYdv5Hs73BUWUcMHMhgfBNwbcCYyvBjV2tt");
        if (!farmState) {
            throw new Error(`Farm not found ${farm.toString()}`);
        }
        for (let userStateIndex = 0; userStateIndex < userStatesAndKeys.length; userStateIndex++) {
            for (let rewardIndex = 0; rewardIndex < farmState.numRewardTokens.toNumber(); rewardIndex++) {
                if (jitoFarm !== farm &&
                    farmState.rewardInfos[rewardIndex].rewardType ==
                        index_1.RewardType.Constant.discriminator) {
                    continue;
                }
                const rewardMint = farmState.rewardInfos[rewardIndex].token.mint;
                const rewardTokenProgram = farmState.rewardInfos[rewardIndex].token.tokenProgram;
                const userRewardAta = await (0, token_1.getAssociatedTokenAddress)(user.address, rewardMint, rewardTokenProgram);
                const treasuryVault = await (0, utils_1.getTreasuryVaultPDA)(this._farmsProgramId, farmState.globalConfig, rewardMint);
                const ataExists = await (0, utils_1.checkIfAccountExists)(this._connection, userRewardAta);
                if (!ataExists) {
                    const [, ix] = await (0, token_1.createAssociatedTokenAccountIdempotentInstruction)(user, rewardMint, rewardTokenProgram, user.address, userRewardAta);
                    ixs.push(ix);
                }
                ixs.push(farmOperations.harvestReward(user, userStatesAndKeys[userStateIndex].key, userRewardAta, farmState.globalConfig, treasuryVault, farm, rewardMint, farmState.rewardInfos[rewardIndex].rewardsVault, farmState.farmVaultsAuthority, (0, option_1.getScopePricesFromFarm)(farmState), rewardTokenProgram, rewardIndex));
            }
        }
        return ixs;
    }
    async transferOwnershipIx(user, userState, newUser) {
        const userStateData = await accounts_1.UserState.fetch(this._connection, userState, this._farmsProgramId);
        if (!userStateData) {
            throw new Error(`User state not found ${userState.toString()}`);
        }
        const farmState = await accounts_1.FarmState.fetch(this._connection, userStateData.farmState, this._farmsProgramId);
        if (!farmState) {
            throw new Error(`Farm state not found ${userStateData.farmState.toString()}`);
        }
        this.validateFarmStateForTransferOwnership(farmState);
        const newOwnerUserState = await (0, utils_1.getUserStatePDA)(programId_1.PROGRAM_ID, userStateData.farmState, newUser);
        return farmOperations.transferOwnership(user, userState, newUser, userStateData.farmState, newOwnerUserState, (0, option_1.getScopePricesFromFarm)(farmState));
    }
    validateFarmStateForTransferOwnership(farmState) {
        if (farmState.lockingMode.toNumber() !== index_1.LockingMode.None.discriminator) {
            throw new Error("Transfer ownership is not allowed for farms with a locking mode");
        }
        if (farmState.isFarmDelegated) {
            throw new Error("Transfer ownership is not allowed for delegated farms");
        }
        if (farmState.withdrawalCooldownPeriod > 0) {
            throw new Error("Transfer ownership is not allowed for farms with a withdrawal cooldown period");
        }
    }
    async transferOwnershipAllUserStatesIx(user, newUser) {
        const userStates = await this.getAllUserStatesForUser(user.address);
        const farms = await this.getFarmStatesFromUserStates(userStates);
        const ixs = new Array();
        for (let index = 0; index < userStates.length; index++) {
            const farmAddress = userStates[index].userState.farmState;
            const farmState = farms.find((farm) => farm.key === farmAddress);
            if (!farmState) {
                throw new Error(`Farm state not found for user state ${userStates[index].key}`);
            }
            this.validateFarmStateForTransferOwnership(farmState.farmState);
            const newOwnerUserState = await (0, utils_1.getUserStatePDA)(programId_1.PROGRAM_ID, farmAddress, newUser);
            ixs[index] = farmOperations.transferOwnership(user, userStates[index].key, newUser, farmAddress, newOwnerUserState, (0, option_1.getScopePricesFromFarm)(farmState.farmState));
        }
        return ixs;
    }
    async createFarmIxs(admin, farm, globalConfig, stakeTokenMint) {
        const farmVault = await (0, utils_1.getFarmVaultPDA)(this._farmsProgramId, farm.address, stakeTokenMint);
        const farmVaultAuthority = await (0, utils_1.getFarmAuthorityPDA)(this._farmsProgramId, farm.address);
        let ixs = [];
        ixs.push(await (0, utils_1.createKeypairRentExemptIx)(this.getConnection(), admin, farm, utils_1.SIZE_FARM_STATE, this._farmsProgramId));
        ixs.push(farmOperations.initializeFarm(globalConfig, admin, farm.address, farmVault, farmVaultAuthority, stakeTokenMint));
        return ixs;
    }
    async createFarmDelegatedIx(admin, farm, globalConfig, farmDelegate) {
        const farmVaultAuthority = await (0, utils_1.getFarmAuthorityPDA)(this._farmsProgramId, farm.address);
        let ixs = [];
        ixs.push(await (0, utils_1.createKeypairRentExemptIx)(this.getConnection(), admin, farm, utils_1.SIZE_FARM_STATE, this._farmsProgramId));
        ixs.push(farmOperations.initializeFarmDelegated(globalConfig, admin, farm.address, farmVaultAuthority, farmDelegate));
        return ixs;
    }
    async addRewardToFarmIx(admin, globalConfig, farm, mint, tokenProgram) {
        const globalConfigState = await accounts_1.GlobalConfig.fetch(this._connection, globalConfig);
        if (!globalConfigState) {
            throw new Error("Could not fetch global config");
        }
        const treasuryVault = await (0, utils_1.getTreasuryVaultPDA)(this._farmsProgramId, globalConfig, mint);
        let farmVaultAuthority = await (0, utils_1.getFarmAuthorityPDA)(this._farmsProgramId, farm);
        const rewardVault = await (0, utils_1.getRewardVaultPDA)(this._farmsProgramId, farm, mint);
        const ix = farmOperations.initializeReward(globalConfig, globalConfigState.treasuryVaultsAuthority, treasuryVault, admin, farm, rewardVault, farmVaultAuthority, mint, tokenProgram);
        return ix;
    }
    async addRewardAmountToFarmIx(payer, farm, mint, amount, rewardIndexOverride = -1, decimalsOverride = -1, tokenProgramOverride = token_2.TOKEN_PROGRAM_ADDRESS, scopePricesOverride = (0, kit_1.none)()) {
        let decimals = decimalsOverride;
        let rewardIndex = rewardIndexOverride;
        let scopePrices = scopePricesOverride;
        let tokenProgram = tokenProgramOverride;
        if (rewardIndex == -1) {
            const farmState = await accounts_1.FarmState.fetch(this._connection, farm);
            if (!farmState) {
                throw new Error(`Could not fetch farm state ${farm}`);
            }
            scopePrices = (0, option_1.getScopePricesFromFarm)(farmState);
            for (let i = 0; farmState.rewardInfos.length; i++) {
                if (farmState.rewardInfos[i].token.mint === mint) {
                    if (farmState.rewardInfos[i].token.tokenProgram !== utils_1.DEFAULT_PUBLIC_KEY) {
                        tokenProgram = farmState.rewardInfos[i].token.tokenProgram;
                    }
                    rewardIndex = i;
                    decimals = farmState.rewardInfos[i].token.decimals.toNumber();
                    break;
                }
            }
        }
        if (decimals == -1) {
            throw new Error(`Could not find reward token ${mint}`);
        }
        let amountLamports = new bn_js_1.default((0, utils_1.collToLamportsDecimal)(amount, decimals).floor().toString());
        const payerRewardAta = await (0, token_1.getAssociatedTokenAddress)(payer.address, mint, tokenProgram);
        let rewardVault = await (0, utils_1.getRewardVaultPDA)(this._farmsProgramId, farm, mint);
        let farmVaultsAuthority = await (0, utils_1.getFarmAuthorityPDA)(this._farmsProgramId, farm);
        const ix = farmOperations.addReward(payer, farm, rewardVault, farmVaultsAuthority, payerRewardAta, mint, scopePrices, rewardIndex, tokenProgram, amountLamports);
        return ix;
    }
    async withdrawRewardAmountFromFarmIx(payer, farm, mint, amount, rewardIndexOverride = -1, decimalsOverride = -1, tokenProgramOverride = token_2.TOKEN_PROGRAM_ADDRESS, scopePricesOverride = (0, kit_1.none)()) {
        let decimals = decimalsOverride;
        let tokenProgram = tokenProgramOverride;
        let rewardIndex = rewardIndexOverride;
        let scopePrices = scopePricesOverride;
        if (rewardIndex == -1) {
            const farmState = await accounts_1.FarmState.fetch(this._connection, farm);
            if (!farmState) {
                throw new Error(`Could not fetch farm state ${farm}`);
            }
            scopePrices = (0, option_1.getScopePricesFromFarm)(farmState);
            for (let i = 0; farmState.rewardInfos.length; i++) {
                if (farmState.rewardInfos[i].token.mint === mint) {
                    rewardIndex = i;
                    decimals = farmState.rewardInfos[i].token.decimals.toNumber();
                    tokenProgram = farmState.rewardInfos[i].token.tokenProgram;
                    break;
                }
            }
        }
        if (decimals == -1) {
            throw new Error(`Could not find reward token ${mint}`);
        }
        let amountLamports = new bn_js_1.default((0, utils_1.collToLamportsDecimal)(amount, decimals).floor().toString());
        let rewardVault = await (0, utils_1.getRewardVaultPDA)(this._farmsProgramId, farm, mint);
        let farmVaultsAuthority = await (0, utils_1.getFarmAuthorityPDA)(this._farmsProgramId, farm);
        const [payerRewardAta, initAtaIdempotentIx] = await (0, token_1.createAssociatedTokenAccountIdempotentInstruction)(payer, mint, tokenProgram, payer.address);
        const ix = farmOperations.withdrawReward(payer, farm, mint, rewardVault, farmVaultsAuthority, payerRewardAta, scopePrices, tokenProgram, rewardIndex, amountLamports);
        return [initAtaIdempotentIx, ix];
    }
    async updateFarmConfigIx(admin, farm, mint, mode, value, rewardIndexOverride = -1, scopePricesOverride = (0, kit_1.none)(), newFarm = false) {
        let rewardIndex = rewardIndexOverride;
        let scopePrices = scopePricesOverride;
        if (rewardIndex == -1 && !newFarm) {
            const farmState = await accounts_1.FarmState.fetch(this._connection, farm);
            if (!farmState) {
                throw new Error(`Could not fetch farm state ${farm}`);
            }
            if (farmState.scopePrices !== utils_1.DEFAULT_PUBLIC_KEY) {
                scopePrices = (0, kit_1.some)(farmState.scopePrices);
            }
            for (let i = 0; farmState.rewardInfos.length; i++) {
                if (farmState.rewardInfos[i].token.mint === mint) {
                    rewardIndex = i;
                    break;
                }
            }
        }
        const ix = farmOperations.updateFarmConfig(admin, farm, scopePrices, rewardIndex, mode, value);
        return ix;
    }
    async refreshFarmIx(farm, scopePrices) {
        return farmOperations.refreshFarm(farm, scopePrices);
    }
    async refreshUserIx(userState, farmState, scopePrices) {
        return farmOperations.refreshUserState(userState, farmState, scopePrices);
    }
    async createGlobalConfigIxs(admin, globalConfig) {
        let ixs = [];
        ixs.push(await (0, utils_1.createKeypairRentExemptIx)(this.getConnection(), admin, globalConfig, utils_1.SIZE_GLOBAL_CONFIG, this._farmsProgramId));
        const treasuryVaultAuthority = await (0, utils_1.getTreasuryAuthorityPDA)(this._farmsProgramId, globalConfig.address);
        ixs.push(farmOperations.initializeGlobalConfig(admin, globalConfig.address, treasuryVaultAuthority));
        return ixs;
    }
    async updateGlobalConfigIx(admin, globalConfig, mode, flagValue, flagValueType) {
        const ix = farmOperations.updateGlobalConfig(admin, globalConfig, mode, flagValue, flagValueType);
        return ix;
    }
    async updateGlobalConfigAdminIx(admin, globalConfig) {
        return farmOperations.updateGlobalConfigAdmin(admin, globalConfig);
    }
    async updateSecondDelegatedAuthorityIx(admin, globalConfig, farm, newSecondDelegatedAuthority) {
        return farmOperations.updateSecondDelegatedAuthority(admin, globalConfig, farm, newSecondDelegatedAuthority);
    }
    async updateFarmAdminIx(admin, farm) {
        return farmOperations.updateFarmAdmin(admin, farm);
    }
    async withdrawTreasuryIx(admin, globalConfig, rewardMint, rewardTokenProgram, amount, withdrawAta) {
        const treasuryVault = await (0, utils_1.getTreasuryVaultPDA)(this._farmsProgramId, globalConfig, rewardMint);
        const treasuryVaultAuthority = await (0, utils_1.getTreasuryAuthorityPDA)(this._farmsProgramId, globalConfig);
        if (!withdrawAta) {
            withdrawAta = await (0, token_1.getAssociatedTokenAddress)(admin.address, rewardMint, rewardTokenProgram);
        }
        return farmOperations.withdrawTreasury(admin, globalConfig, treasuryVault, treasuryVaultAuthority, withdrawAta, amount, rewardMint);
    }
    async updateFarmRpsForRewardIx(payer, rewardMint, farm, rewardsPerSecond) {
        const farmsClient = new Farms(this._connection);
        const farmState = await accounts_1.FarmState.fetch(this._connection, farm, farmsClient.getProgramID());
        if (!farmState) {
            throw new Error("Farm not found");
        }
        let rewardIndex = 0;
        const rewardInfo = farmState.rewardInfos.find((info, index) => {
            rewardIndex = index;
            return info.token.mint === rewardMint;
        });
        if (!rewardInfo) {
            throw new Error("Reward not found in farm");
        }
        const currentRewardScheduleCruve = rewardInfo.rewardScheduleCurve;
        let newRewardScheduleCurve = [];
        for (let point of currentRewardScheduleCruve.points) {
            if (point.tsStart.toString() === consts_2.U64_MAX &&
                point.rewardPerTimeUnit.toNumber() === 0) {
                newRewardScheduleCurve.push({
                    startTs: Date.now(),
                    rps: rewardsPerSecond,
                });
                break;
            }
            {
                newRewardScheduleCurve.push({
                    startTs: new decimal_js_1.default(point.tsStart.toString()).toNumber(),
                    rps: new decimal_js_1.default(point.rewardPerTimeUnit.toString()).toNumber(),
                });
            }
        }
        return await this.updateFarmConfigIx(payer, farm, rewardMint, index_1.FarmConfigOption.fromDecoded({
            [index_1.FarmConfigOption.UpdateRewardScheduleCurvePoints.kind]: "",
        }), newRewardScheduleCurve, rewardIndex);
    }
    async topUpFarmForRewardIx(payer, rewardMint, farm, amountToTopUp) {
        const farmState = await accounts_1.FarmState.fetch(this._connection, farm, this.getProgramID());
        if (!farmState) {
            throw new Error("Farm not found");
        }
        let rewardIndex = 0;
        const rewardInfo = farmState.rewardInfos.find((info, index) => {
            rewardIndex = index;
            return info.token.mint === rewardMint;
        });
        if (!rewardInfo) {
            throw new Error("Reward not found in farm");
        }
        return await this.addRewardAmountToFarmIx(payer, farm, rewardMint, amountToTopUp, rewardIndex);
    }
    async fetchMultipleFarmStatesWithCheckedSize(keys) {
        // Custom deserialization to avoid fetching non-serializable accounts
        const farmStateSize = BigInt(accounts_1.FarmState.layout.span + 8);
        const infos = await this._connection.getMultipleAccounts(keys).send();
        return infos.value.map((info) => {
            if (info === null) {
                return null;
            }
            if (info.space !== farmStateSize) {
                // check if account matches expected size (deserializable)
                return null;
            }
            if (info.owner !== this._farmsProgramId) {
                throw new Error("account doesn't belong to this program");
            }
            return accounts_1.FarmState.decode(Buffer.from(info.data[0], "base64"));
        });
    }
    async processRewardInfos(farmState, totalActiveStakeValue, totalActiveStakeAmount, getPriceByTokenMintDecimal, pricesMap, verbose = false) {
        return await Promise.all(farmState.rewardInfos
            .filter((reward) => (0, utils_1.isValidPubkey)(reward.token.mint))
            .map(async (reward) => {
            const { token: rewardToken } = reward;
            // Find the more recent timestamp and rps
            let rewardAmountPerUnit = this.getRewardPerTimeUnitSecond(reward);
            if (rewardAmountPerUnit.eq(0) ||
                reward.rewardsAvailable.eq(kliquidity_sdk_1.ZERO_BN)) {
                return {
                    rewardMint: rewardToken.mint,
                    rewardDecimals: new decimal_js_1.default(rewardToken.decimals.toString()),
                    value: new decimal_js_1.default(0),
                    yearlyRewards: new decimal_js_1.default(0),
                    monthlyRewards: new decimal_js_1.default(0),
                    weeklyRewards: new decimal_js_1.default(0),
                    dailyRewards: new decimal_js_1.default(0),
                    incentivesApy: 0,
                    hasRewardAvailable: false,
                };
            }
            const cachedRewardTokenPrice = pricesMap?.get(rewardToken.mint);
            const rewardTokenPrice = cachedRewardTokenPrice
                ? cachedRewardTokenPrice
                : await getPriceByTokenMintDecimal(rewardToken.mint);
            const { dailyRewards, weeklyRewards, monthlyRewards, yearlyRewards } = this.calculateRewardsForPeriods(reward, reward.rewardType, new decimal_js_1.default(farmState.totalStakedAmount.toString()), farmState.token.decimals.toNumber(), rewardTokenPrice);
            const rewardValue = yearlyRewards.mul(rewardTokenPrice);
            const incentivesApy = rewardValue
                .div(totalActiveStakeValue)
                .toNumber();
            if (verbose) {
                console.log(`rewardValue ${rewardValue.toString()}`);
                console.log(`totalActiveStakeValue ${totalActiveStakeValue.toString()}`);
                console.log(`totalActiveStakeAmount ${totalActiveStakeAmount}`);
            }
            return {
                rewardMint: rewardToken.mint,
                rewardDecimals: new decimal_js_1.default(rewardToken.decimals.toString()),
                value: rewardValue,
                yearlyRewards,
                monthlyRewards,
                weeklyRewards,
                dailyRewards,
                incentivesApy,
                hasRewardAvailable: reward.rewardsAvailable.gtn(0),
            };
        }));
    }
    async calculateFarmIncentivesApy(farm, getPriceByTokenMintDecimal, stakedTokenPrice, stakedTokenDecimals, pricesMap) {
        const { farmState } = farm;
        const { totalActiveStakeScaled, delegateAuthority } = farmState;
        const totalActiveStakeAmount = (0, utils_1.lamportsToCollDecimal)(delegateAuthority === utils_1.DEFAULT_PUBLIC_KEY
            ? (0, utils_1.scaleDownWads)(totalActiveStakeScaled)
            : totalActiveStakeScaled.toNumber(), stakedTokenDecimals);
        const totalActiveStakeValue = totalActiveStakeAmount.mul(stakedTokenPrice);
        const formattedRewardInfos = await this.processRewardInfos(farmState, totalActiveStakeValue, totalActiveStakeAmount, getPriceByTokenMintDecimal, pricesMap);
        // APYS
        const totalIncentivesApy = formattedRewardInfos.reduce((sum, reward) => {
            sum += reward.hasRewardAvailable ? reward.incentivesApy : 0;
            return sum;
        }, 0);
        return {
            incentivesStats: formattedRewardInfos,
            totalIncentivesApy,
        };
    }
    /**
     * Simulates the farm incentives APY after a stake or unstake operation.
     * @param farm - The farm to simulate the incentives APY for.
     * @param stakedTokenDelta - The difference between the current staked amount and the new staked amount (if positive, it's a stake, if negative, it's an unstake)
     * @param getPriceByTokenMintDecimal - A function to get the price of a token mint.
     * @param stakedTokenPrice - The price of the staked token.
     * @param stakedTokenDecimals - The decimals of the staked token.
     * @param pricesMap - A map of token mints to their prices.
     * @param verbose - Whether to log verbose information.
     * @returns The farm incentives APY after the stake or unstake operation.
     */
    async simulateFarmIncentivesApy(farm, stakedTokenDelta, getPriceByTokenMintDecimal, stakedTokenPrice, stakedTokenDecimals, pricesMap, verbose = false) {
        const { farmState } = farm;
        const { totalActiveStakeScaled, delegateAuthority } = farmState;
        const totalActiveStakeAmount = (0, utils_1.lamportsToCollDecimal)(delegateAuthority === utils_1.DEFAULT_PUBLIC_KEY
            ? (0, utils_1.scaleDownWads)(totalActiveStakeScaled)
            : totalActiveStakeScaled.toNumber(), stakedTokenDecimals);
        const simulatedTotalActiveStakeAmount = totalActiveStakeAmount.plus(stakedTokenDelta);
        const simulatedTotalActiveStakeValue = simulatedTotalActiveStakeAmount.mul(stakedTokenPrice);
        const formattedRewardInfos = await this.processRewardInfos(farmState, simulatedTotalActiveStakeValue, simulatedTotalActiveStakeAmount, getPriceByTokenMintDecimal, pricesMap, verbose);
        // APYS
        const totalIncentivesApy = formattedRewardInfos.reduce((sum, reward) => {
            sum += reward.hasRewardAvailable ? reward.incentivesApy : 0;
            return sum;
        }, 0);
        return {
            incentivesStats: formattedRewardInfos,
            totalIncentivesApy,
        };
    }
    calculateRewardsForPeriods(reward, rewardType, totalStakedAmount, stakedTokenDecimals, price) {
        if (reward.rewardsAvailable.eqn(0)) {
            return {
                dailyRewards: new decimal_js_1.default(0),
                weeklyRewards: new decimal_js_1.default(0),
                monthlyRewards: new decimal_js_1.default(0),
                yearlyRewards: new decimal_js_1.default(0),
            };
        }
        // Find the more recent timestamp and rps
        let rewardAmountPerUnit = this.getRewardPerTimeUnitSecond(reward);
        if (rewardType === index_1.RewardType.Constant.discriminator) {
            const stakedAmountNumber = (0, utils_1.lamportsToCollDecimal)(totalStakedAmount, stakedTokenDecimals);
            const jtoTokens = (0, utils_1.collToLamportsDecimal)(stakedAmountNumber, stakedTokenDecimals).mul(price);
            rewardAmountPerUnit = rewardAmountPerUnit.mul(jtoTokens);
        }
        const dailyReward = rewardAmountPerUnit.mul(consts_1.SECONDS_IN_A_DAY);
        const weeklyReward = rewardAmountPerUnit.mul(consts_1.SECONDS_IN_A_WEEK);
        const monthlyReward = rewardAmountPerUnit.mul(consts_1.SECONDS_IN_A_MONTH);
        const yearlyReward = rewardAmountPerUnit.mul(consts_1.SECONDS_IN_A_YEAR);
        return {
            dailyRewards: dailyReward,
            weeklyRewards: weeklyReward,
            monthlyRewards: monthlyReward,
            yearlyRewards: yearlyReward,
        };
    }
    getRewardPerTimeUnitSecond(reward) {
        const now = new decimal_js_1.default(new Date().getTime()).div(1000);
        let rewardPerTimeUnitSecond = new decimal_js_1.default(0);
        for (let i = 0; i < reward.rewardScheduleCurve.points.length; i++) {
            const { tsStart: tsStartThisPoint, rewardPerTimeUnit } = reward.rewardScheduleCurve.points[i];
            const isLastPoint = i === reward.rewardScheduleCurve.points.length - 1;
            const tsStartNextPoint = isLastPoint
                ? consts_2.U64_MAX
                : reward.rewardScheduleCurve.points[i + 1].tsStart;
            const thisPeriodStart = new decimal_js_1.default(tsStartThisPoint.toString());
            const thisPeriodEnd = new decimal_js_1.default(tsStartNextPoint.toString());
            const rps = new decimal_js_1.default(rewardPerTimeUnit.toString());
            // Rules:
            // Period is in the past:     If we are after this period, then we don't count it
            // Period is in the future:   If we are before this period, we count it fully
            // Period is in the present:  If we are during this period, we count it partially
            // Period is past locking cutoff: We dismiss it
            if (thisPeriodStart <= now && thisPeriodEnd >= now) {
                // Period is in the present:  If we are during this period, we count the reward based on it
                rewardPerTimeUnitSecond = rps;
                break;
            }
            else if (thisPeriodStart > now && thisPeriodEnd > now) {
                // Period is in the future: If we are before this period, we count it fully
                rewardPerTimeUnitSecond = rps;
                break;
            }
        }
        const rewardTokenDecimals = reward.token.decimals.toNumber();
        const rewardAmountPerUnitDecimals = new decimal_js_1.default(10).pow(reward.rewardsPerSecondDecimals.toString());
        const rewardAmountPerUnitLamports = new decimal_js_1.default(10).pow(rewardTokenDecimals.toString());
        const rpsAdjusted = new decimal_js_1.default(rewardPerTimeUnitSecond.toString())
            .div(rewardAmountPerUnitDecimals)
            .div(rewardAmountPerUnitLamports);
        return rewardPerTimeUnitSecond ? rpsAdjusted : new decimal_js_1.default(0);
    }
}
exports.Farms = Farms;
async function getCurrentTimeUnit(farm, slot, timestamp) {
    if (farm.timeUnit == index_1.TimeUnit.Seconds.discriminator) {
        return new decimal_js_1.default(timestamp.toString());
    }
    else {
        return new decimal_js_1.default(slot.toString());
    }
}
async function getCurrentRps(farm, rewardIndex, slot, timestamp) {
    const currentTimeUnit = new decimal_js_1.default(await getCurrentTimeUnit(farm, slot, timestamp));
    return (0, utils_1.calculateCurrentRewardPerToken)(farm.rewardInfos[rewardIndex], currentTimeUnit);
}
const calcAvgBoost = (dollarValueBoosts) => {
    const totalBoostedDollarSumSum = dollarValueBoosts.reduce((acc, [_, boost]) => acc.plus(boost), new decimal_js_1.default(0));
    const totalDollarSum = dollarValueBoosts.reduce((acc, [dollar, _]) => acc.plus(dollar), new decimal_js_1.default(0));
    const avgBoost = totalBoostedDollarSumSum.div(totalDollarSum);
    return avgBoost;
};
exports.calcAvgBoost = calcAvgBoost;
//# sourceMappingURL=Farms.js.map
"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AccountMetaFromJSON: () => AccountMetaFromJSON,
  AccountMetaFromJSONTyped: () => AccountMetaFromJSONTyped,
  AccountMetaToJSON: () => AccountMetaToJSON,
  BASE_PATH: () => BASE_PATH,
  BaseAPI: () => BaseAPI,
  BlobApiResponse: () => BlobApiResponse,
  COLLECTION_FORMATS: () => COLLECTION_FORMATS,
  Configuration: () => Configuration,
  DefaultApi: () => DefaultApi,
  DefaultConfig: () => DefaultConfig,
  FetchError: () => FetchError,
  IndexedRouteMapResponseFromJSON: () => IndexedRouteMapResponseFromJSON,
  IndexedRouteMapResponseFromJSONTyped: () => IndexedRouteMapResponseFromJSONTyped,
  IndexedRouteMapResponseToJSON: () => IndexedRouteMapResponseToJSON,
  InstructionFromJSON: () => InstructionFromJSON,
  InstructionFromJSONTyped: () => InstructionFromJSONTyped,
  InstructionToJSON: () => InstructionToJSON,
  JSONApiResponse: () => JSONApiResponse,
  PlatformFeeFromJSON: () => PlatformFeeFromJSON,
  PlatformFeeFromJSONTyped: () => PlatformFeeFromJSONTyped,
  PlatformFeeToJSON: () => PlatformFeeToJSON,
  PriorityFeeWithMaxLamportsFromJSON: () => PriorityFeeWithMaxLamportsFromJSON,
  PriorityFeeWithMaxLamportsFromJSONTyped: () => PriorityFeeWithMaxLamportsFromJSONTyped,
  PriorityFeeWithMaxLamportsPriorityLevelEnum: () => PriorityFeeWithMaxLamportsPriorityLevelEnum,
  PriorityFeeWithMaxLamportsToJSON: () => PriorityFeeWithMaxLamportsToJSON,
  QuoteGetSwapModeEnum: () => QuoteGetSwapModeEnum,
  QuoteResponseFromJSON: () => QuoteResponseFromJSON,
  QuoteResponseFromJSONTyped: () => QuoteResponseFromJSONTyped,
  QuoteResponseToJSON: () => QuoteResponseToJSON,
  RequiredError: () => RequiredError,
  ResponseError: () => ResponseError,
  RoutePlanStepFromJSON: () => RoutePlanStepFromJSON,
  RoutePlanStepFromJSONTyped: () => RoutePlanStepFromJSONTyped,
  RoutePlanStepToJSON: () => RoutePlanStepToJSON,
  SwapInfoFromJSON: () => SwapInfoFromJSON,
  SwapInfoFromJSONTyped: () => SwapInfoFromJSONTyped,
  SwapInfoToJSON: () => SwapInfoToJSON,
  SwapInstructionsResponseFromJSON: () => SwapInstructionsResponseFromJSON,
  SwapInstructionsResponseFromJSONTyped: () => SwapInstructionsResponseFromJSONTyped,
  SwapInstructionsResponseToJSON: () => SwapInstructionsResponseToJSON,
  SwapMode: () => SwapMode,
  SwapModeFromJSON: () => SwapModeFromJSON,
  SwapModeFromJSONTyped: () => SwapModeFromJSONTyped,
  SwapModeToJSON: () => SwapModeToJSON,
  SwapRequestComputeUnitPriceMicroLamportsFromJSON: () => SwapRequestComputeUnitPriceMicroLamportsFromJSON,
  SwapRequestComputeUnitPriceMicroLamportsFromJSONTyped: () => SwapRequestComputeUnitPriceMicroLamportsFromJSONTyped,
  SwapRequestComputeUnitPriceMicroLamportsToJSON: () => SwapRequestComputeUnitPriceMicroLamportsToJSON,
  SwapRequestDynamicSlippageFromJSON: () => SwapRequestDynamicSlippageFromJSON,
  SwapRequestDynamicSlippageFromJSONTyped: () => SwapRequestDynamicSlippageFromJSONTyped,
  SwapRequestDynamicSlippageToJSON: () => SwapRequestDynamicSlippageToJSON,
  SwapRequestFromJSON: () => SwapRequestFromJSON,
  SwapRequestFromJSONTyped: () => SwapRequestFromJSONTyped,
  SwapRequestPrioritizationFeeLamportsFromJSON: () => SwapRequestPrioritizationFeeLamportsFromJSON,
  SwapRequestPrioritizationFeeLamportsFromJSONTyped: () => SwapRequestPrioritizationFeeLamportsFromJSONTyped,
  SwapRequestPrioritizationFeeLamportsToJSON: () => SwapRequestPrioritizationFeeLamportsToJSON,
  SwapRequestToJSON: () => SwapRequestToJSON,
  SwapResponseDynamicSlippageReportCategoryNameEnum: () => SwapResponseDynamicSlippageReportCategoryNameEnum,
  SwapResponseDynamicSlippageReportFromJSON: () => SwapResponseDynamicSlippageReportFromJSON,
  SwapResponseDynamicSlippageReportFromJSONTyped: () => SwapResponseDynamicSlippageReportFromJSONTyped,
  SwapResponseDynamicSlippageReportToJSON: () => SwapResponseDynamicSlippageReportToJSON,
  SwapResponseFromJSON: () => SwapResponseFromJSON,
  SwapResponseFromJSONTyped: () => SwapResponseFromJSONTyped,
  SwapResponsePrioritizationTypeComputeBudgetFromJSON: () => SwapResponsePrioritizationTypeComputeBudgetFromJSON,
  SwapResponsePrioritizationTypeComputeBudgetFromJSONTyped: () => SwapResponsePrioritizationTypeComputeBudgetFromJSONTyped,
  SwapResponsePrioritizationTypeComputeBudgetToJSON: () => SwapResponsePrioritizationTypeComputeBudgetToJSON,
  SwapResponsePrioritizationTypeFromJSON: () => SwapResponsePrioritizationTypeFromJSON,
  SwapResponsePrioritizationTypeFromJSONTyped: () => SwapResponsePrioritizationTypeFromJSONTyped,
  SwapResponsePrioritizationTypeJitoFromJSON: () => SwapResponsePrioritizationTypeJitoFromJSON,
  SwapResponsePrioritizationTypeJitoFromJSONTyped: () => SwapResponsePrioritizationTypeJitoFromJSONTyped,
  SwapResponsePrioritizationTypeJitoToJSON: () => SwapResponsePrioritizationTypeJitoToJSON,
  SwapResponsePrioritizationTypeToJSON: () => SwapResponsePrioritizationTypeToJSON,
  SwapResponseToJSON: () => SwapResponseToJSON,
  TextApiResponse: () => TextApiResponse,
  VoidApiResponse: () => VoidApiResponse,
  canConsumeForm: () => canConsumeForm,
  createJupiterApiClient: () => createJupiterApiClient,
  exists: () => exists,
  instanceOfAccountMeta: () => instanceOfAccountMeta,
  instanceOfIndexedRouteMapResponse: () => instanceOfIndexedRouteMapResponse,
  instanceOfInstruction: () => instanceOfInstruction,
  instanceOfPlatformFee: () => instanceOfPlatformFee,
  instanceOfPriorityFeeWithMaxLamports: () => instanceOfPriorityFeeWithMaxLamports,
  instanceOfQuoteResponse: () => instanceOfQuoteResponse,
  instanceOfRoutePlanStep: () => instanceOfRoutePlanStep,
  instanceOfSwapInfo: () => instanceOfSwapInfo,
  instanceOfSwapInstructionsResponse: () => instanceOfSwapInstructionsResponse,
  instanceOfSwapRequest: () => instanceOfSwapRequest,
  instanceOfSwapRequestComputeUnitPriceMicroLamports: () => instanceOfSwapRequestComputeUnitPriceMicroLamports,
  instanceOfSwapRequestDynamicSlippage: () => instanceOfSwapRequestDynamicSlippage,
  instanceOfSwapRequestPrioritizationFeeLamports: () => instanceOfSwapRequestPrioritizationFeeLamports,
  instanceOfSwapResponse: () => instanceOfSwapResponse,
  instanceOfSwapResponseDynamicSlippageReport: () => instanceOfSwapResponseDynamicSlippageReport,
  instanceOfSwapResponsePrioritizationType: () => instanceOfSwapResponsePrioritizationType,
  instanceOfSwapResponsePrioritizationTypeComputeBudget: () => instanceOfSwapResponsePrioritizationTypeComputeBudget,
  instanceOfSwapResponsePrioritizationTypeJito: () => instanceOfSwapResponsePrioritizationTypeJito,
  mapValues: () => mapValues,
  querystring: () => querystring
});
module.exports = __toCommonJS(src_exports);

// generated/runtime.ts
var BASE_PATH = "https://quote-api.jup.ag/v6".replace(/\/+$/, "");
var Configuration = class {
  constructor(configuration = {}) {
    this.configuration = configuration;
  }
  set config(configuration) {
    this.configuration = configuration;
  }
  get basePath() {
    return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
  }
  get fetchApi() {
    return this.configuration.fetchApi;
  }
  get middleware() {
    return this.configuration.middleware || [];
  }
  get queryParamsStringify() {
    return this.configuration.queryParamsStringify || querystring;
  }
  get username() {
    return this.configuration.username;
  }
  get password() {
    return this.configuration.password;
  }
  get apiKey() {
    const apiKey = this.configuration.apiKey;
    if (apiKey) {
      return typeof apiKey === "function" ? apiKey : () => apiKey;
    }
    return void 0;
  }
  get accessToken() {
    const accessToken = this.configuration.accessToken;
    if (accessToken) {
      return typeof accessToken === "function" ? accessToken : () => __async(this, null, function* () {
        return accessToken;
      });
    }
    return void 0;
  }
  get headers() {
    return this.configuration.headers;
  }
  get credentials() {
    return this.configuration.credentials;
  }
};
var DefaultConfig = new Configuration();
var _BaseAPI = class _BaseAPI {
  constructor(configuration = DefaultConfig) {
    this.configuration = configuration;
    this.fetchApi = (url, init) => __async(this, null, function* () {
      let fetchParams = { url, init };
      for (const middleware of this.middleware) {
        if (middleware.pre) {
          fetchParams = (yield middleware.pre(__spreadValues({
            fetch: this.fetchApi
          }, fetchParams))) || fetchParams;
        }
      }
      let response = void 0;
      try {
        response = yield (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
      } catch (e) {
        for (const middleware of this.middleware) {
          if (middleware.onError) {
            response = (yield middleware.onError({
              fetch: this.fetchApi,
              url: fetchParams.url,
              init: fetchParams.init,
              error: e,
              response: response ? response.clone() : void 0
            })) || response;
          }
        }
        if (response === void 0) {
          if (e instanceof Error) {
            throw new FetchError(e, "The request failed and the interceptors did not return an alternative response");
          } else {
            throw e;
          }
        }
      }
      for (const middleware of this.middleware) {
        if (middleware.post) {
          response = (yield middleware.post({
            fetch: this.fetchApi,
            url: fetchParams.url,
            init: fetchParams.init,
            response: response.clone()
          })) || response;
        }
      }
      return response;
    });
    this.middleware = configuration.middleware;
  }
  withMiddleware(...middlewares) {
    const next = this.clone();
    next.middleware = next.middleware.concat(...middlewares);
    return next;
  }
  withPreMiddleware(...preMiddlewares) {
    const middlewares = preMiddlewares.map((pre) => ({ pre }));
    return this.withMiddleware(...middlewares);
  }
  withPostMiddleware(...postMiddlewares) {
    const middlewares = postMiddlewares.map((post) => ({ post }));
    return this.withMiddleware(...middlewares);
  }
  /**
   * Check if the given MIME is a JSON MIME.
   * JSON MIME examples:
   *   application/json
   *   application/json; charset=UTF8
   *   APPLICATION/JSON
   *   application/vnd.company+json
   * @param mime - MIME (Multipurpose Internet Mail Extensions)
   * @return True if the given MIME is JSON, false otherwise.
   */
  isJsonMime(mime) {
    if (!mime) {
      return false;
    }
    return _BaseAPI.jsonRegex.test(mime);
  }
  request(context, initOverrides) {
    return __async(this, null, function* () {
      const { url, init } = yield this.createFetchParams(context, initOverrides);
      const response = yield this.fetchApi(url, init);
      if (response && (response.status >= 200 && response.status < 300)) {
        return response;
      }
      throw new ResponseError(response, "Response returned an error code");
    });
  }
  createFetchParams(context, initOverrides) {
    return __async(this, null, function* () {
      let url = this.configuration.basePath + context.path;
      if (context.query !== void 0 && Object.keys(context.query).length !== 0) {
        url += "?" + this.configuration.queryParamsStringify(context.query);
      }
      const headers = Object.assign({}, this.configuration.headers, context.headers);
      Object.keys(headers).forEach((key) => headers[key] === void 0 ? delete headers[key] : {});
      const initOverrideFn = typeof initOverrides === "function" ? initOverrides : () => __async(this, null, function* () {
        return initOverrides;
      });
      const initParams = {
        method: context.method,
        headers,
        body: context.body,
        credentials: this.configuration.credentials
      };
      const overriddenInit = __spreadValues(__spreadValues({}, initParams), yield initOverrideFn({
        init: initParams,
        context
      }));
      let body;
      if (isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body)) {
        body = overriddenInit.body;
      } else if (this.isJsonMime(headers["Content-Type"])) {
        body = JSON.stringify(overriddenInit.body);
      } else {
        body = overriddenInit.body;
      }
      const init = __spreadProps(__spreadValues({}, overriddenInit), {
        body
      });
      return { url, init };
    });
  }
  /**
   * Create a shallow clone of `this` by constructing a new instance
   * and then shallow cloning data members.
   */
  clone() {
    const constructor = this.constructor;
    const next = new constructor(this.configuration);
    next.middleware = this.middleware.slice();
    return next;
  }
};
_BaseAPI.jsonRegex = new RegExp("^(:?application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(:?;.*)?$", "i");
var BaseAPI = _BaseAPI;
function isBlob(value) {
  return typeof Blob !== "undefined" && value instanceof Blob;
}
function isFormData(value) {
  return typeof FormData !== "undefined" && value instanceof FormData;
}
var ResponseError = class extends Error {
  constructor(response, msg) {
    super(msg);
    this.response = response;
    this.name = "ResponseError";
  }
};
var FetchError = class extends Error {
  constructor(cause, msg) {
    super(msg);
    this.cause = cause;
    this.name = "FetchError";
  }
};
var RequiredError = class extends Error {
  constructor(field, msg) {
    super(msg);
    this.field = field;
    this.name = "RequiredError";
  }
};
var COLLECTION_FORMATS = {
  csv: ",",
  ssv: " ",
  tsv: "	",
  pipes: "|"
};
function exists(json, key) {
  const value = json[key];
  return value !== null && value !== void 0;
}
function querystring(params, prefix = "") {
  return Object.keys(params).map((key) => querystringSingleKey(key, params[key], prefix)).filter((part) => part.length > 0).join("&");
}
function querystringSingleKey(key, value, keyPrefix = "") {
  const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
  if (value instanceof Array) {
    const multiValue = value.map((singleValue) => encodeURIComponent(String(singleValue))).join(`&${encodeURIComponent(fullKey)}=`);
    return `${encodeURIComponent(fullKey)}=${multiValue}`;
  }
  if (value instanceof Set) {
    const valueAsArray = Array.from(value);
    return querystringSingleKey(key, valueAsArray, keyPrefix);
  }
  if (value instanceof Date) {
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
  }
  if (value instanceof Object) {
    return querystring(value, fullKey);
  }
  return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
}
function mapValues(data, fn) {
  return Object.keys(data).reduce(
    (acc, key) => __spreadProps(__spreadValues({}, acc), { [key]: fn(data[key]) }),
    {}
  );
}
function canConsumeForm(consumes) {
  for (const consume of consumes) {
    if ("multipart/form-data" === consume.contentType) {
      return true;
    }
  }
  return false;
}
var JSONApiResponse = class {
  constructor(raw, transformer = (jsonValue) => jsonValue) {
    this.raw = raw;
    this.transformer = transformer;
  }
  value() {
    return __async(this, null, function* () {
      return this.transformer(yield this.raw.json());
    });
  }
};
var VoidApiResponse = class {
  constructor(raw) {
    this.raw = raw;
  }
  value() {
    return __async(this, null, function* () {
      return void 0;
    });
  }
};
var BlobApiResponse = class {
  constructor(raw) {
    this.raw = raw;
  }
  value() {
    return __async(this, null, function* () {
      return yield this.raw.blob();
    });
  }
};
var TextApiResponse = class {
  constructor(raw) {
    this.raw = raw;
  }
  value() {
    return __async(this, null, function* () {
      return yield this.raw.text();
    });
  }
};

// generated/models/AccountMeta.ts
function instanceOfAccountMeta(value) {
  let isInstance = true;
  isInstance = isInstance && "pubkey" in value;
  isInstance = isInstance && "isSigner" in value;
  isInstance = isInstance && "isWritable" in value;
  return isInstance;
}
function AccountMetaFromJSON(json) {
  return AccountMetaFromJSONTyped(json, false);
}
function AccountMetaFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "pubkey": json["pubkey"],
    "isSigner": json["isSigner"],
    "isWritable": json["isWritable"]
  };
}
function AccountMetaToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "pubkey": value.pubkey,
    "isSigner": value.isSigner,
    "isWritable": value.isWritable
  };
}

// generated/models/IndexedRouteMapResponse.ts
function instanceOfIndexedRouteMapResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "mintKeys" in value;
  isInstance = isInstance && "indexedRouteMap" in value;
  return isInstance;
}
function IndexedRouteMapResponseFromJSON(json) {
  return IndexedRouteMapResponseFromJSONTyped(json, false);
}
function IndexedRouteMapResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "mintKeys": json["mintKeys"],
    "indexedRouteMap": json["indexedRouteMap"]
  };
}
function IndexedRouteMapResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "mintKeys": value.mintKeys,
    "indexedRouteMap": value.indexedRouteMap
  };
}

// generated/models/Instruction.ts
function instanceOfInstruction(value) {
  let isInstance = true;
  isInstance = isInstance && "programId" in value;
  isInstance = isInstance && "accounts" in value;
  isInstance = isInstance && "data" in value;
  return isInstance;
}
function InstructionFromJSON(json) {
  return InstructionFromJSONTyped(json, false);
}
function InstructionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "programId": json["programId"],
    "accounts": json["accounts"].map(AccountMetaFromJSON),
    "data": json["data"]
  };
}
function InstructionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "programId": value.programId,
    "accounts": value.accounts.map(AccountMetaToJSON),
    "data": value.data
  };
}

// generated/models/PlatformFee.ts
function instanceOfPlatformFee(value) {
  let isInstance = true;
  isInstance = isInstance && "amount" in value;
  isInstance = isInstance && "feeBps" in value;
  return isInstance;
}
function PlatformFeeFromJSON(json) {
  return PlatformFeeFromJSONTyped(json, false);
}
function PlatformFeeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "amount": json["amount"],
    "feeBps": json["feeBps"]
  };
}
function PlatformFeeToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "amount": value.amount,
    "feeBps": value.feeBps
  };
}

// generated/models/PriorityFeeWithMaxLamports.ts
var PriorityFeeWithMaxLamportsPriorityLevelEnum = {
  Medium: "medium",
  High: "high",
  VeryHigh: "veryHigh"
};
function instanceOfPriorityFeeWithMaxLamports(value) {
  let isInstance = true;
  return isInstance;
}
function PriorityFeeWithMaxLamportsFromJSON(json) {
  return PriorityFeeWithMaxLamportsFromJSONTyped(json, false);
}
function PriorityFeeWithMaxLamportsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "global": !exists(json, "global") ? void 0 : json["global"],
    "maxLamports": !exists(json, "maxLamports") ? void 0 : json["maxLamports"],
    "priorityLevel": !exists(json, "priorityLevel") ? void 0 : json["priorityLevel"]
  };
}
function PriorityFeeWithMaxLamportsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "global": value.global,
    "maxLamports": value.maxLamports,
    "priorityLevel": value.priorityLevel
  };
}

// generated/models/SwapInfo.ts
function instanceOfSwapInfo(value) {
  let isInstance = true;
  isInstance = isInstance && "ammKey" in value;
  isInstance = isInstance && "label" in value;
  isInstance = isInstance && "inputMint" in value;
  isInstance = isInstance && "outputMint" in value;
  isInstance = isInstance && "inAmount" in value;
  isInstance = isInstance && "outAmount" in value;
  isInstance = isInstance && "feeAmount" in value;
  isInstance = isInstance && "feeMint" in value;
  return isInstance;
}
function SwapInfoFromJSON(json) {
  return SwapInfoFromJSONTyped(json, false);
}
function SwapInfoFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "ammKey": json["ammKey"],
    "label": json["label"],
    "inputMint": json["inputMint"],
    "outputMint": json["outputMint"],
    "inAmount": json["inAmount"],
    "outAmount": json["outAmount"],
    "feeAmount": json["feeAmount"],
    "feeMint": json["feeMint"]
  };
}
function SwapInfoToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "ammKey": value.ammKey,
    "label": value.label,
    "inputMint": value.inputMint,
    "outputMint": value.outputMint,
    "inAmount": value.inAmount,
    "outAmount": value.outAmount,
    "feeAmount": value.feeAmount,
    "feeMint": value.feeMint
  };
}

// generated/models/RoutePlanStep.ts
function instanceOfRoutePlanStep(value) {
  let isInstance = true;
  isInstance = isInstance && "swapInfo" in value;
  isInstance = isInstance && "percent" in value;
  return isInstance;
}
function RoutePlanStepFromJSON(json) {
  return RoutePlanStepFromJSONTyped(json, false);
}
function RoutePlanStepFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "swapInfo": SwapInfoFromJSON(json["swapInfo"]),
    "percent": json["percent"]
  };
}
function RoutePlanStepToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "swapInfo": SwapInfoToJSON(value.swapInfo),
    "percent": value.percent
  };
}

// generated/models/SwapMode.ts
var SwapMode = {
  ExactIn: "ExactIn",
  ExactOut: "ExactOut"
};
function SwapModeFromJSON(json) {
  return SwapModeFromJSONTyped(json, false);
}
function SwapModeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function SwapModeToJSON(value) {
  return value;
}

// generated/models/QuoteResponse.ts
function instanceOfQuoteResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "inputMint" in value;
  isInstance = isInstance && "inAmount" in value;
  isInstance = isInstance && "outputMint" in value;
  isInstance = isInstance && "outAmount" in value;
  isInstance = isInstance && "otherAmountThreshold" in value;
  isInstance = isInstance && "swapMode" in value;
  isInstance = isInstance && "slippageBps" in value;
  isInstance = isInstance && "priceImpactPct" in value;
  isInstance = isInstance && "routePlan" in value;
  return isInstance;
}
function QuoteResponseFromJSON(json) {
  return QuoteResponseFromJSONTyped(json, false);
}
function QuoteResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "inputMint": json["inputMint"],
    "inAmount": json["inAmount"],
    "outputMint": json["outputMint"],
    "outAmount": json["outAmount"],
    "otherAmountThreshold": json["otherAmountThreshold"],
    "swapMode": SwapModeFromJSON(json["swapMode"]),
    "slippageBps": json["slippageBps"],
    "computedAutoSlippage": !exists(json, "computedAutoSlippage") ? void 0 : json["computedAutoSlippage"],
    "platformFee": !exists(json, "platformFee") ? void 0 : PlatformFeeFromJSON(json["platformFee"]),
    "priceImpactPct": json["priceImpactPct"],
    "routePlan": json["routePlan"].map(RoutePlanStepFromJSON),
    "contextSlot": !exists(json, "contextSlot") ? void 0 : json["contextSlot"],
    "timeTaken": !exists(json, "timeTaken") ? void 0 : json["timeTaken"],
    "swapUsdValue": !exists(json, "swapUsdValue") ? void 0 : json["swapUsdValue"],
    "simplerRouteUsed": !exists(json, "simplerRouteUsed") ? void 0 : json["simplerRouteUsed"]
  };
}
function QuoteResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "inputMint": value.inputMint,
    "inAmount": value.inAmount,
    "outputMint": value.outputMint,
    "outAmount": value.outAmount,
    "otherAmountThreshold": value.otherAmountThreshold,
    "swapMode": SwapModeToJSON(value.swapMode),
    "slippageBps": value.slippageBps,
    "computedAutoSlippage": value.computedAutoSlippage,
    "platformFee": PlatformFeeToJSON(value.platformFee),
    "priceImpactPct": value.priceImpactPct,
    "routePlan": value.routePlan.map(RoutePlanStepToJSON),
    "contextSlot": value.contextSlot,
    "timeTaken": value.timeTaken,
    "swapUsdValue": value.swapUsdValue,
    "simplerRouteUsed": value.simplerRouteUsed
  };
}

// generated/models/SwapInstructionsResponse.ts
function instanceOfSwapInstructionsResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "computeBudgetInstructions" in value;
  isInstance = isInstance && "setupInstructions" in value;
  isInstance = isInstance && "swapInstruction" in value;
  isInstance = isInstance && "addressLookupTableAddresses" in value;
  return isInstance;
}
function SwapInstructionsResponseFromJSON(json) {
  return SwapInstructionsResponseFromJSONTyped(json, false);
}
function SwapInstructionsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "tokenLedgerInstruction": !exists(json, "tokenLedgerInstruction") ? void 0 : InstructionFromJSON(json["tokenLedgerInstruction"]),
    "computeBudgetInstructions": json["computeBudgetInstructions"].map(InstructionFromJSON),
    "setupInstructions": json["setupInstructions"].map(InstructionFromJSON),
    "swapInstruction": InstructionFromJSON(json["swapInstruction"]),
    "cleanupInstruction": !exists(json, "cleanupInstruction") ? void 0 : InstructionFromJSON(json["cleanupInstruction"]),
    "addressLookupTableAddresses": json["addressLookupTableAddresses"]
  };
}
function SwapInstructionsResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "tokenLedgerInstruction": InstructionToJSON(value.tokenLedgerInstruction),
    "computeBudgetInstructions": value.computeBudgetInstructions.map(InstructionToJSON),
    "setupInstructions": value.setupInstructions.map(InstructionToJSON),
    "swapInstruction": InstructionToJSON(value.swapInstruction),
    "cleanupInstruction": InstructionToJSON(value.cleanupInstruction),
    "addressLookupTableAddresses": value.addressLookupTableAddresses
  };
}

// generated/models/SwapRequestComputeUnitPriceMicroLamports.ts
function instanceOfSwapRequestComputeUnitPriceMicroLamports(value) {
  let isInstance = true;
  return isInstance;
}
function SwapRequestComputeUnitPriceMicroLamportsFromJSON(json) {
  return SwapRequestComputeUnitPriceMicroLamportsFromJSONTyped(json, false);
}
function SwapRequestComputeUnitPriceMicroLamportsFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function SwapRequestComputeUnitPriceMicroLamportsToJSON(value) {
  return value;
}

// generated/models/SwapRequestDynamicSlippage.ts
function instanceOfSwapRequestDynamicSlippage(value) {
  let isInstance = true;
  return isInstance;
}
function SwapRequestDynamicSlippageFromJSON(json) {
  return SwapRequestDynamicSlippageFromJSONTyped(json, false);
}
function SwapRequestDynamicSlippageFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "minBps": !exists(json, "minBps") ? void 0 : json["minBps"],
    "maxBps": !exists(json, "maxBps") ? void 0 : json["maxBps"]
  };
}
function SwapRequestDynamicSlippageToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "minBps": value.minBps,
    "maxBps": value.maxBps
  };
}

// generated/models/SwapRequestPrioritizationFeeLamports.ts
function instanceOfSwapRequestPrioritizationFeeLamports(value) {
  let isInstance = true;
  return isInstance;
}
function SwapRequestPrioritizationFeeLamportsFromJSON(json) {
  return SwapRequestPrioritizationFeeLamportsFromJSONTyped(json, false);
}
function SwapRequestPrioritizationFeeLamportsFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function SwapRequestPrioritizationFeeLamportsToJSON(value) {
  return value;
}

// generated/models/SwapRequest.ts
function instanceOfSwapRequest(value) {
  let isInstance = true;
  isInstance = isInstance && "userPublicKey" in value;
  isInstance = isInstance && "quoteResponse" in value;
  return isInstance;
}
function SwapRequestFromJSON(json) {
  return SwapRequestFromJSONTyped(json, false);
}
function SwapRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "userPublicKey": json["userPublicKey"],
    "payer": !exists(json, "payer") ? void 0 : json["payer"],
    "wrapAndUnwrapSol": !exists(json, "wrapAndUnwrapSol") ? void 0 : json["wrapAndUnwrapSol"],
    "useSharedAccounts": !exists(json, "useSharedAccounts") ? void 0 : json["useSharedAccounts"],
    "feeAccount": !exists(json, "feeAccount") ? void 0 : json["feeAccount"],
    "computeUnitPriceMicroLamports": !exists(json, "computeUnitPriceMicroLamports") ? void 0 : SwapRequestComputeUnitPriceMicroLamportsFromJSON(json["computeUnitPriceMicroLamports"]),
    "prioritizationFeeLamports": !exists(json, "prioritizationFeeLamports") ? void 0 : SwapRequestPrioritizationFeeLamportsFromJSON(json["prioritizationFeeLamports"]),
    "asLegacyTransaction": !exists(json, "asLegacyTransaction") ? void 0 : json["asLegacyTransaction"],
    "useTokenLedger": !exists(json, "useTokenLedger") ? void 0 : json["useTokenLedger"],
    "destinationTokenAccount": !exists(json, "destinationTokenAccount") ? void 0 : json["destinationTokenAccount"],
    "dynamicComputeUnitLimit": !exists(json, "dynamicComputeUnitLimit") ? void 0 : json["dynamicComputeUnitLimit"],
    "skipUserAccountsRpcCalls": !exists(json, "skipUserAccountsRpcCalls") ? void 0 : json["skipUserAccountsRpcCalls"],
    "programAuthorityId": !exists(json, "programAuthorityId") ? void 0 : json["programAuthorityId"],
    "allowOptimizedWrappedSolTokenAccount": !exists(json, "allowOptimizedWrappedSolTokenAccount") ? void 0 : json["allowOptimizedWrappedSolTokenAccount"],
    "dynamicSlippage": !exists(json, "dynamicSlippage") ? void 0 : SwapRequestDynamicSlippageFromJSON(json["dynamicSlippage"]),
    "blockhashSlotsToExpiry": !exists(json, "blockhashSlotsToExpiry") ? void 0 : json["blockhashSlotsToExpiry"],
    "correctLastValidBlockHeight": !exists(json, "correctLastValidBlockHeight") ? void 0 : json["correctLastValidBlockHeight"],
    "addConsensusAccount": !exists(json, "addConsensusAccount") ? void 0 : json["addConsensusAccount"],
    "quoteResponse": QuoteResponseFromJSON(json["quoteResponse"])
  };
}
function SwapRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "userPublicKey": value.userPublicKey,
    "payer": value.payer,
    "wrapAndUnwrapSol": value.wrapAndUnwrapSol,
    "useSharedAccounts": value.useSharedAccounts,
    "feeAccount": value.feeAccount,
    "computeUnitPriceMicroLamports": SwapRequestComputeUnitPriceMicroLamportsToJSON(value.computeUnitPriceMicroLamports),
    "prioritizationFeeLamports": SwapRequestPrioritizationFeeLamportsToJSON(value.prioritizationFeeLamports),
    "asLegacyTransaction": value.asLegacyTransaction,
    "useTokenLedger": value.useTokenLedger,
    "destinationTokenAccount": value.destinationTokenAccount,
    "dynamicComputeUnitLimit": value.dynamicComputeUnitLimit,
    "skipUserAccountsRpcCalls": value.skipUserAccountsRpcCalls,
    "programAuthorityId": value.programAuthorityId,
    "allowOptimizedWrappedSolTokenAccount": value.allowOptimizedWrappedSolTokenAccount,
    "dynamicSlippage": SwapRequestDynamicSlippageToJSON(value.dynamicSlippage),
    "blockhashSlotsToExpiry": value.blockhashSlotsToExpiry,
    "correctLastValidBlockHeight": value.correctLastValidBlockHeight,
    "addConsensusAccount": value.addConsensusAccount,
    "quoteResponse": QuoteResponseToJSON(value.quoteResponse)
  };
}

// generated/models/SwapResponseDynamicSlippageReport.ts
var SwapResponseDynamicSlippageReportCategoryNameEnum = {
  Stable: "stable",
  Lst: "lst",
  Bluechip: "bluechip",
  Verified: "verified"
};
function instanceOfSwapResponseDynamicSlippageReport(value) {
  let isInstance = true;
  return isInstance;
}
function SwapResponseDynamicSlippageReportFromJSON(json) {
  return SwapResponseDynamicSlippageReportFromJSONTyped(json, false);
}
function SwapResponseDynamicSlippageReportFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "amplificationRatio": !exists(json, "amplificationRatio") ? void 0 : json["amplificationRatio"],
    "otherAmount": !exists(json, "otherAmount") ? void 0 : json["otherAmount"],
    "simulatedIncurredSlippageBps": !exists(json, "simulatedIncurredSlippageBps") ? void 0 : json["simulatedIncurredSlippageBps"],
    "slippageBps": !exists(json, "slippageBps") ? void 0 : json["slippageBps"],
    "categoryName": !exists(json, "categoryName") ? void 0 : json["categoryName"],
    "heuristicMaxSlippageBps": !exists(json, "heuristicMaxSlippageBps") ? void 0 : json["heuristicMaxSlippageBps"]
  };
}
function SwapResponseDynamicSlippageReportToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "amplificationRatio": value.amplificationRatio,
    "otherAmount": value.otherAmount,
    "simulatedIncurredSlippageBps": value.simulatedIncurredSlippageBps,
    "slippageBps": value.slippageBps,
    "categoryName": value.categoryName,
    "heuristicMaxSlippageBps": value.heuristicMaxSlippageBps
  };
}

// generated/models/SwapResponsePrioritizationTypeComputeBudget.ts
function instanceOfSwapResponsePrioritizationTypeComputeBudget(value) {
  let isInstance = true;
  return isInstance;
}
function SwapResponsePrioritizationTypeComputeBudgetFromJSON(json) {
  return SwapResponsePrioritizationTypeComputeBudgetFromJSONTyped(json, false);
}
function SwapResponsePrioritizationTypeComputeBudgetFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "estimatedMicroLamports": !exists(json, "estimatedMicroLamports") ? void 0 : json["estimatedMicroLamports"],
    "microLamports": !exists(json, "microLamports") ? void 0 : json["microLamports"]
  };
}
function SwapResponsePrioritizationTypeComputeBudgetToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "estimatedMicroLamports": value.estimatedMicroLamports,
    "microLamports": value.microLamports
  };
}

// generated/models/SwapResponsePrioritizationTypeJito.ts
function instanceOfSwapResponsePrioritizationTypeJito(value) {
  let isInstance = true;
  return isInstance;
}
function SwapResponsePrioritizationTypeJitoFromJSON(json) {
  return SwapResponsePrioritizationTypeJitoFromJSONTyped(json, false);
}
function SwapResponsePrioritizationTypeJitoFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "lamports": !exists(json, "lamports") ? void 0 : json["lamports"]
  };
}
function SwapResponsePrioritizationTypeJitoToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "lamports": value.lamports
  };
}

// generated/models/SwapResponsePrioritizationType.ts
function instanceOfSwapResponsePrioritizationType(value) {
  let isInstance = true;
  return isInstance;
}
function SwapResponsePrioritizationTypeFromJSON(json) {
  return SwapResponsePrioritizationTypeFromJSONTyped(json, false);
}
function SwapResponsePrioritizationTypeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "jito": !exists(json, "jito") ? void 0 : SwapResponsePrioritizationTypeJitoFromJSON(json["jito"]),
    "computeBudget": !exists(json, "computeBudget") ? void 0 : SwapResponsePrioritizationTypeComputeBudgetFromJSON(json["computeBudget"])
  };
}
function SwapResponsePrioritizationTypeToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "jito": SwapResponsePrioritizationTypeJitoToJSON(value.jito),
    "computeBudget": SwapResponsePrioritizationTypeComputeBudgetToJSON(value.computeBudget)
  };
}

// generated/models/SwapResponse.ts
function instanceOfSwapResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "swapTransaction" in value;
  isInstance = isInstance && "lastValidBlockHeight" in value;
  isInstance = isInstance && "prioritizationFeeLamports" in value;
  return isInstance;
}
function SwapResponseFromJSON(json) {
  return SwapResponseFromJSONTyped(json, false);
}
function SwapResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "swapTransaction": json["swapTransaction"],
    "lastValidBlockHeight": json["lastValidBlockHeight"],
    "prioritizationFeeLamports": json["prioritizationFeeLamports"],
    "prioritizationType": !exists(json, "prioritizationType") ? void 0 : SwapResponsePrioritizationTypeFromJSON(json["prioritizationType"]),
    "dynamicSlippageReport": !exists(json, "dynamicSlippageReport") ? void 0 : SwapResponseDynamicSlippageReportFromJSON(json["dynamicSlippageReport"])
  };
}
function SwapResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "swapTransaction": value.swapTransaction,
    "lastValidBlockHeight": value.lastValidBlockHeight,
    "prioritizationFeeLamports": value.prioritizationFeeLamports,
    "prioritizationType": SwapResponsePrioritizationTypeToJSON(value.prioritizationType),
    "dynamicSlippageReport": SwapResponseDynamicSlippageReportToJSON(value.dynamicSlippageReport)
  };
}

// generated/apis/DefaultApi.ts
var DefaultApi = class extends BaseAPI {
  /**
   * DEPRECATED, please use /tokens for tradable mints. Returns a hash map, input mint as key and an array of valid output mint as values, token mints are indexed to reduce the file size
   * GET /indexed-route-map
   * @deprecated
   */
  indexedRouteMapGetRaw(requestParameters, initOverrides) {
    return __async(this, null, function* () {
      const queryParameters = {};
      if (requestParameters.onlyDirectRoutes !== void 0) {
        queryParameters["onlyDirectRoutes"] = requestParameters.onlyDirectRoutes;
      }
      const headerParameters = {};
      const response = yield this.request({
        path: `/indexed-route-map`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => IndexedRouteMapResponseFromJSON(jsonValue));
    });
  }
  /**
   * DEPRECATED, please use /tokens for tradable mints. Returns a hash map, input mint as key and an array of valid output mint as values, token mints are indexed to reduce the file size
   * GET /indexed-route-map
   * @deprecated
   */
  indexedRouteMapGet() {
    return __async(this, arguments, function* (requestParameters = {}, initOverrides) {
      const response = yield this.indexedRouteMapGetRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Returns a hash, which key is the program id and value is the label. This is used to help map error from transaction by identifying the fault program id. With that, we can use the `excludeDexes` or `dexes` parameter.
   * GET /program-id-to-label
   */
  programIdToLabelGetRaw(initOverrides) {
    return __async(this, null, function* () {
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/program-id-to-label`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response);
    });
  }
  /**
   * Returns a hash, which key is the program id and value is the label. This is used to help map error from transaction by identifying the fault program id. With that, we can use the `excludeDexes` or `dexes` parameter.
   * GET /program-id-to-label
   */
  programIdToLabelGet(initOverrides) {
    return __async(this, null, function* () {
      const response = yield this.programIdToLabelGetRaw(initOverrides);
      return yield response.value();
    });
  }
  /**
   * Sends a GET request to the Jupiter API to get the best priced quote.
   * GET /quote
   */
  quoteGetRaw(requestParameters, initOverrides) {
    return __async(this, null, function* () {
      if (requestParameters.inputMint === null || requestParameters.inputMint === void 0) {
        throw new RequiredError("inputMint", "Required parameter requestParameters.inputMint was null or undefined when calling quoteGet.");
      }
      if (requestParameters.outputMint === null || requestParameters.outputMint === void 0) {
        throw new RequiredError("outputMint", "Required parameter requestParameters.outputMint was null or undefined when calling quoteGet.");
      }
      if (requestParameters.amount === null || requestParameters.amount === void 0) {
        throw new RequiredError("amount", "Required parameter requestParameters.amount was null or undefined when calling quoteGet.");
      }
      const queryParameters = {};
      if (requestParameters.inputMint !== void 0) {
        queryParameters["inputMint"] = requestParameters.inputMint;
      }
      if (requestParameters.outputMint !== void 0) {
        queryParameters["outputMint"] = requestParameters.outputMint;
      }
      if (requestParameters.amount !== void 0) {
        queryParameters["amount"] = requestParameters.amount;
      }
      if (requestParameters.slippageBps !== void 0) {
        queryParameters["slippageBps"] = requestParameters.slippageBps;
      }
      if (requestParameters.dynamicSlippage !== void 0) {
        queryParameters["dynamicSlippage"] = requestParameters.dynamicSlippage;
      }
      if (requestParameters.autoSlippage !== void 0) {
        queryParameters["autoSlippage"] = requestParameters.autoSlippage;
      }
      if (requestParameters.autoSlippageCollisionUsdValue !== void 0) {
        queryParameters["autoSlippageCollisionUsdValue"] = requestParameters.autoSlippageCollisionUsdValue;
      }
      if (requestParameters.computeAutoSlippage !== void 0) {
        queryParameters["computeAutoSlippage"] = requestParameters.computeAutoSlippage;
      }
      if (requestParameters.maxAutoSlippageBps !== void 0) {
        queryParameters["maxAutoSlippageBps"] = requestParameters.maxAutoSlippageBps;
      }
      if (requestParameters.swapMode !== void 0) {
        queryParameters["swapMode"] = requestParameters.swapMode;
      }
      if (requestParameters.dexes) {
        queryParameters["dexes"] = requestParameters.dexes;
      }
      if (requestParameters.excludeDexes) {
        queryParameters["excludeDexes"] = requestParameters.excludeDexes;
      }
      if (requestParameters.restrictIntermediateTokens !== void 0) {
        queryParameters["restrictIntermediateTokens"] = requestParameters.restrictIntermediateTokens;
      }
      if (requestParameters.onlyDirectRoutes !== void 0) {
        queryParameters["onlyDirectRoutes"] = requestParameters.onlyDirectRoutes;
      }
      if (requestParameters.asLegacyTransaction !== void 0) {
        queryParameters["asLegacyTransaction"] = requestParameters.asLegacyTransaction;
      }
      if (requestParameters.platformFeeBps !== void 0) {
        queryParameters["platformFeeBps"] = requestParameters.platformFeeBps;
      }
      if (requestParameters.maxAccounts !== void 0) {
        queryParameters["maxAccounts"] = requestParameters.maxAccounts;
      }
      if (requestParameters.minimizeSlippage !== void 0) {
        queryParameters["minimizeSlippage"] = requestParameters.minimizeSlippage;
      }
      if (requestParameters.preferLiquidDexes !== void 0) {
        queryParameters["preferLiquidDexes"] = requestParameters.preferLiquidDexes;
      }
      if (requestParameters.tokenCategoryBasedIntermediateTokens !== void 0) {
        queryParameters["tokenCategoryBasedIntermediateTokens"] = requestParameters.tokenCategoryBasedIntermediateTokens;
      }
      if (requestParameters.preferSimpleRouting !== void 0) {
        queryParameters["preferSimpleRouting"] = requestParameters.preferSimpleRouting;
      }
      const headerParameters = {};
      const response = yield this.request({
        path: `/quote`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => QuoteResponseFromJSON(jsonValue));
    });
  }
  /**
   * Sends a GET request to the Jupiter API to get the best priced quote.
   * GET /quote
   */
  quoteGet(requestParameters, initOverrides) {
    return __async(this, null, function* () {
      const response = yield this.quoteGetRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Returns instructions that you can use from the quote you get from `/quote`.
   * POST /swap-instructions
   */
  swapInstructionsPostRaw(requestParameters, initOverrides) {
    return __async(this, null, function* () {
      if (requestParameters.swapRequest === null || requestParameters.swapRequest === void 0) {
        throw new RequiredError("swapRequest", "Required parameter requestParameters.swapRequest was null or undefined when calling swapInstructionsPost.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/swap-instructions`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: SwapRequestToJSON(requestParameters.swapRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => SwapInstructionsResponseFromJSON(jsonValue));
    });
  }
  /**
   * Returns instructions that you can use from the quote you get from `/quote`.
   * POST /swap-instructions
   */
  swapInstructionsPost(requestParameters, initOverrides) {
    return __async(this, null, function* () {
      const response = yield this.swapInstructionsPostRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Returns a transaction that you can use from the quote you get from `/quote`.
   * POST /swap
   */
  swapPostRaw(requestParameters, initOverrides) {
    return __async(this, null, function* () {
      if (requestParameters.swapRequest === null || requestParameters.swapRequest === void 0) {
        throw new RequiredError("swapRequest", "Required parameter requestParameters.swapRequest was null or undefined when calling swapPost.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/swap`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: SwapRequestToJSON(requestParameters.swapRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => SwapResponseFromJSON(jsonValue));
    });
  }
  /**
   * Returns a transaction that you can use from the quote you get from `/quote`.
   * POST /swap
   */
  swapPost(requestParameters, initOverrides) {
    return __async(this, null, function* () {
      const response = yield this.swapPostRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Returns a list of all the tradable mints
   * GET /tokens
   */
  tokensGetRaw(initOverrides) {
    return __async(this, null, function* () {
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/tokens`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response);
    });
  }
  /**
   * Returns a list of all the tradable mints
   * GET /tokens
   */
  tokensGet(initOverrides) {
    return __async(this, null, function* () {
      const response = yield this.tokensGetRaw(initOverrides);
      return yield response.value();
    });
  }
};
var QuoteGetSwapModeEnum = {
  ExactIn: "ExactIn",
  ExactOut: "ExactOut"
};

// src/index.ts
var createJupiterApiClient = (config) => {
  return new DefaultApi(new Configuration(config));
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AccountMetaFromJSON,
  AccountMetaFromJSONTyped,
  AccountMetaToJSON,
  BASE_PATH,
  BaseAPI,
  BlobApiResponse,
  COLLECTION_FORMATS,
  Configuration,
  DefaultApi,
  DefaultConfig,
  FetchError,
  IndexedRouteMapResponseFromJSON,
  IndexedRouteMapResponseFromJSONTyped,
  IndexedRouteMapResponseToJSON,
  InstructionFromJSON,
  InstructionFromJSONTyped,
  InstructionToJSON,
  JSONApiResponse,
  PlatformFeeFromJSON,
  PlatformFeeFromJSONTyped,
  PlatformFeeToJSON,
  PriorityFeeWithMaxLamportsFromJSON,
  PriorityFeeWithMaxLamportsFromJSONTyped,
  PriorityFeeWithMaxLamportsPriorityLevelEnum,
  PriorityFeeWithMaxLamportsToJSON,
  QuoteGetSwapModeEnum,
  QuoteResponseFromJSON,
  QuoteResponseFromJSONTyped,
  QuoteResponseToJSON,
  RequiredError,
  ResponseError,
  RoutePlanStepFromJSON,
  RoutePlanStepFromJSONTyped,
  RoutePlanStepToJSON,
  SwapInfoFromJSON,
  SwapInfoFromJSONTyped,
  SwapInfoToJSON,
  SwapInstructionsResponseFromJSON,
  SwapInstructionsResponseFromJSONTyped,
  SwapInstructionsResponseToJSON,
  SwapMode,
  SwapModeFromJSON,
  SwapModeFromJSONTyped,
  SwapModeToJSON,
  SwapRequestComputeUnitPriceMicroLamportsFromJSON,
  SwapRequestComputeUnitPriceMicroLamportsFromJSONTyped,
  SwapRequestComputeUnitPriceMicroLamportsToJSON,
  SwapRequestDynamicSlippageFromJSON,
  SwapRequestDynamicSlippageFromJSONTyped,
  SwapRequestDynamicSlippageToJSON,
  SwapRequestFromJSON,
  SwapRequestFromJSONTyped,
  SwapRequestPrioritizationFeeLamportsFromJSON,
  SwapRequestPrioritizationFeeLamportsFromJSONTyped,
  SwapRequestPrioritizationFeeLamportsToJSON,
  SwapRequestToJSON,
  SwapResponseDynamicSlippageReportCategoryNameEnum,
  SwapResponseDynamicSlippageReportFromJSON,
  SwapResponseDynamicSlippageReportFromJSONTyped,
  SwapResponseDynamicSlippageReportToJSON,
  SwapResponseFromJSON,
  SwapResponseFromJSONTyped,
  SwapResponsePrioritizationTypeComputeBudgetFromJSON,
  SwapResponsePrioritizationTypeComputeBudgetFromJSONTyped,
  SwapResponsePrioritizationTypeComputeBudgetToJSON,
  SwapResponsePrioritizationTypeFromJSON,
  SwapResponsePrioritizationTypeFromJSONTyped,
  SwapResponsePrioritizationTypeJitoFromJSON,
  SwapResponsePrioritizationTypeJitoFromJSONTyped,
  SwapResponsePrioritizationTypeJitoToJSON,
  SwapResponsePrioritizationTypeToJSON,
  SwapResponseToJSON,
  TextApiResponse,
  VoidApiResponse,
  canConsumeForm,
  createJupiterApiClient,
  exists,
  instanceOfAccountMeta,
  instanceOfIndexedRouteMapResponse,
  instanceOfInstruction,
  instanceOfPlatformFee,
  instanceOfPriorityFeeWithMaxLamports,
  instanceOfQuoteResponse,
  instanceOfRoutePlanStep,
  instanceOfSwapInfo,
  instanceOfSwapInstructionsResponse,
  instanceOfSwapRequest,
  instanceOfSwapRequestComputeUnitPriceMicroLamports,
  instanceOfSwapRequestDynamicSlippage,
  instanceOfSwapRequestPrioritizationFeeLamports,
  instanceOfSwapResponse,
  instanceOfSwapResponseDynamicSlippageReport,
  instanceOfSwapResponsePrioritizationType,
  instanceOfSwapResponsePrioritizationTypeComputeBudget,
  instanceOfSwapResponsePrioritizationTypeJito,
  mapValues,
  querystring
});

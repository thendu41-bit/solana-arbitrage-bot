{"version":3,"sources":["../src/generated/accounts/adaptiveFeeTier.ts","../src/generated/accounts/feeTier.ts","../src/generated/accounts/lockConfig.ts","../src/generated/types/accountsType.ts","../src/generated/types/adaptiveFeeConstants.ts","../src/generated/types/adaptiveFeeVariables.ts","../src/generated/types/lockType.ts","../src/generated/types/lockTypeLabel.ts","../src/generated/types/positionRewardInfo.ts","../src/generated/types/remainingAccountsInfo.ts","../src/generated/types/remainingAccountsSlice.ts","../src/generated/types/tick.ts","../src/generated/types/whirlpoolRewardInfo.ts","../src/generated/accounts/oracle.ts","../src/generated/accounts/position.ts","../src/generated/accounts/positionBundle.ts","../src/generated/accounts/tickArray.ts","../src/generated/accounts/tokenBadge.ts","../src/generated/accounts/whirlpool.ts","../src/generated/accounts/whirlpoolsConfig.ts","../src/generated/accounts/whirlpoolsConfigExtension.ts","../src/generated/errors/whirlpool.ts","../src/generated/programs/whirlpool.ts","../src/generated/instructions/closeBundledPosition.ts","../src/generated/shared/index.ts","../src/generated/instructions/closePosition.ts","../src/generated/instructions/closePositionWithTokenExtensions.ts","../src/generated/instructions/collectFees.ts","../src/generated/instructions/collectFeesV2.ts","../src/generated/instructions/collectProtocolFees.ts","../src/generated/instructions/collectProtocolFeesV2.ts","../src/generated/instructions/collectReward.ts","../src/generated/instructions/collectRewardV2.ts","../src/generated/instructions/decreaseLiquidity.ts","../src/generated/instructions/decreaseLiquidityV2.ts","../src/generated/instructions/deletePositionBundle.ts","../src/generated/instructions/deleteTokenBadge.ts","../src/generated/instructions/increaseLiquidity.ts","../src/generated/instructions/increaseLiquidityV2.ts","../src/generated/instructions/initializeAdaptiveFeeTier.ts","../src/generated/instructions/initializeConfig.ts","../src/generated/instructions/initializeConfigExtension.ts","../src/generated/instructions/initializeFeeTier.ts","../src/generated/instructions/initializePool.ts","../src/generated/instructions/initializePoolV2.ts","../src/generated/instructions/initializePoolWithAdaptiveFee.ts","../src/generated/instructions/initializePositionBundle.ts","../src/generated/instructions/initializePositionBundleWithMetadata.ts","../src/generated/instructions/initializeReward.ts","../src/generated/instructions/initializeRewardV2.ts","../src/generated/instructions/initializeTickArray.ts","../src/generated/instructions/initializeTokenBadge.ts","../src/generated/instructions/lockPosition.ts","../src/generated/instructions/openBundledPosition.ts","../src/generated/instructions/openPosition.ts","../src/generated/instructions/openPositionWithMetadata.ts","../src/generated/instructions/openPositionWithTokenExtensions.ts","../src/generated/instructions/resetPositionRange.ts","../src/generated/instructions/setCollectProtocolFeesAuthority.ts","../src/generated/instructions/setConfigExtensionAuthority.ts","../src/generated/instructions/setDefaultBaseFeeRate.ts","../src/generated/instructions/setDefaultFeeRate.ts","../src/generated/instructions/setDefaultProtocolFeeRate.ts","../src/generated/instructions/setDelegatedFeeAuthority.ts","../src/generated/instructions/setFeeAuthority.ts","../src/generated/instructions/setFeeRate.ts","../src/generated/instructions/setFeeRateByDelegatedFeeAuthority.ts","../src/generated/instructions/setInitializePoolAuthority.ts","../src/generated/instructions/setPresetAdaptiveFeeConstants.ts","../src/generated/instructions/setProtocolFeeRate.ts","../src/generated/instructions/setRewardAuthority.ts","../src/generated/instructions/setRewardAuthorityBySuperAuthority.ts","../src/generated/instructions/setRewardEmissions.ts","../src/generated/instructions/setRewardEmissionsSuperAuthority.ts","../src/generated/instructions/setRewardEmissionsV2.ts","../src/generated/instructions/setTokenBadgeAuthority.ts","../src/generated/instructions/swap.ts","../src/generated/instructions/swapV2.ts","../src/generated/instructions/transferLockedPosition.ts","../src/generated/instructions/twoHopSwap.ts","../src/generated/instructions/twoHopSwapV2.ts","../src/generated/instructions/updateFeesAndRewards.ts","../src/gpa/adaptiveFeeTier.ts","../src/gpa/utils.ts","../src/gpa/feeTier.ts","../src/gpa/oracle.ts","../src/gpa/position.ts","../src/gpa/positionBundle.ts","../src/gpa/tickArray.ts","../src/gpa/tokenBadge.ts","../src/gpa/whirlpool.ts","../src/gpa/whirlpoolsConfig.ts","../src/gpa/whirlpoolsConfigExtension.ts","../src/pda/feeTier.ts","../src/pda/oracle.ts","../src/pda/position.ts","../src/pda/positionBundle.ts","../src/pda/tickArray.ts","../src/pda/tokenBadge.ts","../src/pda/whirlpool.ts","../src/pda/whirlpoolsConfigExtension.ts"],"sourcesContent":["/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  fixDecoderSize,\n  fixEncoderSize,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type Account,\n  type Address,\n  type Codec,\n  type Decoder,\n  type EncodedAccount,\n  type Encoder,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\n\nexport const ADAPTIVE_FEE_TIER_DISCRIMINATOR = new Uint8Array([\n  147, 16, 144, 116, 47, 146, 149, 46,\n]);\n\nexport function getAdaptiveFeeTierDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    ADAPTIVE_FEE_TIER_DISCRIMINATOR\n  );\n}\n\nexport type AdaptiveFeeTier = {\n  discriminator: ReadonlyUint8Array;\n  whirlpoolsConfig: Address;\n  feeTierIndex: number;\n  tickSpacing: number;\n  initializePoolAuthority: Address;\n  delegatedFeeAuthority: Address;\n  defaultBaseFeeRate: number;\n  filterPeriod: number;\n  decayPeriod: number;\n  reductionFactor: number;\n  adaptiveFeeControlFactor: number;\n  maxVolatilityAccumulator: number;\n  tickGroupSize: number;\n  majorSwapThresholdTicks: number;\n};\n\nexport type AdaptiveFeeTierArgs = {\n  whirlpoolsConfig: Address;\n  feeTierIndex: number;\n  tickSpacing: number;\n  initializePoolAuthority: Address;\n  delegatedFeeAuthority: Address;\n  defaultBaseFeeRate: number;\n  filterPeriod: number;\n  decayPeriod: number;\n  reductionFactor: number;\n  adaptiveFeeControlFactor: number;\n  maxVolatilityAccumulator: number;\n  tickGroupSize: number;\n  majorSwapThresholdTicks: number;\n};\n\nexport function getAdaptiveFeeTierEncoder(): Encoder<AdaptiveFeeTierArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['whirlpoolsConfig', getAddressEncoder()],\n      ['feeTierIndex', getU16Encoder()],\n      ['tickSpacing', getU16Encoder()],\n      ['initializePoolAuthority', getAddressEncoder()],\n      ['delegatedFeeAuthority', getAddressEncoder()],\n      ['defaultBaseFeeRate', getU16Encoder()],\n      ['filterPeriod', getU16Encoder()],\n      ['decayPeriod', getU16Encoder()],\n      ['reductionFactor', getU16Encoder()],\n      ['adaptiveFeeControlFactor', getU32Encoder()],\n      ['maxVolatilityAccumulator', getU32Encoder()],\n      ['tickGroupSize', getU16Encoder()],\n      ['majorSwapThresholdTicks', getU16Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: ADAPTIVE_FEE_TIER_DISCRIMINATOR })\n  );\n}\n\nexport function getAdaptiveFeeTierDecoder(): Decoder<AdaptiveFeeTier> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['whirlpoolsConfig', getAddressDecoder()],\n    ['feeTierIndex', getU16Decoder()],\n    ['tickSpacing', getU16Decoder()],\n    ['initializePoolAuthority', getAddressDecoder()],\n    ['delegatedFeeAuthority', getAddressDecoder()],\n    ['defaultBaseFeeRate', getU16Decoder()],\n    ['filterPeriod', getU16Decoder()],\n    ['decayPeriod', getU16Decoder()],\n    ['reductionFactor', getU16Decoder()],\n    ['adaptiveFeeControlFactor', getU32Decoder()],\n    ['maxVolatilityAccumulator', getU32Decoder()],\n    ['tickGroupSize', getU16Decoder()],\n    ['majorSwapThresholdTicks', getU16Decoder()],\n  ]);\n}\n\nexport function getAdaptiveFeeTierCodec(): Codec<\n  AdaptiveFeeTierArgs,\n  AdaptiveFeeTier\n> {\n  return combineCodec(getAdaptiveFeeTierEncoder(), getAdaptiveFeeTierDecoder());\n}\n\nexport function decodeAdaptiveFeeTier<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<AdaptiveFeeTier, TAddress>;\nexport function decodeAdaptiveFeeTier<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<AdaptiveFeeTier, TAddress>;\nexport function decodeAdaptiveFeeTier<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n):\n  | Account<AdaptiveFeeTier, TAddress>\n  | MaybeAccount<AdaptiveFeeTier, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getAdaptiveFeeTierDecoder()\n  );\n}\n\nexport async function fetchAdaptiveFeeTier<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<AdaptiveFeeTier, TAddress>> {\n  const maybeAccount = await fetchMaybeAdaptiveFeeTier(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeAdaptiveFeeTier<\n  TAddress extends string = string,\n>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<AdaptiveFeeTier, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeAdaptiveFeeTier(maybeAccount);\n}\n\nexport async function fetchAllAdaptiveFeeTier(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<AdaptiveFeeTier>[]> {\n  const maybeAccounts = await fetchAllMaybeAdaptiveFeeTier(\n    rpc,\n    addresses,\n    config\n  );\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeAdaptiveFeeTier(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<AdaptiveFeeTier>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) =>\n    decodeAdaptiveFeeTier(maybeAccount)\n  );\n}\n\nexport function getAdaptiveFeeTierSize(): number {\n  return 128;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  fixDecoderSize,\n  fixEncoderSize,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  transformEncoder,\n  type Account,\n  type Address,\n  type Codec,\n  type Decoder,\n  type EncodedAccount,\n  type Encoder,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\n\nexport const FEE_TIER_DISCRIMINATOR = new Uint8Array([\n  56, 75, 159, 76, 142, 68, 190, 105,\n]);\n\nexport function getFeeTierDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(FEE_TIER_DISCRIMINATOR);\n}\n\nexport type FeeTier = {\n  discriminator: ReadonlyUint8Array;\n  whirlpoolsConfig: Address;\n  tickSpacing: number;\n  defaultFeeRate: number;\n};\n\nexport type FeeTierArgs = {\n  whirlpoolsConfig: Address;\n  tickSpacing: number;\n  defaultFeeRate: number;\n};\n\nexport function getFeeTierEncoder(): Encoder<FeeTierArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['whirlpoolsConfig', getAddressEncoder()],\n      ['tickSpacing', getU16Encoder()],\n      ['defaultFeeRate', getU16Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: FEE_TIER_DISCRIMINATOR })\n  );\n}\n\nexport function getFeeTierDecoder(): Decoder<FeeTier> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['whirlpoolsConfig', getAddressDecoder()],\n    ['tickSpacing', getU16Decoder()],\n    ['defaultFeeRate', getU16Decoder()],\n  ]);\n}\n\nexport function getFeeTierCodec(): Codec<FeeTierArgs, FeeTier> {\n  return combineCodec(getFeeTierEncoder(), getFeeTierDecoder());\n}\n\nexport function decodeFeeTier<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<FeeTier, TAddress>;\nexport function decodeFeeTier<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<FeeTier, TAddress>;\nexport function decodeFeeTier<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<FeeTier, TAddress> | MaybeAccount<FeeTier, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getFeeTierDecoder()\n  );\n}\n\nexport async function fetchFeeTier<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<FeeTier, TAddress>> {\n  const maybeAccount = await fetchMaybeFeeTier(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeFeeTier<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<FeeTier, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeFeeTier(maybeAccount);\n}\n\nexport async function fetchAllFeeTier(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<FeeTier>[]> {\n  const maybeAccounts = await fetchAllMaybeFeeTier(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeFeeTier(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<FeeTier>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeFeeTier(maybeAccount));\n}\n\nexport function getFeeTierSize(): number {\n  return 44;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  fixDecoderSize,\n  fixEncoderSize,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type Account,\n  type Address,\n  type Codec,\n  type Decoder,\n  type EncodedAccount,\n  type Encoder,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  getLockTypeLabelDecoder,\n  getLockTypeLabelEncoder,\n  type LockTypeLabel,\n  type LockTypeLabelArgs,\n} from '../types';\n\nexport const LOCK_CONFIG_DISCRIMINATOR = new Uint8Array([\n  106, 47, 238, 159, 124, 12, 160, 192,\n]);\n\nexport function getLockConfigDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(LOCK_CONFIG_DISCRIMINATOR);\n}\n\nexport type LockConfig = {\n  discriminator: ReadonlyUint8Array;\n  position: Address;\n  positionOwner: Address;\n  whirlpool: Address;\n  lockedTimestamp: bigint;\n  lockType: LockTypeLabel;\n};\n\nexport type LockConfigArgs = {\n  position: Address;\n  positionOwner: Address;\n  whirlpool: Address;\n  lockedTimestamp: number | bigint;\n  lockType: LockTypeLabelArgs;\n};\n\nexport function getLockConfigEncoder(): Encoder<LockConfigArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['position', getAddressEncoder()],\n      ['positionOwner', getAddressEncoder()],\n      ['whirlpool', getAddressEncoder()],\n      ['lockedTimestamp', getU64Encoder()],\n      ['lockType', getLockTypeLabelEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: LOCK_CONFIG_DISCRIMINATOR })\n  );\n}\n\nexport function getLockConfigDecoder(): Decoder<LockConfig> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['position', getAddressDecoder()],\n    ['positionOwner', getAddressDecoder()],\n    ['whirlpool', getAddressDecoder()],\n    ['lockedTimestamp', getU64Decoder()],\n    ['lockType', getLockTypeLabelDecoder()],\n  ]);\n}\n\nexport function getLockConfigCodec(): Codec<LockConfigArgs, LockConfig> {\n  return combineCodec(getLockConfigEncoder(), getLockConfigDecoder());\n}\n\nexport function decodeLockConfig<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<LockConfig, TAddress>;\nexport function decodeLockConfig<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<LockConfig, TAddress>;\nexport function decodeLockConfig<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<LockConfig, TAddress> | MaybeAccount<LockConfig, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getLockConfigDecoder()\n  );\n}\n\nexport async function fetchLockConfig<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<LockConfig, TAddress>> {\n  const maybeAccount = await fetchMaybeLockConfig(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeLockConfig<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<LockConfig, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeLockConfig(maybeAccount);\n}\n\nexport async function fetchAllLockConfig(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<LockConfig>[]> {\n  const maybeAccounts = await fetchAllMaybeLockConfig(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeLockConfig(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<LockConfig>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeLockConfig(maybeAccount));\n}\n\nexport function getLockConfigSize(): number {\n  return 113;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\n\nexport enum AccountsType {\n  TransferHookA,\n  TransferHookB,\n  TransferHookReward,\n  TransferHookInput,\n  TransferHookIntermediate,\n  TransferHookOutput,\n  SupplementalTickArrays,\n  SupplementalTickArraysOne,\n  SupplementalTickArraysTwo,\n}\n\nexport type AccountsTypeArgs = AccountsType;\n\nexport function getAccountsTypeEncoder(): Encoder<AccountsTypeArgs> {\n  return getEnumEncoder(AccountsType);\n}\n\nexport function getAccountsTypeDecoder(): Decoder<AccountsType> {\n  return getEnumDecoder(AccountsType);\n}\n\nexport function getAccountsTypeCodec(): Codec<AccountsTypeArgs, AccountsType> {\n  return combineCodec(getAccountsTypeEncoder(), getAccountsTypeDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU32Decoder,\n  getU32Encoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\n\nexport type AdaptiveFeeConstants = {\n  filterPeriod: number;\n  decayPeriod: number;\n  reductionFactor: number;\n  adaptiveFeeControlFactor: number;\n  maxVolatilityAccumulator: number;\n  tickGroupSize: number;\n  majorSwapThresholdTicks: number;\n  reserved: ReadonlyUint8Array;\n};\n\nexport type AdaptiveFeeConstantsArgs = AdaptiveFeeConstants;\n\nexport function getAdaptiveFeeConstantsEncoder(): Encoder<AdaptiveFeeConstantsArgs> {\n  return getStructEncoder([\n    ['filterPeriod', getU16Encoder()],\n    ['decayPeriod', getU16Encoder()],\n    ['reductionFactor', getU16Encoder()],\n    ['adaptiveFeeControlFactor', getU32Encoder()],\n    ['maxVolatilityAccumulator', getU32Encoder()],\n    ['tickGroupSize', getU16Encoder()],\n    ['majorSwapThresholdTicks', getU16Encoder()],\n    ['reserved', fixEncoderSize(getBytesEncoder(), 16)],\n  ]);\n}\n\nexport function getAdaptiveFeeConstantsDecoder(): Decoder<AdaptiveFeeConstants> {\n  return getStructDecoder([\n    ['filterPeriod', getU16Decoder()],\n    ['decayPeriod', getU16Decoder()],\n    ['reductionFactor', getU16Decoder()],\n    ['adaptiveFeeControlFactor', getU32Decoder()],\n    ['maxVolatilityAccumulator', getU32Decoder()],\n    ['tickGroupSize', getU16Decoder()],\n    ['majorSwapThresholdTicks', getU16Decoder()],\n    ['reserved', fixDecoderSize(getBytesDecoder(), 16)],\n  ]);\n}\n\nexport function getAdaptiveFeeConstantsCodec(): Codec<\n  AdaptiveFeeConstantsArgs,\n  AdaptiveFeeConstants\n> {\n  return combineCodec(\n    getAdaptiveFeeConstantsEncoder(),\n    getAdaptiveFeeConstantsDecoder()\n  );\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getI32Decoder,\n  getI32Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\n\nexport type AdaptiveFeeVariables = {\n  lastReferenceUpdateTimestamp: bigint;\n  lastMajorSwapTimestamp: bigint;\n  volatilityReference: number;\n  tickGroupIndexReference: number;\n  volatilityAccumulator: number;\n  reserved: ReadonlyUint8Array;\n};\n\nexport type AdaptiveFeeVariablesArgs = {\n  lastReferenceUpdateTimestamp: number | bigint;\n  lastMajorSwapTimestamp: number | bigint;\n  volatilityReference: number;\n  tickGroupIndexReference: number;\n  volatilityAccumulator: number;\n  reserved: ReadonlyUint8Array;\n};\n\nexport function getAdaptiveFeeVariablesEncoder(): Encoder<AdaptiveFeeVariablesArgs> {\n  return getStructEncoder([\n    ['lastReferenceUpdateTimestamp', getU64Encoder()],\n    ['lastMajorSwapTimestamp', getU64Encoder()],\n    ['volatilityReference', getU32Encoder()],\n    ['tickGroupIndexReference', getI32Encoder()],\n    ['volatilityAccumulator', getU32Encoder()],\n    ['reserved', fixEncoderSize(getBytesEncoder(), 16)],\n  ]);\n}\n\nexport function getAdaptiveFeeVariablesDecoder(): Decoder<AdaptiveFeeVariables> {\n  return getStructDecoder([\n    ['lastReferenceUpdateTimestamp', getU64Decoder()],\n    ['lastMajorSwapTimestamp', getU64Decoder()],\n    ['volatilityReference', getU32Decoder()],\n    ['tickGroupIndexReference', getI32Decoder()],\n    ['volatilityAccumulator', getU32Decoder()],\n    ['reserved', fixDecoderSize(getBytesDecoder(), 16)],\n  ]);\n}\n\nexport function getAdaptiveFeeVariablesCodec(): Codec<\n  AdaptiveFeeVariablesArgs,\n  AdaptiveFeeVariables\n> {\n  return combineCodec(\n    getAdaptiveFeeVariablesEncoder(),\n    getAdaptiveFeeVariablesDecoder()\n  );\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\n\nexport enum LockType {\n  Permanent,\n}\n\nexport type LockTypeArgs = LockType;\n\nexport function getLockTypeEncoder(): Encoder<LockTypeArgs> {\n  return getEnumEncoder(LockType);\n}\n\nexport function getLockTypeDecoder(): Decoder<LockType> {\n  return getEnumDecoder(LockType);\n}\n\nexport function getLockTypeCodec(): Codec<LockTypeArgs, LockType> {\n  return combineCodec(getLockTypeEncoder(), getLockTypeDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\n\nexport enum LockTypeLabel {\n  Permanent,\n}\n\nexport type LockTypeLabelArgs = LockTypeLabel;\n\nexport function getLockTypeLabelEncoder(): Encoder<LockTypeLabelArgs> {\n  return getEnumEncoder(LockTypeLabel);\n}\n\nexport function getLockTypeLabelDecoder(): Decoder<LockTypeLabel> {\n  return getEnumDecoder(LockTypeLabel);\n}\n\nexport function getLockTypeLabelCodec(): Codec<\n  LockTypeLabelArgs,\n  LockTypeLabel\n> {\n  return combineCodec(getLockTypeLabelEncoder(), getLockTypeLabelDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU128Decoder,\n  getU128Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\n\nexport type PositionRewardInfo = {\n  growthInsideCheckpoint: bigint;\n  amountOwed: bigint;\n};\n\nexport type PositionRewardInfoArgs = {\n  growthInsideCheckpoint: number | bigint;\n  amountOwed: number | bigint;\n};\n\nexport function getPositionRewardInfoEncoder(): Encoder<PositionRewardInfoArgs> {\n  return getStructEncoder([\n    ['growthInsideCheckpoint', getU128Encoder()],\n    ['amountOwed', getU64Encoder()],\n  ]);\n}\n\nexport function getPositionRewardInfoDecoder(): Decoder<PositionRewardInfo> {\n  return getStructDecoder([\n    ['growthInsideCheckpoint', getU128Decoder()],\n    ['amountOwed', getU64Decoder()],\n  ]);\n}\n\nexport function getPositionRewardInfoCodec(): Codec<\n  PositionRewardInfoArgs,\n  PositionRewardInfo\n> {\n  return combineCodec(\n    getPositionRewardInfoEncoder(),\n    getPositionRewardInfoDecoder()\n  );\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getArrayDecoder,\n  getArrayEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\nimport {\n  getRemainingAccountsSliceDecoder,\n  getRemainingAccountsSliceEncoder,\n  type RemainingAccountsSlice,\n  type RemainingAccountsSliceArgs,\n} from '.';\n\nexport type RemainingAccountsInfo = { slices: Array<RemainingAccountsSlice> };\n\nexport type RemainingAccountsInfoArgs = {\n  slices: Array<RemainingAccountsSliceArgs>;\n};\n\nexport function getRemainingAccountsInfoEncoder(): Encoder<RemainingAccountsInfoArgs> {\n  return getStructEncoder([\n    ['slices', getArrayEncoder(getRemainingAccountsSliceEncoder())],\n  ]);\n}\n\nexport function getRemainingAccountsInfoDecoder(): Decoder<RemainingAccountsInfo> {\n  return getStructDecoder([\n    ['slices', getArrayDecoder(getRemainingAccountsSliceDecoder())],\n  ]);\n}\n\nexport function getRemainingAccountsInfoCodec(): Codec<\n  RemainingAccountsInfoArgs,\n  RemainingAccountsInfo\n> {\n  return combineCodec(\n    getRemainingAccountsInfoEncoder(),\n    getRemainingAccountsInfoDecoder()\n  );\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\nimport {\n  getAccountsTypeDecoder,\n  getAccountsTypeEncoder,\n  type AccountsType,\n  type AccountsTypeArgs,\n} from '.';\n\nexport type RemainingAccountsSlice = {\n  accountsType: AccountsType;\n  length: number;\n};\n\nexport type RemainingAccountsSliceArgs = {\n  accountsType: AccountsTypeArgs;\n  length: number;\n};\n\nexport function getRemainingAccountsSliceEncoder(): Encoder<RemainingAccountsSliceArgs> {\n  return getStructEncoder([\n    ['accountsType', getAccountsTypeEncoder()],\n    ['length', getU8Encoder()],\n  ]);\n}\n\nexport function getRemainingAccountsSliceDecoder(): Decoder<RemainingAccountsSlice> {\n  return getStructDecoder([\n    ['accountsType', getAccountsTypeDecoder()],\n    ['length', getU8Decoder()],\n  ]);\n}\n\nexport function getRemainingAccountsSliceCodec(): Codec<\n  RemainingAccountsSliceArgs,\n  RemainingAccountsSlice\n> {\n  return combineCodec(\n    getRemainingAccountsSliceEncoder(),\n    getRemainingAccountsSliceDecoder()\n  );\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getArrayDecoder,\n  getArrayEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getI128Decoder,\n  getI128Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU128Decoder,\n  getU128Encoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\n\nexport type Tick = {\n  initialized: boolean;\n  liquidityNet: bigint;\n  liquidityGross: bigint;\n  feeGrowthOutsideA: bigint;\n  feeGrowthOutsideB: bigint;\n  rewardGrowthsOutside: Array<bigint>;\n};\n\nexport type TickArgs = {\n  initialized: boolean;\n  liquidityNet: number | bigint;\n  liquidityGross: number | bigint;\n  feeGrowthOutsideA: number | bigint;\n  feeGrowthOutsideB: number | bigint;\n  rewardGrowthsOutside: Array<number | bigint>;\n};\n\nexport function getTickEncoder(): Encoder<TickArgs> {\n  return getStructEncoder([\n    ['initialized', getBooleanEncoder()],\n    ['liquidityNet', getI128Encoder()],\n    ['liquidityGross', getU128Encoder()],\n    ['feeGrowthOutsideA', getU128Encoder()],\n    ['feeGrowthOutsideB', getU128Encoder()],\n    ['rewardGrowthsOutside', getArrayEncoder(getU128Encoder(), { size: 3 })],\n  ]);\n}\n\nexport function getTickDecoder(): Decoder<Tick> {\n  return getStructDecoder([\n    ['initialized', getBooleanDecoder()],\n    ['liquidityNet', getI128Decoder()],\n    ['liquidityGross', getU128Decoder()],\n    ['feeGrowthOutsideA', getU128Decoder()],\n    ['feeGrowthOutsideB', getU128Decoder()],\n    ['rewardGrowthsOutside', getArrayDecoder(getU128Decoder(), { size: 3 })],\n  ]);\n}\n\nexport function getTickCodec(): Codec<TickArgs, Tick> {\n  return combineCodec(getTickEncoder(), getTickDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU128Decoder,\n  getU128Encoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n} from '@solana/kit';\n\n/**\n * Stores the state relevant for tracking liquidity mining rewards at the `Whirlpool` level.\n * These values are used in conjunction with `PositionRewardInfo`, `Tick.reward_growths_outside`,\n * and `Whirlpool.reward_last_updated_timestamp` to determine how many rewards are earned by open\n * positions.\n */\n\nexport type WhirlpoolRewardInfo = {\n  /** Reward token mint. */\n  mint: Address;\n  /** Reward vault token account. */\n  vault: Address;\n  /** Authority account that has permission to initialize the reward and set emissions. */\n  authority: Address;\n  /** Q64.64 number that indicates how many tokens per second are earned per unit of liquidity. */\n  emissionsPerSecondX64: bigint;\n  /**\n   * Q64.64 number that tracks the total tokens earned per unit of liquidity since the reward\n   * emissions were turned on.\n   */\n  growthGlobalX64: bigint;\n};\n\nexport type WhirlpoolRewardInfoArgs = {\n  /** Reward token mint. */\n  mint: Address;\n  /** Reward vault token account. */\n  vault: Address;\n  /** Authority account that has permission to initialize the reward and set emissions. */\n  authority: Address;\n  /** Q64.64 number that indicates how many tokens per second are earned per unit of liquidity. */\n  emissionsPerSecondX64: number | bigint;\n  /**\n   * Q64.64 number that tracks the total tokens earned per unit of liquidity since the reward\n   * emissions were turned on.\n   */\n  growthGlobalX64: number | bigint;\n};\n\nexport function getWhirlpoolRewardInfoEncoder(): Encoder<WhirlpoolRewardInfoArgs> {\n  return getStructEncoder([\n    ['mint', getAddressEncoder()],\n    ['vault', getAddressEncoder()],\n    ['authority', getAddressEncoder()],\n    ['emissionsPerSecondX64', getU128Encoder()],\n    ['growthGlobalX64', getU128Encoder()],\n  ]);\n}\n\nexport function getWhirlpoolRewardInfoDecoder(): Decoder<WhirlpoolRewardInfo> {\n  return getStructDecoder([\n    ['mint', getAddressDecoder()],\n    ['vault', getAddressDecoder()],\n    ['authority', getAddressDecoder()],\n    ['emissionsPerSecondX64', getU128Decoder()],\n    ['growthGlobalX64', getU128Decoder()],\n  ]);\n}\n\nexport function getWhirlpoolRewardInfoCodec(): Codec<\n  WhirlpoolRewardInfoArgs,\n  WhirlpoolRewardInfo\n> {\n  return combineCodec(\n    getWhirlpoolRewardInfoEncoder(),\n    getWhirlpoolRewardInfoDecoder()\n  );\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  fixDecoderSize,\n  fixEncoderSize,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type Account,\n  type Address,\n  type Codec,\n  type Decoder,\n  type EncodedAccount,\n  type Encoder,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  getAdaptiveFeeConstantsDecoder,\n  getAdaptiveFeeConstantsEncoder,\n  getAdaptiveFeeVariablesDecoder,\n  getAdaptiveFeeVariablesEncoder,\n  type AdaptiveFeeConstants,\n  type AdaptiveFeeConstantsArgs,\n  type AdaptiveFeeVariables,\n  type AdaptiveFeeVariablesArgs,\n} from '../types';\n\nexport const ORACLE_DISCRIMINATOR = new Uint8Array([\n  139, 194, 131, 179, 140, 179, 229, 244,\n]);\n\nexport function getOracleDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(ORACLE_DISCRIMINATOR);\n}\n\nexport type Oracle = {\n  discriminator: ReadonlyUint8Array;\n  whirlpool: Address;\n  tradeEnableTimestamp: bigint;\n  adaptiveFeeConstants: AdaptiveFeeConstants;\n  adaptiveFeeVariables: AdaptiveFeeVariables;\n  reserved: ReadonlyUint8Array;\n};\n\nexport type OracleArgs = {\n  whirlpool: Address;\n  tradeEnableTimestamp: number | bigint;\n  adaptiveFeeConstants: AdaptiveFeeConstantsArgs;\n  adaptiveFeeVariables: AdaptiveFeeVariablesArgs;\n  reserved: ReadonlyUint8Array;\n};\n\nexport function getOracleEncoder(): Encoder<OracleArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['whirlpool', getAddressEncoder()],\n      ['tradeEnableTimestamp', getU64Encoder()],\n      ['adaptiveFeeConstants', getAdaptiveFeeConstantsEncoder()],\n      ['adaptiveFeeVariables', getAdaptiveFeeVariablesEncoder()],\n      ['reserved', fixEncoderSize(getBytesEncoder(), 128)],\n    ]),\n    (value) => ({ ...value, discriminator: ORACLE_DISCRIMINATOR })\n  );\n}\n\nexport function getOracleDecoder(): Decoder<Oracle> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['whirlpool', getAddressDecoder()],\n    ['tradeEnableTimestamp', getU64Decoder()],\n    ['adaptiveFeeConstants', getAdaptiveFeeConstantsDecoder()],\n    ['adaptiveFeeVariables', getAdaptiveFeeVariablesDecoder()],\n    ['reserved', fixDecoderSize(getBytesDecoder(), 128)],\n  ]);\n}\n\nexport function getOracleCodec(): Codec<OracleArgs, Oracle> {\n  return combineCodec(getOracleEncoder(), getOracleDecoder());\n}\n\nexport function decodeOracle<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<Oracle, TAddress>;\nexport function decodeOracle<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<Oracle, TAddress>;\nexport function decodeOracle<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<Oracle, TAddress> | MaybeAccount<Oracle, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getOracleDecoder()\n  );\n}\n\nexport async function fetchOracle<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<Oracle, TAddress>> {\n  const maybeAccount = await fetchMaybeOracle(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeOracle<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<Oracle, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeOracle(maybeAccount);\n}\n\nexport async function fetchAllOracle(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<Oracle>[]> {\n  const maybeAccounts = await fetchAllMaybeOracle(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeOracle(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<Oracle>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeOracle(maybeAccount));\n}\n\nexport function getOracleSize(): number {\n  return 254;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  fixDecoderSize,\n  fixEncoderSize,\n  getAddressDecoder,\n  getAddressEncoder,\n  getArrayDecoder,\n  getArrayEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getI32Decoder,\n  getI32Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU128Decoder,\n  getU128Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type Account,\n  type Address,\n  type Codec,\n  type Decoder,\n  type EncodedAccount,\n  type Encoder,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  getPositionRewardInfoDecoder,\n  getPositionRewardInfoEncoder,\n  type PositionRewardInfo,\n  type PositionRewardInfoArgs,\n} from '../types';\n\nexport const POSITION_DISCRIMINATOR = new Uint8Array([\n  170, 188, 143, 228, 122, 64, 247, 208,\n]);\n\nexport function getPositionDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(POSITION_DISCRIMINATOR);\n}\n\nexport type Position = {\n  discriminator: ReadonlyUint8Array;\n  whirlpool: Address;\n  positionMint: Address;\n  liquidity: bigint;\n  tickLowerIndex: number;\n  tickUpperIndex: number;\n  feeGrowthCheckpointA: bigint;\n  feeOwedA: bigint;\n  feeGrowthCheckpointB: bigint;\n  feeOwedB: bigint;\n  rewardInfos: Array<PositionRewardInfo>;\n};\n\nexport type PositionArgs = {\n  whirlpool: Address;\n  positionMint: Address;\n  liquidity: number | bigint;\n  tickLowerIndex: number;\n  tickUpperIndex: number;\n  feeGrowthCheckpointA: number | bigint;\n  feeOwedA: number | bigint;\n  feeGrowthCheckpointB: number | bigint;\n  feeOwedB: number | bigint;\n  rewardInfos: Array<PositionRewardInfoArgs>;\n};\n\nexport function getPositionEncoder(): Encoder<PositionArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['whirlpool', getAddressEncoder()],\n      ['positionMint', getAddressEncoder()],\n      ['liquidity', getU128Encoder()],\n      ['tickLowerIndex', getI32Encoder()],\n      ['tickUpperIndex', getI32Encoder()],\n      ['feeGrowthCheckpointA', getU128Encoder()],\n      ['feeOwedA', getU64Encoder()],\n      ['feeGrowthCheckpointB', getU128Encoder()],\n      ['feeOwedB', getU64Encoder()],\n      [\n        'rewardInfos',\n        getArrayEncoder(getPositionRewardInfoEncoder(), { size: 3 }),\n      ],\n    ]),\n    (value) => ({ ...value, discriminator: POSITION_DISCRIMINATOR })\n  );\n}\n\nexport function getPositionDecoder(): Decoder<Position> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['whirlpool', getAddressDecoder()],\n    ['positionMint', getAddressDecoder()],\n    ['liquidity', getU128Decoder()],\n    ['tickLowerIndex', getI32Decoder()],\n    ['tickUpperIndex', getI32Decoder()],\n    ['feeGrowthCheckpointA', getU128Decoder()],\n    ['feeOwedA', getU64Decoder()],\n    ['feeGrowthCheckpointB', getU128Decoder()],\n    ['feeOwedB', getU64Decoder()],\n    [\n      'rewardInfos',\n      getArrayDecoder(getPositionRewardInfoDecoder(), { size: 3 }),\n    ],\n  ]);\n}\n\nexport function getPositionCodec(): Codec<PositionArgs, Position> {\n  return combineCodec(getPositionEncoder(), getPositionDecoder());\n}\n\nexport function decodePosition<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<Position, TAddress>;\nexport function decodePosition<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<Position, TAddress>;\nexport function decodePosition<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<Position, TAddress> | MaybeAccount<Position, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getPositionDecoder()\n  );\n}\n\nexport async function fetchPosition<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<Position, TAddress>> {\n  const maybeAccount = await fetchMaybePosition(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybePosition<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<Position, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodePosition(maybeAccount);\n}\n\nexport async function fetchAllPosition(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<Position>[]> {\n  const maybeAccounts = await fetchAllMaybePosition(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybePosition(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<Position>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodePosition(maybeAccount));\n}\n\nexport function getPositionSize(): number {\n  return 216;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  fixDecoderSize,\n  fixEncoderSize,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Account,\n  type Address,\n  type Codec,\n  type Decoder,\n  type EncodedAccount,\n  type Encoder,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\n\nexport const POSITION_BUNDLE_DISCRIMINATOR = new Uint8Array([\n  129, 169, 175, 65, 185, 95, 32, 100,\n]);\n\nexport function getPositionBundleDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    POSITION_BUNDLE_DISCRIMINATOR\n  );\n}\n\nexport type PositionBundle = {\n  discriminator: ReadonlyUint8Array;\n  positionBundleMint: Address;\n  positionBitmap: ReadonlyUint8Array;\n};\n\nexport type PositionBundleArgs = {\n  positionBundleMint: Address;\n  positionBitmap: ReadonlyUint8Array;\n};\n\nexport function getPositionBundleEncoder(): Encoder<PositionBundleArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['positionBundleMint', getAddressEncoder()],\n      ['positionBitmap', fixEncoderSize(getBytesEncoder(), 32)],\n    ]),\n    (value) => ({ ...value, discriminator: POSITION_BUNDLE_DISCRIMINATOR })\n  );\n}\n\nexport function getPositionBundleDecoder(): Decoder<PositionBundle> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['positionBundleMint', getAddressDecoder()],\n    ['positionBitmap', fixDecoderSize(getBytesDecoder(), 32)],\n  ]);\n}\n\nexport function getPositionBundleCodec(): Codec<\n  PositionBundleArgs,\n  PositionBundle\n> {\n  return combineCodec(getPositionBundleEncoder(), getPositionBundleDecoder());\n}\n\nexport function decodePositionBundle<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<PositionBundle, TAddress>;\nexport function decodePositionBundle<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<PositionBundle, TAddress>;\nexport function decodePositionBundle<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<PositionBundle, TAddress> | MaybeAccount<PositionBundle, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getPositionBundleDecoder()\n  );\n}\n\nexport async function fetchPositionBundle<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<PositionBundle, TAddress>> {\n  const maybeAccount = await fetchMaybePositionBundle(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybePositionBundle<\n  TAddress extends string = string,\n>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<PositionBundle, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodePositionBundle(maybeAccount);\n}\n\nexport async function fetchAllPositionBundle(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<PositionBundle>[]> {\n  const maybeAccounts = await fetchAllMaybePositionBundle(\n    rpc,\n    addresses,\n    config\n  );\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybePositionBundle(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<PositionBundle>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) =>\n    decodePositionBundle(maybeAccount)\n  );\n}\n\nexport function getPositionBundleSize(): number {\n  return 72;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  fixDecoderSize,\n  fixEncoderSize,\n  getAddressDecoder,\n  getAddressEncoder,\n  getArrayDecoder,\n  getArrayEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getI32Decoder,\n  getI32Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Account,\n  type Address,\n  type Codec,\n  type Decoder,\n  type EncodedAccount,\n  type Encoder,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  getTickDecoder,\n  getTickEncoder,\n  type Tick,\n  type TickArgs,\n} from '../types';\n\nexport const TICK_ARRAY_DISCRIMINATOR = new Uint8Array([\n  69, 97, 189, 190, 110, 7, 66, 187,\n]);\n\nexport function getTickArrayDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(TICK_ARRAY_DISCRIMINATOR);\n}\n\nexport type TickArray = {\n  discriminator: ReadonlyUint8Array;\n  startTickIndex: number;\n  ticks: Array<Tick>;\n  whirlpool: Address;\n};\n\nexport type TickArrayArgs = {\n  startTickIndex: number;\n  ticks: Array<TickArgs>;\n  whirlpool: Address;\n};\n\nexport function getTickArrayEncoder(): Encoder<TickArrayArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['startTickIndex', getI32Encoder()],\n      ['ticks', getArrayEncoder(getTickEncoder(), { size: 88 })],\n      ['whirlpool', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: TICK_ARRAY_DISCRIMINATOR })\n  );\n}\n\nexport function getTickArrayDecoder(): Decoder<TickArray> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['startTickIndex', getI32Decoder()],\n    ['ticks', getArrayDecoder(getTickDecoder(), { size: 88 })],\n    ['whirlpool', getAddressDecoder()],\n  ]);\n}\n\nexport function getTickArrayCodec(): Codec<TickArrayArgs, TickArray> {\n  return combineCodec(getTickArrayEncoder(), getTickArrayDecoder());\n}\n\nexport function decodeTickArray<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<TickArray, TAddress>;\nexport function decodeTickArray<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<TickArray, TAddress>;\nexport function decodeTickArray<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<TickArray, TAddress> | MaybeAccount<TickArray, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getTickArrayDecoder()\n  );\n}\n\nexport async function fetchTickArray<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<TickArray, TAddress>> {\n  const maybeAccount = await fetchMaybeTickArray(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeTickArray<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<TickArray, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeTickArray(maybeAccount);\n}\n\nexport async function fetchAllTickArray(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<TickArray>[]> {\n  const maybeAccounts = await fetchAllMaybeTickArray(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeTickArray(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<TickArray>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeTickArray(maybeAccount));\n}\n\nexport function getTickArraySize(): number {\n  return 9988;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  fixDecoderSize,\n  fixEncoderSize,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Account,\n  type Address,\n  type Codec,\n  type Decoder,\n  type EncodedAccount,\n  type Encoder,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\n\nexport const TOKEN_BADGE_DISCRIMINATOR = new Uint8Array([\n  116, 219, 204, 229, 249, 116, 255, 150,\n]);\n\nexport function getTokenBadgeDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(TOKEN_BADGE_DISCRIMINATOR);\n}\n\nexport type TokenBadge = {\n  discriminator: ReadonlyUint8Array;\n  whirlpoolsConfig: Address;\n  tokenMint: Address;\n};\n\nexport type TokenBadgeArgs = { whirlpoolsConfig: Address; tokenMint: Address };\n\nexport function getTokenBadgeEncoder(): Encoder<TokenBadgeArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['whirlpoolsConfig', getAddressEncoder()],\n      ['tokenMint', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: TOKEN_BADGE_DISCRIMINATOR })\n  );\n}\n\nexport function getTokenBadgeDecoder(): Decoder<TokenBadge> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['whirlpoolsConfig', getAddressDecoder()],\n    ['tokenMint', getAddressDecoder()],\n  ]);\n}\n\nexport function getTokenBadgeCodec(): Codec<TokenBadgeArgs, TokenBadge> {\n  return combineCodec(getTokenBadgeEncoder(), getTokenBadgeDecoder());\n}\n\nexport function decodeTokenBadge<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<TokenBadge, TAddress>;\nexport function decodeTokenBadge<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<TokenBadge, TAddress>;\nexport function decodeTokenBadge<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<TokenBadge, TAddress> | MaybeAccount<TokenBadge, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getTokenBadgeDecoder()\n  );\n}\n\nexport async function fetchTokenBadge<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<TokenBadge, TAddress>> {\n  const maybeAccount = await fetchMaybeTokenBadge(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeTokenBadge<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<TokenBadge, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeTokenBadge(maybeAccount);\n}\n\nexport async function fetchAllTokenBadge(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<TokenBadge>[]> {\n  const maybeAccounts = await fetchAllMaybeTokenBadge(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeTokenBadge(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<TokenBadge>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeTokenBadge(maybeAccount));\n}\n\nexport function getTokenBadgeSize(): number {\n  return 72;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  fixDecoderSize,\n  fixEncoderSize,\n  getAddressDecoder,\n  getAddressEncoder,\n  getArrayDecoder,\n  getArrayEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getI32Decoder,\n  getI32Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU128Decoder,\n  getU128Encoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type Account,\n  type Address,\n  type Codec,\n  type Decoder,\n  type EncodedAccount,\n  type Encoder,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  getWhirlpoolRewardInfoDecoder,\n  getWhirlpoolRewardInfoEncoder,\n  type WhirlpoolRewardInfo,\n  type WhirlpoolRewardInfoArgs,\n} from '../types';\n\nexport const WHIRLPOOL_DISCRIMINATOR = new Uint8Array([\n  63, 149, 209, 12, 225, 128, 99, 9,\n]);\n\nexport function getWhirlpoolDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(WHIRLPOOL_DISCRIMINATOR);\n}\n\nexport type Whirlpool = {\n  discriminator: ReadonlyUint8Array;\n  whirlpoolsConfig: Address;\n  whirlpoolBump: ReadonlyUint8Array;\n  tickSpacing: number;\n  feeTierIndexSeed: ReadonlyUint8Array;\n  feeRate: number;\n  protocolFeeRate: number;\n  liquidity: bigint;\n  sqrtPrice: bigint;\n  tickCurrentIndex: number;\n  protocolFeeOwedA: bigint;\n  protocolFeeOwedB: bigint;\n  tokenMintA: Address;\n  tokenVaultA: Address;\n  feeGrowthGlobalA: bigint;\n  tokenMintB: Address;\n  tokenVaultB: Address;\n  feeGrowthGlobalB: bigint;\n  rewardLastUpdatedTimestamp: bigint;\n  rewardInfos: Array<WhirlpoolRewardInfo>;\n};\n\nexport type WhirlpoolArgs = {\n  whirlpoolsConfig: Address;\n  whirlpoolBump: ReadonlyUint8Array;\n  tickSpacing: number;\n  feeTierIndexSeed: ReadonlyUint8Array;\n  feeRate: number;\n  protocolFeeRate: number;\n  liquidity: number | bigint;\n  sqrtPrice: number | bigint;\n  tickCurrentIndex: number;\n  protocolFeeOwedA: number | bigint;\n  protocolFeeOwedB: number | bigint;\n  tokenMintA: Address;\n  tokenVaultA: Address;\n  feeGrowthGlobalA: number | bigint;\n  tokenMintB: Address;\n  tokenVaultB: Address;\n  feeGrowthGlobalB: number | bigint;\n  rewardLastUpdatedTimestamp: number | bigint;\n  rewardInfos: Array<WhirlpoolRewardInfoArgs>;\n};\n\nexport function getWhirlpoolEncoder(): Encoder<WhirlpoolArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['whirlpoolsConfig', getAddressEncoder()],\n      ['whirlpoolBump', fixEncoderSize(getBytesEncoder(), 1)],\n      ['tickSpacing', getU16Encoder()],\n      ['feeTierIndexSeed', fixEncoderSize(getBytesEncoder(), 2)],\n      ['feeRate', getU16Encoder()],\n      ['protocolFeeRate', getU16Encoder()],\n      ['liquidity', getU128Encoder()],\n      ['sqrtPrice', getU128Encoder()],\n      ['tickCurrentIndex', getI32Encoder()],\n      ['protocolFeeOwedA', getU64Encoder()],\n      ['protocolFeeOwedB', getU64Encoder()],\n      ['tokenMintA', getAddressEncoder()],\n      ['tokenVaultA', getAddressEncoder()],\n      ['feeGrowthGlobalA', getU128Encoder()],\n      ['tokenMintB', getAddressEncoder()],\n      ['tokenVaultB', getAddressEncoder()],\n      ['feeGrowthGlobalB', getU128Encoder()],\n      ['rewardLastUpdatedTimestamp', getU64Encoder()],\n      [\n        'rewardInfos',\n        getArrayEncoder(getWhirlpoolRewardInfoEncoder(), { size: 3 }),\n      ],\n    ]),\n    (value) => ({ ...value, discriminator: WHIRLPOOL_DISCRIMINATOR })\n  );\n}\n\nexport function getWhirlpoolDecoder(): Decoder<Whirlpool> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['whirlpoolsConfig', getAddressDecoder()],\n    ['whirlpoolBump', fixDecoderSize(getBytesDecoder(), 1)],\n    ['tickSpacing', getU16Decoder()],\n    ['feeTierIndexSeed', fixDecoderSize(getBytesDecoder(), 2)],\n    ['feeRate', getU16Decoder()],\n    ['protocolFeeRate', getU16Decoder()],\n    ['liquidity', getU128Decoder()],\n    ['sqrtPrice', getU128Decoder()],\n    ['tickCurrentIndex', getI32Decoder()],\n    ['protocolFeeOwedA', getU64Decoder()],\n    ['protocolFeeOwedB', getU64Decoder()],\n    ['tokenMintA', getAddressDecoder()],\n    ['tokenVaultA', getAddressDecoder()],\n    ['feeGrowthGlobalA', getU128Decoder()],\n    ['tokenMintB', getAddressDecoder()],\n    ['tokenVaultB', getAddressDecoder()],\n    ['feeGrowthGlobalB', getU128Decoder()],\n    ['rewardLastUpdatedTimestamp', getU64Decoder()],\n    [\n      'rewardInfos',\n      getArrayDecoder(getWhirlpoolRewardInfoDecoder(), { size: 3 }),\n    ],\n  ]);\n}\n\nexport function getWhirlpoolCodec(): Codec<WhirlpoolArgs, Whirlpool> {\n  return combineCodec(getWhirlpoolEncoder(), getWhirlpoolDecoder());\n}\n\nexport function decodeWhirlpool<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<Whirlpool, TAddress>;\nexport function decodeWhirlpool<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<Whirlpool, TAddress>;\nexport function decodeWhirlpool<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<Whirlpool, TAddress> | MaybeAccount<Whirlpool, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getWhirlpoolDecoder()\n  );\n}\n\nexport async function fetchWhirlpool<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<Whirlpool, TAddress>> {\n  const maybeAccount = await fetchMaybeWhirlpool(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeWhirlpool<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<Whirlpool, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeWhirlpool(maybeAccount);\n}\n\nexport async function fetchAllWhirlpool(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<Whirlpool>[]> {\n  const maybeAccounts = await fetchAllMaybeWhirlpool(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeWhirlpool(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<Whirlpool>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeWhirlpool(maybeAccount));\n}\n\nexport function getWhirlpoolSize(): number {\n  return 653;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  fixDecoderSize,\n  fixEncoderSize,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  transformEncoder,\n  type Account,\n  type Address,\n  type Codec,\n  type Decoder,\n  type EncodedAccount,\n  type Encoder,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\n\nexport const WHIRLPOOLS_CONFIG_DISCRIMINATOR = new Uint8Array([\n  157, 20, 49, 224, 217, 87, 193, 254,\n]);\n\nexport function getWhirlpoolsConfigDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    WHIRLPOOLS_CONFIG_DISCRIMINATOR\n  );\n}\n\nexport type WhirlpoolsConfig = {\n  discriminator: ReadonlyUint8Array;\n  feeAuthority: Address;\n  collectProtocolFeesAuthority: Address;\n  rewardEmissionsSuperAuthority: Address;\n  defaultProtocolFeeRate: number;\n};\n\nexport type WhirlpoolsConfigArgs = {\n  feeAuthority: Address;\n  collectProtocolFeesAuthority: Address;\n  rewardEmissionsSuperAuthority: Address;\n  defaultProtocolFeeRate: number;\n};\n\nexport function getWhirlpoolsConfigEncoder(): Encoder<WhirlpoolsConfigArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['feeAuthority', getAddressEncoder()],\n      ['collectProtocolFeesAuthority', getAddressEncoder()],\n      ['rewardEmissionsSuperAuthority', getAddressEncoder()],\n      ['defaultProtocolFeeRate', getU16Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: WHIRLPOOLS_CONFIG_DISCRIMINATOR })\n  );\n}\n\nexport function getWhirlpoolsConfigDecoder(): Decoder<WhirlpoolsConfig> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['feeAuthority', getAddressDecoder()],\n    ['collectProtocolFeesAuthority', getAddressDecoder()],\n    ['rewardEmissionsSuperAuthority', getAddressDecoder()],\n    ['defaultProtocolFeeRate', getU16Decoder()],\n  ]);\n}\n\nexport function getWhirlpoolsConfigCodec(): Codec<\n  WhirlpoolsConfigArgs,\n  WhirlpoolsConfig\n> {\n  return combineCodec(\n    getWhirlpoolsConfigEncoder(),\n    getWhirlpoolsConfigDecoder()\n  );\n}\n\nexport function decodeWhirlpoolsConfig<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<WhirlpoolsConfig, TAddress>;\nexport function decodeWhirlpoolsConfig<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<WhirlpoolsConfig, TAddress>;\nexport function decodeWhirlpoolsConfig<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n):\n  | Account<WhirlpoolsConfig, TAddress>\n  | MaybeAccount<WhirlpoolsConfig, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getWhirlpoolsConfigDecoder()\n  );\n}\n\nexport async function fetchWhirlpoolsConfig<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<WhirlpoolsConfig, TAddress>> {\n  const maybeAccount = await fetchMaybeWhirlpoolsConfig(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeWhirlpoolsConfig<\n  TAddress extends string = string,\n>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<WhirlpoolsConfig, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeWhirlpoolsConfig(maybeAccount);\n}\n\nexport async function fetchAllWhirlpoolsConfig(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<WhirlpoolsConfig>[]> {\n  const maybeAccounts = await fetchAllMaybeWhirlpoolsConfig(\n    rpc,\n    addresses,\n    config\n  );\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeWhirlpoolsConfig(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<WhirlpoolsConfig>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) =>\n    decodeWhirlpoolsConfig(maybeAccount)\n  );\n}\n\nexport function getWhirlpoolsConfigSize(): number {\n  return 106;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  fixDecoderSize,\n  fixEncoderSize,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Account,\n  type Address,\n  type Codec,\n  type Decoder,\n  type EncodedAccount,\n  type Encoder,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\n\nexport const WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR = new Uint8Array([\n  2, 99, 215, 163, 240, 26, 153, 58,\n]);\n\nexport function getWhirlpoolsConfigExtensionDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR\n  );\n}\n\nexport type WhirlpoolsConfigExtension = {\n  discriminator: ReadonlyUint8Array;\n  whirlpoolsConfig: Address;\n  configExtensionAuthority: Address;\n  tokenBadgeAuthority: Address;\n};\n\nexport type WhirlpoolsConfigExtensionArgs = {\n  whirlpoolsConfig: Address;\n  configExtensionAuthority: Address;\n  tokenBadgeAuthority: Address;\n};\n\nexport function getWhirlpoolsConfigExtensionEncoder(): Encoder<WhirlpoolsConfigExtensionArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['whirlpoolsConfig', getAddressEncoder()],\n      ['configExtensionAuthority', getAddressEncoder()],\n      ['tokenBadgeAuthority', getAddressEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getWhirlpoolsConfigExtensionDecoder(): Decoder<WhirlpoolsConfigExtension> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['whirlpoolsConfig', getAddressDecoder()],\n    ['configExtensionAuthority', getAddressDecoder()],\n    ['tokenBadgeAuthority', getAddressDecoder()],\n  ]);\n}\n\nexport function getWhirlpoolsConfigExtensionCodec(): Codec<\n  WhirlpoolsConfigExtensionArgs,\n  WhirlpoolsConfigExtension\n> {\n  return combineCodec(\n    getWhirlpoolsConfigExtensionEncoder(),\n    getWhirlpoolsConfigExtensionDecoder()\n  );\n}\n\nexport function decodeWhirlpoolsConfigExtension<\n  TAddress extends string = string,\n>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<WhirlpoolsConfigExtension, TAddress>;\nexport function decodeWhirlpoolsConfigExtension<\n  TAddress extends string = string,\n>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<WhirlpoolsConfigExtension, TAddress>;\nexport function decodeWhirlpoolsConfigExtension<\n  TAddress extends string = string,\n>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n):\n  | Account<WhirlpoolsConfigExtension, TAddress>\n  | MaybeAccount<WhirlpoolsConfigExtension, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getWhirlpoolsConfigExtensionDecoder()\n  );\n}\n\nexport async function fetchWhirlpoolsConfigExtension<\n  TAddress extends string = string,\n>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<WhirlpoolsConfigExtension, TAddress>> {\n  const maybeAccount = await fetchMaybeWhirlpoolsConfigExtension(\n    rpc,\n    address,\n    config\n  );\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeWhirlpoolsConfigExtension<\n  TAddress extends string = string,\n>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<WhirlpoolsConfigExtension, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeWhirlpoolsConfigExtension(maybeAccount);\n}\n\nexport async function fetchAllWhirlpoolsConfigExtension(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<WhirlpoolsConfigExtension>[]> {\n  const maybeAccounts = await fetchAllMaybeWhirlpoolsConfigExtension(\n    rpc,\n    addresses,\n    config\n  );\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeWhirlpoolsConfigExtension(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<WhirlpoolsConfigExtension>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) =>\n    decodeWhirlpoolsConfigExtension(maybeAccount)\n  );\n}\n\nexport function getWhirlpoolsConfigExtensionSize(): number {\n  return 104;\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  isProgramError,\n  type Address,\n  type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n  type SolanaError,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\n\n/** InvalidEnum: Enum value could not be converted */\nexport const WHIRLPOOL_ERROR__INVALID_ENUM = 0x1770; // 6000\n/** InvalidStartTick: Invalid start tick index provided. */\nexport const WHIRLPOOL_ERROR__INVALID_START_TICK = 0x1771; // 6001\n/** TickArrayExistInPool: Tick-array already exists in this whirlpool */\nexport const WHIRLPOOL_ERROR__TICK_ARRAY_EXIST_IN_POOL = 0x1772; // 6002\n/** TickArrayIndexOutofBounds: Attempt to search for a tick-array failed */\nexport const WHIRLPOOL_ERROR__TICK_ARRAY_INDEX_OUTOF_BOUNDS = 0x1773; // 6003\n/** InvalidTickSpacing: Tick-spacing is not supported */\nexport const WHIRLPOOL_ERROR__INVALID_TICK_SPACING = 0x1774; // 6004\n/** ClosePositionNotEmpty: Position is not empty It cannot be closed */\nexport const WHIRLPOOL_ERROR__CLOSE_POSITION_NOT_EMPTY = 0x1775; // 6005\n/** DivideByZero: Unable to divide by zero */\nexport const WHIRLPOOL_ERROR__DIVIDE_BY_ZERO = 0x1776; // 6006\n/** NumberCastError: Unable to cast number into BigInt */\nexport const WHIRLPOOL_ERROR__NUMBER_CAST_ERROR = 0x1777; // 6007\n/** NumberDownCastError: Unable to down cast number */\nexport const WHIRLPOOL_ERROR__NUMBER_DOWN_CAST_ERROR = 0x1778; // 6008\n/** TickNotFound: Tick not found within tick array */\nexport const WHIRLPOOL_ERROR__TICK_NOT_FOUND = 0x1779; // 6009\n/** InvalidTickIndex: Provided tick index is either out of bounds or uninitializable */\nexport const WHIRLPOOL_ERROR__INVALID_TICK_INDEX = 0x177a; // 6010\n/** SqrtPriceOutOfBounds: Provided sqrt price out of bounds */\nexport const WHIRLPOOL_ERROR__SQRT_PRICE_OUT_OF_BOUNDS = 0x177b; // 6011\n/** LiquidityZero: Liquidity amount must be greater than zero */\nexport const WHIRLPOOL_ERROR__LIQUIDITY_ZERO = 0x177c; // 6012\n/** LiquidityTooHigh: Liquidity amount must be less than i64::MAX */\nexport const WHIRLPOOL_ERROR__LIQUIDITY_TOO_HIGH = 0x177d; // 6013\n/** LiquidityOverflow: Liquidity overflow */\nexport const WHIRLPOOL_ERROR__LIQUIDITY_OVERFLOW = 0x177e; // 6014\n/** LiquidityUnderflow: Liquidity underflow */\nexport const WHIRLPOOL_ERROR__LIQUIDITY_UNDERFLOW = 0x177f; // 6015\n/** LiquidityNetError: Tick liquidity net underflowed or overflowed */\nexport const WHIRLPOOL_ERROR__LIQUIDITY_NET_ERROR = 0x1780; // 6016\n/** TokenMaxExceeded: Exceeded token max */\nexport const WHIRLPOOL_ERROR__TOKEN_MAX_EXCEEDED = 0x1781; // 6017\n/** TokenMinSubceeded: Did not meet token min */\nexport const WHIRLPOOL_ERROR__TOKEN_MIN_SUBCEEDED = 0x1782; // 6018\n/** MissingOrInvalidDelegate: Position token account has a missing or invalid delegate */\nexport const WHIRLPOOL_ERROR__MISSING_OR_INVALID_DELEGATE = 0x1783; // 6019\n/** InvalidPositionTokenAmount: Position token amount must be 1 */\nexport const WHIRLPOOL_ERROR__INVALID_POSITION_TOKEN_AMOUNT = 0x1784; // 6020\n/** InvalidTimestampConversion: Timestamp should be convertible from i64 to u64 */\nexport const WHIRLPOOL_ERROR__INVALID_TIMESTAMP_CONVERSION = 0x1785; // 6021\n/** InvalidTimestamp: Timestamp should be greater than the last updated timestamp */\nexport const WHIRLPOOL_ERROR__INVALID_TIMESTAMP = 0x1786; // 6022\n/** InvalidTickArraySequence: Invalid tick array sequence provided for instruction. */\nexport const WHIRLPOOL_ERROR__INVALID_TICK_ARRAY_SEQUENCE = 0x1787; // 6023\n/** InvalidTokenMintOrder: Token Mint in wrong order */\nexport const WHIRLPOOL_ERROR__INVALID_TOKEN_MINT_ORDER = 0x1788; // 6024\n/** RewardNotInitialized: Reward not initialized */\nexport const WHIRLPOOL_ERROR__REWARD_NOT_INITIALIZED = 0x1789; // 6025\n/** InvalidRewardIndex: Invalid reward index */\nexport const WHIRLPOOL_ERROR__INVALID_REWARD_INDEX = 0x178a; // 6026\n/** RewardVaultAmountInsufficient: Reward vault requires amount to support emissions for at least one day */\nexport const WHIRLPOOL_ERROR__REWARD_VAULT_AMOUNT_INSUFFICIENT = 0x178b; // 6027\n/** FeeRateMaxExceeded: Exceeded max fee rate */\nexport const WHIRLPOOL_ERROR__FEE_RATE_MAX_EXCEEDED = 0x178c; // 6028\n/** ProtocolFeeRateMaxExceeded: Exceeded max protocol fee rate */\nexport const WHIRLPOOL_ERROR__PROTOCOL_FEE_RATE_MAX_EXCEEDED = 0x178d; // 6029\n/** MultiplicationShiftRightOverflow: Multiplication with shift right overflow */\nexport const WHIRLPOOL_ERROR__MULTIPLICATION_SHIFT_RIGHT_OVERFLOW = 0x178e; // 6030\n/** MulDivOverflow: Muldiv overflow */\nexport const WHIRLPOOL_ERROR__MUL_DIV_OVERFLOW = 0x178f; // 6031\n/** MulDivInvalidInput: Invalid div_u256 input */\nexport const WHIRLPOOL_ERROR__MUL_DIV_INVALID_INPUT = 0x1790; // 6032\n/** MultiplicationOverflow: Multiplication overflow */\nexport const WHIRLPOOL_ERROR__MULTIPLICATION_OVERFLOW = 0x1791; // 6033\n/** InvalidSqrtPriceLimitDirection: Provided SqrtPriceLimit not in the same direction as the swap. */\nexport const WHIRLPOOL_ERROR__INVALID_SQRT_PRICE_LIMIT_DIRECTION = 0x1792; // 6034\n/** ZeroTradableAmount: There are no tradable amount to swap. */\nexport const WHIRLPOOL_ERROR__ZERO_TRADABLE_AMOUNT = 0x1793; // 6035\n/** AmountOutBelowMinimum: Amount out below minimum threshold */\nexport const WHIRLPOOL_ERROR__AMOUNT_OUT_BELOW_MINIMUM = 0x1794; // 6036\n/** AmountInAboveMaximum: Amount in above maximum threshold */\nexport const WHIRLPOOL_ERROR__AMOUNT_IN_ABOVE_MAXIMUM = 0x1795; // 6037\n/** TickArraySequenceInvalidIndex: Invalid index for tick array sequence */\nexport const WHIRLPOOL_ERROR__TICK_ARRAY_SEQUENCE_INVALID_INDEX = 0x1796; // 6038\n/** AmountCalcOverflow: Amount calculated overflows */\nexport const WHIRLPOOL_ERROR__AMOUNT_CALC_OVERFLOW = 0x1797; // 6039\n/** AmountRemainingOverflow: Amount remaining overflows */\nexport const WHIRLPOOL_ERROR__AMOUNT_REMAINING_OVERFLOW = 0x1798; // 6040\n/** InvalidIntermediaryMint: Invalid intermediary mint */\nexport const WHIRLPOOL_ERROR__INVALID_INTERMEDIARY_MINT = 0x1799; // 6041\n/** DuplicateTwoHopPool: Duplicate two hop pool */\nexport const WHIRLPOOL_ERROR__DUPLICATE_TWO_HOP_POOL = 0x179a; // 6042\n/** InvalidBundleIndex: Bundle index is out of bounds */\nexport const WHIRLPOOL_ERROR__INVALID_BUNDLE_INDEX = 0x179b; // 6043\n/** BundledPositionAlreadyOpened: Position has already been opened */\nexport const WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_OPENED = 0x179c; // 6044\n/** BundledPositionAlreadyClosed: Position has already been closed */\nexport const WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_CLOSED = 0x179d; // 6045\n/** PositionBundleNotDeletable: Unable to delete PositionBundle with open positions */\nexport const WHIRLPOOL_ERROR__POSITION_BUNDLE_NOT_DELETABLE = 0x179e; // 6046\n/** UnsupportedTokenMint: Token mint has unsupported attributes */\nexport const WHIRLPOOL_ERROR__UNSUPPORTED_TOKEN_MINT = 0x179f; // 6047\n/** RemainingAccountsInvalidSlice: Invalid remaining accounts */\nexport const WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INVALID_SLICE = 0x17a0; // 6048\n/** RemainingAccountsInsufficient: Insufficient remaining accounts */\nexport const WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INSUFFICIENT = 0x17a1; // 6049\n/** NoExtraAccountsForTransferHook: Unable to call transfer hook without extra accounts */\nexport const WHIRLPOOL_ERROR__NO_EXTRA_ACCOUNTS_FOR_TRANSFER_HOOK = 0x17a2; // 6050\n/** IntermediateTokenAmountMismatch: Output and input amount mismatch */\nexport const WHIRLPOOL_ERROR__INTERMEDIATE_TOKEN_AMOUNT_MISMATCH = 0x17a3; // 6051\n/** TransferFeeCalculationError: Transfer fee calculation failed */\nexport const WHIRLPOOL_ERROR__TRANSFER_FEE_CALCULATION_ERROR = 0x17a4; // 6052\n/** RemainingAccountsDuplicatedAccountsType: Same accounts type is provided more than once */\nexport const WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_DUPLICATED_ACCOUNTS_TYPE = 0x17a5; // 6053\n/** FullRangeOnlyPool: This whirlpool only supports full-range positions */\nexport const WHIRLPOOL_ERROR__FULL_RANGE_ONLY_POOL = 0x17a6; // 6054\n/** TooManySupplementalTickArrays: Too many supplemental tick arrays provided */\nexport const WHIRLPOOL_ERROR__TOO_MANY_SUPPLEMENTAL_TICK_ARRAYS = 0x17a7; // 6055\n/** DifferentWhirlpoolTickArrayAccount: TickArray account for different whirlpool provided */\nexport const WHIRLPOOL_ERROR__DIFFERENT_WHIRLPOOL_TICK_ARRAY_ACCOUNT = 0x17a8; // 6056\n/** PartialFillError: Trade resulted in partial fill */\nexport const WHIRLPOOL_ERROR__PARTIAL_FILL_ERROR = 0x17a9; // 6057\n/** PositionNotLockable: Position is not lockable */\nexport const WHIRLPOOL_ERROR__POSITION_NOT_LOCKABLE = 0x17aa; // 6058\n/** OperationNotAllowedOnLockedPosition: Operation not allowed on locked position */\nexport const WHIRLPOOL_ERROR__OPERATION_NOT_ALLOWED_ON_LOCKED_POSITION = 0x17ab; // 6059\n/** SameTickRangeNotAllowed: Cannot reset position range with same tick range */\nexport const WHIRLPOOL_ERROR__SAME_TICK_RANGE_NOT_ALLOWED = 0x17ac; // 6060\n/** InvalidAdaptiveFeeConstants: Invalid adaptive fee constants */\nexport const WHIRLPOOL_ERROR__INVALID_ADAPTIVE_FEE_CONSTANTS = 0x17ad; // 6061\n/** InvalidFeeTierIndex: Invalid fee tier index */\nexport const WHIRLPOOL_ERROR__INVALID_FEE_TIER_INDEX = 0x17ae; // 6062\n/** InvalidTradeEnableTimestamp: Invalid trade enable timestamp */\nexport const WHIRLPOOL_ERROR__INVALID_TRADE_ENABLE_TIMESTAMP = 0x17af; // 6063\n/** TradeIsNotEnabled: Trade is not enabled yet */\nexport const WHIRLPOOL_ERROR__TRADE_IS_NOT_ENABLED = 0x17b0; // 6064\n\nexport type WhirlpoolError =\n  | typeof WHIRLPOOL_ERROR__AMOUNT_CALC_OVERFLOW\n  | typeof WHIRLPOOL_ERROR__AMOUNT_IN_ABOVE_MAXIMUM\n  | typeof WHIRLPOOL_ERROR__AMOUNT_OUT_BELOW_MINIMUM\n  | typeof WHIRLPOOL_ERROR__AMOUNT_REMAINING_OVERFLOW\n  | typeof WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_CLOSED\n  | typeof WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_OPENED\n  | typeof WHIRLPOOL_ERROR__CLOSE_POSITION_NOT_EMPTY\n  | typeof WHIRLPOOL_ERROR__DIFFERENT_WHIRLPOOL_TICK_ARRAY_ACCOUNT\n  | typeof WHIRLPOOL_ERROR__DIVIDE_BY_ZERO\n  | typeof WHIRLPOOL_ERROR__DUPLICATE_TWO_HOP_POOL\n  | typeof WHIRLPOOL_ERROR__FEE_RATE_MAX_EXCEEDED\n  | typeof WHIRLPOOL_ERROR__FULL_RANGE_ONLY_POOL\n  | typeof WHIRLPOOL_ERROR__INTERMEDIATE_TOKEN_AMOUNT_MISMATCH\n  | typeof WHIRLPOOL_ERROR__INVALID_ADAPTIVE_FEE_CONSTANTS\n  | typeof WHIRLPOOL_ERROR__INVALID_BUNDLE_INDEX\n  | typeof WHIRLPOOL_ERROR__INVALID_ENUM\n  | typeof WHIRLPOOL_ERROR__INVALID_FEE_TIER_INDEX\n  | typeof WHIRLPOOL_ERROR__INVALID_INTERMEDIARY_MINT\n  | typeof WHIRLPOOL_ERROR__INVALID_POSITION_TOKEN_AMOUNT\n  | typeof WHIRLPOOL_ERROR__INVALID_REWARD_INDEX\n  | typeof WHIRLPOOL_ERROR__INVALID_SQRT_PRICE_LIMIT_DIRECTION\n  | typeof WHIRLPOOL_ERROR__INVALID_START_TICK\n  | typeof WHIRLPOOL_ERROR__INVALID_TICK_ARRAY_SEQUENCE\n  | typeof WHIRLPOOL_ERROR__INVALID_TICK_INDEX\n  | typeof WHIRLPOOL_ERROR__INVALID_TICK_SPACING\n  | typeof WHIRLPOOL_ERROR__INVALID_TIMESTAMP\n  | typeof WHIRLPOOL_ERROR__INVALID_TIMESTAMP_CONVERSION\n  | typeof WHIRLPOOL_ERROR__INVALID_TOKEN_MINT_ORDER\n  | typeof WHIRLPOOL_ERROR__INVALID_TRADE_ENABLE_TIMESTAMP\n  | typeof WHIRLPOOL_ERROR__LIQUIDITY_NET_ERROR\n  | typeof WHIRLPOOL_ERROR__LIQUIDITY_OVERFLOW\n  | typeof WHIRLPOOL_ERROR__LIQUIDITY_TOO_HIGH\n  | typeof WHIRLPOOL_ERROR__LIQUIDITY_UNDERFLOW\n  | typeof WHIRLPOOL_ERROR__LIQUIDITY_ZERO\n  | typeof WHIRLPOOL_ERROR__MISSING_OR_INVALID_DELEGATE\n  | typeof WHIRLPOOL_ERROR__MUL_DIV_INVALID_INPUT\n  | typeof WHIRLPOOL_ERROR__MUL_DIV_OVERFLOW\n  | typeof WHIRLPOOL_ERROR__MULTIPLICATION_OVERFLOW\n  | typeof WHIRLPOOL_ERROR__MULTIPLICATION_SHIFT_RIGHT_OVERFLOW\n  | typeof WHIRLPOOL_ERROR__NO_EXTRA_ACCOUNTS_FOR_TRANSFER_HOOK\n  | typeof WHIRLPOOL_ERROR__NUMBER_CAST_ERROR\n  | typeof WHIRLPOOL_ERROR__NUMBER_DOWN_CAST_ERROR\n  | typeof WHIRLPOOL_ERROR__OPERATION_NOT_ALLOWED_ON_LOCKED_POSITION\n  | typeof WHIRLPOOL_ERROR__PARTIAL_FILL_ERROR\n  | typeof WHIRLPOOL_ERROR__POSITION_BUNDLE_NOT_DELETABLE\n  | typeof WHIRLPOOL_ERROR__POSITION_NOT_LOCKABLE\n  | typeof WHIRLPOOL_ERROR__PROTOCOL_FEE_RATE_MAX_EXCEEDED\n  | typeof WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_DUPLICATED_ACCOUNTS_TYPE\n  | typeof WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INSUFFICIENT\n  | typeof WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INVALID_SLICE\n  | typeof WHIRLPOOL_ERROR__REWARD_NOT_INITIALIZED\n  | typeof WHIRLPOOL_ERROR__REWARD_VAULT_AMOUNT_INSUFFICIENT\n  | typeof WHIRLPOOL_ERROR__SAME_TICK_RANGE_NOT_ALLOWED\n  | typeof WHIRLPOOL_ERROR__SQRT_PRICE_OUT_OF_BOUNDS\n  | typeof WHIRLPOOL_ERROR__TICK_ARRAY_EXIST_IN_POOL\n  | typeof WHIRLPOOL_ERROR__TICK_ARRAY_INDEX_OUTOF_BOUNDS\n  | typeof WHIRLPOOL_ERROR__TICK_ARRAY_SEQUENCE_INVALID_INDEX\n  | typeof WHIRLPOOL_ERROR__TICK_NOT_FOUND\n  | typeof WHIRLPOOL_ERROR__TOKEN_MAX_EXCEEDED\n  | typeof WHIRLPOOL_ERROR__TOKEN_MIN_SUBCEEDED\n  | typeof WHIRLPOOL_ERROR__TOO_MANY_SUPPLEMENTAL_TICK_ARRAYS\n  | typeof WHIRLPOOL_ERROR__TRADE_IS_NOT_ENABLED\n  | typeof WHIRLPOOL_ERROR__TRANSFER_FEE_CALCULATION_ERROR\n  | typeof WHIRLPOOL_ERROR__UNSUPPORTED_TOKEN_MINT\n  | typeof WHIRLPOOL_ERROR__ZERO_TRADABLE_AMOUNT;\n\nlet whirlpoolErrorMessages: Record<WhirlpoolError, string> | undefined;\nif (process.env.NODE_ENV !== 'production') {\n  whirlpoolErrorMessages = {\n    [WHIRLPOOL_ERROR__AMOUNT_CALC_OVERFLOW]: `Amount calculated overflows`,\n    [WHIRLPOOL_ERROR__AMOUNT_IN_ABOVE_MAXIMUM]: `Amount in above maximum threshold`,\n    [WHIRLPOOL_ERROR__AMOUNT_OUT_BELOW_MINIMUM]: `Amount out below minimum threshold`,\n    [WHIRLPOOL_ERROR__AMOUNT_REMAINING_OVERFLOW]: `Amount remaining overflows`,\n    [WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_CLOSED]: `Position has already been closed`,\n    [WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_OPENED]: `Position has already been opened`,\n    [WHIRLPOOL_ERROR__CLOSE_POSITION_NOT_EMPTY]: `Position is not empty It cannot be closed`,\n    [WHIRLPOOL_ERROR__DIFFERENT_WHIRLPOOL_TICK_ARRAY_ACCOUNT]: `TickArray account for different whirlpool provided`,\n    [WHIRLPOOL_ERROR__DIVIDE_BY_ZERO]: `Unable to divide by zero`,\n    [WHIRLPOOL_ERROR__DUPLICATE_TWO_HOP_POOL]: `Duplicate two hop pool`,\n    [WHIRLPOOL_ERROR__FEE_RATE_MAX_EXCEEDED]: `Exceeded max fee rate`,\n    [WHIRLPOOL_ERROR__FULL_RANGE_ONLY_POOL]: `This whirlpool only supports full-range positions`,\n    [WHIRLPOOL_ERROR__INTERMEDIATE_TOKEN_AMOUNT_MISMATCH]: `Output and input amount mismatch`,\n    [WHIRLPOOL_ERROR__INVALID_ADAPTIVE_FEE_CONSTANTS]: `Invalid adaptive fee constants`,\n    [WHIRLPOOL_ERROR__INVALID_BUNDLE_INDEX]: `Bundle index is out of bounds`,\n    [WHIRLPOOL_ERROR__INVALID_ENUM]: `Enum value could not be converted`,\n    [WHIRLPOOL_ERROR__INVALID_FEE_TIER_INDEX]: `Invalid fee tier index`,\n    [WHIRLPOOL_ERROR__INVALID_INTERMEDIARY_MINT]: `Invalid intermediary mint`,\n    [WHIRLPOOL_ERROR__INVALID_POSITION_TOKEN_AMOUNT]: `Position token amount must be 1`,\n    [WHIRLPOOL_ERROR__INVALID_REWARD_INDEX]: `Invalid reward index`,\n    [WHIRLPOOL_ERROR__INVALID_SQRT_PRICE_LIMIT_DIRECTION]: `Provided SqrtPriceLimit not in the same direction as the swap.`,\n    [WHIRLPOOL_ERROR__INVALID_START_TICK]: `Invalid start tick index provided.`,\n    [WHIRLPOOL_ERROR__INVALID_TICK_ARRAY_SEQUENCE]: `Invalid tick array sequence provided for instruction.`,\n    [WHIRLPOOL_ERROR__INVALID_TICK_INDEX]: `Provided tick index is either out of bounds or uninitializable`,\n    [WHIRLPOOL_ERROR__INVALID_TICK_SPACING]: `Tick-spacing is not supported`,\n    [WHIRLPOOL_ERROR__INVALID_TIMESTAMP]: `Timestamp should be greater than the last updated timestamp`,\n    [WHIRLPOOL_ERROR__INVALID_TIMESTAMP_CONVERSION]: `Timestamp should be convertible from i64 to u64`,\n    [WHIRLPOOL_ERROR__INVALID_TOKEN_MINT_ORDER]: `Token Mint in wrong order`,\n    [WHIRLPOOL_ERROR__INVALID_TRADE_ENABLE_TIMESTAMP]: `Invalid trade enable timestamp`,\n    [WHIRLPOOL_ERROR__LIQUIDITY_NET_ERROR]: `Tick liquidity net underflowed or overflowed`,\n    [WHIRLPOOL_ERROR__LIQUIDITY_OVERFLOW]: `Liquidity overflow`,\n    [WHIRLPOOL_ERROR__LIQUIDITY_TOO_HIGH]: `Liquidity amount must be less than i64::MAX`,\n    [WHIRLPOOL_ERROR__LIQUIDITY_UNDERFLOW]: `Liquidity underflow`,\n    [WHIRLPOOL_ERROR__LIQUIDITY_ZERO]: `Liquidity amount must be greater than zero`,\n    [WHIRLPOOL_ERROR__MISSING_OR_INVALID_DELEGATE]: `Position token account has a missing or invalid delegate`,\n    [WHIRLPOOL_ERROR__MUL_DIV_INVALID_INPUT]: `Invalid div_u256 input`,\n    [WHIRLPOOL_ERROR__MUL_DIV_OVERFLOW]: `Muldiv overflow`,\n    [WHIRLPOOL_ERROR__MULTIPLICATION_OVERFLOW]: `Multiplication overflow`,\n    [WHIRLPOOL_ERROR__MULTIPLICATION_SHIFT_RIGHT_OVERFLOW]: `Multiplication with shift right overflow`,\n    [WHIRLPOOL_ERROR__NO_EXTRA_ACCOUNTS_FOR_TRANSFER_HOOK]: `Unable to call transfer hook without extra accounts`,\n    [WHIRLPOOL_ERROR__NUMBER_CAST_ERROR]: `Unable to cast number into BigInt`,\n    [WHIRLPOOL_ERROR__NUMBER_DOWN_CAST_ERROR]: `Unable to down cast number`,\n    [WHIRLPOOL_ERROR__OPERATION_NOT_ALLOWED_ON_LOCKED_POSITION]: `Operation not allowed on locked position`,\n    [WHIRLPOOL_ERROR__PARTIAL_FILL_ERROR]: `Trade resulted in partial fill`,\n    [WHIRLPOOL_ERROR__POSITION_BUNDLE_NOT_DELETABLE]: `Unable to delete PositionBundle with open positions`,\n    [WHIRLPOOL_ERROR__POSITION_NOT_LOCKABLE]: `Position is not lockable`,\n    [WHIRLPOOL_ERROR__PROTOCOL_FEE_RATE_MAX_EXCEEDED]: `Exceeded max protocol fee rate`,\n    [WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_DUPLICATED_ACCOUNTS_TYPE]: `Same accounts type is provided more than once`,\n    [WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INSUFFICIENT]: `Insufficient remaining accounts`,\n    [WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INVALID_SLICE]: `Invalid remaining accounts`,\n    [WHIRLPOOL_ERROR__REWARD_NOT_INITIALIZED]: `Reward not initialized`,\n    [WHIRLPOOL_ERROR__REWARD_VAULT_AMOUNT_INSUFFICIENT]: `Reward vault requires amount to support emissions for at least one day`,\n    [WHIRLPOOL_ERROR__SAME_TICK_RANGE_NOT_ALLOWED]: `Cannot reset position range with same tick range`,\n    [WHIRLPOOL_ERROR__SQRT_PRICE_OUT_OF_BOUNDS]: `Provided sqrt price out of bounds`,\n    [WHIRLPOOL_ERROR__TICK_ARRAY_EXIST_IN_POOL]: `Tick-array already exists in this whirlpool`,\n    [WHIRLPOOL_ERROR__TICK_ARRAY_INDEX_OUTOF_BOUNDS]: `Attempt to search for a tick-array failed`,\n    [WHIRLPOOL_ERROR__TICK_ARRAY_SEQUENCE_INVALID_INDEX]: `Invalid index for tick array sequence`,\n    [WHIRLPOOL_ERROR__TICK_NOT_FOUND]: `Tick not found within tick array`,\n    [WHIRLPOOL_ERROR__TOKEN_MAX_EXCEEDED]: `Exceeded token max`,\n    [WHIRLPOOL_ERROR__TOKEN_MIN_SUBCEEDED]: `Did not meet token min`,\n    [WHIRLPOOL_ERROR__TOO_MANY_SUPPLEMENTAL_TICK_ARRAYS]: `Too many supplemental tick arrays provided`,\n    [WHIRLPOOL_ERROR__TRADE_IS_NOT_ENABLED]: `Trade is not enabled yet`,\n    [WHIRLPOOL_ERROR__TRANSFER_FEE_CALCULATION_ERROR]: `Transfer fee calculation failed`,\n    [WHIRLPOOL_ERROR__UNSUPPORTED_TOKEN_MINT]: `Token mint has unsupported attributes`,\n    [WHIRLPOOL_ERROR__ZERO_TRADABLE_AMOUNT]: `There are no tradable amount to swap.`,\n  };\n}\n\nexport function getWhirlpoolErrorMessage(code: WhirlpoolError): string {\n  if (process.env.NODE_ENV !== 'production') {\n    return (whirlpoolErrorMessages as Record<WhirlpoolError, string>)[code];\n  }\n\n  return 'Error message not available in production bundles.';\n}\n\nexport function isWhirlpoolError<TProgramErrorCode extends WhirlpoolError>(\n  error: unknown,\n  transactionMessage: {\n    instructions: Record<number, { programAddress: Address }>;\n  },\n  code?: TProgramErrorCode\n): error is SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> &\n  Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> {\n  return isProgramError<TProgramErrorCode>(\n    error,\n    transactionMessage,\n    WHIRLPOOL_PROGRAM_ADDRESS,\n    code\n  );\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  containsBytes,\n  fixEncoderSize,\n  getBytesEncoder,\n  type Address,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  type ParsedCloseBundledPositionInstruction,\n  type ParsedClosePositionInstruction,\n  type ParsedClosePositionWithTokenExtensionsInstruction,\n  type ParsedCollectFeesInstruction,\n  type ParsedCollectFeesV2Instruction,\n  type ParsedCollectProtocolFeesInstruction,\n  type ParsedCollectProtocolFeesV2Instruction,\n  type ParsedCollectRewardInstruction,\n  type ParsedCollectRewardV2Instruction,\n  type ParsedDecreaseLiquidityInstruction,\n  type ParsedDecreaseLiquidityV2Instruction,\n  type ParsedDeletePositionBundleInstruction,\n  type ParsedDeleteTokenBadgeInstruction,\n  type ParsedIncreaseLiquidityInstruction,\n  type ParsedIncreaseLiquidityV2Instruction,\n  type ParsedInitializeAdaptiveFeeTierInstruction,\n  type ParsedInitializeConfigExtensionInstruction,\n  type ParsedInitializeConfigInstruction,\n  type ParsedInitializeFeeTierInstruction,\n  type ParsedInitializePoolInstruction,\n  type ParsedInitializePoolV2Instruction,\n  type ParsedInitializePoolWithAdaptiveFeeInstruction,\n  type ParsedInitializePositionBundleInstruction,\n  type ParsedInitializePositionBundleWithMetadataInstruction,\n  type ParsedInitializeRewardInstruction,\n  type ParsedInitializeRewardV2Instruction,\n  type ParsedInitializeTickArrayInstruction,\n  type ParsedInitializeTokenBadgeInstruction,\n  type ParsedLockPositionInstruction,\n  type ParsedOpenBundledPositionInstruction,\n  type ParsedOpenPositionInstruction,\n  type ParsedOpenPositionWithMetadataInstruction,\n  type ParsedOpenPositionWithTokenExtensionsInstruction,\n  type ParsedResetPositionRangeInstruction,\n  type ParsedSetCollectProtocolFeesAuthorityInstruction,\n  type ParsedSetConfigExtensionAuthorityInstruction,\n  type ParsedSetDefaultBaseFeeRateInstruction,\n  type ParsedSetDefaultFeeRateInstruction,\n  type ParsedSetDefaultProtocolFeeRateInstruction,\n  type ParsedSetDelegatedFeeAuthorityInstruction,\n  type ParsedSetFeeAuthorityInstruction,\n  type ParsedSetFeeRateByDelegatedFeeAuthorityInstruction,\n  type ParsedSetFeeRateInstruction,\n  type ParsedSetInitializePoolAuthorityInstruction,\n  type ParsedSetPresetAdaptiveFeeConstantsInstruction,\n  type ParsedSetProtocolFeeRateInstruction,\n  type ParsedSetRewardAuthorityBySuperAuthorityInstruction,\n  type ParsedSetRewardAuthorityInstruction,\n  type ParsedSetRewardEmissionsInstruction,\n  type ParsedSetRewardEmissionsSuperAuthorityInstruction,\n  type ParsedSetRewardEmissionsV2Instruction,\n  type ParsedSetTokenBadgeAuthorityInstruction,\n  type ParsedSwapInstruction,\n  type ParsedSwapV2Instruction,\n  type ParsedTransferLockedPositionInstruction,\n  type ParsedTwoHopSwapInstruction,\n  type ParsedTwoHopSwapV2Instruction,\n  type ParsedUpdateFeesAndRewardsInstruction,\n} from '../instructions';\n\nexport const WHIRLPOOL_PROGRAM_ADDRESS =\n  'whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc' as Address<'whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc'>;\n\nexport enum WhirlpoolAccount {\n  AdaptiveFeeTier,\n  WhirlpoolsConfig,\n  WhirlpoolsConfigExtension,\n  FeeTier,\n  LockConfig,\n  Oracle,\n  Position,\n  PositionBundle,\n  TickArray,\n  TokenBadge,\n  Whirlpool,\n}\n\nexport function identifyWhirlpoolAccount(\n  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): WhirlpoolAccount {\n  const data = 'data' in account ? account.data : account;\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([147, 16, 144, 116, 47, 146, 149, 46])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolAccount.AdaptiveFeeTier;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([157, 20, 49, 224, 217, 87, 193, 254])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolAccount.WhirlpoolsConfig;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([2, 99, 215, 163, 240, 26, 153, 58])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolAccount.WhirlpoolsConfigExtension;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([56, 75, 159, 76, 142, 68, 190, 105])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolAccount.FeeTier;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([106, 47, 238, 159, 124, 12, 160, 192])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolAccount.LockConfig;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([139, 194, 131, 179, 140, 179, 229, 244])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolAccount.Oracle;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([170, 188, 143, 228, 122, 64, 247, 208])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolAccount.Position;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([129, 169, 175, 65, 185, 95, 32, 100])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolAccount.PositionBundle;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([69, 97, 189, 190, 110, 7, 66, 187])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolAccount.TickArray;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([116, 219, 204, 229, 249, 116, 255, 150])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolAccount.TokenBadge;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([63, 149, 209, 12, 225, 128, 99, 9])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolAccount.Whirlpool;\n  }\n  throw new Error(\n    'The provided account could not be identified as a whirlpool account.'\n  );\n}\n\nexport enum WhirlpoolInstruction {\n  InitializeConfig,\n  InitializePool,\n  InitializeTickArray,\n  InitializeFeeTier,\n  InitializeReward,\n  SetRewardEmissions,\n  OpenPosition,\n  OpenPositionWithMetadata,\n  IncreaseLiquidity,\n  DecreaseLiquidity,\n  UpdateFeesAndRewards,\n  CollectFees,\n  CollectReward,\n  CollectProtocolFees,\n  Swap,\n  ClosePosition,\n  SetDefaultFeeRate,\n  SetDefaultProtocolFeeRate,\n  SetFeeRate,\n  SetProtocolFeeRate,\n  SetFeeAuthority,\n  SetCollectProtocolFeesAuthority,\n  SetRewardAuthority,\n  SetRewardAuthorityBySuperAuthority,\n  SetRewardEmissionsSuperAuthority,\n  TwoHopSwap,\n  InitializePositionBundle,\n  InitializePositionBundleWithMetadata,\n  DeletePositionBundle,\n  OpenBundledPosition,\n  CloseBundledPosition,\n  OpenPositionWithTokenExtensions,\n  ClosePositionWithTokenExtensions,\n  LockPosition,\n  ResetPositionRange,\n  TransferLockedPosition,\n  InitializeAdaptiveFeeTier,\n  SetDefaultBaseFeeRate,\n  SetDelegatedFeeAuthority,\n  SetInitializePoolAuthority,\n  SetPresetAdaptiveFeeConstants,\n  InitializePoolWithAdaptiveFee,\n  SetFeeRateByDelegatedFeeAuthority,\n  CollectFeesV2,\n  CollectProtocolFeesV2,\n  CollectRewardV2,\n  DecreaseLiquidityV2,\n  IncreaseLiquidityV2,\n  InitializePoolV2,\n  InitializeRewardV2,\n  SetRewardEmissionsV2,\n  SwapV2,\n  TwoHopSwapV2,\n  InitializeConfigExtension,\n  SetConfigExtensionAuthority,\n  SetTokenBadgeAuthority,\n  InitializeTokenBadge,\n  DeleteTokenBadge,\n}\n\nexport function identifyWhirlpoolInstruction(\n  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): WhirlpoolInstruction {\n  const data = 'data' in instruction ? instruction.data : instruction;\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([208, 127, 21, 1, 194, 190, 196, 70])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.InitializeConfig;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([95, 180, 10, 172, 84, 174, 232, 40])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.InitializePool;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([11, 188, 193, 214, 141, 91, 149, 184])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.InitializeTickArray;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([183, 74, 156, 160, 112, 2, 42, 30])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.InitializeFeeTier;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([95, 135, 192, 196, 242, 129, 230, 68])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.InitializeReward;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([13, 197, 86, 168, 109, 176, 27, 244])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.SetRewardEmissions;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([135, 128, 47, 77, 15, 152, 240, 49])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.OpenPosition;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([242, 29, 134, 48, 58, 110, 14, 60])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.OpenPositionWithMetadata;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([46, 156, 243, 118, 13, 205, 251, 178])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.IncreaseLiquidity;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([160, 38, 208, 111, 104, 91, 44, 1])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.DecreaseLiquidity;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([154, 230, 250, 13, 236, 209, 75, 223])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.UpdateFeesAndRewards;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([164, 152, 207, 99, 30, 186, 19, 182])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.CollectFees;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([70, 5, 132, 87, 86, 235, 177, 34])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.CollectReward;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([22, 67, 23, 98, 150, 178, 70, 220])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.CollectProtocolFees;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([248, 198, 158, 145, 225, 117, 135, 200])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.Swap;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([123, 134, 81, 0, 49, 68, 98, 98])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.ClosePosition;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([118, 215, 214, 157, 182, 229, 208, 228])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.SetDefaultFeeRate;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([107, 205, 249, 226, 151, 35, 86, 0])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.SetDefaultProtocolFeeRate;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([53, 243, 137, 65, 8, 140, 158, 6])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.SetFeeRate;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([95, 7, 4, 50, 154, 79, 156, 131])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.SetProtocolFeeRate;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([31, 1, 50, 87, 237, 101, 97, 132])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.SetFeeAuthority;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([34, 150, 93, 244, 139, 225, 233, 67])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.SetCollectProtocolFeesAuthority;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([34, 39, 183, 252, 83, 28, 85, 127])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.SetRewardAuthority;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([240, 154, 201, 198, 148, 93, 56, 25])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.SetRewardAuthorityBySuperAuthority;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([207, 5, 200, 209, 122, 56, 82, 183])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.SetRewardEmissionsSuperAuthority;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([195, 96, 237, 108, 68, 162, 219, 230])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.TwoHopSwap;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([117, 45, 241, 149, 24, 18, 194, 65])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.InitializePositionBundle;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([93, 124, 16, 179, 249, 131, 115, 245])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.InitializePositionBundleWithMetadata;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([100, 25, 99, 2, 217, 239, 124, 173])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.DeletePositionBundle;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([169, 113, 126, 171, 213, 172, 212, 49])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.OpenBundledPosition;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([41, 36, 216, 245, 27, 85, 103, 67])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.CloseBundledPosition;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([212, 47, 95, 92, 114, 102, 131, 250])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.OpenPositionWithTokenExtensions;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([1, 182, 135, 59, 155, 25, 99, 223])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.ClosePositionWithTokenExtensions;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([227, 62, 2, 252, 247, 10, 171, 185])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.LockPosition;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([164, 123, 180, 141, 194, 100, 160, 175])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.ResetPositionRange;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([179, 121, 229, 46, 67, 138, 194, 138])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.TransferLockedPosition;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([77, 99, 208, 200, 141, 123, 117, 48])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.InitializeAdaptiveFeeTier;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([229, 66, 84, 251, 164, 134, 183, 7])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.SetDefaultBaseFeeRate;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([193, 234, 231, 147, 138, 57, 3, 122])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.SetDelegatedFeeAuthority;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([125, 43, 127, 235, 149, 26, 106, 236])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.SetInitializePoolAuthority;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([132, 185, 66, 148, 83, 88, 134, 198])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.SetPresetAdaptiveFeeConstants;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([143, 94, 96, 76, 172, 124, 119, 199])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.InitializePoolWithAdaptiveFee;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([121, 121, 54, 114, 131, 230, 162, 104])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.SetFeeRateByDelegatedFeeAuthority;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([207, 117, 95, 191, 229, 180, 226, 15])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.CollectFeesV2;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([103, 128, 222, 134, 114, 200, 22, 200])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.CollectProtocolFeesV2;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([177, 107, 37, 180, 160, 19, 49, 209])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.CollectRewardV2;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([58, 127, 188, 62, 79, 82, 196, 96])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.DecreaseLiquidityV2;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([133, 29, 89, 223, 69, 238, 176, 10])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.IncreaseLiquidityV2;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([207, 45, 87, 242, 27, 63, 204, 67])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.InitializePoolV2;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([91, 1, 77, 50, 235, 229, 133, 49])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.InitializeRewardV2;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([114, 228, 72, 32, 193, 48, 160, 102])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.SetRewardEmissionsV2;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([43, 4, 237, 11, 26, 201, 30, 98])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.SwapV2;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([186, 143, 209, 29, 254, 2, 194, 117])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.TwoHopSwapV2;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([55, 9, 53, 9, 114, 57, 209, 52])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.InitializeConfigExtension;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([44, 94, 241, 116, 24, 188, 60, 143])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.SetConfigExtensionAuthority;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([207, 202, 4, 32, 205, 79, 13, 178])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.SetTokenBadgeAuthority;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([253, 77, 205, 95, 27, 224, 89, 223])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.InitializeTokenBadge;\n  }\n  if (\n    containsBytes(\n      data,\n      fixEncoderSize(getBytesEncoder(), 8).encode(\n        new Uint8Array([53, 146, 68, 8, 18, 117, 17, 185])\n      ),\n      0\n    )\n  ) {\n    return WhirlpoolInstruction.DeleteTokenBadge;\n  }\n  throw new Error(\n    'The provided instruction could not be identified as a whirlpool instruction.'\n  );\n}\n\nexport type ParsedWhirlpoolInstruction<\n  TProgram extends string = 'whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc',\n> =\n  | ({\n      instructionType: WhirlpoolInstruction.InitializeConfig;\n    } & ParsedInitializeConfigInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.InitializePool;\n    } & ParsedInitializePoolInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.InitializeTickArray;\n    } & ParsedInitializeTickArrayInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.InitializeFeeTier;\n    } & ParsedInitializeFeeTierInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.InitializeReward;\n    } & ParsedInitializeRewardInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.SetRewardEmissions;\n    } & ParsedSetRewardEmissionsInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.OpenPosition;\n    } & ParsedOpenPositionInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.OpenPositionWithMetadata;\n    } & ParsedOpenPositionWithMetadataInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.IncreaseLiquidity;\n    } & ParsedIncreaseLiquidityInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.DecreaseLiquidity;\n    } & ParsedDecreaseLiquidityInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.UpdateFeesAndRewards;\n    } & ParsedUpdateFeesAndRewardsInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.CollectFees;\n    } & ParsedCollectFeesInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.CollectReward;\n    } & ParsedCollectRewardInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.CollectProtocolFees;\n    } & ParsedCollectProtocolFeesInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.Swap;\n    } & ParsedSwapInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.ClosePosition;\n    } & ParsedClosePositionInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.SetDefaultFeeRate;\n    } & ParsedSetDefaultFeeRateInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.SetDefaultProtocolFeeRate;\n    } & ParsedSetDefaultProtocolFeeRateInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.SetFeeRate;\n    } & ParsedSetFeeRateInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.SetProtocolFeeRate;\n    } & ParsedSetProtocolFeeRateInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.SetFeeAuthority;\n    } & ParsedSetFeeAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.SetCollectProtocolFeesAuthority;\n    } & ParsedSetCollectProtocolFeesAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.SetRewardAuthority;\n    } & ParsedSetRewardAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.SetRewardAuthorityBySuperAuthority;\n    } & ParsedSetRewardAuthorityBySuperAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.SetRewardEmissionsSuperAuthority;\n    } & ParsedSetRewardEmissionsSuperAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.TwoHopSwap;\n    } & ParsedTwoHopSwapInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.InitializePositionBundle;\n    } & ParsedInitializePositionBundleInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.InitializePositionBundleWithMetadata;\n    } & ParsedInitializePositionBundleWithMetadataInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.DeletePositionBundle;\n    } & ParsedDeletePositionBundleInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.OpenBundledPosition;\n    } & ParsedOpenBundledPositionInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.CloseBundledPosition;\n    } & ParsedCloseBundledPositionInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.OpenPositionWithTokenExtensions;\n    } & ParsedOpenPositionWithTokenExtensionsInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.ClosePositionWithTokenExtensions;\n    } & ParsedClosePositionWithTokenExtensionsInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.LockPosition;\n    } & ParsedLockPositionInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.ResetPositionRange;\n    } & ParsedResetPositionRangeInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.TransferLockedPosition;\n    } & ParsedTransferLockedPositionInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.InitializeAdaptiveFeeTier;\n    } & ParsedInitializeAdaptiveFeeTierInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.SetDefaultBaseFeeRate;\n    } & ParsedSetDefaultBaseFeeRateInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.SetDelegatedFeeAuthority;\n    } & ParsedSetDelegatedFeeAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.SetInitializePoolAuthority;\n    } & ParsedSetInitializePoolAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.SetPresetAdaptiveFeeConstants;\n    } & ParsedSetPresetAdaptiveFeeConstantsInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.InitializePoolWithAdaptiveFee;\n    } & ParsedInitializePoolWithAdaptiveFeeInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.SetFeeRateByDelegatedFeeAuthority;\n    } & ParsedSetFeeRateByDelegatedFeeAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.CollectFeesV2;\n    } & ParsedCollectFeesV2Instruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.CollectProtocolFeesV2;\n    } & ParsedCollectProtocolFeesV2Instruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.CollectRewardV2;\n    } & ParsedCollectRewardV2Instruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.DecreaseLiquidityV2;\n    } & ParsedDecreaseLiquidityV2Instruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.IncreaseLiquidityV2;\n    } & ParsedIncreaseLiquidityV2Instruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.InitializePoolV2;\n    } & ParsedInitializePoolV2Instruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.InitializeRewardV2;\n    } & ParsedInitializeRewardV2Instruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.SetRewardEmissionsV2;\n    } & ParsedSetRewardEmissionsV2Instruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.SwapV2;\n    } & ParsedSwapV2Instruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.TwoHopSwapV2;\n    } & ParsedTwoHopSwapV2Instruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.InitializeConfigExtension;\n    } & ParsedInitializeConfigExtensionInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.SetConfigExtensionAuthority;\n    } & ParsedSetConfigExtensionAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.SetTokenBadgeAuthority;\n    } & ParsedSetTokenBadgeAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.InitializeTokenBadge;\n    } & ParsedInitializeTokenBadgeInstruction<TProgram>)\n  | ({\n      instructionType: WhirlpoolInstruction.DeleteTokenBadge;\n    } & ParsedDeleteTokenBadgeInstruction<TProgram>);\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const CLOSE_BUNDLED_POSITION_DISCRIMINATOR = new Uint8Array([\n  41, 36, 216, 245, 27, 85, 103, 67,\n]);\n\nexport function getCloseBundledPositionDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    CLOSE_BUNDLED_POSITION_DISCRIMINATOR\n  );\n}\n\nexport type CloseBundledPositionInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountBundledPosition extends string | IAccountMeta<string> = string,\n  TAccountPositionBundle extends string | IAccountMeta<string> = string,\n  TAccountPositionBundleTokenAccount extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountPositionBundleAuthority extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountReceiver extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountBundledPosition extends string\n        ? WritableAccount<TAccountBundledPosition>\n        : TAccountBundledPosition,\n      TAccountPositionBundle extends string\n        ? WritableAccount<TAccountPositionBundle>\n        : TAccountPositionBundle,\n      TAccountPositionBundleTokenAccount extends string\n        ? ReadonlyAccount<TAccountPositionBundleTokenAccount>\n        : TAccountPositionBundleTokenAccount,\n      TAccountPositionBundleAuthority extends string\n        ? ReadonlySignerAccount<TAccountPositionBundleAuthority> &\n            IAccountSignerMeta<TAccountPositionBundleAuthority>\n        : TAccountPositionBundleAuthority,\n      TAccountReceiver extends string\n        ? WritableAccount<TAccountReceiver>\n        : TAccountReceiver,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CloseBundledPositionInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  bundleIndex: number;\n};\n\nexport type CloseBundledPositionInstructionDataArgs = { bundleIndex: number };\n\nexport function getCloseBundledPositionInstructionDataEncoder(): Encoder<CloseBundledPositionInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['bundleIndex', getU16Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CLOSE_BUNDLED_POSITION_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getCloseBundledPositionInstructionDataDecoder(): Decoder<CloseBundledPositionInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['bundleIndex', getU16Decoder()],\n  ]);\n}\n\nexport function getCloseBundledPositionInstructionDataCodec(): Codec<\n  CloseBundledPositionInstructionDataArgs,\n  CloseBundledPositionInstructionData\n> {\n  return combineCodec(\n    getCloseBundledPositionInstructionDataEncoder(),\n    getCloseBundledPositionInstructionDataDecoder()\n  );\n}\n\nexport type CloseBundledPositionInput<\n  TAccountBundledPosition extends string = string,\n  TAccountPositionBundle extends string = string,\n  TAccountPositionBundleTokenAccount extends string = string,\n  TAccountPositionBundleAuthority extends string = string,\n  TAccountReceiver extends string = string,\n> = {\n  bundledPosition: Address<TAccountBundledPosition>;\n  positionBundle: Address<TAccountPositionBundle>;\n  positionBundleTokenAccount: Address<TAccountPositionBundleTokenAccount>;\n  positionBundleAuthority: TransactionSigner<TAccountPositionBundleAuthority>;\n  receiver: Address<TAccountReceiver>;\n  bundleIndex: CloseBundledPositionInstructionDataArgs['bundleIndex'];\n};\n\nexport function getCloseBundledPositionInstruction<\n  TAccountBundledPosition extends string,\n  TAccountPositionBundle extends string,\n  TAccountPositionBundleTokenAccount extends string,\n  TAccountPositionBundleAuthority extends string,\n  TAccountReceiver extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: CloseBundledPositionInput<\n    TAccountBundledPosition,\n    TAccountPositionBundle,\n    TAccountPositionBundleTokenAccount,\n    TAccountPositionBundleAuthority,\n    TAccountReceiver\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CloseBundledPositionInstruction<\n  TProgramAddress,\n  TAccountBundledPosition,\n  TAccountPositionBundle,\n  TAccountPositionBundleTokenAccount,\n  TAccountPositionBundleAuthority,\n  TAccountReceiver\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    bundledPosition: { value: input.bundledPosition ?? null, isWritable: true },\n    positionBundle: { value: input.positionBundle ?? null, isWritable: true },\n    positionBundleTokenAccount: {\n      value: input.positionBundleTokenAccount ?? null,\n      isWritable: false,\n    },\n    positionBundleAuthority: {\n      value: input.positionBundleAuthority ?? null,\n      isWritable: false,\n    },\n    receiver: { value: input.receiver ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.bundledPosition),\n      getAccountMeta(accounts.positionBundle),\n      getAccountMeta(accounts.positionBundleTokenAccount),\n      getAccountMeta(accounts.positionBundleAuthority),\n      getAccountMeta(accounts.receiver),\n    ],\n    programAddress,\n    data: getCloseBundledPositionInstructionDataEncoder().encode(\n      args as CloseBundledPositionInstructionDataArgs\n    ),\n  } as CloseBundledPositionInstruction<\n    TProgramAddress,\n    TAccountBundledPosition,\n    TAccountPositionBundle,\n    TAccountPositionBundleTokenAccount,\n    TAccountPositionBundleAuthority,\n    TAccountReceiver\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCloseBundledPositionInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    bundledPosition: TAccountMetas[0];\n    positionBundle: TAccountMetas[1];\n    positionBundleTokenAccount: TAccountMetas[2];\n    positionBundleAuthority: TAccountMetas[3];\n    receiver: TAccountMetas[4];\n  };\n  data: CloseBundledPositionInstructionData;\n};\n\nexport function parseCloseBundledPositionInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedCloseBundledPositionInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 5) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      bundledPosition: getNextAccount(),\n      positionBundle: getNextAccount(),\n      positionBundleTokenAccount: getNextAccount(),\n      positionBundleAuthority: getNextAccount(),\n      receiver: getNextAccount(),\n    },\n    data: getCloseBundledPositionInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  isProgramDerivedAddress,\n  isTransactionSigner as kitIsTransactionSigner,\n  type Address,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type ProgramDerivedAddress,\n  type TransactionSigner,\n  upgradeRoleToSigner,\n} from '@solana/kit';\n\n/**\n * Asserts that the given value is not null or undefined.\n * @internal\n */\nexport function expectSome<T>(value: T | null | undefined): T {\n  if (value == null) {\n    throw new Error('Expected a value but received null or undefined.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a PublicKey.\n * @internal\n */\nexport function expectAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): Address<T> {\n  if (!value) {\n    throw new Error('Expected a Address.');\n  }\n  if (typeof value === 'object' && 'address' in value) {\n    return value.address;\n  }\n  if (Array.isArray(value)) {\n    return value[0];\n  }\n  return value as Address<T>;\n}\n\n/**\n * Asserts that the given value is a PDA.\n * @internal\n */\nexport function expectProgramDerivedAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): ProgramDerivedAddress<T> {\n  if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {\n    throw new Error('Expected a ProgramDerivedAddress.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a TransactionSigner.\n * @internal\n */\nexport function expectTransactionSigner<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): TransactionSigner<T> {\n  if (!value || !isTransactionSigner(value)) {\n    throw new Error('Expected a TransactionSigner.');\n  }\n  return value;\n}\n\n/**\n * Defines an instruction account to resolve.\n * @internal\n */\nexport type ResolvedAccount<\n  T extends string = string,\n  U extends\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null =\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null,\n> = {\n  isWritable: boolean;\n  value: U;\n};\n\n/**\n * Defines an instruction that stores additional bytes on-chain.\n * @internal\n */\nexport type IInstructionWithByteDelta = {\n  byteDelta: number;\n};\n\n/**\n * Get account metas and signers from resolved accounts.\n * @internal\n */\nexport function getAccountMetaFactory(\n  programAddress: Address,\n  optionalAccountStrategy: 'omitted' | 'programId'\n) {\n  return (\n    account: ResolvedAccount\n  ): IAccountMeta | IAccountSignerMeta | undefined => {\n    if (!account.value) {\n      if (optionalAccountStrategy === 'omitted') return;\n      return Object.freeze({\n        address: programAddress,\n        role: AccountRole.READONLY,\n      });\n    }\n\n    const writableRole = account.isWritable\n      ? AccountRole.WRITABLE\n      : AccountRole.READONLY;\n    return Object.freeze({\n      address: expectAddress(account.value),\n      role: isTransactionSigner(account.value)\n        ? upgradeRoleToSigner(writableRole)\n        : writableRole,\n      ...(isTransactionSigner(account.value) ? { signer: account.value } : {}),\n    });\n  };\n}\n\nexport function isTransactionSigner<TAddress extends string = string>(\n  value:\n    | Address<TAddress>\n    | ProgramDerivedAddress<TAddress>\n    | TransactionSigner<TAddress>\n): value is TransactionSigner<TAddress> {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    'address' in value &&\n    kitIsTransactionSigner(value)\n  );\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const CLOSE_POSITION_DISCRIMINATOR = new Uint8Array([\n  123, 134, 81, 0, 49, 68, 98, 98,\n]);\n\nexport function getClosePositionDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    CLOSE_POSITION_DISCRIMINATOR\n  );\n}\n\nexport type ClosePositionInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountPositionAuthority extends string | IAccountMeta<string> = string,\n  TAccountReceiver extends string | IAccountMeta<string> = string,\n  TAccountPosition extends string | IAccountMeta<string> = string,\n  TAccountPositionMint extends string | IAccountMeta<string> = string,\n  TAccountPositionTokenAccount extends string | IAccountMeta<string> = string,\n  TAccountTokenProgram extends\n    | string\n    | IAccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountPositionAuthority extends string\n        ? ReadonlySignerAccount<TAccountPositionAuthority> &\n            IAccountSignerMeta<TAccountPositionAuthority>\n        : TAccountPositionAuthority,\n      TAccountReceiver extends string\n        ? WritableAccount<TAccountReceiver>\n        : TAccountReceiver,\n      TAccountPosition extends string\n        ? WritableAccount<TAccountPosition>\n        : TAccountPosition,\n      TAccountPositionMint extends string\n        ? WritableAccount<TAccountPositionMint>\n        : TAccountPositionMint,\n      TAccountPositionTokenAccount extends string\n        ? WritableAccount<TAccountPositionTokenAccount>\n        : TAccountPositionTokenAccount,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ClosePositionInstructionData = {\n  discriminator: ReadonlyUint8Array;\n};\n\nexport type ClosePositionInstructionDataArgs = {};\n\nexport function getClosePositionInstructionDataEncoder(): Encoder<ClosePositionInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]),\n    (value) => ({ ...value, discriminator: CLOSE_POSITION_DISCRIMINATOR })\n  );\n}\n\nexport function getClosePositionInstructionDataDecoder(): Decoder<ClosePositionInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n  ]);\n}\n\nexport function getClosePositionInstructionDataCodec(): Codec<\n  ClosePositionInstructionDataArgs,\n  ClosePositionInstructionData\n> {\n  return combineCodec(\n    getClosePositionInstructionDataEncoder(),\n    getClosePositionInstructionDataDecoder()\n  );\n}\n\nexport type ClosePositionInput<\n  TAccountPositionAuthority extends string = string,\n  TAccountReceiver extends string = string,\n  TAccountPosition extends string = string,\n  TAccountPositionMint extends string = string,\n  TAccountPositionTokenAccount extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  positionAuthority: TransactionSigner<TAccountPositionAuthority>;\n  receiver: Address<TAccountReceiver>;\n  position: Address<TAccountPosition>;\n  positionMint: Address<TAccountPositionMint>;\n  positionTokenAccount: Address<TAccountPositionTokenAccount>;\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport function getClosePositionInstruction<\n  TAccountPositionAuthority extends string,\n  TAccountReceiver extends string,\n  TAccountPosition extends string,\n  TAccountPositionMint extends string,\n  TAccountPositionTokenAccount extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: ClosePositionInput<\n    TAccountPositionAuthority,\n    TAccountReceiver,\n    TAccountPosition,\n    TAccountPositionMint,\n    TAccountPositionTokenAccount,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ClosePositionInstruction<\n  TProgramAddress,\n  TAccountPositionAuthority,\n  TAccountReceiver,\n  TAccountPosition,\n  TAccountPositionMint,\n  TAccountPositionTokenAccount,\n  TAccountTokenProgram\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    positionAuthority: {\n      value: input.positionAuthority ?? null,\n      isWritable: false,\n    },\n    receiver: { value: input.receiver ?? null, isWritable: true },\n    position: { value: input.position ?? null, isWritable: true },\n    positionMint: { value: input.positionMint ?? null, isWritable: true },\n    positionTokenAccount: {\n      value: input.positionTokenAccount ?? null,\n      isWritable: true,\n    },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.positionAuthority),\n      getAccountMeta(accounts.receiver),\n      getAccountMeta(accounts.position),\n      getAccountMeta(accounts.positionMint),\n      getAccountMeta(accounts.positionTokenAccount),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getClosePositionInstructionDataEncoder().encode({}),\n  } as ClosePositionInstruction<\n    TProgramAddress,\n    TAccountPositionAuthority,\n    TAccountReceiver,\n    TAccountPosition,\n    TAccountPositionMint,\n    TAccountPositionTokenAccount,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedClosePositionInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    positionAuthority: TAccountMetas[0];\n    receiver: TAccountMetas[1];\n    position: TAccountMetas[2];\n    positionMint: TAccountMetas[3];\n    positionTokenAccount: TAccountMetas[4];\n    tokenProgram: TAccountMetas[5];\n  };\n  data: ClosePositionInstructionData;\n};\n\nexport function parseClosePositionInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedClosePositionInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 6) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      positionAuthority: getNextAccount(),\n      receiver: getNextAccount(),\n      position: getNextAccount(),\n      positionMint: getNextAccount(),\n      positionTokenAccount: getNextAccount(),\n      tokenProgram: getNextAccount(),\n    },\n    data: getClosePositionInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const CLOSE_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR =\n  new Uint8Array([1, 182, 135, 59, 155, 25, 99, 223]);\n\nexport function getClosePositionWithTokenExtensionsDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    CLOSE_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR\n  );\n}\n\nexport type ClosePositionWithTokenExtensionsInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountPositionAuthority extends string | IAccountMeta<string> = string,\n  TAccountReceiver extends string | IAccountMeta<string> = string,\n  TAccountPosition extends string | IAccountMeta<string> = string,\n  TAccountPositionMint extends string | IAccountMeta<string> = string,\n  TAccountPositionTokenAccount extends string | IAccountMeta<string> = string,\n  TAccountToken2022Program extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountPositionAuthority extends string\n        ? ReadonlySignerAccount<TAccountPositionAuthority> &\n            IAccountSignerMeta<TAccountPositionAuthority>\n        : TAccountPositionAuthority,\n      TAccountReceiver extends string\n        ? WritableAccount<TAccountReceiver>\n        : TAccountReceiver,\n      TAccountPosition extends string\n        ? WritableAccount<TAccountPosition>\n        : TAccountPosition,\n      TAccountPositionMint extends string\n        ? WritableAccount<TAccountPositionMint>\n        : TAccountPositionMint,\n      TAccountPositionTokenAccount extends string\n        ? WritableAccount<TAccountPositionTokenAccount>\n        : TAccountPositionTokenAccount,\n      TAccountToken2022Program extends string\n        ? ReadonlyAccount<TAccountToken2022Program>\n        : TAccountToken2022Program,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ClosePositionWithTokenExtensionsInstructionData = {\n  discriminator: ReadonlyUint8Array;\n};\n\nexport type ClosePositionWithTokenExtensionsInstructionDataArgs = {};\n\nexport function getClosePositionWithTokenExtensionsInstructionDataEncoder(): Encoder<ClosePositionWithTokenExtensionsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]),\n    (value) => ({\n      ...value,\n      discriminator: CLOSE_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getClosePositionWithTokenExtensionsInstructionDataDecoder(): Decoder<ClosePositionWithTokenExtensionsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n  ]);\n}\n\nexport function getClosePositionWithTokenExtensionsInstructionDataCodec(): Codec<\n  ClosePositionWithTokenExtensionsInstructionDataArgs,\n  ClosePositionWithTokenExtensionsInstructionData\n> {\n  return combineCodec(\n    getClosePositionWithTokenExtensionsInstructionDataEncoder(),\n    getClosePositionWithTokenExtensionsInstructionDataDecoder()\n  );\n}\n\nexport type ClosePositionWithTokenExtensionsInput<\n  TAccountPositionAuthority extends string = string,\n  TAccountReceiver extends string = string,\n  TAccountPosition extends string = string,\n  TAccountPositionMint extends string = string,\n  TAccountPositionTokenAccount extends string = string,\n  TAccountToken2022Program extends string = string,\n> = {\n  positionAuthority: TransactionSigner<TAccountPositionAuthority>;\n  receiver: Address<TAccountReceiver>;\n  position: Address<TAccountPosition>;\n  positionMint: Address<TAccountPositionMint>;\n  positionTokenAccount: Address<TAccountPositionTokenAccount>;\n  token2022Program: Address<TAccountToken2022Program>;\n};\n\nexport function getClosePositionWithTokenExtensionsInstruction<\n  TAccountPositionAuthority extends string,\n  TAccountReceiver extends string,\n  TAccountPosition extends string,\n  TAccountPositionMint extends string,\n  TAccountPositionTokenAccount extends string,\n  TAccountToken2022Program extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: ClosePositionWithTokenExtensionsInput<\n    TAccountPositionAuthority,\n    TAccountReceiver,\n    TAccountPosition,\n    TAccountPositionMint,\n    TAccountPositionTokenAccount,\n    TAccountToken2022Program\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ClosePositionWithTokenExtensionsInstruction<\n  TProgramAddress,\n  TAccountPositionAuthority,\n  TAccountReceiver,\n  TAccountPosition,\n  TAccountPositionMint,\n  TAccountPositionTokenAccount,\n  TAccountToken2022Program\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    positionAuthority: {\n      value: input.positionAuthority ?? null,\n      isWritable: false,\n    },\n    receiver: { value: input.receiver ?? null, isWritable: true },\n    position: { value: input.position ?? null, isWritable: true },\n    positionMint: { value: input.positionMint ?? null, isWritable: true },\n    positionTokenAccount: {\n      value: input.positionTokenAccount ?? null,\n      isWritable: true,\n    },\n    token2022Program: {\n      value: input.token2022Program ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.positionAuthority),\n      getAccountMeta(accounts.receiver),\n      getAccountMeta(accounts.position),\n      getAccountMeta(accounts.positionMint),\n      getAccountMeta(accounts.positionTokenAccount),\n      getAccountMeta(accounts.token2022Program),\n    ],\n    programAddress,\n    data: getClosePositionWithTokenExtensionsInstructionDataEncoder().encode(\n      {}\n    ),\n  } as ClosePositionWithTokenExtensionsInstruction<\n    TProgramAddress,\n    TAccountPositionAuthority,\n    TAccountReceiver,\n    TAccountPosition,\n    TAccountPositionMint,\n    TAccountPositionTokenAccount,\n    TAccountToken2022Program\n  >;\n\n  return instruction;\n}\n\nexport type ParsedClosePositionWithTokenExtensionsInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    positionAuthority: TAccountMetas[0];\n    receiver: TAccountMetas[1];\n    position: TAccountMetas[2];\n    positionMint: TAccountMetas[3];\n    positionTokenAccount: TAccountMetas[4];\n    token2022Program: TAccountMetas[5];\n  };\n  data: ClosePositionWithTokenExtensionsInstructionData;\n};\n\nexport function parseClosePositionWithTokenExtensionsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedClosePositionWithTokenExtensionsInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 6) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      positionAuthority: getNextAccount(),\n      receiver: getNextAccount(),\n      position: getNextAccount(),\n      positionMint: getNextAccount(),\n      positionTokenAccount: getNextAccount(),\n      token2022Program: getNextAccount(),\n    },\n    data: getClosePositionWithTokenExtensionsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const COLLECT_FEES_DISCRIMINATOR = new Uint8Array([\n  164, 152, 207, 99, 30, 186, 19, 182,\n]);\n\nexport function getCollectFeesDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    COLLECT_FEES_DISCRIMINATOR\n  );\n}\n\nexport type CollectFeesInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountPositionAuthority extends string | IAccountMeta<string> = string,\n  TAccountPosition extends string | IAccountMeta<string> = string,\n  TAccountPositionTokenAccount extends string | IAccountMeta<string> = string,\n  TAccountTokenOwnerAccountA extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultA extends string | IAccountMeta<string> = string,\n  TAccountTokenOwnerAccountB extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultB extends string | IAccountMeta<string> = string,\n  TAccountTokenProgram extends\n    | string\n    | IAccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpool extends string\n        ? ReadonlyAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountPositionAuthority extends string\n        ? ReadonlySignerAccount<TAccountPositionAuthority> &\n            IAccountSignerMeta<TAccountPositionAuthority>\n        : TAccountPositionAuthority,\n      TAccountPosition extends string\n        ? WritableAccount<TAccountPosition>\n        : TAccountPosition,\n      TAccountPositionTokenAccount extends string\n        ? ReadonlyAccount<TAccountPositionTokenAccount>\n        : TAccountPositionTokenAccount,\n      TAccountTokenOwnerAccountA extends string\n        ? WritableAccount<TAccountTokenOwnerAccountA>\n        : TAccountTokenOwnerAccountA,\n      TAccountTokenVaultA extends string\n        ? WritableAccount<TAccountTokenVaultA>\n        : TAccountTokenVaultA,\n      TAccountTokenOwnerAccountB extends string\n        ? WritableAccount<TAccountTokenOwnerAccountB>\n        : TAccountTokenOwnerAccountB,\n      TAccountTokenVaultB extends string\n        ? WritableAccount<TAccountTokenVaultB>\n        : TAccountTokenVaultB,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CollectFeesInstructionData = { discriminator: ReadonlyUint8Array };\n\nexport type CollectFeesInstructionDataArgs = {};\n\nexport function getCollectFeesInstructionDataEncoder(): Encoder<CollectFeesInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]),\n    (value) => ({ ...value, discriminator: COLLECT_FEES_DISCRIMINATOR })\n  );\n}\n\nexport function getCollectFeesInstructionDataDecoder(): Decoder<CollectFeesInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n  ]);\n}\n\nexport function getCollectFeesInstructionDataCodec(): Codec<\n  CollectFeesInstructionDataArgs,\n  CollectFeesInstructionData\n> {\n  return combineCodec(\n    getCollectFeesInstructionDataEncoder(),\n    getCollectFeesInstructionDataDecoder()\n  );\n}\n\nexport type CollectFeesInput<\n  TAccountWhirlpool extends string = string,\n  TAccountPositionAuthority extends string = string,\n  TAccountPosition extends string = string,\n  TAccountPositionTokenAccount extends string = string,\n  TAccountTokenOwnerAccountA extends string = string,\n  TAccountTokenVaultA extends string = string,\n  TAccountTokenOwnerAccountB extends string = string,\n  TAccountTokenVaultB extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  whirlpool: Address<TAccountWhirlpool>;\n  positionAuthority: TransactionSigner<TAccountPositionAuthority>;\n  position: Address<TAccountPosition>;\n  positionTokenAccount: Address<TAccountPositionTokenAccount>;\n  tokenOwnerAccountA: Address<TAccountTokenOwnerAccountA>;\n  tokenVaultA: Address<TAccountTokenVaultA>;\n  tokenOwnerAccountB: Address<TAccountTokenOwnerAccountB>;\n  tokenVaultB: Address<TAccountTokenVaultB>;\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport function getCollectFeesInstruction<\n  TAccountWhirlpool extends string,\n  TAccountPositionAuthority extends string,\n  TAccountPosition extends string,\n  TAccountPositionTokenAccount extends string,\n  TAccountTokenOwnerAccountA extends string,\n  TAccountTokenVaultA extends string,\n  TAccountTokenOwnerAccountB extends string,\n  TAccountTokenVaultB extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: CollectFeesInput<\n    TAccountWhirlpool,\n    TAccountPositionAuthority,\n    TAccountPosition,\n    TAccountPositionTokenAccount,\n    TAccountTokenOwnerAccountA,\n    TAccountTokenVaultA,\n    TAccountTokenOwnerAccountB,\n    TAccountTokenVaultB,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CollectFeesInstruction<\n  TProgramAddress,\n  TAccountWhirlpool,\n  TAccountPositionAuthority,\n  TAccountPosition,\n  TAccountPositionTokenAccount,\n  TAccountTokenOwnerAccountA,\n  TAccountTokenVaultA,\n  TAccountTokenOwnerAccountB,\n  TAccountTokenVaultB,\n  TAccountTokenProgram\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpool: { value: input.whirlpool ?? null, isWritable: false },\n    positionAuthority: {\n      value: input.positionAuthority ?? null,\n      isWritable: false,\n    },\n    position: { value: input.position ?? null, isWritable: true },\n    positionTokenAccount: {\n      value: input.positionTokenAccount ?? null,\n      isWritable: false,\n    },\n    tokenOwnerAccountA: {\n      value: input.tokenOwnerAccountA ?? null,\n      isWritable: true,\n    },\n    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },\n    tokenOwnerAccountB: {\n      value: input.tokenOwnerAccountB ?? null,\n      isWritable: true,\n    },\n    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.positionAuthority),\n      getAccountMeta(accounts.position),\n      getAccountMeta(accounts.positionTokenAccount),\n      getAccountMeta(accounts.tokenOwnerAccountA),\n      getAccountMeta(accounts.tokenVaultA),\n      getAccountMeta(accounts.tokenOwnerAccountB),\n      getAccountMeta(accounts.tokenVaultB),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getCollectFeesInstructionDataEncoder().encode({}),\n  } as CollectFeesInstruction<\n    TProgramAddress,\n    TAccountWhirlpool,\n    TAccountPositionAuthority,\n    TAccountPosition,\n    TAccountPositionTokenAccount,\n    TAccountTokenOwnerAccountA,\n    TAccountTokenVaultA,\n    TAccountTokenOwnerAccountB,\n    TAccountTokenVaultB,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCollectFeesInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpool: TAccountMetas[0];\n    positionAuthority: TAccountMetas[1];\n    position: TAccountMetas[2];\n    positionTokenAccount: TAccountMetas[3];\n    tokenOwnerAccountA: TAccountMetas[4];\n    tokenVaultA: TAccountMetas[5];\n    tokenOwnerAccountB: TAccountMetas[6];\n    tokenVaultB: TAccountMetas[7];\n    tokenProgram: TAccountMetas[8];\n  };\n  data: CollectFeesInstructionData;\n};\n\nexport function parseCollectFeesInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedCollectFeesInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 9) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpool: getNextAccount(),\n      positionAuthority: getNextAccount(),\n      position: getNextAccount(),\n      positionTokenAccount: getNextAccount(),\n      tokenOwnerAccountA: getNextAccount(),\n      tokenVaultA: getNextAccount(),\n      tokenOwnerAccountB: getNextAccount(),\n      tokenVaultB: getNextAccount(),\n      tokenProgram: getNextAccount(),\n    },\n    data: getCollectFeesInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getRemainingAccountsInfoDecoder,\n  getRemainingAccountsInfoEncoder,\n  type RemainingAccountsInfo,\n  type RemainingAccountsInfoArgs,\n} from '../types';\n\nexport const COLLECT_FEES_V2_DISCRIMINATOR = new Uint8Array([\n  207, 117, 95, 191, 229, 180, 226, 15,\n]);\n\nexport function getCollectFeesV2DiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    COLLECT_FEES_V2_DISCRIMINATOR\n  );\n}\n\nexport type CollectFeesV2Instruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountPositionAuthority extends string | IAccountMeta<string> = string,\n  TAccountPosition extends string | IAccountMeta<string> = string,\n  TAccountPositionTokenAccount extends string | IAccountMeta<string> = string,\n  TAccountTokenMintA extends string | IAccountMeta<string> = string,\n  TAccountTokenMintB extends string | IAccountMeta<string> = string,\n  TAccountTokenOwnerAccountA extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultA extends string | IAccountMeta<string> = string,\n  TAccountTokenOwnerAccountB extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultB extends string | IAccountMeta<string> = string,\n  TAccountTokenProgramA extends string | IAccountMeta<string> = string,\n  TAccountTokenProgramB extends string | IAccountMeta<string> = string,\n  TAccountMemoProgram extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpool extends string\n        ? ReadonlyAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountPositionAuthority extends string\n        ? ReadonlySignerAccount<TAccountPositionAuthority> &\n            IAccountSignerMeta<TAccountPositionAuthority>\n        : TAccountPositionAuthority,\n      TAccountPosition extends string\n        ? WritableAccount<TAccountPosition>\n        : TAccountPosition,\n      TAccountPositionTokenAccount extends string\n        ? ReadonlyAccount<TAccountPositionTokenAccount>\n        : TAccountPositionTokenAccount,\n      TAccountTokenMintA extends string\n        ? ReadonlyAccount<TAccountTokenMintA>\n        : TAccountTokenMintA,\n      TAccountTokenMintB extends string\n        ? ReadonlyAccount<TAccountTokenMintB>\n        : TAccountTokenMintB,\n      TAccountTokenOwnerAccountA extends string\n        ? WritableAccount<TAccountTokenOwnerAccountA>\n        : TAccountTokenOwnerAccountA,\n      TAccountTokenVaultA extends string\n        ? WritableAccount<TAccountTokenVaultA>\n        : TAccountTokenVaultA,\n      TAccountTokenOwnerAccountB extends string\n        ? WritableAccount<TAccountTokenOwnerAccountB>\n        : TAccountTokenOwnerAccountB,\n      TAccountTokenVaultB extends string\n        ? WritableAccount<TAccountTokenVaultB>\n        : TAccountTokenVaultB,\n      TAccountTokenProgramA extends string\n        ? ReadonlyAccount<TAccountTokenProgramA>\n        : TAccountTokenProgramA,\n      TAccountTokenProgramB extends string\n        ? ReadonlyAccount<TAccountTokenProgramB>\n        : TAccountTokenProgramB,\n      TAccountMemoProgram extends string\n        ? ReadonlyAccount<TAccountMemoProgram>\n        : TAccountMemoProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CollectFeesV2InstructionData = {\n  discriminator: ReadonlyUint8Array;\n  remainingAccountsInfo: Option<RemainingAccountsInfo>;\n};\n\nexport type CollectFeesV2InstructionDataArgs = {\n  remainingAccountsInfo: OptionOrNullable<RemainingAccountsInfoArgs>;\n};\n\nexport function getCollectFeesV2InstructionDataEncoder(): Encoder<CollectFeesV2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      [\n        'remainingAccountsInfo',\n        getOptionEncoder(getRemainingAccountsInfoEncoder()),\n      ],\n    ]),\n    (value) => ({ ...value, discriminator: COLLECT_FEES_V2_DISCRIMINATOR })\n  );\n}\n\nexport function getCollectFeesV2InstructionDataDecoder(): Decoder<CollectFeesV2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    [\n      'remainingAccountsInfo',\n      getOptionDecoder(getRemainingAccountsInfoDecoder()),\n    ],\n  ]);\n}\n\nexport function getCollectFeesV2InstructionDataCodec(): Codec<\n  CollectFeesV2InstructionDataArgs,\n  CollectFeesV2InstructionData\n> {\n  return combineCodec(\n    getCollectFeesV2InstructionDataEncoder(),\n    getCollectFeesV2InstructionDataDecoder()\n  );\n}\n\nexport type CollectFeesV2Input<\n  TAccountWhirlpool extends string = string,\n  TAccountPositionAuthority extends string = string,\n  TAccountPosition extends string = string,\n  TAccountPositionTokenAccount extends string = string,\n  TAccountTokenMintA extends string = string,\n  TAccountTokenMintB extends string = string,\n  TAccountTokenOwnerAccountA extends string = string,\n  TAccountTokenVaultA extends string = string,\n  TAccountTokenOwnerAccountB extends string = string,\n  TAccountTokenVaultB extends string = string,\n  TAccountTokenProgramA extends string = string,\n  TAccountTokenProgramB extends string = string,\n  TAccountMemoProgram extends string = string,\n> = {\n  whirlpool: Address<TAccountWhirlpool>;\n  positionAuthority: TransactionSigner<TAccountPositionAuthority>;\n  position: Address<TAccountPosition>;\n  positionTokenAccount: Address<TAccountPositionTokenAccount>;\n  tokenMintA: Address<TAccountTokenMintA>;\n  tokenMintB: Address<TAccountTokenMintB>;\n  tokenOwnerAccountA: Address<TAccountTokenOwnerAccountA>;\n  tokenVaultA: Address<TAccountTokenVaultA>;\n  tokenOwnerAccountB: Address<TAccountTokenOwnerAccountB>;\n  tokenVaultB: Address<TAccountTokenVaultB>;\n  tokenProgramA: Address<TAccountTokenProgramA>;\n  tokenProgramB: Address<TAccountTokenProgramB>;\n  memoProgram: Address<TAccountMemoProgram>;\n  remainingAccountsInfo: CollectFeesV2InstructionDataArgs['remainingAccountsInfo'];\n};\n\nexport function getCollectFeesV2Instruction<\n  TAccountWhirlpool extends string,\n  TAccountPositionAuthority extends string,\n  TAccountPosition extends string,\n  TAccountPositionTokenAccount extends string,\n  TAccountTokenMintA extends string,\n  TAccountTokenMintB extends string,\n  TAccountTokenOwnerAccountA extends string,\n  TAccountTokenVaultA extends string,\n  TAccountTokenOwnerAccountB extends string,\n  TAccountTokenVaultB extends string,\n  TAccountTokenProgramA extends string,\n  TAccountTokenProgramB extends string,\n  TAccountMemoProgram extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: CollectFeesV2Input<\n    TAccountWhirlpool,\n    TAccountPositionAuthority,\n    TAccountPosition,\n    TAccountPositionTokenAccount,\n    TAccountTokenMintA,\n    TAccountTokenMintB,\n    TAccountTokenOwnerAccountA,\n    TAccountTokenVaultA,\n    TAccountTokenOwnerAccountB,\n    TAccountTokenVaultB,\n    TAccountTokenProgramA,\n    TAccountTokenProgramB,\n    TAccountMemoProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CollectFeesV2Instruction<\n  TProgramAddress,\n  TAccountWhirlpool,\n  TAccountPositionAuthority,\n  TAccountPosition,\n  TAccountPositionTokenAccount,\n  TAccountTokenMintA,\n  TAccountTokenMintB,\n  TAccountTokenOwnerAccountA,\n  TAccountTokenVaultA,\n  TAccountTokenOwnerAccountB,\n  TAccountTokenVaultB,\n  TAccountTokenProgramA,\n  TAccountTokenProgramB,\n  TAccountMemoProgram\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpool: { value: input.whirlpool ?? null, isWritable: false },\n    positionAuthority: {\n      value: input.positionAuthority ?? null,\n      isWritable: false,\n    },\n    position: { value: input.position ?? null, isWritable: true },\n    positionTokenAccount: {\n      value: input.positionTokenAccount ?? null,\n      isWritable: false,\n    },\n    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },\n    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },\n    tokenOwnerAccountA: {\n      value: input.tokenOwnerAccountA ?? null,\n      isWritable: true,\n    },\n    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },\n    tokenOwnerAccountB: {\n      value: input.tokenOwnerAccountB ?? null,\n      isWritable: true,\n    },\n    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },\n    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },\n    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },\n    memoProgram: { value: input.memoProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.positionAuthority),\n      getAccountMeta(accounts.position),\n      getAccountMeta(accounts.positionTokenAccount),\n      getAccountMeta(accounts.tokenMintA),\n      getAccountMeta(accounts.tokenMintB),\n      getAccountMeta(accounts.tokenOwnerAccountA),\n      getAccountMeta(accounts.tokenVaultA),\n      getAccountMeta(accounts.tokenOwnerAccountB),\n      getAccountMeta(accounts.tokenVaultB),\n      getAccountMeta(accounts.tokenProgramA),\n      getAccountMeta(accounts.tokenProgramB),\n      getAccountMeta(accounts.memoProgram),\n    ],\n    programAddress,\n    data: getCollectFeesV2InstructionDataEncoder().encode(\n      args as CollectFeesV2InstructionDataArgs\n    ),\n  } as CollectFeesV2Instruction<\n    TProgramAddress,\n    TAccountWhirlpool,\n    TAccountPositionAuthority,\n    TAccountPosition,\n    TAccountPositionTokenAccount,\n    TAccountTokenMintA,\n    TAccountTokenMintB,\n    TAccountTokenOwnerAccountA,\n    TAccountTokenVaultA,\n    TAccountTokenOwnerAccountB,\n    TAccountTokenVaultB,\n    TAccountTokenProgramA,\n    TAccountTokenProgramB,\n    TAccountMemoProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCollectFeesV2Instruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpool: TAccountMetas[0];\n    positionAuthority: TAccountMetas[1];\n    position: TAccountMetas[2];\n    positionTokenAccount: TAccountMetas[3];\n    tokenMintA: TAccountMetas[4];\n    tokenMintB: TAccountMetas[5];\n    tokenOwnerAccountA: TAccountMetas[6];\n    tokenVaultA: TAccountMetas[7];\n    tokenOwnerAccountB: TAccountMetas[8];\n    tokenVaultB: TAccountMetas[9];\n    tokenProgramA: TAccountMetas[10];\n    tokenProgramB: TAccountMetas[11];\n    memoProgram: TAccountMetas[12];\n  };\n  data: CollectFeesV2InstructionData;\n};\n\nexport function parseCollectFeesV2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedCollectFeesV2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 13) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpool: getNextAccount(),\n      positionAuthority: getNextAccount(),\n      position: getNextAccount(),\n      positionTokenAccount: getNextAccount(),\n      tokenMintA: getNextAccount(),\n      tokenMintB: getNextAccount(),\n      tokenOwnerAccountA: getNextAccount(),\n      tokenVaultA: getNextAccount(),\n      tokenOwnerAccountB: getNextAccount(),\n      tokenVaultB: getNextAccount(),\n      tokenProgramA: getNextAccount(),\n      tokenProgramB: getNextAccount(),\n      memoProgram: getNextAccount(),\n    },\n    data: getCollectFeesV2InstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const COLLECT_PROTOCOL_FEES_DISCRIMINATOR = new Uint8Array([\n  22, 67, 23, 98, 150, 178, 70, 220,\n]);\n\nexport function getCollectProtocolFeesDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    COLLECT_PROTOCOL_FEES_DISCRIMINATOR\n  );\n}\n\nexport type CollectProtocolFeesInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpoolsConfig extends string | IAccountMeta<string> = string,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountCollectProtocolFeesAuthority extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountTokenVaultA extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultB extends string | IAccountMeta<string> = string,\n  TAccountTokenDestinationA extends string | IAccountMeta<string> = string,\n  TAccountTokenDestinationB extends string | IAccountMeta<string> = string,\n  TAccountTokenProgram extends\n    | string\n    | IAccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpoolsConfig extends string\n        ? ReadonlyAccount<TAccountWhirlpoolsConfig>\n        : TAccountWhirlpoolsConfig,\n      TAccountWhirlpool extends string\n        ? WritableAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountCollectProtocolFeesAuthority extends string\n        ? ReadonlySignerAccount<TAccountCollectProtocolFeesAuthority> &\n            IAccountSignerMeta<TAccountCollectProtocolFeesAuthority>\n        : TAccountCollectProtocolFeesAuthority,\n      TAccountTokenVaultA extends string\n        ? WritableAccount<TAccountTokenVaultA>\n        : TAccountTokenVaultA,\n      TAccountTokenVaultB extends string\n        ? WritableAccount<TAccountTokenVaultB>\n        : TAccountTokenVaultB,\n      TAccountTokenDestinationA extends string\n        ? WritableAccount<TAccountTokenDestinationA>\n        : TAccountTokenDestinationA,\n      TAccountTokenDestinationB extends string\n        ? WritableAccount<TAccountTokenDestinationB>\n        : TAccountTokenDestinationB,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CollectProtocolFeesInstructionData = {\n  discriminator: ReadonlyUint8Array;\n};\n\nexport type CollectProtocolFeesInstructionDataArgs = {};\n\nexport function getCollectProtocolFeesInstructionDataEncoder(): Encoder<CollectProtocolFeesInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]),\n    (value) => ({\n      ...value,\n      discriminator: COLLECT_PROTOCOL_FEES_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getCollectProtocolFeesInstructionDataDecoder(): Decoder<CollectProtocolFeesInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n  ]);\n}\n\nexport function getCollectProtocolFeesInstructionDataCodec(): Codec<\n  CollectProtocolFeesInstructionDataArgs,\n  CollectProtocolFeesInstructionData\n> {\n  return combineCodec(\n    getCollectProtocolFeesInstructionDataEncoder(),\n    getCollectProtocolFeesInstructionDataDecoder()\n  );\n}\n\nexport type CollectProtocolFeesInput<\n  TAccountWhirlpoolsConfig extends string = string,\n  TAccountWhirlpool extends string = string,\n  TAccountCollectProtocolFeesAuthority extends string = string,\n  TAccountTokenVaultA extends string = string,\n  TAccountTokenVaultB extends string = string,\n  TAccountTokenDestinationA extends string = string,\n  TAccountTokenDestinationB extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  whirlpoolsConfig: Address<TAccountWhirlpoolsConfig>;\n  whirlpool: Address<TAccountWhirlpool>;\n  collectProtocolFeesAuthority: TransactionSigner<TAccountCollectProtocolFeesAuthority>;\n  tokenVaultA: Address<TAccountTokenVaultA>;\n  tokenVaultB: Address<TAccountTokenVaultB>;\n  tokenDestinationA: Address<TAccountTokenDestinationA>;\n  tokenDestinationB: Address<TAccountTokenDestinationB>;\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport function getCollectProtocolFeesInstruction<\n  TAccountWhirlpoolsConfig extends string,\n  TAccountWhirlpool extends string,\n  TAccountCollectProtocolFeesAuthority extends string,\n  TAccountTokenVaultA extends string,\n  TAccountTokenVaultB extends string,\n  TAccountTokenDestinationA extends string,\n  TAccountTokenDestinationB extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: CollectProtocolFeesInput<\n    TAccountWhirlpoolsConfig,\n    TAccountWhirlpool,\n    TAccountCollectProtocolFeesAuthority,\n    TAccountTokenVaultA,\n    TAccountTokenVaultB,\n    TAccountTokenDestinationA,\n    TAccountTokenDestinationB,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CollectProtocolFeesInstruction<\n  TProgramAddress,\n  TAccountWhirlpoolsConfig,\n  TAccountWhirlpool,\n  TAccountCollectProtocolFeesAuthority,\n  TAccountTokenVaultA,\n  TAccountTokenVaultB,\n  TAccountTokenDestinationA,\n  TAccountTokenDestinationB,\n  TAccountTokenProgram\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpoolsConfig: {\n      value: input.whirlpoolsConfig ?? null,\n      isWritable: false,\n    },\n    whirlpool: { value: input.whirlpool ?? null, isWritable: true },\n    collectProtocolFeesAuthority: {\n      value: input.collectProtocolFeesAuthority ?? null,\n      isWritable: false,\n    },\n    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },\n    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },\n    tokenDestinationA: {\n      value: input.tokenDestinationA ?? null,\n      isWritable: true,\n    },\n    tokenDestinationB: {\n      value: input.tokenDestinationB ?? null,\n      isWritable: true,\n    },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpoolsConfig),\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.collectProtocolFeesAuthority),\n      getAccountMeta(accounts.tokenVaultA),\n      getAccountMeta(accounts.tokenVaultB),\n      getAccountMeta(accounts.tokenDestinationA),\n      getAccountMeta(accounts.tokenDestinationB),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getCollectProtocolFeesInstructionDataEncoder().encode({}),\n  } as CollectProtocolFeesInstruction<\n    TProgramAddress,\n    TAccountWhirlpoolsConfig,\n    TAccountWhirlpool,\n    TAccountCollectProtocolFeesAuthority,\n    TAccountTokenVaultA,\n    TAccountTokenVaultB,\n    TAccountTokenDestinationA,\n    TAccountTokenDestinationB,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCollectProtocolFeesInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpoolsConfig: TAccountMetas[0];\n    whirlpool: TAccountMetas[1];\n    collectProtocolFeesAuthority: TAccountMetas[2];\n    tokenVaultA: TAccountMetas[3];\n    tokenVaultB: TAccountMetas[4];\n    tokenDestinationA: TAccountMetas[5];\n    tokenDestinationB: TAccountMetas[6];\n    tokenProgram: TAccountMetas[7];\n  };\n  data: CollectProtocolFeesInstructionData;\n};\n\nexport function parseCollectProtocolFeesInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedCollectProtocolFeesInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 8) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpoolsConfig: getNextAccount(),\n      whirlpool: getNextAccount(),\n      collectProtocolFeesAuthority: getNextAccount(),\n      tokenVaultA: getNextAccount(),\n      tokenVaultB: getNextAccount(),\n      tokenDestinationA: getNextAccount(),\n      tokenDestinationB: getNextAccount(),\n      tokenProgram: getNextAccount(),\n    },\n    data: getCollectProtocolFeesInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getRemainingAccountsInfoDecoder,\n  getRemainingAccountsInfoEncoder,\n  type RemainingAccountsInfo,\n  type RemainingAccountsInfoArgs,\n} from '../types';\n\nexport const COLLECT_PROTOCOL_FEES_V2_DISCRIMINATOR = new Uint8Array([\n  103, 128, 222, 134, 114, 200, 22, 200,\n]);\n\nexport function getCollectProtocolFeesV2DiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    COLLECT_PROTOCOL_FEES_V2_DISCRIMINATOR\n  );\n}\n\nexport type CollectProtocolFeesV2Instruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpoolsConfig extends string | IAccountMeta<string> = string,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountCollectProtocolFeesAuthority extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountTokenMintA extends string | IAccountMeta<string> = string,\n  TAccountTokenMintB extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultA extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultB extends string | IAccountMeta<string> = string,\n  TAccountTokenDestinationA extends string | IAccountMeta<string> = string,\n  TAccountTokenDestinationB extends string | IAccountMeta<string> = string,\n  TAccountTokenProgramA extends string | IAccountMeta<string> = string,\n  TAccountTokenProgramB extends string | IAccountMeta<string> = string,\n  TAccountMemoProgram extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpoolsConfig extends string\n        ? ReadonlyAccount<TAccountWhirlpoolsConfig>\n        : TAccountWhirlpoolsConfig,\n      TAccountWhirlpool extends string\n        ? WritableAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountCollectProtocolFeesAuthority extends string\n        ? ReadonlySignerAccount<TAccountCollectProtocolFeesAuthority> &\n            IAccountSignerMeta<TAccountCollectProtocolFeesAuthority>\n        : TAccountCollectProtocolFeesAuthority,\n      TAccountTokenMintA extends string\n        ? ReadonlyAccount<TAccountTokenMintA>\n        : TAccountTokenMintA,\n      TAccountTokenMintB extends string\n        ? ReadonlyAccount<TAccountTokenMintB>\n        : TAccountTokenMintB,\n      TAccountTokenVaultA extends string\n        ? WritableAccount<TAccountTokenVaultA>\n        : TAccountTokenVaultA,\n      TAccountTokenVaultB extends string\n        ? WritableAccount<TAccountTokenVaultB>\n        : TAccountTokenVaultB,\n      TAccountTokenDestinationA extends string\n        ? WritableAccount<TAccountTokenDestinationA>\n        : TAccountTokenDestinationA,\n      TAccountTokenDestinationB extends string\n        ? WritableAccount<TAccountTokenDestinationB>\n        : TAccountTokenDestinationB,\n      TAccountTokenProgramA extends string\n        ? ReadonlyAccount<TAccountTokenProgramA>\n        : TAccountTokenProgramA,\n      TAccountTokenProgramB extends string\n        ? ReadonlyAccount<TAccountTokenProgramB>\n        : TAccountTokenProgramB,\n      TAccountMemoProgram extends string\n        ? ReadonlyAccount<TAccountMemoProgram>\n        : TAccountMemoProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CollectProtocolFeesV2InstructionData = {\n  discriminator: ReadonlyUint8Array;\n  remainingAccountsInfo: Option<RemainingAccountsInfo>;\n};\n\nexport type CollectProtocolFeesV2InstructionDataArgs = {\n  remainingAccountsInfo: OptionOrNullable<RemainingAccountsInfoArgs>;\n};\n\nexport function getCollectProtocolFeesV2InstructionDataEncoder(): Encoder<CollectProtocolFeesV2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      [\n        'remainingAccountsInfo',\n        getOptionEncoder(getRemainingAccountsInfoEncoder()),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: COLLECT_PROTOCOL_FEES_V2_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getCollectProtocolFeesV2InstructionDataDecoder(): Decoder<CollectProtocolFeesV2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    [\n      'remainingAccountsInfo',\n      getOptionDecoder(getRemainingAccountsInfoDecoder()),\n    ],\n  ]);\n}\n\nexport function getCollectProtocolFeesV2InstructionDataCodec(): Codec<\n  CollectProtocolFeesV2InstructionDataArgs,\n  CollectProtocolFeesV2InstructionData\n> {\n  return combineCodec(\n    getCollectProtocolFeesV2InstructionDataEncoder(),\n    getCollectProtocolFeesV2InstructionDataDecoder()\n  );\n}\n\nexport type CollectProtocolFeesV2Input<\n  TAccountWhirlpoolsConfig extends string = string,\n  TAccountWhirlpool extends string = string,\n  TAccountCollectProtocolFeesAuthority extends string = string,\n  TAccountTokenMintA extends string = string,\n  TAccountTokenMintB extends string = string,\n  TAccountTokenVaultA extends string = string,\n  TAccountTokenVaultB extends string = string,\n  TAccountTokenDestinationA extends string = string,\n  TAccountTokenDestinationB extends string = string,\n  TAccountTokenProgramA extends string = string,\n  TAccountTokenProgramB extends string = string,\n  TAccountMemoProgram extends string = string,\n> = {\n  whirlpoolsConfig: Address<TAccountWhirlpoolsConfig>;\n  whirlpool: Address<TAccountWhirlpool>;\n  collectProtocolFeesAuthority: TransactionSigner<TAccountCollectProtocolFeesAuthority>;\n  tokenMintA: Address<TAccountTokenMintA>;\n  tokenMintB: Address<TAccountTokenMintB>;\n  tokenVaultA: Address<TAccountTokenVaultA>;\n  tokenVaultB: Address<TAccountTokenVaultB>;\n  tokenDestinationA: Address<TAccountTokenDestinationA>;\n  tokenDestinationB: Address<TAccountTokenDestinationB>;\n  tokenProgramA: Address<TAccountTokenProgramA>;\n  tokenProgramB: Address<TAccountTokenProgramB>;\n  memoProgram: Address<TAccountMemoProgram>;\n  remainingAccountsInfo: CollectProtocolFeesV2InstructionDataArgs['remainingAccountsInfo'];\n};\n\nexport function getCollectProtocolFeesV2Instruction<\n  TAccountWhirlpoolsConfig extends string,\n  TAccountWhirlpool extends string,\n  TAccountCollectProtocolFeesAuthority extends string,\n  TAccountTokenMintA extends string,\n  TAccountTokenMintB extends string,\n  TAccountTokenVaultA extends string,\n  TAccountTokenVaultB extends string,\n  TAccountTokenDestinationA extends string,\n  TAccountTokenDestinationB extends string,\n  TAccountTokenProgramA extends string,\n  TAccountTokenProgramB extends string,\n  TAccountMemoProgram extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: CollectProtocolFeesV2Input<\n    TAccountWhirlpoolsConfig,\n    TAccountWhirlpool,\n    TAccountCollectProtocolFeesAuthority,\n    TAccountTokenMintA,\n    TAccountTokenMintB,\n    TAccountTokenVaultA,\n    TAccountTokenVaultB,\n    TAccountTokenDestinationA,\n    TAccountTokenDestinationB,\n    TAccountTokenProgramA,\n    TAccountTokenProgramB,\n    TAccountMemoProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CollectProtocolFeesV2Instruction<\n  TProgramAddress,\n  TAccountWhirlpoolsConfig,\n  TAccountWhirlpool,\n  TAccountCollectProtocolFeesAuthority,\n  TAccountTokenMintA,\n  TAccountTokenMintB,\n  TAccountTokenVaultA,\n  TAccountTokenVaultB,\n  TAccountTokenDestinationA,\n  TAccountTokenDestinationB,\n  TAccountTokenProgramA,\n  TAccountTokenProgramB,\n  TAccountMemoProgram\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpoolsConfig: {\n      value: input.whirlpoolsConfig ?? null,\n      isWritable: false,\n    },\n    whirlpool: { value: input.whirlpool ?? null, isWritable: true },\n    collectProtocolFeesAuthority: {\n      value: input.collectProtocolFeesAuthority ?? null,\n      isWritable: false,\n    },\n    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },\n    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },\n    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },\n    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },\n    tokenDestinationA: {\n      value: input.tokenDestinationA ?? null,\n      isWritable: true,\n    },\n    tokenDestinationB: {\n      value: input.tokenDestinationB ?? null,\n      isWritable: true,\n    },\n    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },\n    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },\n    memoProgram: { value: input.memoProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpoolsConfig),\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.collectProtocolFeesAuthority),\n      getAccountMeta(accounts.tokenMintA),\n      getAccountMeta(accounts.tokenMintB),\n      getAccountMeta(accounts.tokenVaultA),\n      getAccountMeta(accounts.tokenVaultB),\n      getAccountMeta(accounts.tokenDestinationA),\n      getAccountMeta(accounts.tokenDestinationB),\n      getAccountMeta(accounts.tokenProgramA),\n      getAccountMeta(accounts.tokenProgramB),\n      getAccountMeta(accounts.memoProgram),\n    ],\n    programAddress,\n    data: getCollectProtocolFeesV2InstructionDataEncoder().encode(\n      args as CollectProtocolFeesV2InstructionDataArgs\n    ),\n  } as CollectProtocolFeesV2Instruction<\n    TProgramAddress,\n    TAccountWhirlpoolsConfig,\n    TAccountWhirlpool,\n    TAccountCollectProtocolFeesAuthority,\n    TAccountTokenMintA,\n    TAccountTokenMintB,\n    TAccountTokenVaultA,\n    TAccountTokenVaultB,\n    TAccountTokenDestinationA,\n    TAccountTokenDestinationB,\n    TAccountTokenProgramA,\n    TAccountTokenProgramB,\n    TAccountMemoProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCollectProtocolFeesV2Instruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpoolsConfig: TAccountMetas[0];\n    whirlpool: TAccountMetas[1];\n    collectProtocolFeesAuthority: TAccountMetas[2];\n    tokenMintA: TAccountMetas[3];\n    tokenMintB: TAccountMetas[4];\n    tokenVaultA: TAccountMetas[5];\n    tokenVaultB: TAccountMetas[6];\n    tokenDestinationA: TAccountMetas[7];\n    tokenDestinationB: TAccountMetas[8];\n    tokenProgramA: TAccountMetas[9];\n    tokenProgramB: TAccountMetas[10];\n    memoProgram: TAccountMetas[11];\n  };\n  data: CollectProtocolFeesV2InstructionData;\n};\n\nexport function parseCollectProtocolFeesV2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedCollectProtocolFeesV2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 12) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpoolsConfig: getNextAccount(),\n      whirlpool: getNextAccount(),\n      collectProtocolFeesAuthority: getNextAccount(),\n      tokenMintA: getNextAccount(),\n      tokenMintB: getNextAccount(),\n      tokenVaultA: getNextAccount(),\n      tokenVaultB: getNextAccount(),\n      tokenDestinationA: getNextAccount(),\n      tokenDestinationB: getNextAccount(),\n      tokenProgramA: getNextAccount(),\n      tokenProgramB: getNextAccount(),\n      memoProgram: getNextAccount(),\n    },\n    data: getCollectProtocolFeesV2InstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const COLLECT_REWARD_DISCRIMINATOR = new Uint8Array([\n  70, 5, 132, 87, 86, 235, 177, 34,\n]);\n\nexport function getCollectRewardDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    COLLECT_REWARD_DISCRIMINATOR\n  );\n}\n\nexport type CollectRewardInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountPositionAuthority extends string | IAccountMeta<string> = string,\n  TAccountPosition extends string | IAccountMeta<string> = string,\n  TAccountPositionTokenAccount extends string | IAccountMeta<string> = string,\n  TAccountRewardOwnerAccount extends string | IAccountMeta<string> = string,\n  TAccountRewardVault extends string | IAccountMeta<string> = string,\n  TAccountTokenProgram extends\n    | string\n    | IAccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpool extends string\n        ? ReadonlyAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountPositionAuthority extends string\n        ? ReadonlySignerAccount<TAccountPositionAuthority> &\n            IAccountSignerMeta<TAccountPositionAuthority>\n        : TAccountPositionAuthority,\n      TAccountPosition extends string\n        ? WritableAccount<TAccountPosition>\n        : TAccountPosition,\n      TAccountPositionTokenAccount extends string\n        ? ReadonlyAccount<TAccountPositionTokenAccount>\n        : TAccountPositionTokenAccount,\n      TAccountRewardOwnerAccount extends string\n        ? WritableAccount<TAccountRewardOwnerAccount>\n        : TAccountRewardOwnerAccount,\n      TAccountRewardVault extends string\n        ? WritableAccount<TAccountRewardVault>\n        : TAccountRewardVault,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CollectRewardInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  rewardIndex: number;\n};\n\nexport type CollectRewardInstructionDataArgs = { rewardIndex: number };\n\nexport function getCollectRewardInstructionDataEncoder(): Encoder<CollectRewardInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['rewardIndex', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: COLLECT_REWARD_DISCRIMINATOR })\n  );\n}\n\nexport function getCollectRewardInstructionDataDecoder(): Decoder<CollectRewardInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['rewardIndex', getU8Decoder()],\n  ]);\n}\n\nexport function getCollectRewardInstructionDataCodec(): Codec<\n  CollectRewardInstructionDataArgs,\n  CollectRewardInstructionData\n> {\n  return combineCodec(\n    getCollectRewardInstructionDataEncoder(),\n    getCollectRewardInstructionDataDecoder()\n  );\n}\n\nexport type CollectRewardInput<\n  TAccountWhirlpool extends string = string,\n  TAccountPositionAuthority extends string = string,\n  TAccountPosition extends string = string,\n  TAccountPositionTokenAccount extends string = string,\n  TAccountRewardOwnerAccount extends string = string,\n  TAccountRewardVault extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  whirlpool: Address<TAccountWhirlpool>;\n  positionAuthority: TransactionSigner<TAccountPositionAuthority>;\n  position: Address<TAccountPosition>;\n  positionTokenAccount: Address<TAccountPositionTokenAccount>;\n  rewardOwnerAccount: Address<TAccountRewardOwnerAccount>;\n  rewardVault: Address<TAccountRewardVault>;\n  tokenProgram?: Address<TAccountTokenProgram>;\n  rewardIndex: CollectRewardInstructionDataArgs['rewardIndex'];\n};\n\nexport function getCollectRewardInstruction<\n  TAccountWhirlpool extends string,\n  TAccountPositionAuthority extends string,\n  TAccountPosition extends string,\n  TAccountPositionTokenAccount extends string,\n  TAccountRewardOwnerAccount extends string,\n  TAccountRewardVault extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: CollectRewardInput<\n    TAccountWhirlpool,\n    TAccountPositionAuthority,\n    TAccountPosition,\n    TAccountPositionTokenAccount,\n    TAccountRewardOwnerAccount,\n    TAccountRewardVault,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CollectRewardInstruction<\n  TProgramAddress,\n  TAccountWhirlpool,\n  TAccountPositionAuthority,\n  TAccountPosition,\n  TAccountPositionTokenAccount,\n  TAccountRewardOwnerAccount,\n  TAccountRewardVault,\n  TAccountTokenProgram\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpool: { value: input.whirlpool ?? null, isWritable: false },\n    positionAuthority: {\n      value: input.positionAuthority ?? null,\n      isWritable: false,\n    },\n    position: { value: input.position ?? null, isWritable: true },\n    positionTokenAccount: {\n      value: input.positionTokenAccount ?? null,\n      isWritable: false,\n    },\n    rewardOwnerAccount: {\n      value: input.rewardOwnerAccount ?? null,\n      isWritable: true,\n    },\n    rewardVault: { value: input.rewardVault ?? null, isWritable: true },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.positionAuthority),\n      getAccountMeta(accounts.position),\n      getAccountMeta(accounts.positionTokenAccount),\n      getAccountMeta(accounts.rewardOwnerAccount),\n      getAccountMeta(accounts.rewardVault),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getCollectRewardInstructionDataEncoder().encode(\n      args as CollectRewardInstructionDataArgs\n    ),\n  } as CollectRewardInstruction<\n    TProgramAddress,\n    TAccountWhirlpool,\n    TAccountPositionAuthority,\n    TAccountPosition,\n    TAccountPositionTokenAccount,\n    TAccountRewardOwnerAccount,\n    TAccountRewardVault,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCollectRewardInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpool: TAccountMetas[0];\n    positionAuthority: TAccountMetas[1];\n    position: TAccountMetas[2];\n    positionTokenAccount: TAccountMetas[3];\n    rewardOwnerAccount: TAccountMetas[4];\n    rewardVault: TAccountMetas[5];\n    tokenProgram: TAccountMetas[6];\n  };\n  data: CollectRewardInstructionData;\n};\n\nexport function parseCollectRewardInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedCollectRewardInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 7) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpool: getNextAccount(),\n      positionAuthority: getNextAccount(),\n      position: getNextAccount(),\n      positionTokenAccount: getNextAccount(),\n      rewardOwnerAccount: getNextAccount(),\n      rewardVault: getNextAccount(),\n      tokenProgram: getNextAccount(),\n    },\n    data: getCollectRewardInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getRemainingAccountsInfoDecoder,\n  getRemainingAccountsInfoEncoder,\n  type RemainingAccountsInfo,\n  type RemainingAccountsInfoArgs,\n} from '../types';\n\nexport const COLLECT_REWARD_V2_DISCRIMINATOR = new Uint8Array([\n  177, 107, 37, 180, 160, 19, 49, 209,\n]);\n\nexport function getCollectRewardV2DiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    COLLECT_REWARD_V2_DISCRIMINATOR\n  );\n}\n\nexport type CollectRewardV2Instruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountPositionAuthority extends string | IAccountMeta<string> = string,\n  TAccountPosition extends string | IAccountMeta<string> = string,\n  TAccountPositionTokenAccount extends string | IAccountMeta<string> = string,\n  TAccountRewardOwnerAccount extends string | IAccountMeta<string> = string,\n  TAccountRewardMint extends string | IAccountMeta<string> = string,\n  TAccountRewardVault extends string | IAccountMeta<string> = string,\n  TAccountRewardTokenProgram extends string | IAccountMeta<string> = string,\n  TAccountMemoProgram extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpool extends string\n        ? ReadonlyAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountPositionAuthority extends string\n        ? ReadonlySignerAccount<TAccountPositionAuthority> &\n            IAccountSignerMeta<TAccountPositionAuthority>\n        : TAccountPositionAuthority,\n      TAccountPosition extends string\n        ? WritableAccount<TAccountPosition>\n        : TAccountPosition,\n      TAccountPositionTokenAccount extends string\n        ? ReadonlyAccount<TAccountPositionTokenAccount>\n        : TAccountPositionTokenAccount,\n      TAccountRewardOwnerAccount extends string\n        ? WritableAccount<TAccountRewardOwnerAccount>\n        : TAccountRewardOwnerAccount,\n      TAccountRewardMint extends string\n        ? ReadonlyAccount<TAccountRewardMint>\n        : TAccountRewardMint,\n      TAccountRewardVault extends string\n        ? WritableAccount<TAccountRewardVault>\n        : TAccountRewardVault,\n      TAccountRewardTokenProgram extends string\n        ? ReadonlyAccount<TAccountRewardTokenProgram>\n        : TAccountRewardTokenProgram,\n      TAccountMemoProgram extends string\n        ? ReadonlyAccount<TAccountMemoProgram>\n        : TAccountMemoProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CollectRewardV2InstructionData = {\n  discriminator: ReadonlyUint8Array;\n  rewardIndex: number;\n  remainingAccountsInfo: Option<RemainingAccountsInfo>;\n};\n\nexport type CollectRewardV2InstructionDataArgs = {\n  rewardIndex: number;\n  remainingAccountsInfo: OptionOrNullable<RemainingAccountsInfoArgs>;\n};\n\nexport function getCollectRewardV2InstructionDataEncoder(): Encoder<CollectRewardV2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['rewardIndex', getU8Encoder()],\n      [\n        'remainingAccountsInfo',\n        getOptionEncoder(getRemainingAccountsInfoEncoder()),\n      ],\n    ]),\n    (value) => ({ ...value, discriminator: COLLECT_REWARD_V2_DISCRIMINATOR })\n  );\n}\n\nexport function getCollectRewardV2InstructionDataDecoder(): Decoder<CollectRewardV2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['rewardIndex', getU8Decoder()],\n    [\n      'remainingAccountsInfo',\n      getOptionDecoder(getRemainingAccountsInfoDecoder()),\n    ],\n  ]);\n}\n\nexport function getCollectRewardV2InstructionDataCodec(): Codec<\n  CollectRewardV2InstructionDataArgs,\n  CollectRewardV2InstructionData\n> {\n  return combineCodec(\n    getCollectRewardV2InstructionDataEncoder(),\n    getCollectRewardV2InstructionDataDecoder()\n  );\n}\n\nexport type CollectRewardV2Input<\n  TAccountWhirlpool extends string = string,\n  TAccountPositionAuthority extends string = string,\n  TAccountPosition extends string = string,\n  TAccountPositionTokenAccount extends string = string,\n  TAccountRewardOwnerAccount extends string = string,\n  TAccountRewardMint extends string = string,\n  TAccountRewardVault extends string = string,\n  TAccountRewardTokenProgram extends string = string,\n  TAccountMemoProgram extends string = string,\n> = {\n  whirlpool: Address<TAccountWhirlpool>;\n  positionAuthority: TransactionSigner<TAccountPositionAuthority>;\n  position: Address<TAccountPosition>;\n  positionTokenAccount: Address<TAccountPositionTokenAccount>;\n  rewardOwnerAccount: Address<TAccountRewardOwnerAccount>;\n  rewardMint: Address<TAccountRewardMint>;\n  rewardVault: Address<TAccountRewardVault>;\n  rewardTokenProgram: Address<TAccountRewardTokenProgram>;\n  memoProgram: Address<TAccountMemoProgram>;\n  rewardIndex: CollectRewardV2InstructionDataArgs['rewardIndex'];\n  remainingAccountsInfo: CollectRewardV2InstructionDataArgs['remainingAccountsInfo'];\n};\n\nexport function getCollectRewardV2Instruction<\n  TAccountWhirlpool extends string,\n  TAccountPositionAuthority extends string,\n  TAccountPosition extends string,\n  TAccountPositionTokenAccount extends string,\n  TAccountRewardOwnerAccount extends string,\n  TAccountRewardMint extends string,\n  TAccountRewardVault extends string,\n  TAccountRewardTokenProgram extends string,\n  TAccountMemoProgram extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: CollectRewardV2Input<\n    TAccountWhirlpool,\n    TAccountPositionAuthority,\n    TAccountPosition,\n    TAccountPositionTokenAccount,\n    TAccountRewardOwnerAccount,\n    TAccountRewardMint,\n    TAccountRewardVault,\n    TAccountRewardTokenProgram,\n    TAccountMemoProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CollectRewardV2Instruction<\n  TProgramAddress,\n  TAccountWhirlpool,\n  TAccountPositionAuthority,\n  TAccountPosition,\n  TAccountPositionTokenAccount,\n  TAccountRewardOwnerAccount,\n  TAccountRewardMint,\n  TAccountRewardVault,\n  TAccountRewardTokenProgram,\n  TAccountMemoProgram\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpool: { value: input.whirlpool ?? null, isWritable: false },\n    positionAuthority: {\n      value: input.positionAuthority ?? null,\n      isWritable: false,\n    },\n    position: { value: input.position ?? null, isWritable: true },\n    positionTokenAccount: {\n      value: input.positionTokenAccount ?? null,\n      isWritable: false,\n    },\n    rewardOwnerAccount: {\n      value: input.rewardOwnerAccount ?? null,\n      isWritable: true,\n    },\n    rewardMint: { value: input.rewardMint ?? null, isWritable: false },\n    rewardVault: { value: input.rewardVault ?? null, isWritable: true },\n    rewardTokenProgram: {\n      value: input.rewardTokenProgram ?? null,\n      isWritable: false,\n    },\n    memoProgram: { value: input.memoProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.positionAuthority),\n      getAccountMeta(accounts.position),\n      getAccountMeta(accounts.positionTokenAccount),\n      getAccountMeta(accounts.rewardOwnerAccount),\n      getAccountMeta(accounts.rewardMint),\n      getAccountMeta(accounts.rewardVault),\n      getAccountMeta(accounts.rewardTokenProgram),\n      getAccountMeta(accounts.memoProgram),\n    ],\n    programAddress,\n    data: getCollectRewardV2InstructionDataEncoder().encode(\n      args as CollectRewardV2InstructionDataArgs\n    ),\n  } as CollectRewardV2Instruction<\n    TProgramAddress,\n    TAccountWhirlpool,\n    TAccountPositionAuthority,\n    TAccountPosition,\n    TAccountPositionTokenAccount,\n    TAccountRewardOwnerAccount,\n    TAccountRewardMint,\n    TAccountRewardVault,\n    TAccountRewardTokenProgram,\n    TAccountMemoProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCollectRewardV2Instruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpool: TAccountMetas[0];\n    positionAuthority: TAccountMetas[1];\n    position: TAccountMetas[2];\n    positionTokenAccount: TAccountMetas[3];\n    rewardOwnerAccount: TAccountMetas[4];\n    rewardMint: TAccountMetas[5];\n    rewardVault: TAccountMetas[6];\n    rewardTokenProgram: TAccountMetas[7];\n    memoProgram: TAccountMetas[8];\n  };\n  data: CollectRewardV2InstructionData;\n};\n\nexport function parseCollectRewardV2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedCollectRewardV2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 9) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpool: getNextAccount(),\n      positionAuthority: getNextAccount(),\n      position: getNextAccount(),\n      positionTokenAccount: getNextAccount(),\n      rewardOwnerAccount: getNextAccount(),\n      rewardMint: getNextAccount(),\n      rewardVault: getNextAccount(),\n      rewardTokenProgram: getNextAccount(),\n      memoProgram: getNextAccount(),\n    },\n    data: getCollectRewardV2InstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU128Decoder,\n  getU128Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const DECREASE_LIQUIDITY_DISCRIMINATOR = new Uint8Array([\n  160, 38, 208, 111, 104, 91, 44, 1,\n]);\n\nexport function getDecreaseLiquidityDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    DECREASE_LIQUIDITY_DISCRIMINATOR\n  );\n}\n\nexport type DecreaseLiquidityInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountTokenProgram extends\n    | string\n    | IAccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  TAccountPositionAuthority extends string | IAccountMeta<string> = string,\n  TAccountPosition extends string | IAccountMeta<string> = string,\n  TAccountPositionTokenAccount extends string | IAccountMeta<string> = string,\n  TAccountTokenOwnerAccountA extends string | IAccountMeta<string> = string,\n  TAccountTokenOwnerAccountB extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultA extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultB extends string | IAccountMeta<string> = string,\n  TAccountTickArrayLower extends string | IAccountMeta<string> = string,\n  TAccountTickArrayUpper extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpool extends string\n        ? WritableAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      TAccountPositionAuthority extends string\n        ? ReadonlySignerAccount<TAccountPositionAuthority> &\n            IAccountSignerMeta<TAccountPositionAuthority>\n        : TAccountPositionAuthority,\n      TAccountPosition extends string\n        ? WritableAccount<TAccountPosition>\n        : TAccountPosition,\n      TAccountPositionTokenAccount extends string\n        ? ReadonlyAccount<TAccountPositionTokenAccount>\n        : TAccountPositionTokenAccount,\n      TAccountTokenOwnerAccountA extends string\n        ? WritableAccount<TAccountTokenOwnerAccountA>\n        : TAccountTokenOwnerAccountA,\n      TAccountTokenOwnerAccountB extends string\n        ? WritableAccount<TAccountTokenOwnerAccountB>\n        : TAccountTokenOwnerAccountB,\n      TAccountTokenVaultA extends string\n        ? WritableAccount<TAccountTokenVaultA>\n        : TAccountTokenVaultA,\n      TAccountTokenVaultB extends string\n        ? WritableAccount<TAccountTokenVaultB>\n        : TAccountTokenVaultB,\n      TAccountTickArrayLower extends string\n        ? WritableAccount<TAccountTickArrayLower>\n        : TAccountTickArrayLower,\n      TAccountTickArrayUpper extends string\n        ? WritableAccount<TAccountTickArrayUpper>\n        : TAccountTickArrayUpper,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type DecreaseLiquidityInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  liquidityAmount: bigint;\n  tokenMinA: bigint;\n  tokenMinB: bigint;\n};\n\nexport type DecreaseLiquidityInstructionDataArgs = {\n  liquidityAmount: number | bigint;\n  tokenMinA: number | bigint;\n  tokenMinB: number | bigint;\n};\n\nexport function getDecreaseLiquidityInstructionDataEncoder(): Encoder<DecreaseLiquidityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['liquidityAmount', getU128Encoder()],\n      ['tokenMinA', getU64Encoder()],\n      ['tokenMinB', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: DECREASE_LIQUIDITY_DISCRIMINATOR })\n  );\n}\n\nexport function getDecreaseLiquidityInstructionDataDecoder(): Decoder<DecreaseLiquidityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['liquidityAmount', getU128Decoder()],\n    ['tokenMinA', getU64Decoder()],\n    ['tokenMinB', getU64Decoder()],\n  ]);\n}\n\nexport function getDecreaseLiquidityInstructionDataCodec(): Codec<\n  DecreaseLiquidityInstructionDataArgs,\n  DecreaseLiquidityInstructionData\n> {\n  return combineCodec(\n    getDecreaseLiquidityInstructionDataEncoder(),\n    getDecreaseLiquidityInstructionDataDecoder()\n  );\n}\n\nexport type DecreaseLiquidityInput<\n  TAccountWhirlpool extends string = string,\n  TAccountTokenProgram extends string = string,\n  TAccountPositionAuthority extends string = string,\n  TAccountPosition extends string = string,\n  TAccountPositionTokenAccount extends string = string,\n  TAccountTokenOwnerAccountA extends string = string,\n  TAccountTokenOwnerAccountB extends string = string,\n  TAccountTokenVaultA extends string = string,\n  TAccountTokenVaultB extends string = string,\n  TAccountTickArrayLower extends string = string,\n  TAccountTickArrayUpper extends string = string,\n> = {\n  whirlpool: Address<TAccountWhirlpool>;\n  tokenProgram?: Address<TAccountTokenProgram>;\n  positionAuthority: TransactionSigner<TAccountPositionAuthority>;\n  position: Address<TAccountPosition>;\n  positionTokenAccount: Address<TAccountPositionTokenAccount>;\n  tokenOwnerAccountA: Address<TAccountTokenOwnerAccountA>;\n  tokenOwnerAccountB: Address<TAccountTokenOwnerAccountB>;\n  tokenVaultA: Address<TAccountTokenVaultA>;\n  tokenVaultB: Address<TAccountTokenVaultB>;\n  tickArrayLower: Address<TAccountTickArrayLower>;\n  tickArrayUpper: Address<TAccountTickArrayUpper>;\n  liquidityAmount: DecreaseLiquidityInstructionDataArgs['liquidityAmount'];\n  tokenMinA: DecreaseLiquidityInstructionDataArgs['tokenMinA'];\n  tokenMinB: DecreaseLiquidityInstructionDataArgs['tokenMinB'];\n};\n\nexport function getDecreaseLiquidityInstruction<\n  TAccountWhirlpool extends string,\n  TAccountTokenProgram extends string,\n  TAccountPositionAuthority extends string,\n  TAccountPosition extends string,\n  TAccountPositionTokenAccount extends string,\n  TAccountTokenOwnerAccountA extends string,\n  TAccountTokenOwnerAccountB extends string,\n  TAccountTokenVaultA extends string,\n  TAccountTokenVaultB extends string,\n  TAccountTickArrayLower extends string,\n  TAccountTickArrayUpper extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: DecreaseLiquidityInput<\n    TAccountWhirlpool,\n    TAccountTokenProgram,\n    TAccountPositionAuthority,\n    TAccountPosition,\n    TAccountPositionTokenAccount,\n    TAccountTokenOwnerAccountA,\n    TAccountTokenOwnerAccountB,\n    TAccountTokenVaultA,\n    TAccountTokenVaultB,\n    TAccountTickArrayLower,\n    TAccountTickArrayUpper\n  >,\n  config?: { programAddress?: TProgramAddress }\n): DecreaseLiquidityInstruction<\n  TProgramAddress,\n  TAccountWhirlpool,\n  TAccountTokenProgram,\n  TAccountPositionAuthority,\n  TAccountPosition,\n  TAccountPositionTokenAccount,\n  TAccountTokenOwnerAccountA,\n  TAccountTokenOwnerAccountB,\n  TAccountTokenVaultA,\n  TAccountTokenVaultB,\n  TAccountTickArrayLower,\n  TAccountTickArrayUpper\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpool: { value: input.whirlpool ?? null, isWritable: true },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n    positionAuthority: {\n      value: input.positionAuthority ?? null,\n      isWritable: false,\n    },\n    position: { value: input.position ?? null, isWritable: true },\n    positionTokenAccount: {\n      value: input.positionTokenAccount ?? null,\n      isWritable: false,\n    },\n    tokenOwnerAccountA: {\n      value: input.tokenOwnerAccountA ?? null,\n      isWritable: true,\n    },\n    tokenOwnerAccountB: {\n      value: input.tokenOwnerAccountB ?? null,\n      isWritable: true,\n    },\n    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },\n    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },\n    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },\n    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.tokenProgram),\n      getAccountMeta(accounts.positionAuthority),\n      getAccountMeta(accounts.position),\n      getAccountMeta(accounts.positionTokenAccount),\n      getAccountMeta(accounts.tokenOwnerAccountA),\n      getAccountMeta(accounts.tokenOwnerAccountB),\n      getAccountMeta(accounts.tokenVaultA),\n      getAccountMeta(accounts.tokenVaultB),\n      getAccountMeta(accounts.tickArrayLower),\n      getAccountMeta(accounts.tickArrayUpper),\n    ],\n    programAddress,\n    data: getDecreaseLiquidityInstructionDataEncoder().encode(\n      args as DecreaseLiquidityInstructionDataArgs\n    ),\n  } as DecreaseLiquidityInstruction<\n    TProgramAddress,\n    TAccountWhirlpool,\n    TAccountTokenProgram,\n    TAccountPositionAuthority,\n    TAccountPosition,\n    TAccountPositionTokenAccount,\n    TAccountTokenOwnerAccountA,\n    TAccountTokenOwnerAccountB,\n    TAccountTokenVaultA,\n    TAccountTokenVaultB,\n    TAccountTickArrayLower,\n    TAccountTickArrayUpper\n  >;\n\n  return instruction;\n}\n\nexport type ParsedDecreaseLiquidityInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpool: TAccountMetas[0];\n    tokenProgram: TAccountMetas[1];\n    positionAuthority: TAccountMetas[2];\n    position: TAccountMetas[3];\n    positionTokenAccount: TAccountMetas[4];\n    tokenOwnerAccountA: TAccountMetas[5];\n    tokenOwnerAccountB: TAccountMetas[6];\n    tokenVaultA: TAccountMetas[7];\n    tokenVaultB: TAccountMetas[8];\n    tickArrayLower: TAccountMetas[9];\n    tickArrayUpper: TAccountMetas[10];\n  };\n  data: DecreaseLiquidityInstructionData;\n};\n\nexport function parseDecreaseLiquidityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedDecreaseLiquidityInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 11) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpool: getNextAccount(),\n      tokenProgram: getNextAccount(),\n      positionAuthority: getNextAccount(),\n      position: getNextAccount(),\n      positionTokenAccount: getNextAccount(),\n      tokenOwnerAccountA: getNextAccount(),\n      tokenOwnerAccountB: getNextAccount(),\n      tokenVaultA: getNextAccount(),\n      tokenVaultB: getNextAccount(),\n      tickArrayLower: getNextAccount(),\n      tickArrayUpper: getNextAccount(),\n    },\n    data: getDecreaseLiquidityInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU128Decoder,\n  getU128Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getRemainingAccountsInfoDecoder,\n  getRemainingAccountsInfoEncoder,\n  type RemainingAccountsInfo,\n  type RemainingAccountsInfoArgs,\n} from '../types';\n\nexport const DECREASE_LIQUIDITY_V2_DISCRIMINATOR = new Uint8Array([\n  58, 127, 188, 62, 79, 82, 196, 96,\n]);\n\nexport function getDecreaseLiquidityV2DiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    DECREASE_LIQUIDITY_V2_DISCRIMINATOR\n  );\n}\n\nexport type DecreaseLiquidityV2Instruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountTokenProgramA extends string | IAccountMeta<string> = string,\n  TAccountTokenProgramB extends string | IAccountMeta<string> = string,\n  TAccountMemoProgram extends string | IAccountMeta<string> = string,\n  TAccountPositionAuthority extends string | IAccountMeta<string> = string,\n  TAccountPosition extends string | IAccountMeta<string> = string,\n  TAccountPositionTokenAccount extends string | IAccountMeta<string> = string,\n  TAccountTokenMintA extends string | IAccountMeta<string> = string,\n  TAccountTokenMintB extends string | IAccountMeta<string> = string,\n  TAccountTokenOwnerAccountA extends string | IAccountMeta<string> = string,\n  TAccountTokenOwnerAccountB extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultA extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultB extends string | IAccountMeta<string> = string,\n  TAccountTickArrayLower extends string | IAccountMeta<string> = string,\n  TAccountTickArrayUpper extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpool extends string\n        ? WritableAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountTokenProgramA extends string\n        ? ReadonlyAccount<TAccountTokenProgramA>\n        : TAccountTokenProgramA,\n      TAccountTokenProgramB extends string\n        ? ReadonlyAccount<TAccountTokenProgramB>\n        : TAccountTokenProgramB,\n      TAccountMemoProgram extends string\n        ? ReadonlyAccount<TAccountMemoProgram>\n        : TAccountMemoProgram,\n      TAccountPositionAuthority extends string\n        ? ReadonlySignerAccount<TAccountPositionAuthority> &\n            IAccountSignerMeta<TAccountPositionAuthority>\n        : TAccountPositionAuthority,\n      TAccountPosition extends string\n        ? WritableAccount<TAccountPosition>\n        : TAccountPosition,\n      TAccountPositionTokenAccount extends string\n        ? ReadonlyAccount<TAccountPositionTokenAccount>\n        : TAccountPositionTokenAccount,\n      TAccountTokenMintA extends string\n        ? ReadonlyAccount<TAccountTokenMintA>\n        : TAccountTokenMintA,\n      TAccountTokenMintB extends string\n        ? ReadonlyAccount<TAccountTokenMintB>\n        : TAccountTokenMintB,\n      TAccountTokenOwnerAccountA extends string\n        ? WritableAccount<TAccountTokenOwnerAccountA>\n        : TAccountTokenOwnerAccountA,\n      TAccountTokenOwnerAccountB extends string\n        ? WritableAccount<TAccountTokenOwnerAccountB>\n        : TAccountTokenOwnerAccountB,\n      TAccountTokenVaultA extends string\n        ? WritableAccount<TAccountTokenVaultA>\n        : TAccountTokenVaultA,\n      TAccountTokenVaultB extends string\n        ? WritableAccount<TAccountTokenVaultB>\n        : TAccountTokenVaultB,\n      TAccountTickArrayLower extends string\n        ? WritableAccount<TAccountTickArrayLower>\n        : TAccountTickArrayLower,\n      TAccountTickArrayUpper extends string\n        ? WritableAccount<TAccountTickArrayUpper>\n        : TAccountTickArrayUpper,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type DecreaseLiquidityV2InstructionData = {\n  discriminator: ReadonlyUint8Array;\n  liquidityAmount: bigint;\n  tokenMinA: bigint;\n  tokenMinB: bigint;\n  remainingAccountsInfo: Option<RemainingAccountsInfo>;\n};\n\nexport type DecreaseLiquidityV2InstructionDataArgs = {\n  liquidityAmount: number | bigint;\n  tokenMinA: number | bigint;\n  tokenMinB: number | bigint;\n  remainingAccountsInfo: OptionOrNullable<RemainingAccountsInfoArgs>;\n};\n\nexport function getDecreaseLiquidityV2InstructionDataEncoder(): Encoder<DecreaseLiquidityV2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['liquidityAmount', getU128Encoder()],\n      ['tokenMinA', getU64Encoder()],\n      ['tokenMinB', getU64Encoder()],\n      [\n        'remainingAccountsInfo',\n        getOptionEncoder(getRemainingAccountsInfoEncoder()),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: DECREASE_LIQUIDITY_V2_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getDecreaseLiquidityV2InstructionDataDecoder(): Decoder<DecreaseLiquidityV2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['liquidityAmount', getU128Decoder()],\n    ['tokenMinA', getU64Decoder()],\n    ['tokenMinB', getU64Decoder()],\n    [\n      'remainingAccountsInfo',\n      getOptionDecoder(getRemainingAccountsInfoDecoder()),\n    ],\n  ]);\n}\n\nexport function getDecreaseLiquidityV2InstructionDataCodec(): Codec<\n  DecreaseLiquidityV2InstructionDataArgs,\n  DecreaseLiquidityV2InstructionData\n> {\n  return combineCodec(\n    getDecreaseLiquidityV2InstructionDataEncoder(),\n    getDecreaseLiquidityV2InstructionDataDecoder()\n  );\n}\n\nexport type DecreaseLiquidityV2Input<\n  TAccountWhirlpool extends string = string,\n  TAccountTokenProgramA extends string = string,\n  TAccountTokenProgramB extends string = string,\n  TAccountMemoProgram extends string = string,\n  TAccountPositionAuthority extends string = string,\n  TAccountPosition extends string = string,\n  TAccountPositionTokenAccount extends string = string,\n  TAccountTokenMintA extends string = string,\n  TAccountTokenMintB extends string = string,\n  TAccountTokenOwnerAccountA extends string = string,\n  TAccountTokenOwnerAccountB extends string = string,\n  TAccountTokenVaultA extends string = string,\n  TAccountTokenVaultB extends string = string,\n  TAccountTickArrayLower extends string = string,\n  TAccountTickArrayUpper extends string = string,\n> = {\n  whirlpool: Address<TAccountWhirlpool>;\n  tokenProgramA: Address<TAccountTokenProgramA>;\n  tokenProgramB: Address<TAccountTokenProgramB>;\n  memoProgram: Address<TAccountMemoProgram>;\n  positionAuthority: TransactionSigner<TAccountPositionAuthority>;\n  position: Address<TAccountPosition>;\n  positionTokenAccount: Address<TAccountPositionTokenAccount>;\n  tokenMintA: Address<TAccountTokenMintA>;\n  tokenMintB: Address<TAccountTokenMintB>;\n  tokenOwnerAccountA: Address<TAccountTokenOwnerAccountA>;\n  tokenOwnerAccountB: Address<TAccountTokenOwnerAccountB>;\n  tokenVaultA: Address<TAccountTokenVaultA>;\n  tokenVaultB: Address<TAccountTokenVaultB>;\n  tickArrayLower: Address<TAccountTickArrayLower>;\n  tickArrayUpper: Address<TAccountTickArrayUpper>;\n  liquidityAmount: DecreaseLiquidityV2InstructionDataArgs['liquidityAmount'];\n  tokenMinA: DecreaseLiquidityV2InstructionDataArgs['tokenMinA'];\n  tokenMinB: DecreaseLiquidityV2InstructionDataArgs['tokenMinB'];\n  remainingAccountsInfo: DecreaseLiquidityV2InstructionDataArgs['remainingAccountsInfo'];\n};\n\nexport function getDecreaseLiquidityV2Instruction<\n  TAccountWhirlpool extends string,\n  TAccountTokenProgramA extends string,\n  TAccountTokenProgramB extends string,\n  TAccountMemoProgram extends string,\n  TAccountPositionAuthority extends string,\n  TAccountPosition extends string,\n  TAccountPositionTokenAccount extends string,\n  TAccountTokenMintA extends string,\n  TAccountTokenMintB extends string,\n  TAccountTokenOwnerAccountA extends string,\n  TAccountTokenOwnerAccountB extends string,\n  TAccountTokenVaultA extends string,\n  TAccountTokenVaultB extends string,\n  TAccountTickArrayLower extends string,\n  TAccountTickArrayUpper extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: DecreaseLiquidityV2Input<\n    TAccountWhirlpool,\n    TAccountTokenProgramA,\n    TAccountTokenProgramB,\n    TAccountMemoProgram,\n    TAccountPositionAuthority,\n    TAccountPosition,\n    TAccountPositionTokenAccount,\n    TAccountTokenMintA,\n    TAccountTokenMintB,\n    TAccountTokenOwnerAccountA,\n    TAccountTokenOwnerAccountB,\n    TAccountTokenVaultA,\n    TAccountTokenVaultB,\n    TAccountTickArrayLower,\n    TAccountTickArrayUpper\n  >,\n  config?: { programAddress?: TProgramAddress }\n): DecreaseLiquidityV2Instruction<\n  TProgramAddress,\n  TAccountWhirlpool,\n  TAccountTokenProgramA,\n  TAccountTokenProgramB,\n  TAccountMemoProgram,\n  TAccountPositionAuthority,\n  TAccountPosition,\n  TAccountPositionTokenAccount,\n  TAccountTokenMintA,\n  TAccountTokenMintB,\n  TAccountTokenOwnerAccountA,\n  TAccountTokenOwnerAccountB,\n  TAccountTokenVaultA,\n  TAccountTokenVaultB,\n  TAccountTickArrayLower,\n  TAccountTickArrayUpper\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpool: { value: input.whirlpool ?? null, isWritable: true },\n    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },\n    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },\n    memoProgram: { value: input.memoProgram ?? null, isWritable: false },\n    positionAuthority: {\n      value: input.positionAuthority ?? null,\n      isWritable: false,\n    },\n    position: { value: input.position ?? null, isWritable: true },\n    positionTokenAccount: {\n      value: input.positionTokenAccount ?? null,\n      isWritable: false,\n    },\n    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },\n    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },\n    tokenOwnerAccountA: {\n      value: input.tokenOwnerAccountA ?? null,\n      isWritable: true,\n    },\n    tokenOwnerAccountB: {\n      value: input.tokenOwnerAccountB ?? null,\n      isWritable: true,\n    },\n    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },\n    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },\n    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },\n    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.tokenProgramA),\n      getAccountMeta(accounts.tokenProgramB),\n      getAccountMeta(accounts.memoProgram),\n      getAccountMeta(accounts.positionAuthority),\n      getAccountMeta(accounts.position),\n      getAccountMeta(accounts.positionTokenAccount),\n      getAccountMeta(accounts.tokenMintA),\n      getAccountMeta(accounts.tokenMintB),\n      getAccountMeta(accounts.tokenOwnerAccountA),\n      getAccountMeta(accounts.tokenOwnerAccountB),\n      getAccountMeta(accounts.tokenVaultA),\n      getAccountMeta(accounts.tokenVaultB),\n      getAccountMeta(accounts.tickArrayLower),\n      getAccountMeta(accounts.tickArrayUpper),\n    ],\n    programAddress,\n    data: getDecreaseLiquidityV2InstructionDataEncoder().encode(\n      args as DecreaseLiquidityV2InstructionDataArgs\n    ),\n  } as DecreaseLiquidityV2Instruction<\n    TProgramAddress,\n    TAccountWhirlpool,\n    TAccountTokenProgramA,\n    TAccountTokenProgramB,\n    TAccountMemoProgram,\n    TAccountPositionAuthority,\n    TAccountPosition,\n    TAccountPositionTokenAccount,\n    TAccountTokenMintA,\n    TAccountTokenMintB,\n    TAccountTokenOwnerAccountA,\n    TAccountTokenOwnerAccountB,\n    TAccountTokenVaultA,\n    TAccountTokenVaultB,\n    TAccountTickArrayLower,\n    TAccountTickArrayUpper\n  >;\n\n  return instruction;\n}\n\nexport type ParsedDecreaseLiquidityV2Instruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpool: TAccountMetas[0];\n    tokenProgramA: TAccountMetas[1];\n    tokenProgramB: TAccountMetas[2];\n    memoProgram: TAccountMetas[3];\n    positionAuthority: TAccountMetas[4];\n    position: TAccountMetas[5];\n    positionTokenAccount: TAccountMetas[6];\n    tokenMintA: TAccountMetas[7];\n    tokenMintB: TAccountMetas[8];\n    tokenOwnerAccountA: TAccountMetas[9];\n    tokenOwnerAccountB: TAccountMetas[10];\n    tokenVaultA: TAccountMetas[11];\n    tokenVaultB: TAccountMetas[12];\n    tickArrayLower: TAccountMetas[13];\n    tickArrayUpper: TAccountMetas[14];\n  };\n  data: DecreaseLiquidityV2InstructionData;\n};\n\nexport function parseDecreaseLiquidityV2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedDecreaseLiquidityV2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 15) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpool: getNextAccount(),\n      tokenProgramA: getNextAccount(),\n      tokenProgramB: getNextAccount(),\n      memoProgram: getNextAccount(),\n      positionAuthority: getNextAccount(),\n      position: getNextAccount(),\n      positionTokenAccount: getNextAccount(),\n      tokenMintA: getNextAccount(),\n      tokenMintB: getNextAccount(),\n      tokenOwnerAccountA: getNextAccount(),\n      tokenOwnerAccountB: getNextAccount(),\n      tokenVaultA: getNextAccount(),\n      tokenVaultB: getNextAccount(),\n      tickArrayLower: getNextAccount(),\n      tickArrayUpper: getNextAccount(),\n    },\n    data: getDecreaseLiquidityV2InstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const DELETE_POSITION_BUNDLE_DISCRIMINATOR = new Uint8Array([\n  100, 25, 99, 2, 217, 239, 124, 173,\n]);\n\nexport function getDeletePositionBundleDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    DELETE_POSITION_BUNDLE_DISCRIMINATOR\n  );\n}\n\nexport type DeletePositionBundleInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountPositionBundle extends string | IAccountMeta<string> = string,\n  TAccountPositionBundleMint extends string | IAccountMeta<string> = string,\n  TAccountPositionBundleTokenAccount extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountPositionBundleOwner extends string | IAccountMeta<string> = string,\n  TAccountReceiver extends string | IAccountMeta<string> = string,\n  TAccountTokenProgram extends\n    | string\n    | IAccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountPositionBundle extends string\n        ? WritableAccount<TAccountPositionBundle>\n        : TAccountPositionBundle,\n      TAccountPositionBundleMint extends string\n        ? WritableAccount<TAccountPositionBundleMint>\n        : TAccountPositionBundleMint,\n      TAccountPositionBundleTokenAccount extends string\n        ? WritableAccount<TAccountPositionBundleTokenAccount>\n        : TAccountPositionBundleTokenAccount,\n      TAccountPositionBundleOwner extends string\n        ? ReadonlySignerAccount<TAccountPositionBundleOwner> &\n            IAccountSignerMeta<TAccountPositionBundleOwner>\n        : TAccountPositionBundleOwner,\n      TAccountReceiver extends string\n        ? WritableAccount<TAccountReceiver>\n        : TAccountReceiver,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type DeletePositionBundleInstructionData = {\n  discriminator: ReadonlyUint8Array;\n};\n\nexport type DeletePositionBundleInstructionDataArgs = {};\n\nexport function getDeletePositionBundleInstructionDataEncoder(): Encoder<DeletePositionBundleInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]),\n    (value) => ({\n      ...value,\n      discriminator: DELETE_POSITION_BUNDLE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getDeletePositionBundleInstructionDataDecoder(): Decoder<DeletePositionBundleInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n  ]);\n}\n\nexport function getDeletePositionBundleInstructionDataCodec(): Codec<\n  DeletePositionBundleInstructionDataArgs,\n  DeletePositionBundleInstructionData\n> {\n  return combineCodec(\n    getDeletePositionBundleInstructionDataEncoder(),\n    getDeletePositionBundleInstructionDataDecoder()\n  );\n}\n\nexport type DeletePositionBundleInput<\n  TAccountPositionBundle extends string = string,\n  TAccountPositionBundleMint extends string = string,\n  TAccountPositionBundleTokenAccount extends string = string,\n  TAccountPositionBundleOwner extends string = string,\n  TAccountReceiver extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  positionBundle: Address<TAccountPositionBundle>;\n  positionBundleMint: Address<TAccountPositionBundleMint>;\n  positionBundleTokenAccount: Address<TAccountPositionBundleTokenAccount>;\n  positionBundleOwner: TransactionSigner<TAccountPositionBundleOwner>;\n  receiver: Address<TAccountReceiver>;\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport function getDeletePositionBundleInstruction<\n  TAccountPositionBundle extends string,\n  TAccountPositionBundleMint extends string,\n  TAccountPositionBundleTokenAccount extends string,\n  TAccountPositionBundleOwner extends string,\n  TAccountReceiver extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: DeletePositionBundleInput<\n    TAccountPositionBundle,\n    TAccountPositionBundleMint,\n    TAccountPositionBundleTokenAccount,\n    TAccountPositionBundleOwner,\n    TAccountReceiver,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): DeletePositionBundleInstruction<\n  TProgramAddress,\n  TAccountPositionBundle,\n  TAccountPositionBundleMint,\n  TAccountPositionBundleTokenAccount,\n  TAccountPositionBundleOwner,\n  TAccountReceiver,\n  TAccountTokenProgram\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    positionBundle: { value: input.positionBundle ?? null, isWritable: true },\n    positionBundleMint: {\n      value: input.positionBundleMint ?? null,\n      isWritable: true,\n    },\n    positionBundleTokenAccount: {\n      value: input.positionBundleTokenAccount ?? null,\n      isWritable: true,\n    },\n    positionBundleOwner: {\n      value: input.positionBundleOwner ?? null,\n      isWritable: false,\n    },\n    receiver: { value: input.receiver ?? null, isWritable: true },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.positionBundle),\n      getAccountMeta(accounts.positionBundleMint),\n      getAccountMeta(accounts.positionBundleTokenAccount),\n      getAccountMeta(accounts.positionBundleOwner),\n      getAccountMeta(accounts.receiver),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    programAddress,\n    data: getDeletePositionBundleInstructionDataEncoder().encode({}),\n  } as DeletePositionBundleInstruction<\n    TProgramAddress,\n    TAccountPositionBundle,\n    TAccountPositionBundleMint,\n    TAccountPositionBundleTokenAccount,\n    TAccountPositionBundleOwner,\n    TAccountReceiver,\n    TAccountTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedDeletePositionBundleInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    positionBundle: TAccountMetas[0];\n    positionBundleMint: TAccountMetas[1];\n    positionBundleTokenAccount: TAccountMetas[2];\n    positionBundleOwner: TAccountMetas[3];\n    receiver: TAccountMetas[4];\n    tokenProgram: TAccountMetas[5];\n  };\n  data: DeletePositionBundleInstructionData;\n};\n\nexport function parseDeletePositionBundleInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedDeletePositionBundleInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 6) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      positionBundle: getNextAccount(),\n      positionBundleMint: getNextAccount(),\n      positionBundleTokenAccount: getNextAccount(),\n      positionBundleOwner: getNextAccount(),\n      receiver: getNextAccount(),\n      tokenProgram: getNextAccount(),\n    },\n    data: getDeletePositionBundleInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const DELETE_TOKEN_BADGE_DISCRIMINATOR = new Uint8Array([\n  53, 146, 68, 8, 18, 117, 17, 185,\n]);\n\nexport function getDeleteTokenBadgeDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    DELETE_TOKEN_BADGE_DISCRIMINATOR\n  );\n}\n\nexport type DeleteTokenBadgeInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpoolsConfig extends string | IAccountMeta<string> = string,\n  TAccountWhirlpoolsConfigExtension extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountTokenBadgeAuthority extends string | IAccountMeta<string> = string,\n  TAccountTokenMint extends string | IAccountMeta<string> = string,\n  TAccountTokenBadge extends string | IAccountMeta<string> = string,\n  TAccountReceiver extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpoolsConfig extends string\n        ? ReadonlyAccount<TAccountWhirlpoolsConfig>\n        : TAccountWhirlpoolsConfig,\n      TAccountWhirlpoolsConfigExtension extends string\n        ? ReadonlyAccount<TAccountWhirlpoolsConfigExtension>\n        : TAccountWhirlpoolsConfigExtension,\n      TAccountTokenBadgeAuthority extends string\n        ? ReadonlySignerAccount<TAccountTokenBadgeAuthority> &\n            IAccountSignerMeta<TAccountTokenBadgeAuthority>\n        : TAccountTokenBadgeAuthority,\n      TAccountTokenMint extends string\n        ? ReadonlyAccount<TAccountTokenMint>\n        : TAccountTokenMint,\n      TAccountTokenBadge extends string\n        ? WritableAccount<TAccountTokenBadge>\n        : TAccountTokenBadge,\n      TAccountReceiver extends string\n        ? WritableAccount<TAccountReceiver>\n        : TAccountReceiver,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type DeleteTokenBadgeInstructionData = {\n  discriminator: ReadonlyUint8Array;\n};\n\nexport type DeleteTokenBadgeInstructionDataArgs = {};\n\nexport function getDeleteTokenBadgeInstructionDataEncoder(): Encoder<DeleteTokenBadgeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]),\n    (value) => ({ ...value, discriminator: DELETE_TOKEN_BADGE_DISCRIMINATOR })\n  );\n}\n\nexport function getDeleteTokenBadgeInstructionDataDecoder(): Decoder<DeleteTokenBadgeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n  ]);\n}\n\nexport function getDeleteTokenBadgeInstructionDataCodec(): Codec<\n  DeleteTokenBadgeInstructionDataArgs,\n  DeleteTokenBadgeInstructionData\n> {\n  return combineCodec(\n    getDeleteTokenBadgeInstructionDataEncoder(),\n    getDeleteTokenBadgeInstructionDataDecoder()\n  );\n}\n\nexport type DeleteTokenBadgeInput<\n  TAccountWhirlpoolsConfig extends string = string,\n  TAccountWhirlpoolsConfigExtension extends string = string,\n  TAccountTokenBadgeAuthority extends string = string,\n  TAccountTokenMint extends string = string,\n  TAccountTokenBadge extends string = string,\n  TAccountReceiver extends string = string,\n> = {\n  whirlpoolsConfig: Address<TAccountWhirlpoolsConfig>;\n  whirlpoolsConfigExtension: Address<TAccountWhirlpoolsConfigExtension>;\n  tokenBadgeAuthority: TransactionSigner<TAccountTokenBadgeAuthority>;\n  tokenMint: Address<TAccountTokenMint>;\n  tokenBadge: Address<TAccountTokenBadge>;\n  receiver: Address<TAccountReceiver>;\n};\n\nexport function getDeleteTokenBadgeInstruction<\n  TAccountWhirlpoolsConfig extends string,\n  TAccountWhirlpoolsConfigExtension extends string,\n  TAccountTokenBadgeAuthority extends string,\n  TAccountTokenMint extends string,\n  TAccountTokenBadge extends string,\n  TAccountReceiver extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: DeleteTokenBadgeInput<\n    TAccountWhirlpoolsConfig,\n    TAccountWhirlpoolsConfigExtension,\n    TAccountTokenBadgeAuthority,\n    TAccountTokenMint,\n    TAccountTokenBadge,\n    TAccountReceiver\n  >,\n  config?: { programAddress?: TProgramAddress }\n): DeleteTokenBadgeInstruction<\n  TProgramAddress,\n  TAccountWhirlpoolsConfig,\n  TAccountWhirlpoolsConfigExtension,\n  TAccountTokenBadgeAuthority,\n  TAccountTokenMint,\n  TAccountTokenBadge,\n  TAccountReceiver\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpoolsConfig: {\n      value: input.whirlpoolsConfig ?? null,\n      isWritable: false,\n    },\n    whirlpoolsConfigExtension: {\n      value: input.whirlpoolsConfigExtension ?? null,\n      isWritable: false,\n    },\n    tokenBadgeAuthority: {\n      value: input.tokenBadgeAuthority ?? null,\n      isWritable: false,\n    },\n    tokenMint: { value: input.tokenMint ?? null, isWritable: false },\n    tokenBadge: { value: input.tokenBadge ?? null, isWritable: true },\n    receiver: { value: input.receiver ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpoolsConfig),\n      getAccountMeta(accounts.whirlpoolsConfigExtension),\n      getAccountMeta(accounts.tokenBadgeAuthority),\n      getAccountMeta(accounts.tokenMint),\n      getAccountMeta(accounts.tokenBadge),\n      getAccountMeta(accounts.receiver),\n    ],\n    programAddress,\n    data: getDeleteTokenBadgeInstructionDataEncoder().encode({}),\n  } as DeleteTokenBadgeInstruction<\n    TProgramAddress,\n    TAccountWhirlpoolsConfig,\n    TAccountWhirlpoolsConfigExtension,\n    TAccountTokenBadgeAuthority,\n    TAccountTokenMint,\n    TAccountTokenBadge,\n    TAccountReceiver\n  >;\n\n  return instruction;\n}\n\nexport type ParsedDeleteTokenBadgeInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpoolsConfig: TAccountMetas[0];\n    whirlpoolsConfigExtension: TAccountMetas[1];\n    tokenBadgeAuthority: TAccountMetas[2];\n    tokenMint: TAccountMetas[3];\n    tokenBadge: TAccountMetas[4];\n    receiver: TAccountMetas[5];\n  };\n  data: DeleteTokenBadgeInstructionData;\n};\n\nexport function parseDeleteTokenBadgeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedDeleteTokenBadgeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 6) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpoolsConfig: getNextAccount(),\n      whirlpoolsConfigExtension: getNextAccount(),\n      tokenBadgeAuthority: getNextAccount(),\n      tokenMint: getNextAccount(),\n      tokenBadge: getNextAccount(),\n      receiver: getNextAccount(),\n    },\n    data: getDeleteTokenBadgeInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU128Decoder,\n  getU128Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INCREASE_LIQUIDITY_DISCRIMINATOR = new Uint8Array([\n  46, 156, 243, 118, 13, 205, 251, 178,\n]);\n\nexport function getIncreaseLiquidityDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    INCREASE_LIQUIDITY_DISCRIMINATOR\n  );\n}\n\nexport type IncreaseLiquidityInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountTokenProgram extends\n    | string\n    | IAccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  TAccountPositionAuthority extends string | IAccountMeta<string> = string,\n  TAccountPosition extends string | IAccountMeta<string> = string,\n  TAccountPositionTokenAccount extends string | IAccountMeta<string> = string,\n  TAccountTokenOwnerAccountA extends string | IAccountMeta<string> = string,\n  TAccountTokenOwnerAccountB extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultA extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultB extends string | IAccountMeta<string> = string,\n  TAccountTickArrayLower extends string | IAccountMeta<string> = string,\n  TAccountTickArrayUpper extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpool extends string\n        ? WritableAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      TAccountPositionAuthority extends string\n        ? ReadonlySignerAccount<TAccountPositionAuthority> &\n            IAccountSignerMeta<TAccountPositionAuthority>\n        : TAccountPositionAuthority,\n      TAccountPosition extends string\n        ? WritableAccount<TAccountPosition>\n        : TAccountPosition,\n      TAccountPositionTokenAccount extends string\n        ? ReadonlyAccount<TAccountPositionTokenAccount>\n        : TAccountPositionTokenAccount,\n      TAccountTokenOwnerAccountA extends string\n        ? WritableAccount<TAccountTokenOwnerAccountA>\n        : TAccountTokenOwnerAccountA,\n      TAccountTokenOwnerAccountB extends string\n        ? WritableAccount<TAccountTokenOwnerAccountB>\n        : TAccountTokenOwnerAccountB,\n      TAccountTokenVaultA extends string\n        ? WritableAccount<TAccountTokenVaultA>\n        : TAccountTokenVaultA,\n      TAccountTokenVaultB extends string\n        ? WritableAccount<TAccountTokenVaultB>\n        : TAccountTokenVaultB,\n      TAccountTickArrayLower extends string\n        ? WritableAccount<TAccountTickArrayLower>\n        : TAccountTickArrayLower,\n      TAccountTickArrayUpper extends string\n        ? WritableAccount<TAccountTickArrayUpper>\n        : TAccountTickArrayUpper,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type IncreaseLiquidityInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  liquidityAmount: bigint;\n  tokenMaxA: bigint;\n  tokenMaxB: bigint;\n};\n\nexport type IncreaseLiquidityInstructionDataArgs = {\n  liquidityAmount: number | bigint;\n  tokenMaxA: number | bigint;\n  tokenMaxB: number | bigint;\n};\n\nexport function getIncreaseLiquidityInstructionDataEncoder(): Encoder<IncreaseLiquidityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['liquidityAmount', getU128Encoder()],\n      ['tokenMaxA', getU64Encoder()],\n      ['tokenMaxB', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INCREASE_LIQUIDITY_DISCRIMINATOR })\n  );\n}\n\nexport function getIncreaseLiquidityInstructionDataDecoder(): Decoder<IncreaseLiquidityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['liquidityAmount', getU128Decoder()],\n    ['tokenMaxA', getU64Decoder()],\n    ['tokenMaxB', getU64Decoder()],\n  ]);\n}\n\nexport function getIncreaseLiquidityInstructionDataCodec(): Codec<\n  IncreaseLiquidityInstructionDataArgs,\n  IncreaseLiquidityInstructionData\n> {\n  return combineCodec(\n    getIncreaseLiquidityInstructionDataEncoder(),\n    getIncreaseLiquidityInstructionDataDecoder()\n  );\n}\n\nexport type IncreaseLiquidityInput<\n  TAccountWhirlpool extends string = string,\n  TAccountTokenProgram extends string = string,\n  TAccountPositionAuthority extends string = string,\n  TAccountPosition extends string = string,\n  TAccountPositionTokenAccount extends string = string,\n  TAccountTokenOwnerAccountA extends string = string,\n  TAccountTokenOwnerAccountB extends string = string,\n  TAccountTokenVaultA extends string = string,\n  TAccountTokenVaultB extends string = string,\n  TAccountTickArrayLower extends string = string,\n  TAccountTickArrayUpper extends string = string,\n> = {\n  whirlpool: Address<TAccountWhirlpool>;\n  tokenProgram?: Address<TAccountTokenProgram>;\n  positionAuthority: TransactionSigner<TAccountPositionAuthority>;\n  position: Address<TAccountPosition>;\n  positionTokenAccount: Address<TAccountPositionTokenAccount>;\n  tokenOwnerAccountA: Address<TAccountTokenOwnerAccountA>;\n  tokenOwnerAccountB: Address<TAccountTokenOwnerAccountB>;\n  tokenVaultA: Address<TAccountTokenVaultA>;\n  tokenVaultB: Address<TAccountTokenVaultB>;\n  tickArrayLower: Address<TAccountTickArrayLower>;\n  tickArrayUpper: Address<TAccountTickArrayUpper>;\n  liquidityAmount: IncreaseLiquidityInstructionDataArgs['liquidityAmount'];\n  tokenMaxA: IncreaseLiquidityInstructionDataArgs['tokenMaxA'];\n  tokenMaxB: IncreaseLiquidityInstructionDataArgs['tokenMaxB'];\n};\n\nexport function getIncreaseLiquidityInstruction<\n  TAccountWhirlpool extends string,\n  TAccountTokenProgram extends string,\n  TAccountPositionAuthority extends string,\n  TAccountPosition extends string,\n  TAccountPositionTokenAccount extends string,\n  TAccountTokenOwnerAccountA extends string,\n  TAccountTokenOwnerAccountB extends string,\n  TAccountTokenVaultA extends string,\n  TAccountTokenVaultB extends string,\n  TAccountTickArrayLower extends string,\n  TAccountTickArrayUpper extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: IncreaseLiquidityInput<\n    TAccountWhirlpool,\n    TAccountTokenProgram,\n    TAccountPositionAuthority,\n    TAccountPosition,\n    TAccountPositionTokenAccount,\n    TAccountTokenOwnerAccountA,\n    TAccountTokenOwnerAccountB,\n    TAccountTokenVaultA,\n    TAccountTokenVaultB,\n    TAccountTickArrayLower,\n    TAccountTickArrayUpper\n  >,\n  config?: { programAddress?: TProgramAddress }\n): IncreaseLiquidityInstruction<\n  TProgramAddress,\n  TAccountWhirlpool,\n  TAccountTokenProgram,\n  TAccountPositionAuthority,\n  TAccountPosition,\n  TAccountPositionTokenAccount,\n  TAccountTokenOwnerAccountA,\n  TAccountTokenOwnerAccountB,\n  TAccountTokenVaultA,\n  TAccountTokenVaultB,\n  TAccountTickArrayLower,\n  TAccountTickArrayUpper\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpool: { value: input.whirlpool ?? null, isWritable: true },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n    positionAuthority: {\n      value: input.positionAuthority ?? null,\n      isWritable: false,\n    },\n    position: { value: input.position ?? null, isWritable: true },\n    positionTokenAccount: {\n      value: input.positionTokenAccount ?? null,\n      isWritable: false,\n    },\n    tokenOwnerAccountA: {\n      value: input.tokenOwnerAccountA ?? null,\n      isWritable: true,\n    },\n    tokenOwnerAccountB: {\n      value: input.tokenOwnerAccountB ?? null,\n      isWritable: true,\n    },\n    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },\n    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },\n    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },\n    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.tokenProgram),\n      getAccountMeta(accounts.positionAuthority),\n      getAccountMeta(accounts.position),\n      getAccountMeta(accounts.positionTokenAccount),\n      getAccountMeta(accounts.tokenOwnerAccountA),\n      getAccountMeta(accounts.tokenOwnerAccountB),\n      getAccountMeta(accounts.tokenVaultA),\n      getAccountMeta(accounts.tokenVaultB),\n      getAccountMeta(accounts.tickArrayLower),\n      getAccountMeta(accounts.tickArrayUpper),\n    ],\n    programAddress,\n    data: getIncreaseLiquidityInstructionDataEncoder().encode(\n      args as IncreaseLiquidityInstructionDataArgs\n    ),\n  } as IncreaseLiquidityInstruction<\n    TProgramAddress,\n    TAccountWhirlpool,\n    TAccountTokenProgram,\n    TAccountPositionAuthority,\n    TAccountPosition,\n    TAccountPositionTokenAccount,\n    TAccountTokenOwnerAccountA,\n    TAccountTokenOwnerAccountB,\n    TAccountTokenVaultA,\n    TAccountTokenVaultB,\n    TAccountTickArrayLower,\n    TAccountTickArrayUpper\n  >;\n\n  return instruction;\n}\n\nexport type ParsedIncreaseLiquidityInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpool: TAccountMetas[0];\n    tokenProgram: TAccountMetas[1];\n    positionAuthority: TAccountMetas[2];\n    position: TAccountMetas[3];\n    positionTokenAccount: TAccountMetas[4];\n    tokenOwnerAccountA: TAccountMetas[5];\n    tokenOwnerAccountB: TAccountMetas[6];\n    tokenVaultA: TAccountMetas[7];\n    tokenVaultB: TAccountMetas[8];\n    tickArrayLower: TAccountMetas[9];\n    tickArrayUpper: TAccountMetas[10];\n  };\n  data: IncreaseLiquidityInstructionData;\n};\n\nexport function parseIncreaseLiquidityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedIncreaseLiquidityInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 11) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpool: getNextAccount(),\n      tokenProgram: getNextAccount(),\n      positionAuthority: getNextAccount(),\n      position: getNextAccount(),\n      positionTokenAccount: getNextAccount(),\n      tokenOwnerAccountA: getNextAccount(),\n      tokenOwnerAccountB: getNextAccount(),\n      tokenVaultA: getNextAccount(),\n      tokenVaultB: getNextAccount(),\n      tickArrayLower: getNextAccount(),\n      tickArrayUpper: getNextAccount(),\n    },\n    data: getIncreaseLiquidityInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU128Decoder,\n  getU128Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getRemainingAccountsInfoDecoder,\n  getRemainingAccountsInfoEncoder,\n  type RemainingAccountsInfo,\n  type RemainingAccountsInfoArgs,\n} from '../types';\n\nexport const INCREASE_LIQUIDITY_V2_DISCRIMINATOR = new Uint8Array([\n  133, 29, 89, 223, 69, 238, 176, 10,\n]);\n\nexport function getIncreaseLiquidityV2DiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    INCREASE_LIQUIDITY_V2_DISCRIMINATOR\n  );\n}\n\nexport type IncreaseLiquidityV2Instruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountTokenProgramA extends string | IAccountMeta<string> = string,\n  TAccountTokenProgramB extends string | IAccountMeta<string> = string,\n  TAccountMemoProgram extends string | IAccountMeta<string> = string,\n  TAccountPositionAuthority extends string | IAccountMeta<string> = string,\n  TAccountPosition extends string | IAccountMeta<string> = string,\n  TAccountPositionTokenAccount extends string | IAccountMeta<string> = string,\n  TAccountTokenMintA extends string | IAccountMeta<string> = string,\n  TAccountTokenMintB extends string | IAccountMeta<string> = string,\n  TAccountTokenOwnerAccountA extends string | IAccountMeta<string> = string,\n  TAccountTokenOwnerAccountB extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultA extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultB extends string | IAccountMeta<string> = string,\n  TAccountTickArrayLower extends string | IAccountMeta<string> = string,\n  TAccountTickArrayUpper extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpool extends string\n        ? WritableAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountTokenProgramA extends string\n        ? ReadonlyAccount<TAccountTokenProgramA>\n        : TAccountTokenProgramA,\n      TAccountTokenProgramB extends string\n        ? ReadonlyAccount<TAccountTokenProgramB>\n        : TAccountTokenProgramB,\n      TAccountMemoProgram extends string\n        ? ReadonlyAccount<TAccountMemoProgram>\n        : TAccountMemoProgram,\n      TAccountPositionAuthority extends string\n        ? ReadonlySignerAccount<TAccountPositionAuthority> &\n            IAccountSignerMeta<TAccountPositionAuthority>\n        : TAccountPositionAuthority,\n      TAccountPosition extends string\n        ? WritableAccount<TAccountPosition>\n        : TAccountPosition,\n      TAccountPositionTokenAccount extends string\n        ? ReadonlyAccount<TAccountPositionTokenAccount>\n        : TAccountPositionTokenAccount,\n      TAccountTokenMintA extends string\n        ? ReadonlyAccount<TAccountTokenMintA>\n        : TAccountTokenMintA,\n      TAccountTokenMintB extends string\n        ? ReadonlyAccount<TAccountTokenMintB>\n        : TAccountTokenMintB,\n      TAccountTokenOwnerAccountA extends string\n        ? WritableAccount<TAccountTokenOwnerAccountA>\n        : TAccountTokenOwnerAccountA,\n      TAccountTokenOwnerAccountB extends string\n        ? WritableAccount<TAccountTokenOwnerAccountB>\n        : TAccountTokenOwnerAccountB,\n      TAccountTokenVaultA extends string\n        ? WritableAccount<TAccountTokenVaultA>\n        : TAccountTokenVaultA,\n      TAccountTokenVaultB extends string\n        ? WritableAccount<TAccountTokenVaultB>\n        : TAccountTokenVaultB,\n      TAccountTickArrayLower extends string\n        ? WritableAccount<TAccountTickArrayLower>\n        : TAccountTickArrayLower,\n      TAccountTickArrayUpper extends string\n        ? WritableAccount<TAccountTickArrayUpper>\n        : TAccountTickArrayUpper,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type IncreaseLiquidityV2InstructionData = {\n  discriminator: ReadonlyUint8Array;\n  liquidityAmount: bigint;\n  tokenMaxA: bigint;\n  tokenMaxB: bigint;\n  remainingAccountsInfo: Option<RemainingAccountsInfo>;\n};\n\nexport type IncreaseLiquidityV2InstructionDataArgs = {\n  liquidityAmount: number | bigint;\n  tokenMaxA: number | bigint;\n  tokenMaxB: number | bigint;\n  remainingAccountsInfo: OptionOrNullable<RemainingAccountsInfoArgs>;\n};\n\nexport function getIncreaseLiquidityV2InstructionDataEncoder(): Encoder<IncreaseLiquidityV2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['liquidityAmount', getU128Encoder()],\n      ['tokenMaxA', getU64Encoder()],\n      ['tokenMaxB', getU64Encoder()],\n      [\n        'remainingAccountsInfo',\n        getOptionEncoder(getRemainingAccountsInfoEncoder()),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INCREASE_LIQUIDITY_V2_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getIncreaseLiquidityV2InstructionDataDecoder(): Decoder<IncreaseLiquidityV2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['liquidityAmount', getU128Decoder()],\n    ['tokenMaxA', getU64Decoder()],\n    ['tokenMaxB', getU64Decoder()],\n    [\n      'remainingAccountsInfo',\n      getOptionDecoder(getRemainingAccountsInfoDecoder()),\n    ],\n  ]);\n}\n\nexport function getIncreaseLiquidityV2InstructionDataCodec(): Codec<\n  IncreaseLiquidityV2InstructionDataArgs,\n  IncreaseLiquidityV2InstructionData\n> {\n  return combineCodec(\n    getIncreaseLiquidityV2InstructionDataEncoder(),\n    getIncreaseLiquidityV2InstructionDataDecoder()\n  );\n}\n\nexport type IncreaseLiquidityV2Input<\n  TAccountWhirlpool extends string = string,\n  TAccountTokenProgramA extends string = string,\n  TAccountTokenProgramB extends string = string,\n  TAccountMemoProgram extends string = string,\n  TAccountPositionAuthority extends string = string,\n  TAccountPosition extends string = string,\n  TAccountPositionTokenAccount extends string = string,\n  TAccountTokenMintA extends string = string,\n  TAccountTokenMintB extends string = string,\n  TAccountTokenOwnerAccountA extends string = string,\n  TAccountTokenOwnerAccountB extends string = string,\n  TAccountTokenVaultA extends string = string,\n  TAccountTokenVaultB extends string = string,\n  TAccountTickArrayLower extends string = string,\n  TAccountTickArrayUpper extends string = string,\n> = {\n  whirlpool: Address<TAccountWhirlpool>;\n  tokenProgramA: Address<TAccountTokenProgramA>;\n  tokenProgramB: Address<TAccountTokenProgramB>;\n  memoProgram: Address<TAccountMemoProgram>;\n  positionAuthority: TransactionSigner<TAccountPositionAuthority>;\n  position: Address<TAccountPosition>;\n  positionTokenAccount: Address<TAccountPositionTokenAccount>;\n  tokenMintA: Address<TAccountTokenMintA>;\n  tokenMintB: Address<TAccountTokenMintB>;\n  tokenOwnerAccountA: Address<TAccountTokenOwnerAccountA>;\n  tokenOwnerAccountB: Address<TAccountTokenOwnerAccountB>;\n  tokenVaultA: Address<TAccountTokenVaultA>;\n  tokenVaultB: Address<TAccountTokenVaultB>;\n  tickArrayLower: Address<TAccountTickArrayLower>;\n  tickArrayUpper: Address<TAccountTickArrayUpper>;\n  liquidityAmount: IncreaseLiquidityV2InstructionDataArgs['liquidityAmount'];\n  tokenMaxA: IncreaseLiquidityV2InstructionDataArgs['tokenMaxA'];\n  tokenMaxB: IncreaseLiquidityV2InstructionDataArgs['tokenMaxB'];\n  remainingAccountsInfo: IncreaseLiquidityV2InstructionDataArgs['remainingAccountsInfo'];\n};\n\nexport function getIncreaseLiquidityV2Instruction<\n  TAccountWhirlpool extends string,\n  TAccountTokenProgramA extends string,\n  TAccountTokenProgramB extends string,\n  TAccountMemoProgram extends string,\n  TAccountPositionAuthority extends string,\n  TAccountPosition extends string,\n  TAccountPositionTokenAccount extends string,\n  TAccountTokenMintA extends string,\n  TAccountTokenMintB extends string,\n  TAccountTokenOwnerAccountA extends string,\n  TAccountTokenOwnerAccountB extends string,\n  TAccountTokenVaultA extends string,\n  TAccountTokenVaultB extends string,\n  TAccountTickArrayLower extends string,\n  TAccountTickArrayUpper extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: IncreaseLiquidityV2Input<\n    TAccountWhirlpool,\n    TAccountTokenProgramA,\n    TAccountTokenProgramB,\n    TAccountMemoProgram,\n    TAccountPositionAuthority,\n    TAccountPosition,\n    TAccountPositionTokenAccount,\n    TAccountTokenMintA,\n    TAccountTokenMintB,\n    TAccountTokenOwnerAccountA,\n    TAccountTokenOwnerAccountB,\n    TAccountTokenVaultA,\n    TAccountTokenVaultB,\n    TAccountTickArrayLower,\n    TAccountTickArrayUpper\n  >,\n  config?: { programAddress?: TProgramAddress }\n): IncreaseLiquidityV2Instruction<\n  TProgramAddress,\n  TAccountWhirlpool,\n  TAccountTokenProgramA,\n  TAccountTokenProgramB,\n  TAccountMemoProgram,\n  TAccountPositionAuthority,\n  TAccountPosition,\n  TAccountPositionTokenAccount,\n  TAccountTokenMintA,\n  TAccountTokenMintB,\n  TAccountTokenOwnerAccountA,\n  TAccountTokenOwnerAccountB,\n  TAccountTokenVaultA,\n  TAccountTokenVaultB,\n  TAccountTickArrayLower,\n  TAccountTickArrayUpper\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpool: { value: input.whirlpool ?? null, isWritable: true },\n    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },\n    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },\n    memoProgram: { value: input.memoProgram ?? null, isWritable: false },\n    positionAuthority: {\n      value: input.positionAuthority ?? null,\n      isWritable: false,\n    },\n    position: { value: input.position ?? null, isWritable: true },\n    positionTokenAccount: {\n      value: input.positionTokenAccount ?? null,\n      isWritable: false,\n    },\n    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },\n    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },\n    tokenOwnerAccountA: {\n      value: input.tokenOwnerAccountA ?? null,\n      isWritable: true,\n    },\n    tokenOwnerAccountB: {\n      value: input.tokenOwnerAccountB ?? null,\n      isWritable: true,\n    },\n    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },\n    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },\n    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },\n    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.tokenProgramA),\n      getAccountMeta(accounts.tokenProgramB),\n      getAccountMeta(accounts.memoProgram),\n      getAccountMeta(accounts.positionAuthority),\n      getAccountMeta(accounts.position),\n      getAccountMeta(accounts.positionTokenAccount),\n      getAccountMeta(accounts.tokenMintA),\n      getAccountMeta(accounts.tokenMintB),\n      getAccountMeta(accounts.tokenOwnerAccountA),\n      getAccountMeta(accounts.tokenOwnerAccountB),\n      getAccountMeta(accounts.tokenVaultA),\n      getAccountMeta(accounts.tokenVaultB),\n      getAccountMeta(accounts.tickArrayLower),\n      getAccountMeta(accounts.tickArrayUpper),\n    ],\n    programAddress,\n    data: getIncreaseLiquidityV2InstructionDataEncoder().encode(\n      args as IncreaseLiquidityV2InstructionDataArgs\n    ),\n  } as IncreaseLiquidityV2Instruction<\n    TProgramAddress,\n    TAccountWhirlpool,\n    TAccountTokenProgramA,\n    TAccountTokenProgramB,\n    TAccountMemoProgram,\n    TAccountPositionAuthority,\n    TAccountPosition,\n    TAccountPositionTokenAccount,\n    TAccountTokenMintA,\n    TAccountTokenMintB,\n    TAccountTokenOwnerAccountA,\n    TAccountTokenOwnerAccountB,\n    TAccountTokenVaultA,\n    TAccountTokenVaultB,\n    TAccountTickArrayLower,\n    TAccountTickArrayUpper\n  >;\n\n  return instruction;\n}\n\nexport type ParsedIncreaseLiquidityV2Instruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpool: TAccountMetas[0];\n    tokenProgramA: TAccountMetas[1];\n    tokenProgramB: TAccountMetas[2];\n    memoProgram: TAccountMetas[3];\n    positionAuthority: TAccountMetas[4];\n    position: TAccountMetas[5];\n    positionTokenAccount: TAccountMetas[6];\n    tokenMintA: TAccountMetas[7];\n    tokenMintB: TAccountMetas[8];\n    tokenOwnerAccountA: TAccountMetas[9];\n    tokenOwnerAccountB: TAccountMetas[10];\n    tokenVaultA: TAccountMetas[11];\n    tokenVaultB: TAccountMetas[12];\n    tickArrayLower: TAccountMetas[13];\n    tickArrayUpper: TAccountMetas[14];\n  };\n  data: IncreaseLiquidityV2InstructionData;\n};\n\nexport function parseIncreaseLiquidityV2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedIncreaseLiquidityV2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 15) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpool: getNextAccount(),\n      tokenProgramA: getNextAccount(),\n      tokenProgramB: getNextAccount(),\n      memoProgram: getNextAccount(),\n      positionAuthority: getNextAccount(),\n      position: getNextAccount(),\n      positionTokenAccount: getNextAccount(),\n      tokenMintA: getNextAccount(),\n      tokenMintB: getNextAccount(),\n      tokenOwnerAccountA: getNextAccount(),\n      tokenOwnerAccountB: getNextAccount(),\n      tokenVaultA: getNextAccount(),\n      tokenVaultB: getNextAccount(),\n      tickArrayLower: getNextAccount(),\n      tickArrayUpper: getNextAccount(),\n    },\n    data: getIncreaseLiquidityV2InstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_ADAPTIVE_FEE_TIER_DISCRIMINATOR = new Uint8Array([\n  77, 99, 208, 200, 141, 123, 117, 48,\n]);\n\nexport function getInitializeAdaptiveFeeTierDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    INITIALIZE_ADAPTIVE_FEE_TIER_DISCRIMINATOR\n  );\n}\n\nexport type InitializeAdaptiveFeeTierInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpoolsConfig extends string | IAccountMeta<string> = string,\n  TAccountAdaptiveFeeTier extends string | IAccountMeta<string> = string,\n  TAccountFunder extends string | IAccountMeta<string> = string,\n  TAccountFeeAuthority extends string | IAccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpoolsConfig extends string\n        ? ReadonlyAccount<TAccountWhirlpoolsConfig>\n        : TAccountWhirlpoolsConfig,\n      TAccountAdaptiveFeeTier extends string\n        ? WritableAccount<TAccountAdaptiveFeeTier>\n        : TAccountAdaptiveFeeTier,\n      TAccountFunder extends string\n        ? WritableSignerAccount<TAccountFunder> &\n            IAccountSignerMeta<TAccountFunder>\n        : TAccountFunder,\n      TAccountFeeAuthority extends string\n        ? ReadonlySignerAccount<TAccountFeeAuthority> &\n            IAccountSignerMeta<TAccountFeeAuthority>\n        : TAccountFeeAuthority,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeAdaptiveFeeTierInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  feeTierIndex: number;\n  tickSpacing: number;\n  initializePoolAuthority: Address;\n  delegatedFeeAuthority: Address;\n  defaultBaseFeeRate: number;\n  filterPeriod: number;\n  decayPeriod: number;\n  reductionFactor: number;\n  adaptiveFeeControlFactor: number;\n  maxVolatilityAccumulator: number;\n  tickGroupSize: number;\n  majorSwapThresholdTicks: number;\n};\n\nexport type InitializeAdaptiveFeeTierInstructionDataArgs = {\n  feeTierIndex: number;\n  tickSpacing: number;\n  initializePoolAuthority: Address;\n  delegatedFeeAuthority: Address;\n  defaultBaseFeeRate: number;\n  filterPeriod: number;\n  decayPeriod: number;\n  reductionFactor: number;\n  adaptiveFeeControlFactor: number;\n  maxVolatilityAccumulator: number;\n  tickGroupSize: number;\n  majorSwapThresholdTicks: number;\n};\n\nexport function getInitializeAdaptiveFeeTierInstructionDataEncoder(): Encoder<InitializeAdaptiveFeeTierInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['feeTierIndex', getU16Encoder()],\n      ['tickSpacing', getU16Encoder()],\n      ['initializePoolAuthority', getAddressEncoder()],\n      ['delegatedFeeAuthority', getAddressEncoder()],\n      ['defaultBaseFeeRate', getU16Encoder()],\n      ['filterPeriod', getU16Encoder()],\n      ['decayPeriod', getU16Encoder()],\n      ['reductionFactor', getU16Encoder()],\n      ['adaptiveFeeControlFactor', getU32Encoder()],\n      ['maxVolatilityAccumulator', getU32Encoder()],\n      ['tickGroupSize', getU16Encoder()],\n      ['majorSwapThresholdTicks', getU16Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_ADAPTIVE_FEE_TIER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeAdaptiveFeeTierInstructionDataDecoder(): Decoder<InitializeAdaptiveFeeTierInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['feeTierIndex', getU16Decoder()],\n    ['tickSpacing', getU16Decoder()],\n    ['initializePoolAuthority', getAddressDecoder()],\n    ['delegatedFeeAuthority', getAddressDecoder()],\n    ['defaultBaseFeeRate', getU16Decoder()],\n    ['filterPeriod', getU16Decoder()],\n    ['decayPeriod', getU16Decoder()],\n    ['reductionFactor', getU16Decoder()],\n    ['adaptiveFeeControlFactor', getU32Decoder()],\n    ['maxVolatilityAccumulator', getU32Decoder()],\n    ['tickGroupSize', getU16Decoder()],\n    ['majorSwapThresholdTicks', getU16Decoder()],\n  ]);\n}\n\nexport function getInitializeAdaptiveFeeTierInstructionDataCodec(): Codec<\n  InitializeAdaptiveFeeTierInstructionDataArgs,\n  InitializeAdaptiveFeeTierInstructionData\n> {\n  return combineCodec(\n    getInitializeAdaptiveFeeTierInstructionDataEncoder(),\n    getInitializeAdaptiveFeeTierInstructionDataDecoder()\n  );\n}\n\nexport type InitializeAdaptiveFeeTierInput<\n  TAccountWhirlpoolsConfig extends string = string,\n  TAccountAdaptiveFeeTier extends string = string,\n  TAccountFunder extends string = string,\n  TAccountFeeAuthority extends string = string,\n  TAccountSystemProgram extends string = string,\n> = {\n  whirlpoolsConfig: Address<TAccountWhirlpoolsConfig>;\n  adaptiveFeeTier: Address<TAccountAdaptiveFeeTier>;\n  funder: TransactionSigner<TAccountFunder>;\n  feeAuthority: TransactionSigner<TAccountFeeAuthority>;\n  systemProgram?: Address<TAccountSystemProgram>;\n  feeTierIndex: InitializeAdaptiveFeeTierInstructionDataArgs['feeTierIndex'];\n  tickSpacing: InitializeAdaptiveFeeTierInstructionDataArgs['tickSpacing'];\n  initializePoolAuthority: InitializeAdaptiveFeeTierInstructionDataArgs['initializePoolAuthority'];\n  delegatedFeeAuthority: InitializeAdaptiveFeeTierInstructionDataArgs['delegatedFeeAuthority'];\n  defaultBaseFeeRate: InitializeAdaptiveFeeTierInstructionDataArgs['defaultBaseFeeRate'];\n  filterPeriod: InitializeAdaptiveFeeTierInstructionDataArgs['filterPeriod'];\n  decayPeriod: InitializeAdaptiveFeeTierInstructionDataArgs['decayPeriod'];\n  reductionFactor: InitializeAdaptiveFeeTierInstructionDataArgs['reductionFactor'];\n  adaptiveFeeControlFactor: InitializeAdaptiveFeeTierInstructionDataArgs['adaptiveFeeControlFactor'];\n  maxVolatilityAccumulator: InitializeAdaptiveFeeTierInstructionDataArgs['maxVolatilityAccumulator'];\n  tickGroupSize: InitializeAdaptiveFeeTierInstructionDataArgs['tickGroupSize'];\n  majorSwapThresholdTicks: InitializeAdaptiveFeeTierInstructionDataArgs['majorSwapThresholdTicks'];\n};\n\nexport function getInitializeAdaptiveFeeTierInstruction<\n  TAccountWhirlpoolsConfig extends string,\n  TAccountAdaptiveFeeTier extends string,\n  TAccountFunder extends string,\n  TAccountFeeAuthority extends string,\n  TAccountSystemProgram extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: InitializeAdaptiveFeeTierInput<\n    TAccountWhirlpoolsConfig,\n    TAccountAdaptiveFeeTier,\n    TAccountFunder,\n    TAccountFeeAuthority,\n    TAccountSystemProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeAdaptiveFeeTierInstruction<\n  TProgramAddress,\n  TAccountWhirlpoolsConfig,\n  TAccountAdaptiveFeeTier,\n  TAccountFunder,\n  TAccountFeeAuthority,\n  TAccountSystemProgram\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpoolsConfig: {\n      value: input.whirlpoolsConfig ?? null,\n      isWritable: false,\n    },\n    adaptiveFeeTier: { value: input.adaptiveFeeTier ?? null, isWritable: true },\n    funder: { value: input.funder ?? null, isWritable: true },\n    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpoolsConfig),\n      getAccountMeta(accounts.adaptiveFeeTier),\n      getAccountMeta(accounts.funder),\n      getAccountMeta(accounts.feeAuthority),\n      getAccountMeta(accounts.systemProgram),\n    ],\n    programAddress,\n    data: getInitializeAdaptiveFeeTierInstructionDataEncoder().encode(\n      args as InitializeAdaptiveFeeTierInstructionDataArgs\n    ),\n  } as InitializeAdaptiveFeeTierInstruction<\n    TProgramAddress,\n    TAccountWhirlpoolsConfig,\n    TAccountAdaptiveFeeTier,\n    TAccountFunder,\n    TAccountFeeAuthority,\n    TAccountSystemProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeAdaptiveFeeTierInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpoolsConfig: TAccountMetas[0];\n    adaptiveFeeTier: TAccountMetas[1];\n    funder: TAccountMetas[2];\n    feeAuthority: TAccountMetas[3];\n    systemProgram: TAccountMetas[4];\n  };\n  data: InitializeAdaptiveFeeTierInstructionData;\n};\n\nexport function parseInitializeAdaptiveFeeTierInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeAdaptiveFeeTierInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 5) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpoolsConfig: getNextAccount(),\n      adaptiveFeeTier: getNextAccount(),\n      funder: getNextAccount(),\n      feeAuthority: getNextAccount(),\n      systemProgram: getNextAccount(),\n    },\n    data: getInitializeAdaptiveFeeTierInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_CONFIG_DISCRIMINATOR = new Uint8Array([\n  208, 127, 21, 1, 194, 190, 196, 70,\n]);\n\nexport function getInitializeConfigDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    INITIALIZE_CONFIG_DISCRIMINATOR\n  );\n}\n\nexport type InitializeConfigInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountConfig extends string | IAccountMeta<string> = string,\n  TAccountFunder extends string | IAccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountConfig extends string\n        ? WritableSignerAccount<TAccountConfig> &\n            IAccountSignerMeta<TAccountConfig>\n        : TAccountConfig,\n      TAccountFunder extends string\n        ? WritableSignerAccount<TAccountFunder> &\n            IAccountSignerMeta<TAccountFunder>\n        : TAccountFunder,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeConfigInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  feeAuthority: Address;\n  collectProtocolFeesAuthority: Address;\n  rewardEmissionsSuperAuthority: Address;\n  defaultProtocolFeeRate: number;\n};\n\nexport type InitializeConfigInstructionDataArgs = {\n  feeAuthority: Address;\n  collectProtocolFeesAuthority: Address;\n  rewardEmissionsSuperAuthority: Address;\n  defaultProtocolFeeRate: number;\n};\n\nexport function getInitializeConfigInstructionDataEncoder(): Encoder<InitializeConfigInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['feeAuthority', getAddressEncoder()],\n      ['collectProtocolFeesAuthority', getAddressEncoder()],\n      ['rewardEmissionsSuperAuthority', getAddressEncoder()],\n      ['defaultProtocolFeeRate', getU16Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_CONFIG_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeConfigInstructionDataDecoder(): Decoder<InitializeConfigInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['feeAuthority', getAddressDecoder()],\n    ['collectProtocolFeesAuthority', getAddressDecoder()],\n    ['rewardEmissionsSuperAuthority', getAddressDecoder()],\n    ['defaultProtocolFeeRate', getU16Decoder()],\n  ]);\n}\n\nexport function getInitializeConfigInstructionDataCodec(): Codec<\n  InitializeConfigInstructionDataArgs,\n  InitializeConfigInstructionData\n> {\n  return combineCodec(\n    getInitializeConfigInstructionDataEncoder(),\n    getInitializeConfigInstructionDataDecoder()\n  );\n}\n\nexport type InitializeConfigInput<\n  TAccountConfig extends string = string,\n  TAccountFunder extends string = string,\n  TAccountSystemProgram extends string = string,\n> = {\n  config: TransactionSigner<TAccountConfig>;\n  funder: TransactionSigner<TAccountFunder>;\n  systemProgram?: Address<TAccountSystemProgram>;\n  feeAuthority: InitializeConfigInstructionDataArgs['feeAuthority'];\n  collectProtocolFeesAuthority: InitializeConfigInstructionDataArgs['collectProtocolFeesAuthority'];\n  rewardEmissionsSuperAuthority: InitializeConfigInstructionDataArgs['rewardEmissionsSuperAuthority'];\n  defaultProtocolFeeRate: InitializeConfigInstructionDataArgs['defaultProtocolFeeRate'];\n};\n\nexport function getInitializeConfigInstruction<\n  TAccountConfig extends string,\n  TAccountFunder extends string,\n  TAccountSystemProgram extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: InitializeConfigInput<\n    TAccountConfig,\n    TAccountFunder,\n    TAccountSystemProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeConfigInstruction<\n  TProgramAddress,\n  TAccountConfig,\n  TAccountFunder,\n  TAccountSystemProgram\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    config: { value: input.config ?? null, isWritable: true },\n    funder: { value: input.funder ?? null, isWritable: true },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.config),\n      getAccountMeta(accounts.funder),\n      getAccountMeta(accounts.systemProgram),\n    ],\n    programAddress,\n    data: getInitializeConfigInstructionDataEncoder().encode(\n      args as InitializeConfigInstructionDataArgs\n    ),\n  } as InitializeConfigInstruction<\n    TProgramAddress,\n    TAccountConfig,\n    TAccountFunder,\n    TAccountSystemProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeConfigInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    config: TAccountMetas[0];\n    funder: TAccountMetas[1];\n    systemProgram: TAccountMetas[2];\n  };\n  data: InitializeConfigInstructionData;\n};\n\nexport function parseInitializeConfigInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeConfigInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      config: getNextAccount(),\n      funder: getNextAccount(),\n      systemProgram: getNextAccount(),\n    },\n    data: getInitializeConfigInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_CONFIG_EXTENSION_DISCRIMINATOR = new Uint8Array([\n  55, 9, 53, 9, 114, 57, 209, 52,\n]);\n\nexport function getInitializeConfigExtensionDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    INITIALIZE_CONFIG_EXTENSION_DISCRIMINATOR\n  );\n}\n\nexport type InitializeConfigExtensionInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountConfig extends string | IAccountMeta<string> = string,\n  TAccountConfigExtension extends string | IAccountMeta<string> = string,\n  TAccountFunder extends string | IAccountMeta<string> = string,\n  TAccountFeeAuthority extends string | IAccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountConfig extends string\n        ? ReadonlyAccount<TAccountConfig>\n        : TAccountConfig,\n      TAccountConfigExtension extends string\n        ? WritableAccount<TAccountConfigExtension>\n        : TAccountConfigExtension,\n      TAccountFunder extends string\n        ? WritableSignerAccount<TAccountFunder> &\n            IAccountSignerMeta<TAccountFunder>\n        : TAccountFunder,\n      TAccountFeeAuthority extends string\n        ? ReadonlySignerAccount<TAccountFeeAuthority> &\n            IAccountSignerMeta<TAccountFeeAuthority>\n        : TAccountFeeAuthority,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeConfigExtensionInstructionData = {\n  discriminator: ReadonlyUint8Array;\n};\n\nexport type InitializeConfigExtensionInstructionDataArgs = {};\n\nexport function getInitializeConfigExtensionInstructionDataEncoder(): Encoder<InitializeConfigExtensionInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_CONFIG_EXTENSION_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeConfigExtensionInstructionDataDecoder(): Decoder<InitializeConfigExtensionInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n  ]);\n}\n\nexport function getInitializeConfigExtensionInstructionDataCodec(): Codec<\n  InitializeConfigExtensionInstructionDataArgs,\n  InitializeConfigExtensionInstructionData\n> {\n  return combineCodec(\n    getInitializeConfigExtensionInstructionDataEncoder(),\n    getInitializeConfigExtensionInstructionDataDecoder()\n  );\n}\n\nexport type InitializeConfigExtensionInput<\n  TAccountConfig extends string = string,\n  TAccountConfigExtension extends string = string,\n  TAccountFunder extends string = string,\n  TAccountFeeAuthority extends string = string,\n  TAccountSystemProgram extends string = string,\n> = {\n  config: Address<TAccountConfig>;\n  configExtension: Address<TAccountConfigExtension>;\n  funder: TransactionSigner<TAccountFunder>;\n  feeAuthority: TransactionSigner<TAccountFeeAuthority>;\n  systemProgram?: Address<TAccountSystemProgram>;\n};\n\nexport function getInitializeConfigExtensionInstruction<\n  TAccountConfig extends string,\n  TAccountConfigExtension extends string,\n  TAccountFunder extends string,\n  TAccountFeeAuthority extends string,\n  TAccountSystemProgram extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: InitializeConfigExtensionInput<\n    TAccountConfig,\n    TAccountConfigExtension,\n    TAccountFunder,\n    TAccountFeeAuthority,\n    TAccountSystemProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeConfigExtensionInstruction<\n  TProgramAddress,\n  TAccountConfig,\n  TAccountConfigExtension,\n  TAccountFunder,\n  TAccountFeeAuthority,\n  TAccountSystemProgram\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    config: { value: input.config ?? null, isWritable: false },\n    configExtension: { value: input.configExtension ?? null, isWritable: true },\n    funder: { value: input.funder ?? null, isWritable: true },\n    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.config),\n      getAccountMeta(accounts.configExtension),\n      getAccountMeta(accounts.funder),\n      getAccountMeta(accounts.feeAuthority),\n      getAccountMeta(accounts.systemProgram),\n    ],\n    programAddress,\n    data: getInitializeConfigExtensionInstructionDataEncoder().encode({}),\n  } as InitializeConfigExtensionInstruction<\n    TProgramAddress,\n    TAccountConfig,\n    TAccountConfigExtension,\n    TAccountFunder,\n    TAccountFeeAuthority,\n    TAccountSystemProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeConfigExtensionInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    config: TAccountMetas[0];\n    configExtension: TAccountMetas[1];\n    funder: TAccountMetas[2];\n    feeAuthority: TAccountMetas[3];\n    systemProgram: TAccountMetas[4];\n  };\n  data: InitializeConfigExtensionInstructionData;\n};\n\nexport function parseInitializeConfigExtensionInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeConfigExtensionInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 5) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      config: getNextAccount(),\n      configExtension: getNextAccount(),\n      funder: getNextAccount(),\n      feeAuthority: getNextAccount(),\n      systemProgram: getNextAccount(),\n    },\n    data: getInitializeConfigExtensionInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_FEE_TIER_DISCRIMINATOR = new Uint8Array([\n  183, 74, 156, 160, 112, 2, 42, 30,\n]);\n\nexport function getInitializeFeeTierDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    INITIALIZE_FEE_TIER_DISCRIMINATOR\n  );\n}\n\nexport type InitializeFeeTierInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountConfig extends string | IAccountMeta<string> = string,\n  TAccountFeeTier extends string | IAccountMeta<string> = string,\n  TAccountFunder extends string | IAccountMeta<string> = string,\n  TAccountFeeAuthority extends string | IAccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountConfig extends string\n        ? ReadonlyAccount<TAccountConfig>\n        : TAccountConfig,\n      TAccountFeeTier extends string\n        ? WritableAccount<TAccountFeeTier>\n        : TAccountFeeTier,\n      TAccountFunder extends string\n        ? WritableSignerAccount<TAccountFunder> &\n            IAccountSignerMeta<TAccountFunder>\n        : TAccountFunder,\n      TAccountFeeAuthority extends string\n        ? ReadonlySignerAccount<TAccountFeeAuthority> &\n            IAccountSignerMeta<TAccountFeeAuthority>\n        : TAccountFeeAuthority,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeFeeTierInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  tickSpacing: number;\n  defaultFeeRate: number;\n};\n\nexport type InitializeFeeTierInstructionDataArgs = {\n  tickSpacing: number;\n  defaultFeeRate: number;\n};\n\nexport function getInitializeFeeTierInstructionDataEncoder(): Encoder<InitializeFeeTierInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['tickSpacing', getU16Encoder()],\n      ['defaultFeeRate', getU16Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_FEE_TIER_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeFeeTierInstructionDataDecoder(): Decoder<InitializeFeeTierInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['tickSpacing', getU16Decoder()],\n    ['defaultFeeRate', getU16Decoder()],\n  ]);\n}\n\nexport function getInitializeFeeTierInstructionDataCodec(): Codec<\n  InitializeFeeTierInstructionDataArgs,\n  InitializeFeeTierInstructionData\n> {\n  return combineCodec(\n    getInitializeFeeTierInstructionDataEncoder(),\n    getInitializeFeeTierInstructionDataDecoder()\n  );\n}\n\nexport type InitializeFeeTierInput<\n  TAccountConfig extends string = string,\n  TAccountFeeTier extends string = string,\n  TAccountFunder extends string = string,\n  TAccountFeeAuthority extends string = string,\n  TAccountSystemProgram extends string = string,\n> = {\n  config: Address<TAccountConfig>;\n  feeTier: Address<TAccountFeeTier>;\n  funder: TransactionSigner<TAccountFunder>;\n  feeAuthority: TransactionSigner<TAccountFeeAuthority>;\n  systemProgram?: Address<TAccountSystemProgram>;\n  tickSpacing: InitializeFeeTierInstructionDataArgs['tickSpacing'];\n  defaultFeeRate: InitializeFeeTierInstructionDataArgs['defaultFeeRate'];\n};\n\nexport function getInitializeFeeTierInstruction<\n  TAccountConfig extends string,\n  TAccountFeeTier extends string,\n  TAccountFunder extends string,\n  TAccountFeeAuthority extends string,\n  TAccountSystemProgram extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: InitializeFeeTierInput<\n    TAccountConfig,\n    TAccountFeeTier,\n    TAccountFunder,\n    TAccountFeeAuthority,\n    TAccountSystemProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeFeeTierInstruction<\n  TProgramAddress,\n  TAccountConfig,\n  TAccountFeeTier,\n  TAccountFunder,\n  TAccountFeeAuthority,\n  TAccountSystemProgram\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    config: { value: input.config ?? null, isWritable: false },\n    feeTier: { value: input.feeTier ?? null, isWritable: true },\n    funder: { value: input.funder ?? null, isWritable: true },\n    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.config),\n      getAccountMeta(accounts.feeTier),\n      getAccountMeta(accounts.funder),\n      getAccountMeta(accounts.feeAuthority),\n      getAccountMeta(accounts.systemProgram),\n    ],\n    programAddress,\n    data: getInitializeFeeTierInstructionDataEncoder().encode(\n      args as InitializeFeeTierInstructionDataArgs\n    ),\n  } as InitializeFeeTierInstruction<\n    TProgramAddress,\n    TAccountConfig,\n    TAccountFeeTier,\n    TAccountFunder,\n    TAccountFeeAuthority,\n    TAccountSystemProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeFeeTierInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    config: TAccountMetas[0];\n    feeTier: TAccountMetas[1];\n    funder: TAccountMetas[2];\n    feeAuthority: TAccountMetas[3];\n    systemProgram: TAccountMetas[4];\n  };\n  data: InitializeFeeTierInstructionData;\n};\n\nexport function parseInitializeFeeTierInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeFeeTierInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 5) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      config: getNextAccount(),\n      feeTier: getNextAccount(),\n      funder: getNextAccount(),\n      feeAuthority: getNextAccount(),\n      systemProgram: getNextAccount(),\n    },\n    data: getInitializeFeeTierInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU128Decoder,\n  getU128Encoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_POOL_DISCRIMINATOR = new Uint8Array([\n  95, 180, 10, 172, 84, 174, 232, 40,\n]);\n\nexport function getInitializePoolDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    INITIALIZE_POOL_DISCRIMINATOR\n  );\n}\n\nexport type InitializePoolInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpoolsConfig extends string | IAccountMeta<string> = string,\n  TAccountTokenMintA extends string | IAccountMeta<string> = string,\n  TAccountTokenMintB extends string | IAccountMeta<string> = string,\n  TAccountFunder extends string | IAccountMeta<string> = string,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultA extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultB extends string | IAccountMeta<string> = string,\n  TAccountFeeTier extends string | IAccountMeta<string> = string,\n  TAccountTokenProgram extends\n    | string\n    | IAccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TAccountRent extends\n    | string\n    | IAccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpoolsConfig extends string\n        ? ReadonlyAccount<TAccountWhirlpoolsConfig>\n        : TAccountWhirlpoolsConfig,\n      TAccountTokenMintA extends string\n        ? ReadonlyAccount<TAccountTokenMintA>\n        : TAccountTokenMintA,\n      TAccountTokenMintB extends string\n        ? ReadonlyAccount<TAccountTokenMintB>\n        : TAccountTokenMintB,\n      TAccountFunder extends string\n        ? WritableSignerAccount<TAccountFunder> &\n            IAccountSignerMeta<TAccountFunder>\n        : TAccountFunder,\n      TAccountWhirlpool extends string\n        ? WritableAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountTokenVaultA extends string\n        ? WritableSignerAccount<TAccountTokenVaultA> &\n            IAccountSignerMeta<TAccountTokenVaultA>\n        : TAccountTokenVaultA,\n      TAccountTokenVaultB extends string\n        ? WritableSignerAccount<TAccountTokenVaultB> &\n            IAccountSignerMeta<TAccountTokenVaultB>\n        : TAccountTokenVaultB,\n      TAccountFeeTier extends string\n        ? ReadonlyAccount<TAccountFeeTier>\n        : TAccountFeeTier,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializePoolInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  whirlpoolBump: number;\n  tickSpacing: number;\n  initialSqrtPrice: bigint;\n};\n\nexport type InitializePoolInstructionDataArgs = {\n  whirlpoolBump: number;\n  tickSpacing: number;\n  initialSqrtPrice: number | bigint;\n};\n\nexport function getInitializePoolInstructionDataEncoder(): Encoder<InitializePoolInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['whirlpoolBump', getU8Encoder()],\n      ['tickSpacing', getU16Encoder()],\n      ['initialSqrtPrice', getU128Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_POOL_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializePoolInstructionDataDecoder(): Decoder<InitializePoolInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['whirlpoolBump', getU8Decoder()],\n    ['tickSpacing', getU16Decoder()],\n    ['initialSqrtPrice', getU128Decoder()],\n  ]);\n}\n\nexport function getInitializePoolInstructionDataCodec(): Codec<\n  InitializePoolInstructionDataArgs,\n  InitializePoolInstructionData\n> {\n  return combineCodec(\n    getInitializePoolInstructionDataEncoder(),\n    getInitializePoolInstructionDataDecoder()\n  );\n}\n\nexport type InitializePoolInput<\n  TAccountWhirlpoolsConfig extends string = string,\n  TAccountTokenMintA extends string = string,\n  TAccountTokenMintB extends string = string,\n  TAccountFunder extends string = string,\n  TAccountWhirlpool extends string = string,\n  TAccountTokenVaultA extends string = string,\n  TAccountTokenVaultB extends string = string,\n  TAccountFeeTier extends string = string,\n  TAccountTokenProgram extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountRent extends string = string,\n> = {\n  whirlpoolsConfig: Address<TAccountWhirlpoolsConfig>;\n  tokenMintA: Address<TAccountTokenMintA>;\n  tokenMintB: Address<TAccountTokenMintB>;\n  funder: TransactionSigner<TAccountFunder>;\n  whirlpool: Address<TAccountWhirlpool>;\n  tokenVaultA: TransactionSigner<TAccountTokenVaultA>;\n  tokenVaultB: TransactionSigner<TAccountTokenVaultB>;\n  feeTier: Address<TAccountFeeTier>;\n  tokenProgram?: Address<TAccountTokenProgram>;\n  systemProgram?: Address<TAccountSystemProgram>;\n  rent?: Address<TAccountRent>;\n  whirlpoolBump: InitializePoolInstructionDataArgs['whirlpoolBump'];\n  tickSpacing: InitializePoolInstructionDataArgs['tickSpacing'];\n  initialSqrtPrice: InitializePoolInstructionDataArgs['initialSqrtPrice'];\n};\n\nexport function getInitializePoolInstruction<\n  TAccountWhirlpoolsConfig extends string,\n  TAccountTokenMintA extends string,\n  TAccountTokenMintB extends string,\n  TAccountFunder extends string,\n  TAccountWhirlpool extends string,\n  TAccountTokenVaultA extends string,\n  TAccountTokenVaultB extends string,\n  TAccountFeeTier extends string,\n  TAccountTokenProgram extends string,\n  TAccountSystemProgram extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: InitializePoolInput<\n    TAccountWhirlpoolsConfig,\n    TAccountTokenMintA,\n    TAccountTokenMintB,\n    TAccountFunder,\n    TAccountWhirlpool,\n    TAccountTokenVaultA,\n    TAccountTokenVaultB,\n    TAccountFeeTier,\n    TAccountTokenProgram,\n    TAccountSystemProgram,\n    TAccountRent\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializePoolInstruction<\n  TProgramAddress,\n  TAccountWhirlpoolsConfig,\n  TAccountTokenMintA,\n  TAccountTokenMintB,\n  TAccountFunder,\n  TAccountWhirlpool,\n  TAccountTokenVaultA,\n  TAccountTokenVaultB,\n  TAccountFeeTier,\n  TAccountTokenProgram,\n  TAccountSystemProgram,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpoolsConfig: {\n      value: input.whirlpoolsConfig ?? null,\n      isWritable: false,\n    },\n    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },\n    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },\n    funder: { value: input.funder ?? null, isWritable: true },\n    whirlpool: { value: input.whirlpool ?? null, isWritable: true },\n    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },\n    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },\n    feeTier: { value: input.feeTier ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpoolsConfig),\n      getAccountMeta(accounts.tokenMintA),\n      getAccountMeta(accounts.tokenMintB),\n      getAccountMeta(accounts.funder),\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.tokenVaultA),\n      getAccountMeta(accounts.tokenVaultB),\n      getAccountMeta(accounts.feeTier),\n      getAccountMeta(accounts.tokenProgram),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.rent),\n    ],\n    programAddress,\n    data: getInitializePoolInstructionDataEncoder().encode(\n      args as InitializePoolInstructionDataArgs\n    ),\n  } as InitializePoolInstruction<\n    TProgramAddress,\n    TAccountWhirlpoolsConfig,\n    TAccountTokenMintA,\n    TAccountTokenMintB,\n    TAccountFunder,\n    TAccountWhirlpool,\n    TAccountTokenVaultA,\n    TAccountTokenVaultB,\n    TAccountFeeTier,\n    TAccountTokenProgram,\n    TAccountSystemProgram,\n    TAccountRent\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializePoolInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpoolsConfig: TAccountMetas[0];\n    tokenMintA: TAccountMetas[1];\n    tokenMintB: TAccountMetas[2];\n    funder: TAccountMetas[3];\n    whirlpool: TAccountMetas[4];\n    tokenVaultA: TAccountMetas[5];\n    tokenVaultB: TAccountMetas[6];\n    feeTier: TAccountMetas[7];\n    tokenProgram: TAccountMetas[8];\n    systemProgram: TAccountMetas[9];\n    rent: TAccountMetas[10];\n  };\n  data: InitializePoolInstructionData;\n};\n\nexport function parseInitializePoolInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializePoolInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 11) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpoolsConfig: getNextAccount(),\n      tokenMintA: getNextAccount(),\n      tokenMintB: getNextAccount(),\n      funder: getNextAccount(),\n      whirlpool: getNextAccount(),\n      tokenVaultA: getNextAccount(),\n      tokenVaultB: getNextAccount(),\n      feeTier: getNextAccount(),\n      tokenProgram: getNextAccount(),\n      systemProgram: getNextAccount(),\n      rent: getNextAccount(),\n    },\n    data: getInitializePoolInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU128Decoder,\n  getU128Encoder,\n  getU16Decoder,\n  getU16Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_POOL_V2_DISCRIMINATOR = new Uint8Array([\n  207, 45, 87, 242, 27, 63, 204, 67,\n]);\n\nexport function getInitializePoolV2DiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    INITIALIZE_POOL_V2_DISCRIMINATOR\n  );\n}\n\nexport type InitializePoolV2Instruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpoolsConfig extends string | IAccountMeta<string> = string,\n  TAccountTokenMintA extends string | IAccountMeta<string> = string,\n  TAccountTokenMintB extends string | IAccountMeta<string> = string,\n  TAccountTokenBadgeA extends string | IAccountMeta<string> = string,\n  TAccountTokenBadgeB extends string | IAccountMeta<string> = string,\n  TAccountFunder extends string | IAccountMeta<string> = string,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultA extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultB extends string | IAccountMeta<string> = string,\n  TAccountFeeTier extends string | IAccountMeta<string> = string,\n  TAccountTokenProgramA extends string | IAccountMeta<string> = string,\n  TAccountTokenProgramB extends string | IAccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TAccountRent extends\n    | string\n    | IAccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpoolsConfig extends string\n        ? ReadonlyAccount<TAccountWhirlpoolsConfig>\n        : TAccountWhirlpoolsConfig,\n      TAccountTokenMintA extends string\n        ? ReadonlyAccount<TAccountTokenMintA>\n        : TAccountTokenMintA,\n      TAccountTokenMintB extends string\n        ? ReadonlyAccount<TAccountTokenMintB>\n        : TAccountTokenMintB,\n      TAccountTokenBadgeA extends string\n        ? ReadonlyAccount<TAccountTokenBadgeA>\n        : TAccountTokenBadgeA,\n      TAccountTokenBadgeB extends string\n        ? ReadonlyAccount<TAccountTokenBadgeB>\n        : TAccountTokenBadgeB,\n      TAccountFunder extends string\n        ? WritableSignerAccount<TAccountFunder> &\n            IAccountSignerMeta<TAccountFunder>\n        : TAccountFunder,\n      TAccountWhirlpool extends string\n        ? WritableAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountTokenVaultA extends string\n        ? WritableSignerAccount<TAccountTokenVaultA> &\n            IAccountSignerMeta<TAccountTokenVaultA>\n        : TAccountTokenVaultA,\n      TAccountTokenVaultB extends string\n        ? WritableSignerAccount<TAccountTokenVaultB> &\n            IAccountSignerMeta<TAccountTokenVaultB>\n        : TAccountTokenVaultB,\n      TAccountFeeTier extends string\n        ? ReadonlyAccount<TAccountFeeTier>\n        : TAccountFeeTier,\n      TAccountTokenProgramA extends string\n        ? ReadonlyAccount<TAccountTokenProgramA>\n        : TAccountTokenProgramA,\n      TAccountTokenProgramB extends string\n        ? ReadonlyAccount<TAccountTokenProgramB>\n        : TAccountTokenProgramB,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializePoolV2InstructionData = {\n  discriminator: ReadonlyUint8Array;\n  tickSpacing: number;\n  initialSqrtPrice: bigint;\n};\n\nexport type InitializePoolV2InstructionDataArgs = {\n  tickSpacing: number;\n  initialSqrtPrice: number | bigint;\n};\n\nexport function getInitializePoolV2InstructionDataEncoder(): Encoder<InitializePoolV2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['tickSpacing', getU16Encoder()],\n      ['initialSqrtPrice', getU128Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_POOL_V2_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializePoolV2InstructionDataDecoder(): Decoder<InitializePoolV2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['tickSpacing', getU16Decoder()],\n    ['initialSqrtPrice', getU128Decoder()],\n  ]);\n}\n\nexport function getInitializePoolV2InstructionDataCodec(): Codec<\n  InitializePoolV2InstructionDataArgs,\n  InitializePoolV2InstructionData\n> {\n  return combineCodec(\n    getInitializePoolV2InstructionDataEncoder(),\n    getInitializePoolV2InstructionDataDecoder()\n  );\n}\n\nexport type InitializePoolV2Input<\n  TAccountWhirlpoolsConfig extends string = string,\n  TAccountTokenMintA extends string = string,\n  TAccountTokenMintB extends string = string,\n  TAccountTokenBadgeA extends string = string,\n  TAccountTokenBadgeB extends string = string,\n  TAccountFunder extends string = string,\n  TAccountWhirlpool extends string = string,\n  TAccountTokenVaultA extends string = string,\n  TAccountTokenVaultB extends string = string,\n  TAccountFeeTier extends string = string,\n  TAccountTokenProgramA extends string = string,\n  TAccountTokenProgramB extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountRent extends string = string,\n> = {\n  whirlpoolsConfig: Address<TAccountWhirlpoolsConfig>;\n  tokenMintA: Address<TAccountTokenMintA>;\n  tokenMintB: Address<TAccountTokenMintB>;\n  tokenBadgeA: Address<TAccountTokenBadgeA>;\n  tokenBadgeB: Address<TAccountTokenBadgeB>;\n  funder: TransactionSigner<TAccountFunder>;\n  whirlpool: Address<TAccountWhirlpool>;\n  tokenVaultA: TransactionSigner<TAccountTokenVaultA>;\n  tokenVaultB: TransactionSigner<TAccountTokenVaultB>;\n  feeTier: Address<TAccountFeeTier>;\n  tokenProgramA: Address<TAccountTokenProgramA>;\n  tokenProgramB: Address<TAccountTokenProgramB>;\n  systemProgram?: Address<TAccountSystemProgram>;\n  rent?: Address<TAccountRent>;\n  tickSpacing: InitializePoolV2InstructionDataArgs['tickSpacing'];\n  initialSqrtPrice: InitializePoolV2InstructionDataArgs['initialSqrtPrice'];\n};\n\nexport function getInitializePoolV2Instruction<\n  TAccountWhirlpoolsConfig extends string,\n  TAccountTokenMintA extends string,\n  TAccountTokenMintB extends string,\n  TAccountTokenBadgeA extends string,\n  TAccountTokenBadgeB extends string,\n  TAccountFunder extends string,\n  TAccountWhirlpool extends string,\n  TAccountTokenVaultA extends string,\n  TAccountTokenVaultB extends string,\n  TAccountFeeTier extends string,\n  TAccountTokenProgramA extends string,\n  TAccountTokenProgramB extends string,\n  TAccountSystemProgram extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: InitializePoolV2Input<\n    TAccountWhirlpoolsConfig,\n    TAccountTokenMintA,\n    TAccountTokenMintB,\n    TAccountTokenBadgeA,\n    TAccountTokenBadgeB,\n    TAccountFunder,\n    TAccountWhirlpool,\n    TAccountTokenVaultA,\n    TAccountTokenVaultB,\n    TAccountFeeTier,\n    TAccountTokenProgramA,\n    TAccountTokenProgramB,\n    TAccountSystemProgram,\n    TAccountRent\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializePoolV2Instruction<\n  TProgramAddress,\n  TAccountWhirlpoolsConfig,\n  TAccountTokenMintA,\n  TAccountTokenMintB,\n  TAccountTokenBadgeA,\n  TAccountTokenBadgeB,\n  TAccountFunder,\n  TAccountWhirlpool,\n  TAccountTokenVaultA,\n  TAccountTokenVaultB,\n  TAccountFeeTier,\n  TAccountTokenProgramA,\n  TAccountTokenProgramB,\n  TAccountSystemProgram,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpoolsConfig: {\n      value: input.whirlpoolsConfig ?? null,\n      isWritable: false,\n    },\n    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },\n    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },\n    tokenBadgeA: { value: input.tokenBadgeA ?? null, isWritable: false },\n    tokenBadgeB: { value: input.tokenBadgeB ?? null, isWritable: false },\n    funder: { value: input.funder ?? null, isWritable: true },\n    whirlpool: { value: input.whirlpool ?? null, isWritable: true },\n    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },\n    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },\n    feeTier: { value: input.feeTier ?? null, isWritable: false },\n    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },\n    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpoolsConfig),\n      getAccountMeta(accounts.tokenMintA),\n      getAccountMeta(accounts.tokenMintB),\n      getAccountMeta(accounts.tokenBadgeA),\n      getAccountMeta(accounts.tokenBadgeB),\n      getAccountMeta(accounts.funder),\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.tokenVaultA),\n      getAccountMeta(accounts.tokenVaultB),\n      getAccountMeta(accounts.feeTier),\n      getAccountMeta(accounts.tokenProgramA),\n      getAccountMeta(accounts.tokenProgramB),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.rent),\n    ],\n    programAddress,\n    data: getInitializePoolV2InstructionDataEncoder().encode(\n      args as InitializePoolV2InstructionDataArgs\n    ),\n  } as InitializePoolV2Instruction<\n    TProgramAddress,\n    TAccountWhirlpoolsConfig,\n    TAccountTokenMintA,\n    TAccountTokenMintB,\n    TAccountTokenBadgeA,\n    TAccountTokenBadgeB,\n    TAccountFunder,\n    TAccountWhirlpool,\n    TAccountTokenVaultA,\n    TAccountTokenVaultB,\n    TAccountFeeTier,\n    TAccountTokenProgramA,\n    TAccountTokenProgramB,\n    TAccountSystemProgram,\n    TAccountRent\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializePoolV2Instruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpoolsConfig: TAccountMetas[0];\n    tokenMintA: TAccountMetas[1];\n    tokenMintB: TAccountMetas[2];\n    tokenBadgeA: TAccountMetas[3];\n    tokenBadgeB: TAccountMetas[4];\n    funder: TAccountMetas[5];\n    whirlpool: TAccountMetas[6];\n    tokenVaultA: TAccountMetas[7];\n    tokenVaultB: TAccountMetas[8];\n    feeTier: TAccountMetas[9];\n    tokenProgramA: TAccountMetas[10];\n    tokenProgramB: TAccountMetas[11];\n    systemProgram: TAccountMetas[12];\n    rent: TAccountMetas[13];\n  };\n  data: InitializePoolV2InstructionData;\n};\n\nexport function parseInitializePoolV2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializePoolV2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 14) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpoolsConfig: getNextAccount(),\n      tokenMintA: getNextAccount(),\n      tokenMintB: getNextAccount(),\n      tokenBadgeA: getNextAccount(),\n      tokenBadgeB: getNextAccount(),\n      funder: getNextAccount(),\n      whirlpool: getNextAccount(),\n      tokenVaultA: getNextAccount(),\n      tokenVaultB: getNextAccount(),\n      feeTier: getNextAccount(),\n      tokenProgramA: getNextAccount(),\n      tokenProgramB: getNextAccount(),\n      systemProgram: getNextAccount(),\n      rent: getNextAccount(),\n    },\n    data: getInitializePoolV2InstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU128Decoder,\n  getU128Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_POOL_WITH_ADAPTIVE_FEE_DISCRIMINATOR = new Uint8Array([\n  143, 94, 96, 76, 172, 124, 119, 199,\n]);\n\nexport function getInitializePoolWithAdaptiveFeeDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    INITIALIZE_POOL_WITH_ADAPTIVE_FEE_DISCRIMINATOR\n  );\n}\n\nexport type InitializePoolWithAdaptiveFeeInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpoolsConfig extends string | IAccountMeta<string> = string,\n  TAccountTokenMintA extends string | IAccountMeta<string> = string,\n  TAccountTokenMintB extends string | IAccountMeta<string> = string,\n  TAccountTokenBadgeA extends string | IAccountMeta<string> = string,\n  TAccountTokenBadgeB extends string | IAccountMeta<string> = string,\n  TAccountFunder extends string | IAccountMeta<string> = string,\n  TAccountInitializePoolAuthority extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountOracle extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultA extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultB extends string | IAccountMeta<string> = string,\n  TAccountAdaptiveFeeTier extends string | IAccountMeta<string> = string,\n  TAccountTokenProgramA extends string | IAccountMeta<string> = string,\n  TAccountTokenProgramB extends string | IAccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TAccountRent extends\n    | string\n    | IAccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpoolsConfig extends string\n        ? ReadonlyAccount<TAccountWhirlpoolsConfig>\n        : TAccountWhirlpoolsConfig,\n      TAccountTokenMintA extends string\n        ? ReadonlyAccount<TAccountTokenMintA>\n        : TAccountTokenMintA,\n      TAccountTokenMintB extends string\n        ? ReadonlyAccount<TAccountTokenMintB>\n        : TAccountTokenMintB,\n      TAccountTokenBadgeA extends string\n        ? ReadonlyAccount<TAccountTokenBadgeA>\n        : TAccountTokenBadgeA,\n      TAccountTokenBadgeB extends string\n        ? ReadonlyAccount<TAccountTokenBadgeB>\n        : TAccountTokenBadgeB,\n      TAccountFunder extends string\n        ? WritableSignerAccount<TAccountFunder> &\n            IAccountSignerMeta<TAccountFunder>\n        : TAccountFunder,\n      TAccountInitializePoolAuthority extends string\n        ? ReadonlySignerAccount<TAccountInitializePoolAuthority> &\n            IAccountSignerMeta<TAccountInitializePoolAuthority>\n        : TAccountInitializePoolAuthority,\n      TAccountWhirlpool extends string\n        ? WritableAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountOracle extends string\n        ? WritableAccount<TAccountOracle>\n        : TAccountOracle,\n      TAccountTokenVaultA extends string\n        ? WritableSignerAccount<TAccountTokenVaultA> &\n            IAccountSignerMeta<TAccountTokenVaultA>\n        : TAccountTokenVaultA,\n      TAccountTokenVaultB extends string\n        ? WritableSignerAccount<TAccountTokenVaultB> &\n            IAccountSignerMeta<TAccountTokenVaultB>\n        : TAccountTokenVaultB,\n      TAccountAdaptiveFeeTier extends string\n        ? ReadonlyAccount<TAccountAdaptiveFeeTier>\n        : TAccountAdaptiveFeeTier,\n      TAccountTokenProgramA extends string\n        ? ReadonlyAccount<TAccountTokenProgramA>\n        : TAccountTokenProgramA,\n      TAccountTokenProgramB extends string\n        ? ReadonlyAccount<TAccountTokenProgramB>\n        : TAccountTokenProgramB,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializePoolWithAdaptiveFeeInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  initialSqrtPrice: bigint;\n  tradeEnableTimestamp: Option<bigint>;\n};\n\nexport type InitializePoolWithAdaptiveFeeInstructionDataArgs = {\n  initialSqrtPrice: number | bigint;\n  tradeEnableTimestamp: OptionOrNullable<number | bigint>;\n};\n\nexport function getInitializePoolWithAdaptiveFeeInstructionDataEncoder(): Encoder<InitializePoolWithAdaptiveFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['initialSqrtPrice', getU128Encoder()],\n      ['tradeEnableTimestamp', getOptionEncoder(getU64Encoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_POOL_WITH_ADAPTIVE_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializePoolWithAdaptiveFeeInstructionDataDecoder(): Decoder<InitializePoolWithAdaptiveFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['initialSqrtPrice', getU128Decoder()],\n    ['tradeEnableTimestamp', getOptionDecoder(getU64Decoder())],\n  ]);\n}\n\nexport function getInitializePoolWithAdaptiveFeeInstructionDataCodec(): Codec<\n  InitializePoolWithAdaptiveFeeInstructionDataArgs,\n  InitializePoolWithAdaptiveFeeInstructionData\n> {\n  return combineCodec(\n    getInitializePoolWithAdaptiveFeeInstructionDataEncoder(),\n    getInitializePoolWithAdaptiveFeeInstructionDataDecoder()\n  );\n}\n\nexport type InitializePoolWithAdaptiveFeeInput<\n  TAccountWhirlpoolsConfig extends string = string,\n  TAccountTokenMintA extends string = string,\n  TAccountTokenMintB extends string = string,\n  TAccountTokenBadgeA extends string = string,\n  TAccountTokenBadgeB extends string = string,\n  TAccountFunder extends string = string,\n  TAccountInitializePoolAuthority extends string = string,\n  TAccountWhirlpool extends string = string,\n  TAccountOracle extends string = string,\n  TAccountTokenVaultA extends string = string,\n  TAccountTokenVaultB extends string = string,\n  TAccountAdaptiveFeeTier extends string = string,\n  TAccountTokenProgramA extends string = string,\n  TAccountTokenProgramB extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountRent extends string = string,\n> = {\n  whirlpoolsConfig: Address<TAccountWhirlpoolsConfig>;\n  tokenMintA: Address<TAccountTokenMintA>;\n  tokenMintB: Address<TAccountTokenMintB>;\n  tokenBadgeA: Address<TAccountTokenBadgeA>;\n  tokenBadgeB: Address<TAccountTokenBadgeB>;\n  funder: TransactionSigner<TAccountFunder>;\n  initializePoolAuthority: TransactionSigner<TAccountInitializePoolAuthority>;\n  whirlpool: Address<TAccountWhirlpool>;\n  oracle: Address<TAccountOracle>;\n  tokenVaultA: TransactionSigner<TAccountTokenVaultA>;\n  tokenVaultB: TransactionSigner<TAccountTokenVaultB>;\n  adaptiveFeeTier: Address<TAccountAdaptiveFeeTier>;\n  tokenProgramA: Address<TAccountTokenProgramA>;\n  tokenProgramB: Address<TAccountTokenProgramB>;\n  systemProgram?: Address<TAccountSystemProgram>;\n  rent?: Address<TAccountRent>;\n  initialSqrtPrice: InitializePoolWithAdaptiveFeeInstructionDataArgs['initialSqrtPrice'];\n  tradeEnableTimestamp: InitializePoolWithAdaptiveFeeInstructionDataArgs['tradeEnableTimestamp'];\n};\n\nexport function getInitializePoolWithAdaptiveFeeInstruction<\n  TAccountWhirlpoolsConfig extends string,\n  TAccountTokenMintA extends string,\n  TAccountTokenMintB extends string,\n  TAccountTokenBadgeA extends string,\n  TAccountTokenBadgeB extends string,\n  TAccountFunder extends string,\n  TAccountInitializePoolAuthority extends string,\n  TAccountWhirlpool extends string,\n  TAccountOracle extends string,\n  TAccountTokenVaultA extends string,\n  TAccountTokenVaultB extends string,\n  TAccountAdaptiveFeeTier extends string,\n  TAccountTokenProgramA extends string,\n  TAccountTokenProgramB extends string,\n  TAccountSystemProgram extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: InitializePoolWithAdaptiveFeeInput<\n    TAccountWhirlpoolsConfig,\n    TAccountTokenMintA,\n    TAccountTokenMintB,\n    TAccountTokenBadgeA,\n    TAccountTokenBadgeB,\n    TAccountFunder,\n    TAccountInitializePoolAuthority,\n    TAccountWhirlpool,\n    TAccountOracle,\n    TAccountTokenVaultA,\n    TAccountTokenVaultB,\n    TAccountAdaptiveFeeTier,\n    TAccountTokenProgramA,\n    TAccountTokenProgramB,\n    TAccountSystemProgram,\n    TAccountRent\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializePoolWithAdaptiveFeeInstruction<\n  TProgramAddress,\n  TAccountWhirlpoolsConfig,\n  TAccountTokenMintA,\n  TAccountTokenMintB,\n  TAccountTokenBadgeA,\n  TAccountTokenBadgeB,\n  TAccountFunder,\n  TAccountInitializePoolAuthority,\n  TAccountWhirlpool,\n  TAccountOracle,\n  TAccountTokenVaultA,\n  TAccountTokenVaultB,\n  TAccountAdaptiveFeeTier,\n  TAccountTokenProgramA,\n  TAccountTokenProgramB,\n  TAccountSystemProgram,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpoolsConfig: {\n      value: input.whirlpoolsConfig ?? null,\n      isWritable: false,\n    },\n    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },\n    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },\n    tokenBadgeA: { value: input.tokenBadgeA ?? null, isWritable: false },\n    tokenBadgeB: { value: input.tokenBadgeB ?? null, isWritable: false },\n    funder: { value: input.funder ?? null, isWritable: true },\n    initializePoolAuthority: {\n      value: input.initializePoolAuthority ?? null,\n      isWritable: false,\n    },\n    whirlpool: { value: input.whirlpool ?? null, isWritable: true },\n    oracle: { value: input.oracle ?? null, isWritable: true },\n    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },\n    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },\n    adaptiveFeeTier: {\n      value: input.adaptiveFeeTier ?? null,\n      isWritable: false,\n    },\n    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },\n    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpoolsConfig),\n      getAccountMeta(accounts.tokenMintA),\n      getAccountMeta(accounts.tokenMintB),\n      getAccountMeta(accounts.tokenBadgeA),\n      getAccountMeta(accounts.tokenBadgeB),\n      getAccountMeta(accounts.funder),\n      getAccountMeta(accounts.initializePoolAuthority),\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.oracle),\n      getAccountMeta(accounts.tokenVaultA),\n      getAccountMeta(accounts.tokenVaultB),\n      getAccountMeta(accounts.adaptiveFeeTier),\n      getAccountMeta(accounts.tokenProgramA),\n      getAccountMeta(accounts.tokenProgramB),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.rent),\n    ],\n    programAddress,\n    data: getInitializePoolWithAdaptiveFeeInstructionDataEncoder().encode(\n      args as InitializePoolWithAdaptiveFeeInstructionDataArgs\n    ),\n  } as InitializePoolWithAdaptiveFeeInstruction<\n    TProgramAddress,\n    TAccountWhirlpoolsConfig,\n    TAccountTokenMintA,\n    TAccountTokenMintB,\n    TAccountTokenBadgeA,\n    TAccountTokenBadgeB,\n    TAccountFunder,\n    TAccountInitializePoolAuthority,\n    TAccountWhirlpool,\n    TAccountOracle,\n    TAccountTokenVaultA,\n    TAccountTokenVaultB,\n    TAccountAdaptiveFeeTier,\n    TAccountTokenProgramA,\n    TAccountTokenProgramB,\n    TAccountSystemProgram,\n    TAccountRent\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializePoolWithAdaptiveFeeInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpoolsConfig: TAccountMetas[0];\n    tokenMintA: TAccountMetas[1];\n    tokenMintB: TAccountMetas[2];\n    tokenBadgeA: TAccountMetas[3];\n    tokenBadgeB: TAccountMetas[4];\n    funder: TAccountMetas[5];\n    initializePoolAuthority: TAccountMetas[6];\n    whirlpool: TAccountMetas[7];\n    oracle: TAccountMetas[8];\n    tokenVaultA: TAccountMetas[9];\n    tokenVaultB: TAccountMetas[10];\n    adaptiveFeeTier: TAccountMetas[11];\n    tokenProgramA: TAccountMetas[12];\n    tokenProgramB: TAccountMetas[13];\n    systemProgram: TAccountMetas[14];\n    rent: TAccountMetas[15];\n  };\n  data: InitializePoolWithAdaptiveFeeInstructionData;\n};\n\nexport function parseInitializePoolWithAdaptiveFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializePoolWithAdaptiveFeeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 16) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpoolsConfig: getNextAccount(),\n      tokenMintA: getNextAccount(),\n      tokenMintB: getNextAccount(),\n      tokenBadgeA: getNextAccount(),\n      tokenBadgeB: getNextAccount(),\n      funder: getNextAccount(),\n      initializePoolAuthority: getNextAccount(),\n      whirlpool: getNextAccount(),\n      oracle: getNextAccount(),\n      tokenVaultA: getNextAccount(),\n      tokenVaultB: getNextAccount(),\n      adaptiveFeeTier: getNextAccount(),\n      tokenProgramA: getNextAccount(),\n      tokenProgramB: getNextAccount(),\n      systemProgram: getNextAccount(),\n      rent: getNextAccount(),\n    },\n    data: getInitializePoolWithAdaptiveFeeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_POSITION_BUNDLE_DISCRIMINATOR = new Uint8Array([\n  117, 45, 241, 149, 24, 18, 194, 65,\n]);\n\nexport function getInitializePositionBundleDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    INITIALIZE_POSITION_BUNDLE_DISCRIMINATOR\n  );\n}\n\nexport type InitializePositionBundleInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountPositionBundle extends string | IAccountMeta<string> = string,\n  TAccountPositionBundleMint extends string | IAccountMeta<string> = string,\n  TAccountPositionBundleTokenAccount extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountPositionBundleOwner extends string | IAccountMeta<string> = string,\n  TAccountFunder extends string | IAccountMeta<string> = string,\n  TAccountTokenProgram extends\n    | string\n    | IAccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TAccountRent extends\n    | string\n    | IAccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TAccountAssociatedTokenProgram extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountPositionBundle extends string\n        ? WritableAccount<TAccountPositionBundle>\n        : TAccountPositionBundle,\n      TAccountPositionBundleMint extends string\n        ? WritableSignerAccount<TAccountPositionBundleMint> &\n            IAccountSignerMeta<TAccountPositionBundleMint>\n        : TAccountPositionBundleMint,\n      TAccountPositionBundleTokenAccount extends string\n        ? WritableAccount<TAccountPositionBundleTokenAccount>\n        : TAccountPositionBundleTokenAccount,\n      TAccountPositionBundleOwner extends string\n        ? ReadonlyAccount<TAccountPositionBundleOwner>\n        : TAccountPositionBundleOwner,\n      TAccountFunder extends string\n        ? WritableSignerAccount<TAccountFunder> &\n            IAccountSignerMeta<TAccountFunder>\n        : TAccountFunder,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      TAccountAssociatedTokenProgram extends string\n        ? ReadonlyAccount<TAccountAssociatedTokenProgram>\n        : TAccountAssociatedTokenProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializePositionBundleInstructionData = {\n  discriminator: ReadonlyUint8Array;\n};\n\nexport type InitializePositionBundleInstructionDataArgs = {};\n\nexport function getInitializePositionBundleInstructionDataEncoder(): Encoder<InitializePositionBundleInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_POSITION_BUNDLE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializePositionBundleInstructionDataDecoder(): Decoder<InitializePositionBundleInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n  ]);\n}\n\nexport function getInitializePositionBundleInstructionDataCodec(): Codec<\n  InitializePositionBundleInstructionDataArgs,\n  InitializePositionBundleInstructionData\n> {\n  return combineCodec(\n    getInitializePositionBundleInstructionDataEncoder(),\n    getInitializePositionBundleInstructionDataDecoder()\n  );\n}\n\nexport type InitializePositionBundleInput<\n  TAccountPositionBundle extends string = string,\n  TAccountPositionBundleMint extends string = string,\n  TAccountPositionBundleTokenAccount extends string = string,\n  TAccountPositionBundleOwner extends string = string,\n  TAccountFunder extends string = string,\n  TAccountTokenProgram extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountRent extends string = string,\n  TAccountAssociatedTokenProgram extends string = string,\n> = {\n  positionBundle: Address<TAccountPositionBundle>;\n  positionBundleMint: TransactionSigner<TAccountPositionBundleMint>;\n  positionBundleTokenAccount: Address<TAccountPositionBundleTokenAccount>;\n  positionBundleOwner: Address<TAccountPositionBundleOwner>;\n  funder: TransactionSigner<TAccountFunder>;\n  tokenProgram?: Address<TAccountTokenProgram>;\n  systemProgram?: Address<TAccountSystemProgram>;\n  rent?: Address<TAccountRent>;\n  associatedTokenProgram: Address<TAccountAssociatedTokenProgram>;\n};\n\nexport function getInitializePositionBundleInstruction<\n  TAccountPositionBundle extends string,\n  TAccountPositionBundleMint extends string,\n  TAccountPositionBundleTokenAccount extends string,\n  TAccountPositionBundleOwner extends string,\n  TAccountFunder extends string,\n  TAccountTokenProgram extends string,\n  TAccountSystemProgram extends string,\n  TAccountRent extends string,\n  TAccountAssociatedTokenProgram extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: InitializePositionBundleInput<\n    TAccountPositionBundle,\n    TAccountPositionBundleMint,\n    TAccountPositionBundleTokenAccount,\n    TAccountPositionBundleOwner,\n    TAccountFunder,\n    TAccountTokenProgram,\n    TAccountSystemProgram,\n    TAccountRent,\n    TAccountAssociatedTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializePositionBundleInstruction<\n  TProgramAddress,\n  TAccountPositionBundle,\n  TAccountPositionBundleMint,\n  TAccountPositionBundleTokenAccount,\n  TAccountPositionBundleOwner,\n  TAccountFunder,\n  TAccountTokenProgram,\n  TAccountSystemProgram,\n  TAccountRent,\n  TAccountAssociatedTokenProgram\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    positionBundle: { value: input.positionBundle ?? null, isWritable: true },\n    positionBundleMint: {\n      value: input.positionBundleMint ?? null,\n      isWritable: true,\n    },\n    positionBundleTokenAccount: {\n      value: input.positionBundleTokenAccount ?? null,\n      isWritable: true,\n    },\n    positionBundleOwner: {\n      value: input.positionBundleOwner ?? null,\n      isWritable: false,\n    },\n    funder: { value: input.funder ?? null, isWritable: true },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false },\n    associatedTokenProgram: {\n      value: input.associatedTokenProgram ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.positionBundle),\n      getAccountMeta(accounts.positionBundleMint),\n      getAccountMeta(accounts.positionBundleTokenAccount),\n      getAccountMeta(accounts.positionBundleOwner),\n      getAccountMeta(accounts.funder),\n      getAccountMeta(accounts.tokenProgram),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.rent),\n      getAccountMeta(accounts.associatedTokenProgram),\n    ],\n    programAddress,\n    data: getInitializePositionBundleInstructionDataEncoder().encode({}),\n  } as InitializePositionBundleInstruction<\n    TProgramAddress,\n    TAccountPositionBundle,\n    TAccountPositionBundleMint,\n    TAccountPositionBundleTokenAccount,\n    TAccountPositionBundleOwner,\n    TAccountFunder,\n    TAccountTokenProgram,\n    TAccountSystemProgram,\n    TAccountRent,\n    TAccountAssociatedTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializePositionBundleInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    positionBundle: TAccountMetas[0];\n    positionBundleMint: TAccountMetas[1];\n    positionBundleTokenAccount: TAccountMetas[2];\n    positionBundleOwner: TAccountMetas[3];\n    funder: TAccountMetas[4];\n    tokenProgram: TAccountMetas[5];\n    systemProgram: TAccountMetas[6];\n    rent: TAccountMetas[7];\n    associatedTokenProgram: TAccountMetas[8];\n  };\n  data: InitializePositionBundleInstructionData;\n};\n\nexport function parseInitializePositionBundleInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializePositionBundleInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 9) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      positionBundle: getNextAccount(),\n      positionBundleMint: getNextAccount(),\n      positionBundleTokenAccount: getNextAccount(),\n      positionBundleOwner: getNextAccount(),\n      funder: getNextAccount(),\n      tokenProgram: getNextAccount(),\n      systemProgram: getNextAccount(),\n      rent: getNextAccount(),\n      associatedTokenProgram: getNextAccount(),\n    },\n    data: getInitializePositionBundleInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_POSITION_BUNDLE_WITH_METADATA_DISCRIMINATOR =\n  new Uint8Array([93, 124, 16, 179, 249, 131, 115, 245]);\n\nexport function getInitializePositionBundleWithMetadataDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    INITIALIZE_POSITION_BUNDLE_WITH_METADATA_DISCRIMINATOR\n  );\n}\n\nexport type InitializePositionBundleWithMetadataInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountPositionBundle extends string | IAccountMeta<string> = string,\n  TAccountPositionBundleMint extends string | IAccountMeta<string> = string,\n  TAccountPositionBundleMetadata extends string | IAccountMeta<string> = string,\n  TAccountPositionBundleTokenAccount extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountPositionBundleOwner extends string | IAccountMeta<string> = string,\n  TAccountFunder extends string | IAccountMeta<string> = string,\n  TAccountMetadataUpdateAuth extends string | IAccountMeta<string> = string,\n  TAccountTokenProgram extends\n    | string\n    | IAccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TAccountRent extends\n    | string\n    | IAccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TAccountAssociatedTokenProgram extends string | IAccountMeta<string> = string,\n  TAccountMetadataProgram extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountPositionBundle extends string\n        ? WritableAccount<TAccountPositionBundle>\n        : TAccountPositionBundle,\n      TAccountPositionBundleMint extends string\n        ? WritableSignerAccount<TAccountPositionBundleMint> &\n            IAccountSignerMeta<TAccountPositionBundleMint>\n        : TAccountPositionBundleMint,\n      TAccountPositionBundleMetadata extends string\n        ? WritableAccount<TAccountPositionBundleMetadata>\n        : TAccountPositionBundleMetadata,\n      TAccountPositionBundleTokenAccount extends string\n        ? WritableAccount<TAccountPositionBundleTokenAccount>\n        : TAccountPositionBundleTokenAccount,\n      TAccountPositionBundleOwner extends string\n        ? ReadonlyAccount<TAccountPositionBundleOwner>\n        : TAccountPositionBundleOwner,\n      TAccountFunder extends string\n        ? WritableSignerAccount<TAccountFunder> &\n            IAccountSignerMeta<TAccountFunder>\n        : TAccountFunder,\n      TAccountMetadataUpdateAuth extends string\n        ? ReadonlyAccount<TAccountMetadataUpdateAuth>\n        : TAccountMetadataUpdateAuth,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      TAccountAssociatedTokenProgram extends string\n        ? ReadonlyAccount<TAccountAssociatedTokenProgram>\n        : TAccountAssociatedTokenProgram,\n      TAccountMetadataProgram extends string\n        ? ReadonlyAccount<TAccountMetadataProgram>\n        : TAccountMetadataProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializePositionBundleWithMetadataInstructionData = {\n  discriminator: ReadonlyUint8Array;\n};\n\nexport type InitializePositionBundleWithMetadataInstructionDataArgs = {};\n\nexport function getInitializePositionBundleWithMetadataInstructionDataEncoder(): Encoder<InitializePositionBundleWithMetadataInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_POSITION_BUNDLE_WITH_METADATA_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializePositionBundleWithMetadataInstructionDataDecoder(): Decoder<InitializePositionBundleWithMetadataInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n  ]);\n}\n\nexport function getInitializePositionBundleWithMetadataInstructionDataCodec(): Codec<\n  InitializePositionBundleWithMetadataInstructionDataArgs,\n  InitializePositionBundleWithMetadataInstructionData\n> {\n  return combineCodec(\n    getInitializePositionBundleWithMetadataInstructionDataEncoder(),\n    getInitializePositionBundleWithMetadataInstructionDataDecoder()\n  );\n}\n\nexport type InitializePositionBundleWithMetadataInput<\n  TAccountPositionBundle extends string = string,\n  TAccountPositionBundleMint extends string = string,\n  TAccountPositionBundleMetadata extends string = string,\n  TAccountPositionBundleTokenAccount extends string = string,\n  TAccountPositionBundleOwner extends string = string,\n  TAccountFunder extends string = string,\n  TAccountMetadataUpdateAuth extends string = string,\n  TAccountTokenProgram extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountRent extends string = string,\n  TAccountAssociatedTokenProgram extends string = string,\n  TAccountMetadataProgram extends string = string,\n> = {\n  positionBundle: Address<TAccountPositionBundle>;\n  positionBundleMint: TransactionSigner<TAccountPositionBundleMint>;\n  /** https://github.com/metaplex-foundation/metaplex-program-library/blob/773a574c4b34e5b9f248a81306ec24db064e255f/token-metadata/program/src/utils/metadata.rs#L100 */\n  positionBundleMetadata: Address<TAccountPositionBundleMetadata>;\n  positionBundleTokenAccount: Address<TAccountPositionBundleTokenAccount>;\n  positionBundleOwner: Address<TAccountPositionBundleOwner>;\n  funder: TransactionSigner<TAccountFunder>;\n  metadataUpdateAuth: Address<TAccountMetadataUpdateAuth>;\n  tokenProgram?: Address<TAccountTokenProgram>;\n  systemProgram?: Address<TAccountSystemProgram>;\n  rent?: Address<TAccountRent>;\n  associatedTokenProgram: Address<TAccountAssociatedTokenProgram>;\n  metadataProgram: Address<TAccountMetadataProgram>;\n};\n\nexport function getInitializePositionBundleWithMetadataInstruction<\n  TAccountPositionBundle extends string,\n  TAccountPositionBundleMint extends string,\n  TAccountPositionBundleMetadata extends string,\n  TAccountPositionBundleTokenAccount extends string,\n  TAccountPositionBundleOwner extends string,\n  TAccountFunder extends string,\n  TAccountMetadataUpdateAuth extends string,\n  TAccountTokenProgram extends string,\n  TAccountSystemProgram extends string,\n  TAccountRent extends string,\n  TAccountAssociatedTokenProgram extends string,\n  TAccountMetadataProgram extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: InitializePositionBundleWithMetadataInput<\n    TAccountPositionBundle,\n    TAccountPositionBundleMint,\n    TAccountPositionBundleMetadata,\n    TAccountPositionBundleTokenAccount,\n    TAccountPositionBundleOwner,\n    TAccountFunder,\n    TAccountMetadataUpdateAuth,\n    TAccountTokenProgram,\n    TAccountSystemProgram,\n    TAccountRent,\n    TAccountAssociatedTokenProgram,\n    TAccountMetadataProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializePositionBundleWithMetadataInstruction<\n  TProgramAddress,\n  TAccountPositionBundle,\n  TAccountPositionBundleMint,\n  TAccountPositionBundleMetadata,\n  TAccountPositionBundleTokenAccount,\n  TAccountPositionBundleOwner,\n  TAccountFunder,\n  TAccountMetadataUpdateAuth,\n  TAccountTokenProgram,\n  TAccountSystemProgram,\n  TAccountRent,\n  TAccountAssociatedTokenProgram,\n  TAccountMetadataProgram\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    positionBundle: { value: input.positionBundle ?? null, isWritable: true },\n    positionBundleMint: {\n      value: input.positionBundleMint ?? null,\n      isWritable: true,\n    },\n    positionBundleMetadata: {\n      value: input.positionBundleMetadata ?? null,\n      isWritable: true,\n    },\n    positionBundleTokenAccount: {\n      value: input.positionBundleTokenAccount ?? null,\n      isWritable: true,\n    },\n    positionBundleOwner: {\n      value: input.positionBundleOwner ?? null,\n      isWritable: false,\n    },\n    funder: { value: input.funder ?? null, isWritable: true },\n    metadataUpdateAuth: {\n      value: input.metadataUpdateAuth ?? null,\n      isWritable: false,\n    },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false },\n    associatedTokenProgram: {\n      value: input.associatedTokenProgram ?? null,\n      isWritable: false,\n    },\n    metadataProgram: {\n      value: input.metadataProgram ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.positionBundle),\n      getAccountMeta(accounts.positionBundleMint),\n      getAccountMeta(accounts.positionBundleMetadata),\n      getAccountMeta(accounts.positionBundleTokenAccount),\n      getAccountMeta(accounts.positionBundleOwner),\n      getAccountMeta(accounts.funder),\n      getAccountMeta(accounts.metadataUpdateAuth),\n      getAccountMeta(accounts.tokenProgram),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.rent),\n      getAccountMeta(accounts.associatedTokenProgram),\n      getAccountMeta(accounts.metadataProgram),\n    ],\n    programAddress,\n    data: getInitializePositionBundleWithMetadataInstructionDataEncoder().encode(\n      {}\n    ),\n  } as InitializePositionBundleWithMetadataInstruction<\n    TProgramAddress,\n    TAccountPositionBundle,\n    TAccountPositionBundleMint,\n    TAccountPositionBundleMetadata,\n    TAccountPositionBundleTokenAccount,\n    TAccountPositionBundleOwner,\n    TAccountFunder,\n    TAccountMetadataUpdateAuth,\n    TAccountTokenProgram,\n    TAccountSystemProgram,\n    TAccountRent,\n    TAccountAssociatedTokenProgram,\n    TAccountMetadataProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializePositionBundleWithMetadataInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    positionBundle: TAccountMetas[0];\n    positionBundleMint: TAccountMetas[1];\n    /** https://github.com/metaplex-foundation/metaplex-program-library/blob/773a574c4b34e5b9f248a81306ec24db064e255f/token-metadata/program/src/utils/metadata.rs#L100 */\n    positionBundleMetadata: TAccountMetas[2];\n    positionBundleTokenAccount: TAccountMetas[3];\n    positionBundleOwner: TAccountMetas[4];\n    funder: TAccountMetas[5];\n    metadataUpdateAuth: TAccountMetas[6];\n    tokenProgram: TAccountMetas[7];\n    systemProgram: TAccountMetas[8];\n    rent: TAccountMetas[9];\n    associatedTokenProgram: TAccountMetas[10];\n    metadataProgram: TAccountMetas[11];\n  };\n  data: InitializePositionBundleWithMetadataInstructionData;\n};\n\nexport function parseInitializePositionBundleWithMetadataInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializePositionBundleWithMetadataInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 12) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      positionBundle: getNextAccount(),\n      positionBundleMint: getNextAccount(),\n      positionBundleMetadata: getNextAccount(),\n      positionBundleTokenAccount: getNextAccount(),\n      positionBundleOwner: getNextAccount(),\n      funder: getNextAccount(),\n      metadataUpdateAuth: getNextAccount(),\n      tokenProgram: getNextAccount(),\n      systemProgram: getNextAccount(),\n      rent: getNextAccount(),\n      associatedTokenProgram: getNextAccount(),\n      metadataProgram: getNextAccount(),\n    },\n    data: getInitializePositionBundleWithMetadataInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_REWARD_DISCRIMINATOR = new Uint8Array([\n  95, 135, 192, 196, 242, 129, 230, 68,\n]);\n\nexport function getInitializeRewardDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    INITIALIZE_REWARD_DISCRIMINATOR\n  );\n}\n\nexport type InitializeRewardInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountRewardAuthority extends string | IAccountMeta<string> = string,\n  TAccountFunder extends string | IAccountMeta<string> = string,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountRewardMint extends string | IAccountMeta<string> = string,\n  TAccountRewardVault extends string | IAccountMeta<string> = string,\n  TAccountTokenProgram extends\n    | string\n    | IAccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TAccountRent extends\n    | string\n    | IAccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountRewardAuthority extends string\n        ? ReadonlySignerAccount<TAccountRewardAuthority> &\n            IAccountSignerMeta<TAccountRewardAuthority>\n        : TAccountRewardAuthority,\n      TAccountFunder extends string\n        ? WritableSignerAccount<TAccountFunder> &\n            IAccountSignerMeta<TAccountFunder>\n        : TAccountFunder,\n      TAccountWhirlpool extends string\n        ? WritableAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountRewardMint extends string\n        ? ReadonlyAccount<TAccountRewardMint>\n        : TAccountRewardMint,\n      TAccountRewardVault extends string\n        ? WritableSignerAccount<TAccountRewardVault> &\n            IAccountSignerMeta<TAccountRewardVault>\n        : TAccountRewardVault,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeRewardInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  rewardIndex: number;\n};\n\nexport type InitializeRewardInstructionDataArgs = { rewardIndex: number };\n\nexport function getInitializeRewardInstructionDataEncoder(): Encoder<InitializeRewardInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['rewardIndex', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_REWARD_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeRewardInstructionDataDecoder(): Decoder<InitializeRewardInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['rewardIndex', getU8Decoder()],\n  ]);\n}\n\nexport function getInitializeRewardInstructionDataCodec(): Codec<\n  InitializeRewardInstructionDataArgs,\n  InitializeRewardInstructionData\n> {\n  return combineCodec(\n    getInitializeRewardInstructionDataEncoder(),\n    getInitializeRewardInstructionDataDecoder()\n  );\n}\n\nexport type InitializeRewardInput<\n  TAccountRewardAuthority extends string = string,\n  TAccountFunder extends string = string,\n  TAccountWhirlpool extends string = string,\n  TAccountRewardMint extends string = string,\n  TAccountRewardVault extends string = string,\n  TAccountTokenProgram extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountRent extends string = string,\n> = {\n  rewardAuthority: TransactionSigner<TAccountRewardAuthority>;\n  funder: TransactionSigner<TAccountFunder>;\n  whirlpool: Address<TAccountWhirlpool>;\n  rewardMint: Address<TAccountRewardMint>;\n  rewardVault: TransactionSigner<TAccountRewardVault>;\n  tokenProgram?: Address<TAccountTokenProgram>;\n  systemProgram?: Address<TAccountSystemProgram>;\n  rent?: Address<TAccountRent>;\n  rewardIndex: InitializeRewardInstructionDataArgs['rewardIndex'];\n};\n\nexport function getInitializeRewardInstruction<\n  TAccountRewardAuthority extends string,\n  TAccountFunder extends string,\n  TAccountWhirlpool extends string,\n  TAccountRewardMint extends string,\n  TAccountRewardVault extends string,\n  TAccountTokenProgram extends string,\n  TAccountSystemProgram extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: InitializeRewardInput<\n    TAccountRewardAuthority,\n    TAccountFunder,\n    TAccountWhirlpool,\n    TAccountRewardMint,\n    TAccountRewardVault,\n    TAccountTokenProgram,\n    TAccountSystemProgram,\n    TAccountRent\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeRewardInstruction<\n  TProgramAddress,\n  TAccountRewardAuthority,\n  TAccountFunder,\n  TAccountWhirlpool,\n  TAccountRewardMint,\n  TAccountRewardVault,\n  TAccountTokenProgram,\n  TAccountSystemProgram,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    rewardAuthority: {\n      value: input.rewardAuthority ?? null,\n      isWritable: false,\n    },\n    funder: { value: input.funder ?? null, isWritable: true },\n    whirlpool: { value: input.whirlpool ?? null, isWritable: true },\n    rewardMint: { value: input.rewardMint ?? null, isWritable: false },\n    rewardVault: { value: input.rewardVault ?? null, isWritable: true },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.rewardAuthority),\n      getAccountMeta(accounts.funder),\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.rewardMint),\n      getAccountMeta(accounts.rewardVault),\n      getAccountMeta(accounts.tokenProgram),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.rent),\n    ],\n    programAddress,\n    data: getInitializeRewardInstructionDataEncoder().encode(\n      args as InitializeRewardInstructionDataArgs\n    ),\n  } as InitializeRewardInstruction<\n    TProgramAddress,\n    TAccountRewardAuthority,\n    TAccountFunder,\n    TAccountWhirlpool,\n    TAccountRewardMint,\n    TAccountRewardVault,\n    TAccountTokenProgram,\n    TAccountSystemProgram,\n    TAccountRent\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeRewardInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    rewardAuthority: TAccountMetas[0];\n    funder: TAccountMetas[1];\n    whirlpool: TAccountMetas[2];\n    rewardMint: TAccountMetas[3];\n    rewardVault: TAccountMetas[4];\n    tokenProgram: TAccountMetas[5];\n    systemProgram: TAccountMetas[6];\n    rent: TAccountMetas[7];\n  };\n  data: InitializeRewardInstructionData;\n};\n\nexport function parseInitializeRewardInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeRewardInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 8) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      rewardAuthority: getNextAccount(),\n      funder: getNextAccount(),\n      whirlpool: getNextAccount(),\n      rewardMint: getNextAccount(),\n      rewardVault: getNextAccount(),\n      tokenProgram: getNextAccount(),\n      systemProgram: getNextAccount(),\n      rent: getNextAccount(),\n    },\n    data: getInitializeRewardInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_REWARD_V2_DISCRIMINATOR = new Uint8Array([\n  91, 1, 77, 50, 235, 229, 133, 49,\n]);\n\nexport function getInitializeRewardV2DiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    INITIALIZE_REWARD_V2_DISCRIMINATOR\n  );\n}\n\nexport type InitializeRewardV2Instruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountRewardAuthority extends string | IAccountMeta<string> = string,\n  TAccountFunder extends string | IAccountMeta<string> = string,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountRewardMint extends string | IAccountMeta<string> = string,\n  TAccountRewardTokenBadge extends string | IAccountMeta<string> = string,\n  TAccountRewardVault extends string | IAccountMeta<string> = string,\n  TAccountRewardTokenProgram extends string | IAccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TAccountRent extends\n    | string\n    | IAccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountRewardAuthority extends string\n        ? ReadonlySignerAccount<TAccountRewardAuthority> &\n            IAccountSignerMeta<TAccountRewardAuthority>\n        : TAccountRewardAuthority,\n      TAccountFunder extends string\n        ? WritableSignerAccount<TAccountFunder> &\n            IAccountSignerMeta<TAccountFunder>\n        : TAccountFunder,\n      TAccountWhirlpool extends string\n        ? WritableAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountRewardMint extends string\n        ? ReadonlyAccount<TAccountRewardMint>\n        : TAccountRewardMint,\n      TAccountRewardTokenBadge extends string\n        ? ReadonlyAccount<TAccountRewardTokenBadge>\n        : TAccountRewardTokenBadge,\n      TAccountRewardVault extends string\n        ? WritableSignerAccount<TAccountRewardVault> &\n            IAccountSignerMeta<TAccountRewardVault>\n        : TAccountRewardVault,\n      TAccountRewardTokenProgram extends string\n        ? ReadonlyAccount<TAccountRewardTokenProgram>\n        : TAccountRewardTokenProgram,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeRewardV2InstructionData = {\n  discriminator: ReadonlyUint8Array;\n  rewardIndex: number;\n};\n\nexport type InitializeRewardV2InstructionDataArgs = { rewardIndex: number };\n\nexport function getInitializeRewardV2InstructionDataEncoder(): Encoder<InitializeRewardV2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['rewardIndex', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_REWARD_V2_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeRewardV2InstructionDataDecoder(): Decoder<InitializeRewardV2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['rewardIndex', getU8Decoder()],\n  ]);\n}\n\nexport function getInitializeRewardV2InstructionDataCodec(): Codec<\n  InitializeRewardV2InstructionDataArgs,\n  InitializeRewardV2InstructionData\n> {\n  return combineCodec(\n    getInitializeRewardV2InstructionDataEncoder(),\n    getInitializeRewardV2InstructionDataDecoder()\n  );\n}\n\nexport type InitializeRewardV2Input<\n  TAccountRewardAuthority extends string = string,\n  TAccountFunder extends string = string,\n  TAccountWhirlpool extends string = string,\n  TAccountRewardMint extends string = string,\n  TAccountRewardTokenBadge extends string = string,\n  TAccountRewardVault extends string = string,\n  TAccountRewardTokenProgram extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountRent extends string = string,\n> = {\n  rewardAuthority: TransactionSigner<TAccountRewardAuthority>;\n  funder: TransactionSigner<TAccountFunder>;\n  whirlpool: Address<TAccountWhirlpool>;\n  rewardMint: Address<TAccountRewardMint>;\n  rewardTokenBadge: Address<TAccountRewardTokenBadge>;\n  rewardVault: TransactionSigner<TAccountRewardVault>;\n  rewardTokenProgram: Address<TAccountRewardTokenProgram>;\n  systemProgram?: Address<TAccountSystemProgram>;\n  rent?: Address<TAccountRent>;\n  rewardIndex: InitializeRewardV2InstructionDataArgs['rewardIndex'];\n};\n\nexport function getInitializeRewardV2Instruction<\n  TAccountRewardAuthority extends string,\n  TAccountFunder extends string,\n  TAccountWhirlpool extends string,\n  TAccountRewardMint extends string,\n  TAccountRewardTokenBadge extends string,\n  TAccountRewardVault extends string,\n  TAccountRewardTokenProgram extends string,\n  TAccountSystemProgram extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: InitializeRewardV2Input<\n    TAccountRewardAuthority,\n    TAccountFunder,\n    TAccountWhirlpool,\n    TAccountRewardMint,\n    TAccountRewardTokenBadge,\n    TAccountRewardVault,\n    TAccountRewardTokenProgram,\n    TAccountSystemProgram,\n    TAccountRent\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeRewardV2Instruction<\n  TProgramAddress,\n  TAccountRewardAuthority,\n  TAccountFunder,\n  TAccountWhirlpool,\n  TAccountRewardMint,\n  TAccountRewardTokenBadge,\n  TAccountRewardVault,\n  TAccountRewardTokenProgram,\n  TAccountSystemProgram,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    rewardAuthority: {\n      value: input.rewardAuthority ?? null,\n      isWritable: false,\n    },\n    funder: { value: input.funder ?? null, isWritable: true },\n    whirlpool: { value: input.whirlpool ?? null, isWritable: true },\n    rewardMint: { value: input.rewardMint ?? null, isWritable: false },\n    rewardTokenBadge: {\n      value: input.rewardTokenBadge ?? null,\n      isWritable: false,\n    },\n    rewardVault: { value: input.rewardVault ?? null, isWritable: true },\n    rewardTokenProgram: {\n      value: input.rewardTokenProgram ?? null,\n      isWritable: false,\n    },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.rewardAuthority),\n      getAccountMeta(accounts.funder),\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.rewardMint),\n      getAccountMeta(accounts.rewardTokenBadge),\n      getAccountMeta(accounts.rewardVault),\n      getAccountMeta(accounts.rewardTokenProgram),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.rent),\n    ],\n    programAddress,\n    data: getInitializeRewardV2InstructionDataEncoder().encode(\n      args as InitializeRewardV2InstructionDataArgs\n    ),\n  } as InitializeRewardV2Instruction<\n    TProgramAddress,\n    TAccountRewardAuthority,\n    TAccountFunder,\n    TAccountWhirlpool,\n    TAccountRewardMint,\n    TAccountRewardTokenBadge,\n    TAccountRewardVault,\n    TAccountRewardTokenProgram,\n    TAccountSystemProgram,\n    TAccountRent\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeRewardV2Instruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    rewardAuthority: TAccountMetas[0];\n    funder: TAccountMetas[1];\n    whirlpool: TAccountMetas[2];\n    rewardMint: TAccountMetas[3];\n    rewardTokenBadge: TAccountMetas[4];\n    rewardVault: TAccountMetas[5];\n    rewardTokenProgram: TAccountMetas[6];\n    systemProgram: TAccountMetas[7];\n    rent: TAccountMetas[8];\n  };\n  data: InitializeRewardV2InstructionData;\n};\n\nexport function parseInitializeRewardV2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeRewardV2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 9) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      rewardAuthority: getNextAccount(),\n      funder: getNextAccount(),\n      whirlpool: getNextAccount(),\n      rewardMint: getNextAccount(),\n      rewardTokenBadge: getNextAccount(),\n      rewardVault: getNextAccount(),\n      rewardTokenProgram: getNextAccount(),\n      systemProgram: getNextAccount(),\n      rent: getNextAccount(),\n    },\n    data: getInitializeRewardV2InstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getI32Decoder,\n  getI32Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_TICK_ARRAY_DISCRIMINATOR = new Uint8Array([\n  11, 188, 193, 214, 141, 91, 149, 184,\n]);\n\nexport function getInitializeTickArrayDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    INITIALIZE_TICK_ARRAY_DISCRIMINATOR\n  );\n}\n\nexport type InitializeTickArrayInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountFunder extends string | IAccountMeta<string> = string,\n  TAccountTickArray extends string | IAccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpool extends string\n        ? ReadonlyAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountFunder extends string\n        ? WritableSignerAccount<TAccountFunder> &\n            IAccountSignerMeta<TAccountFunder>\n        : TAccountFunder,\n      TAccountTickArray extends string\n        ? WritableAccount<TAccountTickArray>\n        : TAccountTickArray,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeTickArrayInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  startTickIndex: number;\n};\n\nexport type InitializeTickArrayInstructionDataArgs = { startTickIndex: number };\n\nexport function getInitializeTickArrayInstructionDataEncoder(): Encoder<InitializeTickArrayInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['startTickIndex', getI32Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_TICK_ARRAY_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeTickArrayInstructionDataDecoder(): Decoder<InitializeTickArrayInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['startTickIndex', getI32Decoder()],\n  ]);\n}\n\nexport function getInitializeTickArrayInstructionDataCodec(): Codec<\n  InitializeTickArrayInstructionDataArgs,\n  InitializeTickArrayInstructionData\n> {\n  return combineCodec(\n    getInitializeTickArrayInstructionDataEncoder(),\n    getInitializeTickArrayInstructionDataDecoder()\n  );\n}\n\nexport type InitializeTickArrayInput<\n  TAccountWhirlpool extends string = string,\n  TAccountFunder extends string = string,\n  TAccountTickArray extends string = string,\n  TAccountSystemProgram extends string = string,\n> = {\n  whirlpool: Address<TAccountWhirlpool>;\n  funder: TransactionSigner<TAccountFunder>;\n  tickArray: Address<TAccountTickArray>;\n  systemProgram?: Address<TAccountSystemProgram>;\n  startTickIndex: InitializeTickArrayInstructionDataArgs['startTickIndex'];\n};\n\nexport function getInitializeTickArrayInstruction<\n  TAccountWhirlpool extends string,\n  TAccountFunder extends string,\n  TAccountTickArray extends string,\n  TAccountSystemProgram extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: InitializeTickArrayInput<\n    TAccountWhirlpool,\n    TAccountFunder,\n    TAccountTickArray,\n    TAccountSystemProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeTickArrayInstruction<\n  TProgramAddress,\n  TAccountWhirlpool,\n  TAccountFunder,\n  TAccountTickArray,\n  TAccountSystemProgram\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpool: { value: input.whirlpool ?? null, isWritable: false },\n    funder: { value: input.funder ?? null, isWritable: true },\n    tickArray: { value: input.tickArray ?? null, isWritable: true },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.funder),\n      getAccountMeta(accounts.tickArray),\n      getAccountMeta(accounts.systemProgram),\n    ],\n    programAddress,\n    data: getInitializeTickArrayInstructionDataEncoder().encode(\n      args as InitializeTickArrayInstructionDataArgs\n    ),\n  } as InitializeTickArrayInstruction<\n    TProgramAddress,\n    TAccountWhirlpool,\n    TAccountFunder,\n    TAccountTickArray,\n    TAccountSystemProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeTickArrayInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpool: TAccountMetas[0];\n    funder: TAccountMetas[1];\n    tickArray: TAccountMetas[2];\n    systemProgram: TAccountMetas[3];\n  };\n  data: InitializeTickArrayInstructionData;\n};\n\nexport function parseInitializeTickArrayInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeTickArrayInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpool: getNextAccount(),\n      funder: getNextAccount(),\n      tickArray: getNextAccount(),\n      systemProgram: getNextAccount(),\n    },\n    data: getInitializeTickArrayInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_TOKEN_BADGE_DISCRIMINATOR = new Uint8Array([\n  253, 77, 205, 95, 27, 224, 89, 223,\n]);\n\nexport function getInitializeTokenBadgeDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    INITIALIZE_TOKEN_BADGE_DISCRIMINATOR\n  );\n}\n\nexport type InitializeTokenBadgeInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpoolsConfig extends string | IAccountMeta<string> = string,\n  TAccountWhirlpoolsConfigExtension extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountTokenBadgeAuthority extends string | IAccountMeta<string> = string,\n  TAccountTokenMint extends string | IAccountMeta<string> = string,\n  TAccountTokenBadge extends string | IAccountMeta<string> = string,\n  TAccountFunder extends string | IAccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpoolsConfig extends string\n        ? ReadonlyAccount<TAccountWhirlpoolsConfig>\n        : TAccountWhirlpoolsConfig,\n      TAccountWhirlpoolsConfigExtension extends string\n        ? ReadonlyAccount<TAccountWhirlpoolsConfigExtension>\n        : TAccountWhirlpoolsConfigExtension,\n      TAccountTokenBadgeAuthority extends string\n        ? ReadonlySignerAccount<TAccountTokenBadgeAuthority> &\n            IAccountSignerMeta<TAccountTokenBadgeAuthority>\n        : TAccountTokenBadgeAuthority,\n      TAccountTokenMint extends string\n        ? ReadonlyAccount<TAccountTokenMint>\n        : TAccountTokenMint,\n      TAccountTokenBadge extends string\n        ? WritableAccount<TAccountTokenBadge>\n        : TAccountTokenBadge,\n      TAccountFunder extends string\n        ? WritableSignerAccount<TAccountFunder> &\n            IAccountSignerMeta<TAccountFunder>\n        : TAccountFunder,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeTokenBadgeInstructionData = {\n  discriminator: ReadonlyUint8Array;\n};\n\nexport type InitializeTokenBadgeInstructionDataArgs = {};\n\nexport function getInitializeTokenBadgeInstructionDataEncoder(): Encoder<InitializeTokenBadgeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_TOKEN_BADGE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeTokenBadgeInstructionDataDecoder(): Decoder<InitializeTokenBadgeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n  ]);\n}\n\nexport function getInitializeTokenBadgeInstructionDataCodec(): Codec<\n  InitializeTokenBadgeInstructionDataArgs,\n  InitializeTokenBadgeInstructionData\n> {\n  return combineCodec(\n    getInitializeTokenBadgeInstructionDataEncoder(),\n    getInitializeTokenBadgeInstructionDataDecoder()\n  );\n}\n\nexport type InitializeTokenBadgeInput<\n  TAccountWhirlpoolsConfig extends string = string,\n  TAccountWhirlpoolsConfigExtension extends string = string,\n  TAccountTokenBadgeAuthority extends string = string,\n  TAccountTokenMint extends string = string,\n  TAccountTokenBadge extends string = string,\n  TAccountFunder extends string = string,\n  TAccountSystemProgram extends string = string,\n> = {\n  whirlpoolsConfig: Address<TAccountWhirlpoolsConfig>;\n  whirlpoolsConfigExtension: Address<TAccountWhirlpoolsConfigExtension>;\n  tokenBadgeAuthority: TransactionSigner<TAccountTokenBadgeAuthority>;\n  tokenMint: Address<TAccountTokenMint>;\n  tokenBadge: Address<TAccountTokenBadge>;\n  funder: TransactionSigner<TAccountFunder>;\n  systemProgram?: Address<TAccountSystemProgram>;\n};\n\nexport function getInitializeTokenBadgeInstruction<\n  TAccountWhirlpoolsConfig extends string,\n  TAccountWhirlpoolsConfigExtension extends string,\n  TAccountTokenBadgeAuthority extends string,\n  TAccountTokenMint extends string,\n  TAccountTokenBadge extends string,\n  TAccountFunder extends string,\n  TAccountSystemProgram extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: InitializeTokenBadgeInput<\n    TAccountWhirlpoolsConfig,\n    TAccountWhirlpoolsConfigExtension,\n    TAccountTokenBadgeAuthority,\n    TAccountTokenMint,\n    TAccountTokenBadge,\n    TAccountFunder,\n    TAccountSystemProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeTokenBadgeInstruction<\n  TProgramAddress,\n  TAccountWhirlpoolsConfig,\n  TAccountWhirlpoolsConfigExtension,\n  TAccountTokenBadgeAuthority,\n  TAccountTokenMint,\n  TAccountTokenBadge,\n  TAccountFunder,\n  TAccountSystemProgram\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpoolsConfig: {\n      value: input.whirlpoolsConfig ?? null,\n      isWritable: false,\n    },\n    whirlpoolsConfigExtension: {\n      value: input.whirlpoolsConfigExtension ?? null,\n      isWritable: false,\n    },\n    tokenBadgeAuthority: {\n      value: input.tokenBadgeAuthority ?? null,\n      isWritable: false,\n    },\n    tokenMint: { value: input.tokenMint ?? null, isWritable: false },\n    tokenBadge: { value: input.tokenBadge ?? null, isWritable: true },\n    funder: { value: input.funder ?? null, isWritable: true },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpoolsConfig),\n      getAccountMeta(accounts.whirlpoolsConfigExtension),\n      getAccountMeta(accounts.tokenBadgeAuthority),\n      getAccountMeta(accounts.tokenMint),\n      getAccountMeta(accounts.tokenBadge),\n      getAccountMeta(accounts.funder),\n      getAccountMeta(accounts.systemProgram),\n    ],\n    programAddress,\n    data: getInitializeTokenBadgeInstructionDataEncoder().encode({}),\n  } as InitializeTokenBadgeInstruction<\n    TProgramAddress,\n    TAccountWhirlpoolsConfig,\n    TAccountWhirlpoolsConfigExtension,\n    TAccountTokenBadgeAuthority,\n    TAccountTokenMint,\n    TAccountTokenBadge,\n    TAccountFunder,\n    TAccountSystemProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedInitializeTokenBadgeInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpoolsConfig: TAccountMetas[0];\n    whirlpoolsConfigExtension: TAccountMetas[1];\n    tokenBadgeAuthority: TAccountMetas[2];\n    tokenMint: TAccountMetas[3];\n    tokenBadge: TAccountMetas[4];\n    funder: TAccountMetas[5];\n    systemProgram: TAccountMetas[6];\n  };\n  data: InitializeTokenBadgeInstructionData;\n};\n\nexport function parseInitializeTokenBadgeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedInitializeTokenBadgeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 7) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpoolsConfig: getNextAccount(),\n      whirlpoolsConfigExtension: getNextAccount(),\n      tokenBadgeAuthority: getNextAccount(),\n      tokenMint: getNextAccount(),\n      tokenBadge: getNextAccount(),\n      funder: getNextAccount(),\n      systemProgram: getNextAccount(),\n    },\n    data: getInitializeTokenBadgeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getLockTypeDecoder,\n  getLockTypeEncoder,\n  type LockType,\n  type LockTypeArgs,\n} from '../types';\n\nexport const LOCK_POSITION_DISCRIMINATOR = new Uint8Array([\n  227, 62, 2, 252, 247, 10, 171, 185,\n]);\n\nexport function getLockPositionDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    LOCK_POSITION_DISCRIMINATOR\n  );\n}\n\nexport type LockPositionInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountFunder extends string | IAccountMeta<string> = string,\n  TAccountPositionAuthority extends string | IAccountMeta<string> = string,\n  TAccountPosition extends string | IAccountMeta<string> = string,\n  TAccountPositionMint extends string | IAccountMeta<string> = string,\n  TAccountPositionTokenAccount extends string | IAccountMeta<string> = string,\n  TAccountLockConfig extends string | IAccountMeta<string> = string,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountToken2022Program extends string | IAccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountFunder extends string\n        ? WritableSignerAccount<TAccountFunder> &\n            IAccountSignerMeta<TAccountFunder>\n        : TAccountFunder,\n      TAccountPositionAuthority extends string\n        ? ReadonlySignerAccount<TAccountPositionAuthority> &\n            IAccountSignerMeta<TAccountPositionAuthority>\n        : TAccountPositionAuthority,\n      TAccountPosition extends string\n        ? ReadonlyAccount<TAccountPosition>\n        : TAccountPosition,\n      TAccountPositionMint extends string\n        ? ReadonlyAccount<TAccountPositionMint>\n        : TAccountPositionMint,\n      TAccountPositionTokenAccount extends string\n        ? WritableAccount<TAccountPositionTokenAccount>\n        : TAccountPositionTokenAccount,\n      TAccountLockConfig extends string\n        ? WritableAccount<TAccountLockConfig>\n        : TAccountLockConfig,\n      TAccountWhirlpool extends string\n        ? ReadonlyAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountToken2022Program extends string\n        ? ReadonlyAccount<TAccountToken2022Program>\n        : TAccountToken2022Program,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type LockPositionInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  lockType: LockType;\n};\n\nexport type LockPositionInstructionDataArgs = { lockType: LockTypeArgs };\n\nexport function getLockPositionInstructionDataEncoder(): Encoder<LockPositionInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['lockType', getLockTypeEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: LOCK_POSITION_DISCRIMINATOR })\n  );\n}\n\nexport function getLockPositionInstructionDataDecoder(): Decoder<LockPositionInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['lockType', getLockTypeDecoder()],\n  ]);\n}\n\nexport function getLockPositionInstructionDataCodec(): Codec<\n  LockPositionInstructionDataArgs,\n  LockPositionInstructionData\n> {\n  return combineCodec(\n    getLockPositionInstructionDataEncoder(),\n    getLockPositionInstructionDataDecoder()\n  );\n}\n\nexport type LockPositionInput<\n  TAccountFunder extends string = string,\n  TAccountPositionAuthority extends string = string,\n  TAccountPosition extends string = string,\n  TAccountPositionMint extends string = string,\n  TAccountPositionTokenAccount extends string = string,\n  TAccountLockConfig extends string = string,\n  TAccountWhirlpool extends string = string,\n  TAccountToken2022Program extends string = string,\n  TAccountSystemProgram extends string = string,\n> = {\n  funder: TransactionSigner<TAccountFunder>;\n  positionAuthority: TransactionSigner<TAccountPositionAuthority>;\n  position: Address<TAccountPosition>;\n  positionMint: Address<TAccountPositionMint>;\n  positionTokenAccount: Address<TAccountPositionTokenAccount>;\n  lockConfig: Address<TAccountLockConfig>;\n  whirlpool: Address<TAccountWhirlpool>;\n  token2022Program: Address<TAccountToken2022Program>;\n  systemProgram?: Address<TAccountSystemProgram>;\n  lockType: LockPositionInstructionDataArgs['lockType'];\n};\n\nexport function getLockPositionInstruction<\n  TAccountFunder extends string,\n  TAccountPositionAuthority extends string,\n  TAccountPosition extends string,\n  TAccountPositionMint extends string,\n  TAccountPositionTokenAccount extends string,\n  TAccountLockConfig extends string,\n  TAccountWhirlpool extends string,\n  TAccountToken2022Program extends string,\n  TAccountSystemProgram extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: LockPositionInput<\n    TAccountFunder,\n    TAccountPositionAuthority,\n    TAccountPosition,\n    TAccountPositionMint,\n    TAccountPositionTokenAccount,\n    TAccountLockConfig,\n    TAccountWhirlpool,\n    TAccountToken2022Program,\n    TAccountSystemProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): LockPositionInstruction<\n  TProgramAddress,\n  TAccountFunder,\n  TAccountPositionAuthority,\n  TAccountPosition,\n  TAccountPositionMint,\n  TAccountPositionTokenAccount,\n  TAccountLockConfig,\n  TAccountWhirlpool,\n  TAccountToken2022Program,\n  TAccountSystemProgram\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    funder: { value: input.funder ?? null, isWritable: true },\n    positionAuthority: {\n      value: input.positionAuthority ?? null,\n      isWritable: false,\n    },\n    position: { value: input.position ?? null, isWritable: false },\n    positionMint: { value: input.positionMint ?? null, isWritable: false },\n    positionTokenAccount: {\n      value: input.positionTokenAccount ?? null,\n      isWritable: true,\n    },\n    lockConfig: { value: input.lockConfig ?? null, isWritable: true },\n    whirlpool: { value: input.whirlpool ?? null, isWritable: false },\n    token2022Program: {\n      value: input.token2022Program ?? null,\n      isWritable: false,\n    },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.funder),\n      getAccountMeta(accounts.positionAuthority),\n      getAccountMeta(accounts.position),\n      getAccountMeta(accounts.positionMint),\n      getAccountMeta(accounts.positionTokenAccount),\n      getAccountMeta(accounts.lockConfig),\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.token2022Program),\n      getAccountMeta(accounts.systemProgram),\n    ],\n    programAddress,\n    data: getLockPositionInstructionDataEncoder().encode(\n      args as LockPositionInstructionDataArgs\n    ),\n  } as LockPositionInstruction<\n    TProgramAddress,\n    TAccountFunder,\n    TAccountPositionAuthority,\n    TAccountPosition,\n    TAccountPositionMint,\n    TAccountPositionTokenAccount,\n    TAccountLockConfig,\n    TAccountWhirlpool,\n    TAccountToken2022Program,\n    TAccountSystemProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedLockPositionInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    funder: TAccountMetas[0];\n    positionAuthority: TAccountMetas[1];\n    position: TAccountMetas[2];\n    positionMint: TAccountMetas[3];\n    positionTokenAccount: TAccountMetas[4];\n    lockConfig: TAccountMetas[5];\n    whirlpool: TAccountMetas[6];\n    token2022Program: TAccountMetas[7];\n    systemProgram: TAccountMetas[8];\n  };\n  data: LockPositionInstructionData;\n};\n\nexport function parseLockPositionInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedLockPositionInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 9) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      funder: getNextAccount(),\n      positionAuthority: getNextAccount(),\n      position: getNextAccount(),\n      positionMint: getNextAccount(),\n      positionTokenAccount: getNextAccount(),\n      lockConfig: getNextAccount(),\n      whirlpool: getNextAccount(),\n      token2022Program: getNextAccount(),\n      systemProgram: getNextAccount(),\n    },\n    data: getLockPositionInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getI32Decoder,\n  getI32Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const OPEN_BUNDLED_POSITION_DISCRIMINATOR = new Uint8Array([\n  169, 113, 126, 171, 213, 172, 212, 49,\n]);\n\nexport function getOpenBundledPositionDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    OPEN_BUNDLED_POSITION_DISCRIMINATOR\n  );\n}\n\nexport type OpenBundledPositionInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountBundledPosition extends string | IAccountMeta<string> = string,\n  TAccountPositionBundle extends string | IAccountMeta<string> = string,\n  TAccountPositionBundleTokenAccount extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountPositionBundleAuthority extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountFunder extends string | IAccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TAccountRent extends\n    | string\n    | IAccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountBundledPosition extends string\n        ? WritableAccount<TAccountBundledPosition>\n        : TAccountBundledPosition,\n      TAccountPositionBundle extends string\n        ? WritableAccount<TAccountPositionBundle>\n        : TAccountPositionBundle,\n      TAccountPositionBundleTokenAccount extends string\n        ? ReadonlyAccount<TAccountPositionBundleTokenAccount>\n        : TAccountPositionBundleTokenAccount,\n      TAccountPositionBundleAuthority extends string\n        ? ReadonlySignerAccount<TAccountPositionBundleAuthority> &\n            IAccountSignerMeta<TAccountPositionBundleAuthority>\n        : TAccountPositionBundleAuthority,\n      TAccountWhirlpool extends string\n        ? ReadonlyAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountFunder extends string\n        ? WritableSignerAccount<TAccountFunder> &\n            IAccountSignerMeta<TAccountFunder>\n        : TAccountFunder,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type OpenBundledPositionInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  bundleIndex: number;\n  tickLowerIndex: number;\n  tickUpperIndex: number;\n};\n\nexport type OpenBundledPositionInstructionDataArgs = {\n  bundleIndex: number;\n  tickLowerIndex: number;\n  tickUpperIndex: number;\n};\n\nexport function getOpenBundledPositionInstructionDataEncoder(): Encoder<OpenBundledPositionInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['bundleIndex', getU16Encoder()],\n      ['tickLowerIndex', getI32Encoder()],\n      ['tickUpperIndex', getI32Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: OPEN_BUNDLED_POSITION_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getOpenBundledPositionInstructionDataDecoder(): Decoder<OpenBundledPositionInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['bundleIndex', getU16Decoder()],\n    ['tickLowerIndex', getI32Decoder()],\n    ['tickUpperIndex', getI32Decoder()],\n  ]);\n}\n\nexport function getOpenBundledPositionInstructionDataCodec(): Codec<\n  OpenBundledPositionInstructionDataArgs,\n  OpenBundledPositionInstructionData\n> {\n  return combineCodec(\n    getOpenBundledPositionInstructionDataEncoder(),\n    getOpenBundledPositionInstructionDataDecoder()\n  );\n}\n\nexport type OpenBundledPositionInput<\n  TAccountBundledPosition extends string = string,\n  TAccountPositionBundle extends string = string,\n  TAccountPositionBundleTokenAccount extends string = string,\n  TAccountPositionBundleAuthority extends string = string,\n  TAccountWhirlpool extends string = string,\n  TAccountFunder extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountRent extends string = string,\n> = {\n  bundledPosition: Address<TAccountBundledPosition>;\n  positionBundle: Address<TAccountPositionBundle>;\n  positionBundleTokenAccount: Address<TAccountPositionBundleTokenAccount>;\n  positionBundleAuthority: TransactionSigner<TAccountPositionBundleAuthority>;\n  whirlpool: Address<TAccountWhirlpool>;\n  funder: TransactionSigner<TAccountFunder>;\n  systemProgram?: Address<TAccountSystemProgram>;\n  rent?: Address<TAccountRent>;\n  bundleIndex: OpenBundledPositionInstructionDataArgs['bundleIndex'];\n  tickLowerIndex: OpenBundledPositionInstructionDataArgs['tickLowerIndex'];\n  tickUpperIndex: OpenBundledPositionInstructionDataArgs['tickUpperIndex'];\n};\n\nexport function getOpenBundledPositionInstruction<\n  TAccountBundledPosition extends string,\n  TAccountPositionBundle extends string,\n  TAccountPositionBundleTokenAccount extends string,\n  TAccountPositionBundleAuthority extends string,\n  TAccountWhirlpool extends string,\n  TAccountFunder extends string,\n  TAccountSystemProgram extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: OpenBundledPositionInput<\n    TAccountBundledPosition,\n    TAccountPositionBundle,\n    TAccountPositionBundleTokenAccount,\n    TAccountPositionBundleAuthority,\n    TAccountWhirlpool,\n    TAccountFunder,\n    TAccountSystemProgram,\n    TAccountRent\n  >,\n  config?: { programAddress?: TProgramAddress }\n): OpenBundledPositionInstruction<\n  TProgramAddress,\n  TAccountBundledPosition,\n  TAccountPositionBundle,\n  TAccountPositionBundleTokenAccount,\n  TAccountPositionBundleAuthority,\n  TAccountWhirlpool,\n  TAccountFunder,\n  TAccountSystemProgram,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    bundledPosition: { value: input.bundledPosition ?? null, isWritable: true },\n    positionBundle: { value: input.positionBundle ?? null, isWritable: true },\n    positionBundleTokenAccount: {\n      value: input.positionBundleTokenAccount ?? null,\n      isWritable: false,\n    },\n    positionBundleAuthority: {\n      value: input.positionBundleAuthority ?? null,\n      isWritable: false,\n    },\n    whirlpool: { value: input.whirlpool ?? null, isWritable: false },\n    funder: { value: input.funder ?? null, isWritable: true },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.bundledPosition),\n      getAccountMeta(accounts.positionBundle),\n      getAccountMeta(accounts.positionBundleTokenAccount),\n      getAccountMeta(accounts.positionBundleAuthority),\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.funder),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.rent),\n    ],\n    programAddress,\n    data: getOpenBundledPositionInstructionDataEncoder().encode(\n      args as OpenBundledPositionInstructionDataArgs\n    ),\n  } as OpenBundledPositionInstruction<\n    TProgramAddress,\n    TAccountBundledPosition,\n    TAccountPositionBundle,\n    TAccountPositionBundleTokenAccount,\n    TAccountPositionBundleAuthority,\n    TAccountWhirlpool,\n    TAccountFunder,\n    TAccountSystemProgram,\n    TAccountRent\n  >;\n\n  return instruction;\n}\n\nexport type ParsedOpenBundledPositionInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    bundledPosition: TAccountMetas[0];\n    positionBundle: TAccountMetas[1];\n    positionBundleTokenAccount: TAccountMetas[2];\n    positionBundleAuthority: TAccountMetas[3];\n    whirlpool: TAccountMetas[4];\n    funder: TAccountMetas[5];\n    systemProgram: TAccountMetas[6];\n    rent: TAccountMetas[7];\n  };\n  data: OpenBundledPositionInstructionData;\n};\n\nexport function parseOpenBundledPositionInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedOpenBundledPositionInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 8) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      bundledPosition: getNextAccount(),\n      positionBundle: getNextAccount(),\n      positionBundleTokenAccount: getNextAccount(),\n      positionBundleAuthority: getNextAccount(),\n      whirlpool: getNextAccount(),\n      funder: getNextAccount(),\n      systemProgram: getNextAccount(),\n      rent: getNextAccount(),\n    },\n    data: getOpenBundledPositionInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getI32Decoder,\n  getI32Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const OPEN_POSITION_DISCRIMINATOR = new Uint8Array([\n  135, 128, 47, 77, 15, 152, 240, 49,\n]);\n\nexport function getOpenPositionDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    OPEN_POSITION_DISCRIMINATOR\n  );\n}\n\nexport type OpenPositionInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountFunder extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TAccountPosition extends string | IAccountMeta<string> = string,\n  TAccountPositionMint extends string | IAccountMeta<string> = string,\n  TAccountPositionTokenAccount extends string | IAccountMeta<string> = string,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountTokenProgram extends\n    | string\n    | IAccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TAccountRent extends\n    | string\n    | IAccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TAccountAssociatedTokenProgram extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountFunder extends string\n        ? WritableSignerAccount<TAccountFunder> &\n            IAccountSignerMeta<TAccountFunder>\n        : TAccountFunder,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      TAccountPosition extends string\n        ? WritableAccount<TAccountPosition>\n        : TAccountPosition,\n      TAccountPositionMint extends string\n        ? WritableSignerAccount<TAccountPositionMint> &\n            IAccountSignerMeta<TAccountPositionMint>\n        : TAccountPositionMint,\n      TAccountPositionTokenAccount extends string\n        ? WritableAccount<TAccountPositionTokenAccount>\n        : TAccountPositionTokenAccount,\n      TAccountWhirlpool extends string\n        ? ReadonlyAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      TAccountAssociatedTokenProgram extends string\n        ? ReadonlyAccount<TAccountAssociatedTokenProgram>\n        : TAccountAssociatedTokenProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type OpenPositionInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  positionBump: number;\n  tickLowerIndex: number;\n  tickUpperIndex: number;\n};\n\nexport type OpenPositionInstructionDataArgs = {\n  positionBump: number;\n  tickLowerIndex: number;\n  tickUpperIndex: number;\n};\n\nexport function getOpenPositionInstructionDataEncoder(): Encoder<OpenPositionInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['positionBump', getU8Encoder()],\n      ['tickLowerIndex', getI32Encoder()],\n      ['tickUpperIndex', getI32Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: OPEN_POSITION_DISCRIMINATOR })\n  );\n}\n\nexport function getOpenPositionInstructionDataDecoder(): Decoder<OpenPositionInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['positionBump', getU8Decoder()],\n    ['tickLowerIndex', getI32Decoder()],\n    ['tickUpperIndex', getI32Decoder()],\n  ]);\n}\n\nexport function getOpenPositionInstructionDataCodec(): Codec<\n  OpenPositionInstructionDataArgs,\n  OpenPositionInstructionData\n> {\n  return combineCodec(\n    getOpenPositionInstructionDataEncoder(),\n    getOpenPositionInstructionDataDecoder()\n  );\n}\n\nexport type OpenPositionInput<\n  TAccountFunder extends string = string,\n  TAccountOwner extends string = string,\n  TAccountPosition extends string = string,\n  TAccountPositionMint extends string = string,\n  TAccountPositionTokenAccount extends string = string,\n  TAccountWhirlpool extends string = string,\n  TAccountTokenProgram extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountRent extends string = string,\n  TAccountAssociatedTokenProgram extends string = string,\n> = {\n  funder: TransactionSigner<TAccountFunder>;\n  owner: Address<TAccountOwner>;\n  position: Address<TAccountPosition>;\n  positionMint: TransactionSigner<TAccountPositionMint>;\n  positionTokenAccount: Address<TAccountPositionTokenAccount>;\n  whirlpool: Address<TAccountWhirlpool>;\n  tokenProgram?: Address<TAccountTokenProgram>;\n  systemProgram?: Address<TAccountSystemProgram>;\n  rent?: Address<TAccountRent>;\n  associatedTokenProgram: Address<TAccountAssociatedTokenProgram>;\n  positionBump: OpenPositionInstructionDataArgs['positionBump'];\n  tickLowerIndex: OpenPositionInstructionDataArgs['tickLowerIndex'];\n  tickUpperIndex: OpenPositionInstructionDataArgs['tickUpperIndex'];\n};\n\nexport function getOpenPositionInstruction<\n  TAccountFunder extends string,\n  TAccountOwner extends string,\n  TAccountPosition extends string,\n  TAccountPositionMint extends string,\n  TAccountPositionTokenAccount extends string,\n  TAccountWhirlpool extends string,\n  TAccountTokenProgram extends string,\n  TAccountSystemProgram extends string,\n  TAccountRent extends string,\n  TAccountAssociatedTokenProgram extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: OpenPositionInput<\n    TAccountFunder,\n    TAccountOwner,\n    TAccountPosition,\n    TAccountPositionMint,\n    TAccountPositionTokenAccount,\n    TAccountWhirlpool,\n    TAccountTokenProgram,\n    TAccountSystemProgram,\n    TAccountRent,\n    TAccountAssociatedTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): OpenPositionInstruction<\n  TProgramAddress,\n  TAccountFunder,\n  TAccountOwner,\n  TAccountPosition,\n  TAccountPositionMint,\n  TAccountPositionTokenAccount,\n  TAccountWhirlpool,\n  TAccountTokenProgram,\n  TAccountSystemProgram,\n  TAccountRent,\n  TAccountAssociatedTokenProgram\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    funder: { value: input.funder ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    position: { value: input.position ?? null, isWritable: true },\n    positionMint: { value: input.positionMint ?? null, isWritable: true },\n    positionTokenAccount: {\n      value: input.positionTokenAccount ?? null,\n      isWritable: true,\n    },\n    whirlpool: { value: input.whirlpool ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false },\n    associatedTokenProgram: {\n      value: input.associatedTokenProgram ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.funder),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.position),\n      getAccountMeta(accounts.positionMint),\n      getAccountMeta(accounts.positionTokenAccount),\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.tokenProgram),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.rent),\n      getAccountMeta(accounts.associatedTokenProgram),\n    ],\n    programAddress,\n    data: getOpenPositionInstructionDataEncoder().encode(\n      args as OpenPositionInstructionDataArgs\n    ),\n  } as OpenPositionInstruction<\n    TProgramAddress,\n    TAccountFunder,\n    TAccountOwner,\n    TAccountPosition,\n    TAccountPositionMint,\n    TAccountPositionTokenAccount,\n    TAccountWhirlpool,\n    TAccountTokenProgram,\n    TAccountSystemProgram,\n    TAccountRent,\n    TAccountAssociatedTokenProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedOpenPositionInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    funder: TAccountMetas[0];\n    owner: TAccountMetas[1];\n    position: TAccountMetas[2];\n    positionMint: TAccountMetas[3];\n    positionTokenAccount: TAccountMetas[4];\n    whirlpool: TAccountMetas[5];\n    tokenProgram: TAccountMetas[6];\n    systemProgram: TAccountMetas[7];\n    rent: TAccountMetas[8];\n    associatedTokenProgram: TAccountMetas[9];\n  };\n  data: OpenPositionInstructionData;\n};\n\nexport function parseOpenPositionInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedOpenPositionInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 10) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      funder: getNextAccount(),\n      owner: getNextAccount(),\n      position: getNextAccount(),\n      positionMint: getNextAccount(),\n      positionTokenAccount: getNextAccount(),\n      whirlpool: getNextAccount(),\n      tokenProgram: getNextAccount(),\n      systemProgram: getNextAccount(),\n      rent: getNextAccount(),\n      associatedTokenProgram: getNextAccount(),\n    },\n    data: getOpenPositionInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getI32Decoder,\n  getI32Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const OPEN_POSITION_WITH_METADATA_DISCRIMINATOR = new Uint8Array([\n  242, 29, 134, 48, 58, 110, 14, 60,\n]);\n\nexport function getOpenPositionWithMetadataDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    OPEN_POSITION_WITH_METADATA_DISCRIMINATOR\n  );\n}\n\nexport type OpenPositionWithMetadataInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountFunder extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TAccountPosition extends string | IAccountMeta<string> = string,\n  TAccountPositionMint extends string | IAccountMeta<string> = string,\n  TAccountPositionMetadataAccount extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountPositionTokenAccount extends string | IAccountMeta<string> = string,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountTokenProgram extends\n    | string\n    | IAccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TAccountRent extends\n    | string\n    | IAccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TAccountAssociatedTokenProgram extends string | IAccountMeta<string> = string,\n  TAccountMetadataProgram extends string | IAccountMeta<string> = string,\n  TAccountMetadataUpdateAuth extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountFunder extends string\n        ? WritableSignerAccount<TAccountFunder> &\n            IAccountSignerMeta<TAccountFunder>\n        : TAccountFunder,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      TAccountPosition extends string\n        ? WritableAccount<TAccountPosition>\n        : TAccountPosition,\n      TAccountPositionMint extends string\n        ? WritableSignerAccount<TAccountPositionMint> &\n            IAccountSignerMeta<TAccountPositionMint>\n        : TAccountPositionMint,\n      TAccountPositionMetadataAccount extends string\n        ? WritableAccount<TAccountPositionMetadataAccount>\n        : TAccountPositionMetadataAccount,\n      TAccountPositionTokenAccount extends string\n        ? WritableAccount<TAccountPositionTokenAccount>\n        : TAccountPositionTokenAccount,\n      TAccountWhirlpool extends string\n        ? ReadonlyAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      TAccountAssociatedTokenProgram extends string\n        ? ReadonlyAccount<TAccountAssociatedTokenProgram>\n        : TAccountAssociatedTokenProgram,\n      TAccountMetadataProgram extends string\n        ? ReadonlyAccount<TAccountMetadataProgram>\n        : TAccountMetadataProgram,\n      TAccountMetadataUpdateAuth extends string\n        ? ReadonlyAccount<TAccountMetadataUpdateAuth>\n        : TAccountMetadataUpdateAuth,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type OpenPositionWithMetadataInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  positionBump: number;\n  metadataBump: number;\n  tickLowerIndex: number;\n  tickUpperIndex: number;\n};\n\nexport type OpenPositionWithMetadataInstructionDataArgs = {\n  positionBump: number;\n  metadataBump: number;\n  tickLowerIndex: number;\n  tickUpperIndex: number;\n};\n\nexport function getOpenPositionWithMetadataInstructionDataEncoder(): Encoder<OpenPositionWithMetadataInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['positionBump', getU8Encoder()],\n      ['metadataBump', getU8Encoder()],\n      ['tickLowerIndex', getI32Encoder()],\n      ['tickUpperIndex', getI32Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: OPEN_POSITION_WITH_METADATA_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getOpenPositionWithMetadataInstructionDataDecoder(): Decoder<OpenPositionWithMetadataInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['positionBump', getU8Decoder()],\n    ['metadataBump', getU8Decoder()],\n    ['tickLowerIndex', getI32Decoder()],\n    ['tickUpperIndex', getI32Decoder()],\n  ]);\n}\n\nexport function getOpenPositionWithMetadataInstructionDataCodec(): Codec<\n  OpenPositionWithMetadataInstructionDataArgs,\n  OpenPositionWithMetadataInstructionData\n> {\n  return combineCodec(\n    getOpenPositionWithMetadataInstructionDataEncoder(),\n    getOpenPositionWithMetadataInstructionDataDecoder()\n  );\n}\n\nexport type OpenPositionWithMetadataInput<\n  TAccountFunder extends string = string,\n  TAccountOwner extends string = string,\n  TAccountPosition extends string = string,\n  TAccountPositionMint extends string = string,\n  TAccountPositionMetadataAccount extends string = string,\n  TAccountPositionTokenAccount extends string = string,\n  TAccountWhirlpool extends string = string,\n  TAccountTokenProgram extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountRent extends string = string,\n  TAccountAssociatedTokenProgram extends string = string,\n  TAccountMetadataProgram extends string = string,\n  TAccountMetadataUpdateAuth extends string = string,\n> = {\n  funder: TransactionSigner<TAccountFunder>;\n  owner: Address<TAccountOwner>;\n  position: Address<TAccountPosition>;\n  positionMint: TransactionSigner<TAccountPositionMint>;\n  /** https://github.com/metaplex-foundation/mpl-token-metadata/blob/master/programs/token-metadata/program/src/utils/metadata.rs#L78 */\n  positionMetadataAccount: Address<TAccountPositionMetadataAccount>;\n  positionTokenAccount: Address<TAccountPositionTokenAccount>;\n  whirlpool: Address<TAccountWhirlpool>;\n  tokenProgram?: Address<TAccountTokenProgram>;\n  systemProgram?: Address<TAccountSystemProgram>;\n  rent?: Address<TAccountRent>;\n  associatedTokenProgram: Address<TAccountAssociatedTokenProgram>;\n  metadataProgram: Address<TAccountMetadataProgram>;\n  metadataUpdateAuth: Address<TAccountMetadataUpdateAuth>;\n  positionBump: OpenPositionWithMetadataInstructionDataArgs['positionBump'];\n  metadataBump: OpenPositionWithMetadataInstructionDataArgs['metadataBump'];\n  tickLowerIndex: OpenPositionWithMetadataInstructionDataArgs['tickLowerIndex'];\n  tickUpperIndex: OpenPositionWithMetadataInstructionDataArgs['tickUpperIndex'];\n};\n\nexport function getOpenPositionWithMetadataInstruction<\n  TAccountFunder extends string,\n  TAccountOwner extends string,\n  TAccountPosition extends string,\n  TAccountPositionMint extends string,\n  TAccountPositionMetadataAccount extends string,\n  TAccountPositionTokenAccount extends string,\n  TAccountWhirlpool extends string,\n  TAccountTokenProgram extends string,\n  TAccountSystemProgram extends string,\n  TAccountRent extends string,\n  TAccountAssociatedTokenProgram extends string,\n  TAccountMetadataProgram extends string,\n  TAccountMetadataUpdateAuth extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: OpenPositionWithMetadataInput<\n    TAccountFunder,\n    TAccountOwner,\n    TAccountPosition,\n    TAccountPositionMint,\n    TAccountPositionMetadataAccount,\n    TAccountPositionTokenAccount,\n    TAccountWhirlpool,\n    TAccountTokenProgram,\n    TAccountSystemProgram,\n    TAccountRent,\n    TAccountAssociatedTokenProgram,\n    TAccountMetadataProgram,\n    TAccountMetadataUpdateAuth\n  >,\n  config?: { programAddress?: TProgramAddress }\n): OpenPositionWithMetadataInstruction<\n  TProgramAddress,\n  TAccountFunder,\n  TAccountOwner,\n  TAccountPosition,\n  TAccountPositionMint,\n  TAccountPositionMetadataAccount,\n  TAccountPositionTokenAccount,\n  TAccountWhirlpool,\n  TAccountTokenProgram,\n  TAccountSystemProgram,\n  TAccountRent,\n  TAccountAssociatedTokenProgram,\n  TAccountMetadataProgram,\n  TAccountMetadataUpdateAuth\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    funder: { value: input.funder ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    position: { value: input.position ?? null, isWritable: true },\n    positionMint: { value: input.positionMint ?? null, isWritable: true },\n    positionMetadataAccount: {\n      value: input.positionMetadataAccount ?? null,\n      isWritable: true,\n    },\n    positionTokenAccount: {\n      value: input.positionTokenAccount ?? null,\n      isWritable: true,\n    },\n    whirlpool: { value: input.whirlpool ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false },\n    associatedTokenProgram: {\n      value: input.associatedTokenProgram ?? null,\n      isWritable: false,\n    },\n    metadataProgram: {\n      value: input.metadataProgram ?? null,\n      isWritable: false,\n    },\n    metadataUpdateAuth: {\n      value: input.metadataUpdateAuth ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.funder),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.position),\n      getAccountMeta(accounts.positionMint),\n      getAccountMeta(accounts.positionMetadataAccount),\n      getAccountMeta(accounts.positionTokenAccount),\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.tokenProgram),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.rent),\n      getAccountMeta(accounts.associatedTokenProgram),\n      getAccountMeta(accounts.metadataProgram),\n      getAccountMeta(accounts.metadataUpdateAuth),\n    ],\n    programAddress,\n    data: getOpenPositionWithMetadataInstructionDataEncoder().encode(\n      args as OpenPositionWithMetadataInstructionDataArgs\n    ),\n  } as OpenPositionWithMetadataInstruction<\n    TProgramAddress,\n    TAccountFunder,\n    TAccountOwner,\n    TAccountPosition,\n    TAccountPositionMint,\n    TAccountPositionMetadataAccount,\n    TAccountPositionTokenAccount,\n    TAccountWhirlpool,\n    TAccountTokenProgram,\n    TAccountSystemProgram,\n    TAccountRent,\n    TAccountAssociatedTokenProgram,\n    TAccountMetadataProgram,\n    TAccountMetadataUpdateAuth\n  >;\n\n  return instruction;\n}\n\nexport type ParsedOpenPositionWithMetadataInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    funder: TAccountMetas[0];\n    owner: TAccountMetas[1];\n    position: TAccountMetas[2];\n    positionMint: TAccountMetas[3];\n    /** https://github.com/metaplex-foundation/mpl-token-metadata/blob/master/programs/token-metadata/program/src/utils/metadata.rs#L78 */\n    positionMetadataAccount: TAccountMetas[4];\n    positionTokenAccount: TAccountMetas[5];\n    whirlpool: TAccountMetas[6];\n    tokenProgram: TAccountMetas[7];\n    systemProgram: TAccountMetas[8];\n    rent: TAccountMetas[9];\n    associatedTokenProgram: TAccountMetas[10];\n    metadataProgram: TAccountMetas[11];\n    metadataUpdateAuth: TAccountMetas[12];\n  };\n  data: OpenPositionWithMetadataInstructionData;\n};\n\nexport function parseOpenPositionWithMetadataInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedOpenPositionWithMetadataInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 13) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      funder: getNextAccount(),\n      owner: getNextAccount(),\n      position: getNextAccount(),\n      positionMint: getNextAccount(),\n      positionMetadataAccount: getNextAccount(),\n      positionTokenAccount: getNextAccount(),\n      whirlpool: getNextAccount(),\n      tokenProgram: getNextAccount(),\n      systemProgram: getNextAccount(),\n      rent: getNextAccount(),\n      associatedTokenProgram: getNextAccount(),\n      metadataProgram: getNextAccount(),\n      metadataUpdateAuth: getNextAccount(),\n    },\n    data: getOpenPositionWithMetadataInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getI32Decoder,\n  getI32Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const OPEN_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR = new Uint8Array(\n  [212, 47, 95, 92, 114, 102, 131, 250]\n);\n\nexport function getOpenPositionWithTokenExtensionsDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    OPEN_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR\n  );\n}\n\nexport type OpenPositionWithTokenExtensionsInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountFunder extends string | IAccountMeta<string> = string,\n  TAccountOwner extends string | IAccountMeta<string> = string,\n  TAccountPosition extends string | IAccountMeta<string> = string,\n  TAccountPositionMint extends string | IAccountMeta<string> = string,\n  TAccountPositionTokenAccount extends string | IAccountMeta<string> = string,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountToken2022Program extends string | IAccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TAccountAssociatedTokenProgram extends string | IAccountMeta<string> = string,\n  TAccountMetadataUpdateAuth extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountFunder extends string\n        ? WritableSignerAccount<TAccountFunder> &\n            IAccountSignerMeta<TAccountFunder>\n        : TAccountFunder,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      TAccountPosition extends string\n        ? WritableAccount<TAccountPosition>\n        : TAccountPosition,\n      TAccountPositionMint extends string\n        ? WritableSignerAccount<TAccountPositionMint> &\n            IAccountSignerMeta<TAccountPositionMint>\n        : TAccountPositionMint,\n      TAccountPositionTokenAccount extends string\n        ? WritableAccount<TAccountPositionTokenAccount>\n        : TAccountPositionTokenAccount,\n      TAccountWhirlpool extends string\n        ? ReadonlyAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountToken2022Program extends string\n        ? ReadonlyAccount<TAccountToken2022Program>\n        : TAccountToken2022Program,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountAssociatedTokenProgram extends string\n        ? ReadonlyAccount<TAccountAssociatedTokenProgram>\n        : TAccountAssociatedTokenProgram,\n      TAccountMetadataUpdateAuth extends string\n        ? ReadonlyAccount<TAccountMetadataUpdateAuth>\n        : TAccountMetadataUpdateAuth,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type OpenPositionWithTokenExtensionsInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  tickLowerIndex: number;\n  tickUpperIndex: number;\n  withTokenMetadataExtension: boolean;\n};\n\nexport type OpenPositionWithTokenExtensionsInstructionDataArgs = {\n  tickLowerIndex: number;\n  tickUpperIndex: number;\n  withTokenMetadataExtension: boolean;\n};\n\nexport function getOpenPositionWithTokenExtensionsInstructionDataEncoder(): Encoder<OpenPositionWithTokenExtensionsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['tickLowerIndex', getI32Encoder()],\n      ['tickUpperIndex', getI32Encoder()],\n      ['withTokenMetadataExtension', getBooleanEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: OPEN_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getOpenPositionWithTokenExtensionsInstructionDataDecoder(): Decoder<OpenPositionWithTokenExtensionsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['tickLowerIndex', getI32Decoder()],\n    ['tickUpperIndex', getI32Decoder()],\n    ['withTokenMetadataExtension', getBooleanDecoder()],\n  ]);\n}\n\nexport function getOpenPositionWithTokenExtensionsInstructionDataCodec(): Codec<\n  OpenPositionWithTokenExtensionsInstructionDataArgs,\n  OpenPositionWithTokenExtensionsInstructionData\n> {\n  return combineCodec(\n    getOpenPositionWithTokenExtensionsInstructionDataEncoder(),\n    getOpenPositionWithTokenExtensionsInstructionDataDecoder()\n  );\n}\n\nexport type OpenPositionWithTokenExtensionsInput<\n  TAccountFunder extends string = string,\n  TAccountOwner extends string = string,\n  TAccountPosition extends string = string,\n  TAccountPositionMint extends string = string,\n  TAccountPositionTokenAccount extends string = string,\n  TAccountWhirlpool extends string = string,\n  TAccountToken2022Program extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountAssociatedTokenProgram extends string = string,\n  TAccountMetadataUpdateAuth extends string = string,\n> = {\n  funder: TransactionSigner<TAccountFunder>;\n  owner: Address<TAccountOwner>;\n  position: Address<TAccountPosition>;\n  positionMint: TransactionSigner<TAccountPositionMint>;\n  positionTokenAccount: Address<TAccountPositionTokenAccount>;\n  whirlpool: Address<TAccountWhirlpool>;\n  token2022Program: Address<TAccountToken2022Program>;\n  systemProgram?: Address<TAccountSystemProgram>;\n  associatedTokenProgram: Address<TAccountAssociatedTokenProgram>;\n  metadataUpdateAuth: Address<TAccountMetadataUpdateAuth>;\n  tickLowerIndex: OpenPositionWithTokenExtensionsInstructionDataArgs['tickLowerIndex'];\n  tickUpperIndex: OpenPositionWithTokenExtensionsInstructionDataArgs['tickUpperIndex'];\n  withTokenMetadataExtension: OpenPositionWithTokenExtensionsInstructionDataArgs['withTokenMetadataExtension'];\n};\n\nexport function getOpenPositionWithTokenExtensionsInstruction<\n  TAccountFunder extends string,\n  TAccountOwner extends string,\n  TAccountPosition extends string,\n  TAccountPositionMint extends string,\n  TAccountPositionTokenAccount extends string,\n  TAccountWhirlpool extends string,\n  TAccountToken2022Program extends string,\n  TAccountSystemProgram extends string,\n  TAccountAssociatedTokenProgram extends string,\n  TAccountMetadataUpdateAuth extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: OpenPositionWithTokenExtensionsInput<\n    TAccountFunder,\n    TAccountOwner,\n    TAccountPosition,\n    TAccountPositionMint,\n    TAccountPositionTokenAccount,\n    TAccountWhirlpool,\n    TAccountToken2022Program,\n    TAccountSystemProgram,\n    TAccountAssociatedTokenProgram,\n    TAccountMetadataUpdateAuth\n  >,\n  config?: { programAddress?: TProgramAddress }\n): OpenPositionWithTokenExtensionsInstruction<\n  TProgramAddress,\n  TAccountFunder,\n  TAccountOwner,\n  TAccountPosition,\n  TAccountPositionMint,\n  TAccountPositionTokenAccount,\n  TAccountWhirlpool,\n  TAccountToken2022Program,\n  TAccountSystemProgram,\n  TAccountAssociatedTokenProgram,\n  TAccountMetadataUpdateAuth\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    funder: { value: input.funder ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    position: { value: input.position ?? null, isWritable: true },\n    positionMint: { value: input.positionMint ?? null, isWritable: true },\n    positionTokenAccount: {\n      value: input.positionTokenAccount ?? null,\n      isWritable: true,\n    },\n    whirlpool: { value: input.whirlpool ?? null, isWritable: false },\n    token2022Program: {\n      value: input.token2022Program ?? null,\n      isWritable: false,\n    },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    associatedTokenProgram: {\n      value: input.associatedTokenProgram ?? null,\n      isWritable: false,\n    },\n    metadataUpdateAuth: {\n      value: input.metadataUpdateAuth ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.funder),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.position),\n      getAccountMeta(accounts.positionMint),\n      getAccountMeta(accounts.positionTokenAccount),\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.token2022Program),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.associatedTokenProgram),\n      getAccountMeta(accounts.metadataUpdateAuth),\n    ],\n    programAddress,\n    data: getOpenPositionWithTokenExtensionsInstructionDataEncoder().encode(\n      args as OpenPositionWithTokenExtensionsInstructionDataArgs\n    ),\n  } as OpenPositionWithTokenExtensionsInstruction<\n    TProgramAddress,\n    TAccountFunder,\n    TAccountOwner,\n    TAccountPosition,\n    TAccountPositionMint,\n    TAccountPositionTokenAccount,\n    TAccountWhirlpool,\n    TAccountToken2022Program,\n    TAccountSystemProgram,\n    TAccountAssociatedTokenProgram,\n    TAccountMetadataUpdateAuth\n  >;\n\n  return instruction;\n}\n\nexport type ParsedOpenPositionWithTokenExtensionsInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    funder: TAccountMetas[0];\n    owner: TAccountMetas[1];\n    position: TAccountMetas[2];\n    positionMint: TAccountMetas[3];\n    positionTokenAccount: TAccountMetas[4];\n    whirlpool: TAccountMetas[5];\n    token2022Program: TAccountMetas[6];\n    systemProgram: TAccountMetas[7];\n    associatedTokenProgram: TAccountMetas[8];\n    metadataUpdateAuth: TAccountMetas[9];\n  };\n  data: OpenPositionWithTokenExtensionsInstructionData;\n};\n\nexport function parseOpenPositionWithTokenExtensionsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedOpenPositionWithTokenExtensionsInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 10) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      funder: getNextAccount(),\n      owner: getNextAccount(),\n      position: getNextAccount(),\n      positionMint: getNextAccount(),\n      positionTokenAccount: getNextAccount(),\n      whirlpool: getNextAccount(),\n      token2022Program: getNextAccount(),\n      systemProgram: getNextAccount(),\n      associatedTokenProgram: getNextAccount(),\n      metadataUpdateAuth: getNextAccount(),\n    },\n    data: getOpenPositionWithTokenExtensionsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getI32Decoder,\n  getI32Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const RESET_POSITION_RANGE_DISCRIMINATOR = new Uint8Array([\n  164, 123, 180, 141, 194, 100, 160, 175,\n]);\n\nexport function getResetPositionRangeDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    RESET_POSITION_RANGE_DISCRIMINATOR\n  );\n}\n\nexport type ResetPositionRangeInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountFunder extends string | IAccountMeta<string> = string,\n  TAccountPositionAuthority extends string | IAccountMeta<string> = string,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountPosition extends string | IAccountMeta<string> = string,\n  TAccountPositionTokenAccount extends string | IAccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountFunder extends string\n        ? WritableSignerAccount<TAccountFunder> &\n            IAccountSignerMeta<TAccountFunder>\n        : TAccountFunder,\n      TAccountPositionAuthority extends string\n        ? ReadonlySignerAccount<TAccountPositionAuthority> &\n            IAccountSignerMeta<TAccountPositionAuthority>\n        : TAccountPositionAuthority,\n      TAccountWhirlpool extends string\n        ? ReadonlyAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountPosition extends string\n        ? WritableAccount<TAccountPosition>\n        : TAccountPosition,\n      TAccountPositionTokenAccount extends string\n        ? ReadonlyAccount<TAccountPositionTokenAccount>\n        : TAccountPositionTokenAccount,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ResetPositionRangeInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  newTickLowerIndex: number;\n  newTickUpperIndex: number;\n};\n\nexport type ResetPositionRangeInstructionDataArgs = {\n  newTickLowerIndex: number;\n  newTickUpperIndex: number;\n};\n\nexport function getResetPositionRangeInstructionDataEncoder(): Encoder<ResetPositionRangeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['newTickLowerIndex', getI32Encoder()],\n      ['newTickUpperIndex', getI32Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: RESET_POSITION_RANGE_DISCRIMINATOR })\n  );\n}\n\nexport function getResetPositionRangeInstructionDataDecoder(): Decoder<ResetPositionRangeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['newTickLowerIndex', getI32Decoder()],\n    ['newTickUpperIndex', getI32Decoder()],\n  ]);\n}\n\nexport function getResetPositionRangeInstructionDataCodec(): Codec<\n  ResetPositionRangeInstructionDataArgs,\n  ResetPositionRangeInstructionData\n> {\n  return combineCodec(\n    getResetPositionRangeInstructionDataEncoder(),\n    getResetPositionRangeInstructionDataDecoder()\n  );\n}\n\nexport type ResetPositionRangeInput<\n  TAccountFunder extends string = string,\n  TAccountPositionAuthority extends string = string,\n  TAccountWhirlpool extends string = string,\n  TAccountPosition extends string = string,\n  TAccountPositionTokenAccount extends string = string,\n  TAccountSystemProgram extends string = string,\n> = {\n  funder: TransactionSigner<TAccountFunder>;\n  positionAuthority: TransactionSigner<TAccountPositionAuthority>;\n  whirlpool: Address<TAccountWhirlpool>;\n  position: Address<TAccountPosition>;\n  positionTokenAccount: Address<TAccountPositionTokenAccount>;\n  systemProgram?: Address<TAccountSystemProgram>;\n  newTickLowerIndex: ResetPositionRangeInstructionDataArgs['newTickLowerIndex'];\n  newTickUpperIndex: ResetPositionRangeInstructionDataArgs['newTickUpperIndex'];\n};\n\nexport function getResetPositionRangeInstruction<\n  TAccountFunder extends string,\n  TAccountPositionAuthority extends string,\n  TAccountWhirlpool extends string,\n  TAccountPosition extends string,\n  TAccountPositionTokenAccount extends string,\n  TAccountSystemProgram extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: ResetPositionRangeInput<\n    TAccountFunder,\n    TAccountPositionAuthority,\n    TAccountWhirlpool,\n    TAccountPosition,\n    TAccountPositionTokenAccount,\n    TAccountSystemProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ResetPositionRangeInstruction<\n  TProgramAddress,\n  TAccountFunder,\n  TAccountPositionAuthority,\n  TAccountWhirlpool,\n  TAccountPosition,\n  TAccountPositionTokenAccount,\n  TAccountSystemProgram\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    funder: { value: input.funder ?? null, isWritable: true },\n    positionAuthority: {\n      value: input.positionAuthority ?? null,\n      isWritable: false,\n    },\n    whirlpool: { value: input.whirlpool ?? null, isWritable: false },\n    position: { value: input.position ?? null, isWritable: true },\n    positionTokenAccount: {\n      value: input.positionTokenAccount ?? null,\n      isWritable: false,\n    },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.funder),\n      getAccountMeta(accounts.positionAuthority),\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.position),\n      getAccountMeta(accounts.positionTokenAccount),\n      getAccountMeta(accounts.systemProgram),\n    ],\n    programAddress,\n    data: getResetPositionRangeInstructionDataEncoder().encode(\n      args as ResetPositionRangeInstructionDataArgs\n    ),\n  } as ResetPositionRangeInstruction<\n    TProgramAddress,\n    TAccountFunder,\n    TAccountPositionAuthority,\n    TAccountWhirlpool,\n    TAccountPosition,\n    TAccountPositionTokenAccount,\n    TAccountSystemProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedResetPositionRangeInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    funder: TAccountMetas[0];\n    positionAuthority: TAccountMetas[1];\n    whirlpool: TAccountMetas[2];\n    position: TAccountMetas[3];\n    positionTokenAccount: TAccountMetas[4];\n    systemProgram: TAccountMetas[5];\n  };\n  data: ResetPositionRangeInstructionData;\n};\n\nexport function parseResetPositionRangeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedResetPositionRangeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 6) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      funder: getNextAccount(),\n      positionAuthority: getNextAccount(),\n      whirlpool: getNextAccount(),\n      position: getNextAccount(),\n      positionTokenAccount: getNextAccount(),\n      systemProgram: getNextAccount(),\n    },\n    data: getResetPositionRangeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SET_COLLECT_PROTOCOL_FEES_AUTHORITY_DISCRIMINATOR = new Uint8Array(\n  [34, 150, 93, 244, 139, 225, 233, 67]\n);\n\nexport function getSetCollectProtocolFeesAuthorityDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    SET_COLLECT_PROTOCOL_FEES_AUTHORITY_DISCRIMINATOR\n  );\n}\n\nexport type SetCollectProtocolFeesAuthorityInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpoolsConfig extends string | IAccountMeta<string> = string,\n  TAccountCollectProtocolFeesAuthority extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountNewCollectProtocolFeesAuthority extends\n    | string\n    | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpoolsConfig extends string\n        ? WritableAccount<TAccountWhirlpoolsConfig>\n        : TAccountWhirlpoolsConfig,\n      TAccountCollectProtocolFeesAuthority extends string\n        ? ReadonlySignerAccount<TAccountCollectProtocolFeesAuthority> &\n            IAccountSignerMeta<TAccountCollectProtocolFeesAuthority>\n        : TAccountCollectProtocolFeesAuthority,\n      TAccountNewCollectProtocolFeesAuthority extends string\n        ? ReadonlyAccount<TAccountNewCollectProtocolFeesAuthority>\n        : TAccountNewCollectProtocolFeesAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetCollectProtocolFeesAuthorityInstructionData = {\n  discriminator: ReadonlyUint8Array;\n};\n\nexport type SetCollectProtocolFeesAuthorityInstructionDataArgs = {};\n\nexport function getSetCollectProtocolFeesAuthorityInstructionDataEncoder(): Encoder<SetCollectProtocolFeesAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]),\n    (value) => ({\n      ...value,\n      discriminator: SET_COLLECT_PROTOCOL_FEES_AUTHORITY_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetCollectProtocolFeesAuthorityInstructionDataDecoder(): Decoder<SetCollectProtocolFeesAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n  ]);\n}\n\nexport function getSetCollectProtocolFeesAuthorityInstructionDataCodec(): Codec<\n  SetCollectProtocolFeesAuthorityInstructionDataArgs,\n  SetCollectProtocolFeesAuthorityInstructionData\n> {\n  return combineCodec(\n    getSetCollectProtocolFeesAuthorityInstructionDataEncoder(),\n    getSetCollectProtocolFeesAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type SetCollectProtocolFeesAuthorityInput<\n  TAccountWhirlpoolsConfig extends string = string,\n  TAccountCollectProtocolFeesAuthority extends string = string,\n  TAccountNewCollectProtocolFeesAuthority extends string = string,\n> = {\n  whirlpoolsConfig: Address<TAccountWhirlpoolsConfig>;\n  collectProtocolFeesAuthority: TransactionSigner<TAccountCollectProtocolFeesAuthority>;\n  newCollectProtocolFeesAuthority: Address<TAccountNewCollectProtocolFeesAuthority>;\n};\n\nexport function getSetCollectProtocolFeesAuthorityInstruction<\n  TAccountWhirlpoolsConfig extends string,\n  TAccountCollectProtocolFeesAuthority extends string,\n  TAccountNewCollectProtocolFeesAuthority extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: SetCollectProtocolFeesAuthorityInput<\n    TAccountWhirlpoolsConfig,\n    TAccountCollectProtocolFeesAuthority,\n    TAccountNewCollectProtocolFeesAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): SetCollectProtocolFeesAuthorityInstruction<\n  TProgramAddress,\n  TAccountWhirlpoolsConfig,\n  TAccountCollectProtocolFeesAuthority,\n  TAccountNewCollectProtocolFeesAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpoolsConfig: {\n      value: input.whirlpoolsConfig ?? null,\n      isWritable: true,\n    },\n    collectProtocolFeesAuthority: {\n      value: input.collectProtocolFeesAuthority ?? null,\n      isWritable: false,\n    },\n    newCollectProtocolFeesAuthority: {\n      value: input.newCollectProtocolFeesAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpoolsConfig),\n      getAccountMeta(accounts.collectProtocolFeesAuthority),\n      getAccountMeta(accounts.newCollectProtocolFeesAuthority),\n    ],\n    programAddress,\n    data: getSetCollectProtocolFeesAuthorityInstructionDataEncoder().encode({}),\n  } as SetCollectProtocolFeesAuthorityInstruction<\n    TProgramAddress,\n    TAccountWhirlpoolsConfig,\n    TAccountCollectProtocolFeesAuthority,\n    TAccountNewCollectProtocolFeesAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedSetCollectProtocolFeesAuthorityInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpoolsConfig: TAccountMetas[0];\n    collectProtocolFeesAuthority: TAccountMetas[1];\n    newCollectProtocolFeesAuthority: TAccountMetas[2];\n  };\n  data: SetCollectProtocolFeesAuthorityInstructionData;\n};\n\nexport function parseSetCollectProtocolFeesAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedSetCollectProtocolFeesAuthorityInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpoolsConfig: getNextAccount(),\n      collectProtocolFeesAuthority: getNextAccount(),\n      newCollectProtocolFeesAuthority: getNextAccount(),\n    },\n    data: getSetCollectProtocolFeesAuthorityInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SET_CONFIG_EXTENSION_AUTHORITY_DISCRIMINATOR = new Uint8Array([\n  44, 94, 241, 116, 24, 188, 60, 143,\n]);\n\nexport function getSetConfigExtensionAuthorityDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    SET_CONFIG_EXTENSION_AUTHORITY_DISCRIMINATOR\n  );\n}\n\nexport type SetConfigExtensionAuthorityInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpoolsConfig extends string | IAccountMeta<string> = string,\n  TAccountWhirlpoolsConfigExtension extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountConfigExtensionAuthority extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountNewConfigExtensionAuthority extends\n    | string\n    | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpoolsConfig extends string\n        ? ReadonlyAccount<TAccountWhirlpoolsConfig>\n        : TAccountWhirlpoolsConfig,\n      TAccountWhirlpoolsConfigExtension extends string\n        ? WritableAccount<TAccountWhirlpoolsConfigExtension>\n        : TAccountWhirlpoolsConfigExtension,\n      TAccountConfigExtensionAuthority extends string\n        ? ReadonlySignerAccount<TAccountConfigExtensionAuthority> &\n            IAccountSignerMeta<TAccountConfigExtensionAuthority>\n        : TAccountConfigExtensionAuthority,\n      TAccountNewConfigExtensionAuthority extends string\n        ? ReadonlyAccount<TAccountNewConfigExtensionAuthority>\n        : TAccountNewConfigExtensionAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetConfigExtensionAuthorityInstructionData = {\n  discriminator: ReadonlyUint8Array;\n};\n\nexport type SetConfigExtensionAuthorityInstructionDataArgs = {};\n\nexport function getSetConfigExtensionAuthorityInstructionDataEncoder(): Encoder<SetConfigExtensionAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]),\n    (value) => ({\n      ...value,\n      discriminator: SET_CONFIG_EXTENSION_AUTHORITY_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetConfigExtensionAuthorityInstructionDataDecoder(): Decoder<SetConfigExtensionAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n  ]);\n}\n\nexport function getSetConfigExtensionAuthorityInstructionDataCodec(): Codec<\n  SetConfigExtensionAuthorityInstructionDataArgs,\n  SetConfigExtensionAuthorityInstructionData\n> {\n  return combineCodec(\n    getSetConfigExtensionAuthorityInstructionDataEncoder(),\n    getSetConfigExtensionAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type SetConfigExtensionAuthorityInput<\n  TAccountWhirlpoolsConfig extends string = string,\n  TAccountWhirlpoolsConfigExtension extends string = string,\n  TAccountConfigExtensionAuthority extends string = string,\n  TAccountNewConfigExtensionAuthority extends string = string,\n> = {\n  whirlpoolsConfig: Address<TAccountWhirlpoolsConfig>;\n  whirlpoolsConfigExtension: Address<TAccountWhirlpoolsConfigExtension>;\n  configExtensionAuthority: TransactionSigner<TAccountConfigExtensionAuthority>;\n  newConfigExtensionAuthority: Address<TAccountNewConfigExtensionAuthority>;\n};\n\nexport function getSetConfigExtensionAuthorityInstruction<\n  TAccountWhirlpoolsConfig extends string,\n  TAccountWhirlpoolsConfigExtension extends string,\n  TAccountConfigExtensionAuthority extends string,\n  TAccountNewConfigExtensionAuthority extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: SetConfigExtensionAuthorityInput<\n    TAccountWhirlpoolsConfig,\n    TAccountWhirlpoolsConfigExtension,\n    TAccountConfigExtensionAuthority,\n    TAccountNewConfigExtensionAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): SetConfigExtensionAuthorityInstruction<\n  TProgramAddress,\n  TAccountWhirlpoolsConfig,\n  TAccountWhirlpoolsConfigExtension,\n  TAccountConfigExtensionAuthority,\n  TAccountNewConfigExtensionAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpoolsConfig: {\n      value: input.whirlpoolsConfig ?? null,\n      isWritable: false,\n    },\n    whirlpoolsConfigExtension: {\n      value: input.whirlpoolsConfigExtension ?? null,\n      isWritable: true,\n    },\n    configExtensionAuthority: {\n      value: input.configExtensionAuthority ?? null,\n      isWritable: false,\n    },\n    newConfigExtensionAuthority: {\n      value: input.newConfigExtensionAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpoolsConfig),\n      getAccountMeta(accounts.whirlpoolsConfigExtension),\n      getAccountMeta(accounts.configExtensionAuthority),\n      getAccountMeta(accounts.newConfigExtensionAuthority),\n    ],\n    programAddress,\n    data: getSetConfigExtensionAuthorityInstructionDataEncoder().encode({}),\n  } as SetConfigExtensionAuthorityInstruction<\n    TProgramAddress,\n    TAccountWhirlpoolsConfig,\n    TAccountWhirlpoolsConfigExtension,\n    TAccountConfigExtensionAuthority,\n    TAccountNewConfigExtensionAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedSetConfigExtensionAuthorityInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpoolsConfig: TAccountMetas[0];\n    whirlpoolsConfigExtension: TAccountMetas[1];\n    configExtensionAuthority: TAccountMetas[2];\n    newConfigExtensionAuthority: TAccountMetas[3];\n  };\n  data: SetConfigExtensionAuthorityInstructionData;\n};\n\nexport function parseSetConfigExtensionAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedSetConfigExtensionAuthorityInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpoolsConfig: getNextAccount(),\n      whirlpoolsConfigExtension: getNextAccount(),\n      configExtensionAuthority: getNextAccount(),\n      newConfigExtensionAuthority: getNextAccount(),\n    },\n    data: getSetConfigExtensionAuthorityInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SET_DEFAULT_BASE_FEE_RATE_DISCRIMINATOR = new Uint8Array([\n  229, 66, 84, 251, 164, 134, 183, 7,\n]);\n\nexport function getSetDefaultBaseFeeRateDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    SET_DEFAULT_BASE_FEE_RATE_DISCRIMINATOR\n  );\n}\n\nexport type SetDefaultBaseFeeRateInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpoolsConfig extends string | IAccountMeta<string> = string,\n  TAccountAdaptiveFeeTier extends string | IAccountMeta<string> = string,\n  TAccountFeeAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpoolsConfig extends string\n        ? ReadonlyAccount<TAccountWhirlpoolsConfig>\n        : TAccountWhirlpoolsConfig,\n      TAccountAdaptiveFeeTier extends string\n        ? WritableAccount<TAccountAdaptiveFeeTier>\n        : TAccountAdaptiveFeeTier,\n      TAccountFeeAuthority extends string\n        ? ReadonlySignerAccount<TAccountFeeAuthority> &\n            IAccountSignerMeta<TAccountFeeAuthority>\n        : TAccountFeeAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetDefaultBaseFeeRateInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  defaultBaseFeeRate: number;\n};\n\nexport type SetDefaultBaseFeeRateInstructionDataArgs = {\n  defaultBaseFeeRate: number;\n};\n\nexport function getSetDefaultBaseFeeRateInstructionDataEncoder(): Encoder<SetDefaultBaseFeeRateInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['defaultBaseFeeRate', getU16Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: SET_DEFAULT_BASE_FEE_RATE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetDefaultBaseFeeRateInstructionDataDecoder(): Decoder<SetDefaultBaseFeeRateInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['defaultBaseFeeRate', getU16Decoder()],\n  ]);\n}\n\nexport function getSetDefaultBaseFeeRateInstructionDataCodec(): Codec<\n  SetDefaultBaseFeeRateInstructionDataArgs,\n  SetDefaultBaseFeeRateInstructionData\n> {\n  return combineCodec(\n    getSetDefaultBaseFeeRateInstructionDataEncoder(),\n    getSetDefaultBaseFeeRateInstructionDataDecoder()\n  );\n}\n\nexport type SetDefaultBaseFeeRateInput<\n  TAccountWhirlpoolsConfig extends string = string,\n  TAccountAdaptiveFeeTier extends string = string,\n  TAccountFeeAuthority extends string = string,\n> = {\n  whirlpoolsConfig: Address<TAccountWhirlpoolsConfig>;\n  adaptiveFeeTier: Address<TAccountAdaptiveFeeTier>;\n  feeAuthority: TransactionSigner<TAccountFeeAuthority>;\n  defaultBaseFeeRate: SetDefaultBaseFeeRateInstructionDataArgs['defaultBaseFeeRate'];\n};\n\nexport function getSetDefaultBaseFeeRateInstruction<\n  TAccountWhirlpoolsConfig extends string,\n  TAccountAdaptiveFeeTier extends string,\n  TAccountFeeAuthority extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: SetDefaultBaseFeeRateInput<\n    TAccountWhirlpoolsConfig,\n    TAccountAdaptiveFeeTier,\n    TAccountFeeAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): SetDefaultBaseFeeRateInstruction<\n  TProgramAddress,\n  TAccountWhirlpoolsConfig,\n  TAccountAdaptiveFeeTier,\n  TAccountFeeAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpoolsConfig: {\n      value: input.whirlpoolsConfig ?? null,\n      isWritable: false,\n    },\n    adaptiveFeeTier: { value: input.adaptiveFeeTier ?? null, isWritable: true },\n    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpoolsConfig),\n      getAccountMeta(accounts.adaptiveFeeTier),\n      getAccountMeta(accounts.feeAuthority),\n    ],\n    programAddress,\n    data: getSetDefaultBaseFeeRateInstructionDataEncoder().encode(\n      args as SetDefaultBaseFeeRateInstructionDataArgs\n    ),\n  } as SetDefaultBaseFeeRateInstruction<\n    TProgramAddress,\n    TAccountWhirlpoolsConfig,\n    TAccountAdaptiveFeeTier,\n    TAccountFeeAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedSetDefaultBaseFeeRateInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpoolsConfig: TAccountMetas[0];\n    adaptiveFeeTier: TAccountMetas[1];\n    feeAuthority: TAccountMetas[2];\n  };\n  data: SetDefaultBaseFeeRateInstructionData;\n};\n\nexport function parseSetDefaultBaseFeeRateInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedSetDefaultBaseFeeRateInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpoolsConfig: getNextAccount(),\n      adaptiveFeeTier: getNextAccount(),\n      feeAuthority: getNextAccount(),\n    },\n    data: getSetDefaultBaseFeeRateInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SET_DEFAULT_FEE_RATE_DISCRIMINATOR = new Uint8Array([\n  118, 215, 214, 157, 182, 229, 208, 228,\n]);\n\nexport function getSetDefaultFeeRateDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    SET_DEFAULT_FEE_RATE_DISCRIMINATOR\n  );\n}\n\nexport type SetDefaultFeeRateInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpoolsConfig extends string | IAccountMeta<string> = string,\n  TAccountFeeTier extends string | IAccountMeta<string> = string,\n  TAccountFeeAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpoolsConfig extends string\n        ? ReadonlyAccount<TAccountWhirlpoolsConfig>\n        : TAccountWhirlpoolsConfig,\n      TAccountFeeTier extends string\n        ? WritableAccount<TAccountFeeTier>\n        : TAccountFeeTier,\n      TAccountFeeAuthority extends string\n        ? ReadonlySignerAccount<TAccountFeeAuthority> &\n            IAccountSignerMeta<TAccountFeeAuthority>\n        : TAccountFeeAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetDefaultFeeRateInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  defaultFeeRate: number;\n};\n\nexport type SetDefaultFeeRateInstructionDataArgs = { defaultFeeRate: number };\n\nexport function getSetDefaultFeeRateInstructionDataEncoder(): Encoder<SetDefaultFeeRateInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['defaultFeeRate', getU16Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: SET_DEFAULT_FEE_RATE_DISCRIMINATOR })\n  );\n}\n\nexport function getSetDefaultFeeRateInstructionDataDecoder(): Decoder<SetDefaultFeeRateInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['defaultFeeRate', getU16Decoder()],\n  ]);\n}\n\nexport function getSetDefaultFeeRateInstructionDataCodec(): Codec<\n  SetDefaultFeeRateInstructionDataArgs,\n  SetDefaultFeeRateInstructionData\n> {\n  return combineCodec(\n    getSetDefaultFeeRateInstructionDataEncoder(),\n    getSetDefaultFeeRateInstructionDataDecoder()\n  );\n}\n\nexport type SetDefaultFeeRateInput<\n  TAccountWhirlpoolsConfig extends string = string,\n  TAccountFeeTier extends string = string,\n  TAccountFeeAuthority extends string = string,\n> = {\n  whirlpoolsConfig: Address<TAccountWhirlpoolsConfig>;\n  feeTier: Address<TAccountFeeTier>;\n  feeAuthority: TransactionSigner<TAccountFeeAuthority>;\n  defaultFeeRate: SetDefaultFeeRateInstructionDataArgs['defaultFeeRate'];\n};\n\nexport function getSetDefaultFeeRateInstruction<\n  TAccountWhirlpoolsConfig extends string,\n  TAccountFeeTier extends string,\n  TAccountFeeAuthority extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: SetDefaultFeeRateInput<\n    TAccountWhirlpoolsConfig,\n    TAccountFeeTier,\n    TAccountFeeAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): SetDefaultFeeRateInstruction<\n  TProgramAddress,\n  TAccountWhirlpoolsConfig,\n  TAccountFeeTier,\n  TAccountFeeAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpoolsConfig: {\n      value: input.whirlpoolsConfig ?? null,\n      isWritable: false,\n    },\n    feeTier: { value: input.feeTier ?? null, isWritable: true },\n    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpoolsConfig),\n      getAccountMeta(accounts.feeTier),\n      getAccountMeta(accounts.feeAuthority),\n    ],\n    programAddress,\n    data: getSetDefaultFeeRateInstructionDataEncoder().encode(\n      args as SetDefaultFeeRateInstructionDataArgs\n    ),\n  } as SetDefaultFeeRateInstruction<\n    TProgramAddress,\n    TAccountWhirlpoolsConfig,\n    TAccountFeeTier,\n    TAccountFeeAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedSetDefaultFeeRateInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpoolsConfig: TAccountMetas[0];\n    feeTier: TAccountMetas[1];\n    feeAuthority: TAccountMetas[2];\n  };\n  data: SetDefaultFeeRateInstructionData;\n};\n\nexport function parseSetDefaultFeeRateInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedSetDefaultFeeRateInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpoolsConfig: getNextAccount(),\n      feeTier: getNextAccount(),\n      feeAuthority: getNextAccount(),\n    },\n    data: getSetDefaultFeeRateInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SET_DEFAULT_PROTOCOL_FEE_RATE_DISCRIMINATOR = new Uint8Array([\n  107, 205, 249, 226, 151, 35, 86, 0,\n]);\n\nexport function getSetDefaultProtocolFeeRateDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    SET_DEFAULT_PROTOCOL_FEE_RATE_DISCRIMINATOR\n  );\n}\n\nexport type SetDefaultProtocolFeeRateInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpoolsConfig extends string | IAccountMeta<string> = string,\n  TAccountFeeAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpoolsConfig extends string\n        ? WritableAccount<TAccountWhirlpoolsConfig>\n        : TAccountWhirlpoolsConfig,\n      TAccountFeeAuthority extends string\n        ? ReadonlySignerAccount<TAccountFeeAuthority> &\n            IAccountSignerMeta<TAccountFeeAuthority>\n        : TAccountFeeAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetDefaultProtocolFeeRateInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  defaultProtocolFeeRate: number;\n};\n\nexport type SetDefaultProtocolFeeRateInstructionDataArgs = {\n  defaultProtocolFeeRate: number;\n};\n\nexport function getSetDefaultProtocolFeeRateInstructionDataEncoder(): Encoder<SetDefaultProtocolFeeRateInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['defaultProtocolFeeRate', getU16Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: SET_DEFAULT_PROTOCOL_FEE_RATE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetDefaultProtocolFeeRateInstructionDataDecoder(): Decoder<SetDefaultProtocolFeeRateInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['defaultProtocolFeeRate', getU16Decoder()],\n  ]);\n}\n\nexport function getSetDefaultProtocolFeeRateInstructionDataCodec(): Codec<\n  SetDefaultProtocolFeeRateInstructionDataArgs,\n  SetDefaultProtocolFeeRateInstructionData\n> {\n  return combineCodec(\n    getSetDefaultProtocolFeeRateInstructionDataEncoder(),\n    getSetDefaultProtocolFeeRateInstructionDataDecoder()\n  );\n}\n\nexport type SetDefaultProtocolFeeRateInput<\n  TAccountWhirlpoolsConfig extends string = string,\n  TAccountFeeAuthority extends string = string,\n> = {\n  whirlpoolsConfig: Address<TAccountWhirlpoolsConfig>;\n  feeAuthority: TransactionSigner<TAccountFeeAuthority>;\n  defaultProtocolFeeRate: SetDefaultProtocolFeeRateInstructionDataArgs['defaultProtocolFeeRate'];\n};\n\nexport function getSetDefaultProtocolFeeRateInstruction<\n  TAccountWhirlpoolsConfig extends string,\n  TAccountFeeAuthority extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: SetDefaultProtocolFeeRateInput<\n    TAccountWhirlpoolsConfig,\n    TAccountFeeAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): SetDefaultProtocolFeeRateInstruction<\n  TProgramAddress,\n  TAccountWhirlpoolsConfig,\n  TAccountFeeAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpoolsConfig: {\n      value: input.whirlpoolsConfig ?? null,\n      isWritable: true,\n    },\n    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpoolsConfig),\n      getAccountMeta(accounts.feeAuthority),\n    ],\n    programAddress,\n    data: getSetDefaultProtocolFeeRateInstructionDataEncoder().encode(\n      args as SetDefaultProtocolFeeRateInstructionDataArgs\n    ),\n  } as SetDefaultProtocolFeeRateInstruction<\n    TProgramAddress,\n    TAccountWhirlpoolsConfig,\n    TAccountFeeAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedSetDefaultProtocolFeeRateInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpoolsConfig: TAccountMetas[0];\n    feeAuthority: TAccountMetas[1];\n  };\n  data: SetDefaultProtocolFeeRateInstructionData;\n};\n\nexport function parseSetDefaultProtocolFeeRateInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedSetDefaultProtocolFeeRateInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpoolsConfig: getNextAccount(),\n      feeAuthority: getNextAccount(),\n    },\n    data: getSetDefaultProtocolFeeRateInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SET_DELEGATED_FEE_AUTHORITY_DISCRIMINATOR = new Uint8Array([\n  193, 234, 231, 147, 138, 57, 3, 122,\n]);\n\nexport function getSetDelegatedFeeAuthorityDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    SET_DELEGATED_FEE_AUTHORITY_DISCRIMINATOR\n  );\n}\n\nexport type SetDelegatedFeeAuthorityInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpoolsConfig extends string | IAccountMeta<string> = string,\n  TAccountAdaptiveFeeTier extends string | IAccountMeta<string> = string,\n  TAccountFeeAuthority extends string | IAccountMeta<string> = string,\n  TAccountNewDelegatedFeeAuthority extends\n    | string\n    | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpoolsConfig extends string\n        ? ReadonlyAccount<TAccountWhirlpoolsConfig>\n        : TAccountWhirlpoolsConfig,\n      TAccountAdaptiveFeeTier extends string\n        ? WritableAccount<TAccountAdaptiveFeeTier>\n        : TAccountAdaptiveFeeTier,\n      TAccountFeeAuthority extends string\n        ? ReadonlySignerAccount<TAccountFeeAuthority> &\n            IAccountSignerMeta<TAccountFeeAuthority>\n        : TAccountFeeAuthority,\n      TAccountNewDelegatedFeeAuthority extends string\n        ? ReadonlyAccount<TAccountNewDelegatedFeeAuthority>\n        : TAccountNewDelegatedFeeAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetDelegatedFeeAuthorityInstructionData = {\n  discriminator: ReadonlyUint8Array;\n};\n\nexport type SetDelegatedFeeAuthorityInstructionDataArgs = {};\n\nexport function getSetDelegatedFeeAuthorityInstructionDataEncoder(): Encoder<SetDelegatedFeeAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]),\n    (value) => ({\n      ...value,\n      discriminator: SET_DELEGATED_FEE_AUTHORITY_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetDelegatedFeeAuthorityInstructionDataDecoder(): Decoder<SetDelegatedFeeAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n  ]);\n}\n\nexport function getSetDelegatedFeeAuthorityInstructionDataCodec(): Codec<\n  SetDelegatedFeeAuthorityInstructionDataArgs,\n  SetDelegatedFeeAuthorityInstructionData\n> {\n  return combineCodec(\n    getSetDelegatedFeeAuthorityInstructionDataEncoder(),\n    getSetDelegatedFeeAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type SetDelegatedFeeAuthorityInput<\n  TAccountWhirlpoolsConfig extends string = string,\n  TAccountAdaptiveFeeTier extends string = string,\n  TAccountFeeAuthority extends string = string,\n  TAccountNewDelegatedFeeAuthority extends string = string,\n> = {\n  whirlpoolsConfig: Address<TAccountWhirlpoolsConfig>;\n  adaptiveFeeTier: Address<TAccountAdaptiveFeeTier>;\n  feeAuthority: TransactionSigner<TAccountFeeAuthority>;\n  newDelegatedFeeAuthority: Address<TAccountNewDelegatedFeeAuthority>;\n};\n\nexport function getSetDelegatedFeeAuthorityInstruction<\n  TAccountWhirlpoolsConfig extends string,\n  TAccountAdaptiveFeeTier extends string,\n  TAccountFeeAuthority extends string,\n  TAccountNewDelegatedFeeAuthority extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: SetDelegatedFeeAuthorityInput<\n    TAccountWhirlpoolsConfig,\n    TAccountAdaptiveFeeTier,\n    TAccountFeeAuthority,\n    TAccountNewDelegatedFeeAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): SetDelegatedFeeAuthorityInstruction<\n  TProgramAddress,\n  TAccountWhirlpoolsConfig,\n  TAccountAdaptiveFeeTier,\n  TAccountFeeAuthority,\n  TAccountNewDelegatedFeeAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpoolsConfig: {\n      value: input.whirlpoolsConfig ?? null,\n      isWritable: false,\n    },\n    adaptiveFeeTier: { value: input.adaptiveFeeTier ?? null, isWritable: true },\n    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },\n    newDelegatedFeeAuthority: {\n      value: input.newDelegatedFeeAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpoolsConfig),\n      getAccountMeta(accounts.adaptiveFeeTier),\n      getAccountMeta(accounts.feeAuthority),\n      getAccountMeta(accounts.newDelegatedFeeAuthority),\n    ],\n    programAddress,\n    data: getSetDelegatedFeeAuthorityInstructionDataEncoder().encode({}),\n  } as SetDelegatedFeeAuthorityInstruction<\n    TProgramAddress,\n    TAccountWhirlpoolsConfig,\n    TAccountAdaptiveFeeTier,\n    TAccountFeeAuthority,\n    TAccountNewDelegatedFeeAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedSetDelegatedFeeAuthorityInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpoolsConfig: TAccountMetas[0];\n    adaptiveFeeTier: TAccountMetas[1];\n    feeAuthority: TAccountMetas[2];\n    newDelegatedFeeAuthority: TAccountMetas[3];\n  };\n  data: SetDelegatedFeeAuthorityInstructionData;\n};\n\nexport function parseSetDelegatedFeeAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedSetDelegatedFeeAuthorityInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpoolsConfig: getNextAccount(),\n      adaptiveFeeTier: getNextAccount(),\n      feeAuthority: getNextAccount(),\n      newDelegatedFeeAuthority: getNextAccount(),\n    },\n    data: getSetDelegatedFeeAuthorityInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SET_FEE_AUTHORITY_DISCRIMINATOR = new Uint8Array([\n  31, 1, 50, 87, 237, 101, 97, 132,\n]);\n\nexport function getSetFeeAuthorityDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    SET_FEE_AUTHORITY_DISCRIMINATOR\n  );\n}\n\nexport type SetFeeAuthorityInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpoolsConfig extends string | IAccountMeta<string> = string,\n  TAccountFeeAuthority extends string | IAccountMeta<string> = string,\n  TAccountNewFeeAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpoolsConfig extends string\n        ? WritableAccount<TAccountWhirlpoolsConfig>\n        : TAccountWhirlpoolsConfig,\n      TAccountFeeAuthority extends string\n        ? ReadonlySignerAccount<TAccountFeeAuthority> &\n            IAccountSignerMeta<TAccountFeeAuthority>\n        : TAccountFeeAuthority,\n      TAccountNewFeeAuthority extends string\n        ? ReadonlyAccount<TAccountNewFeeAuthority>\n        : TAccountNewFeeAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetFeeAuthorityInstructionData = {\n  discriminator: ReadonlyUint8Array;\n};\n\nexport type SetFeeAuthorityInstructionDataArgs = {};\n\nexport function getSetFeeAuthorityInstructionDataEncoder(): Encoder<SetFeeAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]),\n    (value) => ({ ...value, discriminator: SET_FEE_AUTHORITY_DISCRIMINATOR })\n  );\n}\n\nexport function getSetFeeAuthorityInstructionDataDecoder(): Decoder<SetFeeAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n  ]);\n}\n\nexport function getSetFeeAuthorityInstructionDataCodec(): Codec<\n  SetFeeAuthorityInstructionDataArgs,\n  SetFeeAuthorityInstructionData\n> {\n  return combineCodec(\n    getSetFeeAuthorityInstructionDataEncoder(),\n    getSetFeeAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type SetFeeAuthorityInput<\n  TAccountWhirlpoolsConfig extends string = string,\n  TAccountFeeAuthority extends string = string,\n  TAccountNewFeeAuthority extends string = string,\n> = {\n  whirlpoolsConfig: Address<TAccountWhirlpoolsConfig>;\n  feeAuthority: TransactionSigner<TAccountFeeAuthority>;\n  newFeeAuthority: Address<TAccountNewFeeAuthority>;\n};\n\nexport function getSetFeeAuthorityInstruction<\n  TAccountWhirlpoolsConfig extends string,\n  TAccountFeeAuthority extends string,\n  TAccountNewFeeAuthority extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: SetFeeAuthorityInput<\n    TAccountWhirlpoolsConfig,\n    TAccountFeeAuthority,\n    TAccountNewFeeAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): SetFeeAuthorityInstruction<\n  TProgramAddress,\n  TAccountWhirlpoolsConfig,\n  TAccountFeeAuthority,\n  TAccountNewFeeAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpoolsConfig: {\n      value: input.whirlpoolsConfig ?? null,\n      isWritable: true,\n    },\n    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },\n    newFeeAuthority: {\n      value: input.newFeeAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpoolsConfig),\n      getAccountMeta(accounts.feeAuthority),\n      getAccountMeta(accounts.newFeeAuthority),\n    ],\n    programAddress,\n    data: getSetFeeAuthorityInstructionDataEncoder().encode({}),\n  } as SetFeeAuthorityInstruction<\n    TProgramAddress,\n    TAccountWhirlpoolsConfig,\n    TAccountFeeAuthority,\n    TAccountNewFeeAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedSetFeeAuthorityInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpoolsConfig: TAccountMetas[0];\n    feeAuthority: TAccountMetas[1];\n    newFeeAuthority: TAccountMetas[2];\n  };\n  data: SetFeeAuthorityInstructionData;\n};\n\nexport function parseSetFeeAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedSetFeeAuthorityInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpoolsConfig: getNextAccount(),\n      feeAuthority: getNextAccount(),\n      newFeeAuthority: getNextAccount(),\n    },\n    data: getSetFeeAuthorityInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SET_FEE_RATE_DISCRIMINATOR = new Uint8Array([\n  53, 243, 137, 65, 8, 140, 158, 6,\n]);\n\nexport function getSetFeeRateDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    SET_FEE_RATE_DISCRIMINATOR\n  );\n}\n\nexport type SetFeeRateInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpoolsConfig extends string | IAccountMeta<string> = string,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountFeeAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpoolsConfig extends string\n        ? ReadonlyAccount<TAccountWhirlpoolsConfig>\n        : TAccountWhirlpoolsConfig,\n      TAccountWhirlpool extends string\n        ? WritableAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountFeeAuthority extends string\n        ? ReadonlySignerAccount<TAccountFeeAuthority> &\n            IAccountSignerMeta<TAccountFeeAuthority>\n        : TAccountFeeAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetFeeRateInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  feeRate: number;\n};\n\nexport type SetFeeRateInstructionDataArgs = { feeRate: number };\n\nexport function getSetFeeRateInstructionDataEncoder(): Encoder<SetFeeRateInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['feeRate', getU16Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: SET_FEE_RATE_DISCRIMINATOR })\n  );\n}\n\nexport function getSetFeeRateInstructionDataDecoder(): Decoder<SetFeeRateInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['feeRate', getU16Decoder()],\n  ]);\n}\n\nexport function getSetFeeRateInstructionDataCodec(): Codec<\n  SetFeeRateInstructionDataArgs,\n  SetFeeRateInstructionData\n> {\n  return combineCodec(\n    getSetFeeRateInstructionDataEncoder(),\n    getSetFeeRateInstructionDataDecoder()\n  );\n}\n\nexport type SetFeeRateInput<\n  TAccountWhirlpoolsConfig extends string = string,\n  TAccountWhirlpool extends string = string,\n  TAccountFeeAuthority extends string = string,\n> = {\n  whirlpoolsConfig: Address<TAccountWhirlpoolsConfig>;\n  whirlpool: Address<TAccountWhirlpool>;\n  feeAuthority: TransactionSigner<TAccountFeeAuthority>;\n  feeRate: SetFeeRateInstructionDataArgs['feeRate'];\n};\n\nexport function getSetFeeRateInstruction<\n  TAccountWhirlpoolsConfig extends string,\n  TAccountWhirlpool extends string,\n  TAccountFeeAuthority extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: SetFeeRateInput<\n    TAccountWhirlpoolsConfig,\n    TAccountWhirlpool,\n    TAccountFeeAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): SetFeeRateInstruction<\n  TProgramAddress,\n  TAccountWhirlpoolsConfig,\n  TAccountWhirlpool,\n  TAccountFeeAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpoolsConfig: {\n      value: input.whirlpoolsConfig ?? null,\n      isWritable: false,\n    },\n    whirlpool: { value: input.whirlpool ?? null, isWritable: true },\n    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpoolsConfig),\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.feeAuthority),\n    ],\n    programAddress,\n    data: getSetFeeRateInstructionDataEncoder().encode(\n      args as SetFeeRateInstructionDataArgs\n    ),\n  } as SetFeeRateInstruction<\n    TProgramAddress,\n    TAccountWhirlpoolsConfig,\n    TAccountWhirlpool,\n    TAccountFeeAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedSetFeeRateInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpoolsConfig: TAccountMetas[0];\n    whirlpool: TAccountMetas[1];\n    feeAuthority: TAccountMetas[2];\n  };\n  data: SetFeeRateInstructionData;\n};\n\nexport function parseSetFeeRateInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedSetFeeRateInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpoolsConfig: getNextAccount(),\n      whirlpool: getNextAccount(),\n      feeAuthority: getNextAccount(),\n    },\n    data: getSetFeeRateInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SET_FEE_RATE_BY_DELEGATED_FEE_AUTHORITY_DISCRIMINATOR =\n  new Uint8Array([121, 121, 54, 114, 131, 230, 162, 104]);\n\nexport function getSetFeeRateByDelegatedFeeAuthorityDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    SET_FEE_RATE_BY_DELEGATED_FEE_AUTHORITY_DISCRIMINATOR\n  );\n}\n\nexport type SetFeeRateByDelegatedFeeAuthorityInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountAdaptiveFeeTier extends string | IAccountMeta<string> = string,\n  TAccountDelegatedFeeAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpool extends string\n        ? WritableAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountAdaptiveFeeTier extends string\n        ? ReadonlyAccount<TAccountAdaptiveFeeTier>\n        : TAccountAdaptiveFeeTier,\n      TAccountDelegatedFeeAuthority extends string\n        ? ReadonlySignerAccount<TAccountDelegatedFeeAuthority> &\n            IAccountSignerMeta<TAccountDelegatedFeeAuthority>\n        : TAccountDelegatedFeeAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetFeeRateByDelegatedFeeAuthorityInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  feeRate: number;\n};\n\nexport type SetFeeRateByDelegatedFeeAuthorityInstructionDataArgs = {\n  feeRate: number;\n};\n\nexport function getSetFeeRateByDelegatedFeeAuthorityInstructionDataEncoder(): Encoder<SetFeeRateByDelegatedFeeAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['feeRate', getU16Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: SET_FEE_RATE_BY_DELEGATED_FEE_AUTHORITY_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetFeeRateByDelegatedFeeAuthorityInstructionDataDecoder(): Decoder<SetFeeRateByDelegatedFeeAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['feeRate', getU16Decoder()],\n  ]);\n}\n\nexport function getSetFeeRateByDelegatedFeeAuthorityInstructionDataCodec(): Codec<\n  SetFeeRateByDelegatedFeeAuthorityInstructionDataArgs,\n  SetFeeRateByDelegatedFeeAuthorityInstructionData\n> {\n  return combineCodec(\n    getSetFeeRateByDelegatedFeeAuthorityInstructionDataEncoder(),\n    getSetFeeRateByDelegatedFeeAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type SetFeeRateByDelegatedFeeAuthorityInput<\n  TAccountWhirlpool extends string = string,\n  TAccountAdaptiveFeeTier extends string = string,\n  TAccountDelegatedFeeAuthority extends string = string,\n> = {\n  whirlpool: Address<TAccountWhirlpool>;\n  adaptiveFeeTier: Address<TAccountAdaptiveFeeTier>;\n  delegatedFeeAuthority: TransactionSigner<TAccountDelegatedFeeAuthority>;\n  feeRate: SetFeeRateByDelegatedFeeAuthorityInstructionDataArgs['feeRate'];\n};\n\nexport function getSetFeeRateByDelegatedFeeAuthorityInstruction<\n  TAccountWhirlpool extends string,\n  TAccountAdaptiveFeeTier extends string,\n  TAccountDelegatedFeeAuthority extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: SetFeeRateByDelegatedFeeAuthorityInput<\n    TAccountWhirlpool,\n    TAccountAdaptiveFeeTier,\n    TAccountDelegatedFeeAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): SetFeeRateByDelegatedFeeAuthorityInstruction<\n  TProgramAddress,\n  TAccountWhirlpool,\n  TAccountAdaptiveFeeTier,\n  TAccountDelegatedFeeAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpool: { value: input.whirlpool ?? null, isWritable: true },\n    adaptiveFeeTier: {\n      value: input.adaptiveFeeTier ?? null,\n      isWritable: false,\n    },\n    delegatedFeeAuthority: {\n      value: input.delegatedFeeAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.adaptiveFeeTier),\n      getAccountMeta(accounts.delegatedFeeAuthority),\n    ],\n    programAddress,\n    data: getSetFeeRateByDelegatedFeeAuthorityInstructionDataEncoder().encode(\n      args as SetFeeRateByDelegatedFeeAuthorityInstructionDataArgs\n    ),\n  } as SetFeeRateByDelegatedFeeAuthorityInstruction<\n    TProgramAddress,\n    TAccountWhirlpool,\n    TAccountAdaptiveFeeTier,\n    TAccountDelegatedFeeAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedSetFeeRateByDelegatedFeeAuthorityInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpool: TAccountMetas[0];\n    adaptiveFeeTier: TAccountMetas[1];\n    delegatedFeeAuthority: TAccountMetas[2];\n  };\n  data: SetFeeRateByDelegatedFeeAuthorityInstructionData;\n};\n\nexport function parseSetFeeRateByDelegatedFeeAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedSetFeeRateByDelegatedFeeAuthorityInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpool: getNextAccount(),\n      adaptiveFeeTier: getNextAccount(),\n      delegatedFeeAuthority: getNextAccount(),\n    },\n    data: getSetFeeRateByDelegatedFeeAuthorityInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SET_INITIALIZE_POOL_AUTHORITY_DISCRIMINATOR = new Uint8Array([\n  125, 43, 127, 235, 149, 26, 106, 236,\n]);\n\nexport function getSetInitializePoolAuthorityDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    SET_INITIALIZE_POOL_AUTHORITY_DISCRIMINATOR\n  );\n}\n\nexport type SetInitializePoolAuthorityInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpoolsConfig extends string | IAccountMeta<string> = string,\n  TAccountAdaptiveFeeTier extends string | IAccountMeta<string> = string,\n  TAccountFeeAuthority extends string | IAccountMeta<string> = string,\n  TAccountNewInitializePoolAuthority extends\n    | string\n    | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpoolsConfig extends string\n        ? ReadonlyAccount<TAccountWhirlpoolsConfig>\n        : TAccountWhirlpoolsConfig,\n      TAccountAdaptiveFeeTier extends string\n        ? WritableAccount<TAccountAdaptiveFeeTier>\n        : TAccountAdaptiveFeeTier,\n      TAccountFeeAuthority extends string\n        ? ReadonlySignerAccount<TAccountFeeAuthority> &\n            IAccountSignerMeta<TAccountFeeAuthority>\n        : TAccountFeeAuthority,\n      TAccountNewInitializePoolAuthority extends string\n        ? ReadonlyAccount<TAccountNewInitializePoolAuthority>\n        : TAccountNewInitializePoolAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetInitializePoolAuthorityInstructionData = {\n  discriminator: ReadonlyUint8Array;\n};\n\nexport type SetInitializePoolAuthorityInstructionDataArgs = {};\n\nexport function getSetInitializePoolAuthorityInstructionDataEncoder(): Encoder<SetInitializePoolAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]),\n    (value) => ({\n      ...value,\n      discriminator: SET_INITIALIZE_POOL_AUTHORITY_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetInitializePoolAuthorityInstructionDataDecoder(): Decoder<SetInitializePoolAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n  ]);\n}\n\nexport function getSetInitializePoolAuthorityInstructionDataCodec(): Codec<\n  SetInitializePoolAuthorityInstructionDataArgs,\n  SetInitializePoolAuthorityInstructionData\n> {\n  return combineCodec(\n    getSetInitializePoolAuthorityInstructionDataEncoder(),\n    getSetInitializePoolAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type SetInitializePoolAuthorityInput<\n  TAccountWhirlpoolsConfig extends string = string,\n  TAccountAdaptiveFeeTier extends string = string,\n  TAccountFeeAuthority extends string = string,\n  TAccountNewInitializePoolAuthority extends string = string,\n> = {\n  whirlpoolsConfig: Address<TAccountWhirlpoolsConfig>;\n  adaptiveFeeTier: Address<TAccountAdaptiveFeeTier>;\n  feeAuthority: TransactionSigner<TAccountFeeAuthority>;\n  newInitializePoolAuthority: Address<TAccountNewInitializePoolAuthority>;\n};\n\nexport function getSetInitializePoolAuthorityInstruction<\n  TAccountWhirlpoolsConfig extends string,\n  TAccountAdaptiveFeeTier extends string,\n  TAccountFeeAuthority extends string,\n  TAccountNewInitializePoolAuthority extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: SetInitializePoolAuthorityInput<\n    TAccountWhirlpoolsConfig,\n    TAccountAdaptiveFeeTier,\n    TAccountFeeAuthority,\n    TAccountNewInitializePoolAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): SetInitializePoolAuthorityInstruction<\n  TProgramAddress,\n  TAccountWhirlpoolsConfig,\n  TAccountAdaptiveFeeTier,\n  TAccountFeeAuthority,\n  TAccountNewInitializePoolAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpoolsConfig: {\n      value: input.whirlpoolsConfig ?? null,\n      isWritable: false,\n    },\n    adaptiveFeeTier: { value: input.adaptiveFeeTier ?? null, isWritable: true },\n    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },\n    newInitializePoolAuthority: {\n      value: input.newInitializePoolAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpoolsConfig),\n      getAccountMeta(accounts.adaptiveFeeTier),\n      getAccountMeta(accounts.feeAuthority),\n      getAccountMeta(accounts.newInitializePoolAuthority),\n    ],\n    programAddress,\n    data: getSetInitializePoolAuthorityInstructionDataEncoder().encode({}),\n  } as SetInitializePoolAuthorityInstruction<\n    TProgramAddress,\n    TAccountWhirlpoolsConfig,\n    TAccountAdaptiveFeeTier,\n    TAccountFeeAuthority,\n    TAccountNewInitializePoolAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedSetInitializePoolAuthorityInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpoolsConfig: TAccountMetas[0];\n    adaptiveFeeTier: TAccountMetas[1];\n    feeAuthority: TAccountMetas[2];\n    newInitializePoolAuthority: TAccountMetas[3];\n  };\n  data: SetInitializePoolAuthorityInstructionData;\n};\n\nexport function parseSetInitializePoolAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedSetInitializePoolAuthorityInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpoolsConfig: getNextAccount(),\n      adaptiveFeeTier: getNextAccount(),\n      feeAuthority: getNextAccount(),\n      newInitializePoolAuthority: getNextAccount(),\n    },\n    data: getSetInitializePoolAuthorityInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SET_PRESET_ADAPTIVE_FEE_CONSTANTS_DISCRIMINATOR = new Uint8Array([\n  132, 185, 66, 148, 83, 88, 134, 198,\n]);\n\nexport function getSetPresetAdaptiveFeeConstantsDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    SET_PRESET_ADAPTIVE_FEE_CONSTANTS_DISCRIMINATOR\n  );\n}\n\nexport type SetPresetAdaptiveFeeConstantsInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpoolsConfig extends string | IAccountMeta<string> = string,\n  TAccountAdaptiveFeeTier extends string | IAccountMeta<string> = string,\n  TAccountFeeAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpoolsConfig extends string\n        ? ReadonlyAccount<TAccountWhirlpoolsConfig>\n        : TAccountWhirlpoolsConfig,\n      TAccountAdaptiveFeeTier extends string\n        ? WritableAccount<TAccountAdaptiveFeeTier>\n        : TAccountAdaptiveFeeTier,\n      TAccountFeeAuthority extends string\n        ? ReadonlySignerAccount<TAccountFeeAuthority> &\n            IAccountSignerMeta<TAccountFeeAuthority>\n        : TAccountFeeAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetPresetAdaptiveFeeConstantsInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  filterPeriod: number;\n  decayPeriod: number;\n  reductionFactor: number;\n  adaptiveFeeControlFactor: number;\n  maxVolatilityAccumulator: number;\n  tickGroupSize: number;\n  majorSwapThresholdTicks: number;\n};\n\nexport type SetPresetAdaptiveFeeConstantsInstructionDataArgs = {\n  filterPeriod: number;\n  decayPeriod: number;\n  reductionFactor: number;\n  adaptiveFeeControlFactor: number;\n  maxVolatilityAccumulator: number;\n  tickGroupSize: number;\n  majorSwapThresholdTicks: number;\n};\n\nexport function getSetPresetAdaptiveFeeConstantsInstructionDataEncoder(): Encoder<SetPresetAdaptiveFeeConstantsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['filterPeriod', getU16Encoder()],\n      ['decayPeriod', getU16Encoder()],\n      ['reductionFactor', getU16Encoder()],\n      ['adaptiveFeeControlFactor', getU32Encoder()],\n      ['maxVolatilityAccumulator', getU32Encoder()],\n      ['tickGroupSize', getU16Encoder()],\n      ['majorSwapThresholdTicks', getU16Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: SET_PRESET_ADAPTIVE_FEE_CONSTANTS_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetPresetAdaptiveFeeConstantsInstructionDataDecoder(): Decoder<SetPresetAdaptiveFeeConstantsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['filterPeriod', getU16Decoder()],\n    ['decayPeriod', getU16Decoder()],\n    ['reductionFactor', getU16Decoder()],\n    ['adaptiveFeeControlFactor', getU32Decoder()],\n    ['maxVolatilityAccumulator', getU32Decoder()],\n    ['tickGroupSize', getU16Decoder()],\n    ['majorSwapThresholdTicks', getU16Decoder()],\n  ]);\n}\n\nexport function getSetPresetAdaptiveFeeConstantsInstructionDataCodec(): Codec<\n  SetPresetAdaptiveFeeConstantsInstructionDataArgs,\n  SetPresetAdaptiveFeeConstantsInstructionData\n> {\n  return combineCodec(\n    getSetPresetAdaptiveFeeConstantsInstructionDataEncoder(),\n    getSetPresetAdaptiveFeeConstantsInstructionDataDecoder()\n  );\n}\n\nexport type SetPresetAdaptiveFeeConstantsInput<\n  TAccountWhirlpoolsConfig extends string = string,\n  TAccountAdaptiveFeeTier extends string = string,\n  TAccountFeeAuthority extends string = string,\n> = {\n  whirlpoolsConfig: Address<TAccountWhirlpoolsConfig>;\n  adaptiveFeeTier: Address<TAccountAdaptiveFeeTier>;\n  feeAuthority: TransactionSigner<TAccountFeeAuthority>;\n  filterPeriod: SetPresetAdaptiveFeeConstantsInstructionDataArgs['filterPeriod'];\n  decayPeriod: SetPresetAdaptiveFeeConstantsInstructionDataArgs['decayPeriod'];\n  reductionFactor: SetPresetAdaptiveFeeConstantsInstructionDataArgs['reductionFactor'];\n  adaptiveFeeControlFactor: SetPresetAdaptiveFeeConstantsInstructionDataArgs['adaptiveFeeControlFactor'];\n  maxVolatilityAccumulator: SetPresetAdaptiveFeeConstantsInstructionDataArgs['maxVolatilityAccumulator'];\n  tickGroupSize: SetPresetAdaptiveFeeConstantsInstructionDataArgs['tickGroupSize'];\n  majorSwapThresholdTicks: SetPresetAdaptiveFeeConstantsInstructionDataArgs['majorSwapThresholdTicks'];\n};\n\nexport function getSetPresetAdaptiveFeeConstantsInstruction<\n  TAccountWhirlpoolsConfig extends string,\n  TAccountAdaptiveFeeTier extends string,\n  TAccountFeeAuthority extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: SetPresetAdaptiveFeeConstantsInput<\n    TAccountWhirlpoolsConfig,\n    TAccountAdaptiveFeeTier,\n    TAccountFeeAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): SetPresetAdaptiveFeeConstantsInstruction<\n  TProgramAddress,\n  TAccountWhirlpoolsConfig,\n  TAccountAdaptiveFeeTier,\n  TAccountFeeAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpoolsConfig: {\n      value: input.whirlpoolsConfig ?? null,\n      isWritable: false,\n    },\n    adaptiveFeeTier: { value: input.adaptiveFeeTier ?? null, isWritable: true },\n    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpoolsConfig),\n      getAccountMeta(accounts.adaptiveFeeTier),\n      getAccountMeta(accounts.feeAuthority),\n    ],\n    programAddress,\n    data: getSetPresetAdaptiveFeeConstantsInstructionDataEncoder().encode(\n      args as SetPresetAdaptiveFeeConstantsInstructionDataArgs\n    ),\n  } as SetPresetAdaptiveFeeConstantsInstruction<\n    TProgramAddress,\n    TAccountWhirlpoolsConfig,\n    TAccountAdaptiveFeeTier,\n    TAccountFeeAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedSetPresetAdaptiveFeeConstantsInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpoolsConfig: TAccountMetas[0];\n    adaptiveFeeTier: TAccountMetas[1];\n    feeAuthority: TAccountMetas[2];\n  };\n  data: SetPresetAdaptiveFeeConstantsInstructionData;\n};\n\nexport function parseSetPresetAdaptiveFeeConstantsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedSetPresetAdaptiveFeeConstantsInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpoolsConfig: getNextAccount(),\n      adaptiveFeeTier: getNextAccount(),\n      feeAuthority: getNextAccount(),\n    },\n    data: getSetPresetAdaptiveFeeConstantsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SET_PROTOCOL_FEE_RATE_DISCRIMINATOR = new Uint8Array([\n  95, 7, 4, 50, 154, 79, 156, 131,\n]);\n\nexport function getSetProtocolFeeRateDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    SET_PROTOCOL_FEE_RATE_DISCRIMINATOR\n  );\n}\n\nexport type SetProtocolFeeRateInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpoolsConfig extends string | IAccountMeta<string> = string,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountFeeAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpoolsConfig extends string\n        ? ReadonlyAccount<TAccountWhirlpoolsConfig>\n        : TAccountWhirlpoolsConfig,\n      TAccountWhirlpool extends string\n        ? WritableAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountFeeAuthority extends string\n        ? ReadonlySignerAccount<TAccountFeeAuthority> &\n            IAccountSignerMeta<TAccountFeeAuthority>\n        : TAccountFeeAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetProtocolFeeRateInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  protocolFeeRate: number;\n};\n\nexport type SetProtocolFeeRateInstructionDataArgs = { protocolFeeRate: number };\n\nexport function getSetProtocolFeeRateInstructionDataEncoder(): Encoder<SetProtocolFeeRateInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['protocolFeeRate', getU16Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: SET_PROTOCOL_FEE_RATE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetProtocolFeeRateInstructionDataDecoder(): Decoder<SetProtocolFeeRateInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['protocolFeeRate', getU16Decoder()],\n  ]);\n}\n\nexport function getSetProtocolFeeRateInstructionDataCodec(): Codec<\n  SetProtocolFeeRateInstructionDataArgs,\n  SetProtocolFeeRateInstructionData\n> {\n  return combineCodec(\n    getSetProtocolFeeRateInstructionDataEncoder(),\n    getSetProtocolFeeRateInstructionDataDecoder()\n  );\n}\n\nexport type SetProtocolFeeRateInput<\n  TAccountWhirlpoolsConfig extends string = string,\n  TAccountWhirlpool extends string = string,\n  TAccountFeeAuthority extends string = string,\n> = {\n  whirlpoolsConfig: Address<TAccountWhirlpoolsConfig>;\n  whirlpool: Address<TAccountWhirlpool>;\n  feeAuthority: TransactionSigner<TAccountFeeAuthority>;\n  protocolFeeRate: SetProtocolFeeRateInstructionDataArgs['protocolFeeRate'];\n};\n\nexport function getSetProtocolFeeRateInstruction<\n  TAccountWhirlpoolsConfig extends string,\n  TAccountWhirlpool extends string,\n  TAccountFeeAuthority extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: SetProtocolFeeRateInput<\n    TAccountWhirlpoolsConfig,\n    TAccountWhirlpool,\n    TAccountFeeAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): SetProtocolFeeRateInstruction<\n  TProgramAddress,\n  TAccountWhirlpoolsConfig,\n  TAccountWhirlpool,\n  TAccountFeeAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpoolsConfig: {\n      value: input.whirlpoolsConfig ?? null,\n      isWritable: false,\n    },\n    whirlpool: { value: input.whirlpool ?? null, isWritable: true },\n    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpoolsConfig),\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.feeAuthority),\n    ],\n    programAddress,\n    data: getSetProtocolFeeRateInstructionDataEncoder().encode(\n      args as SetProtocolFeeRateInstructionDataArgs\n    ),\n  } as SetProtocolFeeRateInstruction<\n    TProgramAddress,\n    TAccountWhirlpoolsConfig,\n    TAccountWhirlpool,\n    TAccountFeeAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedSetProtocolFeeRateInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpoolsConfig: TAccountMetas[0];\n    whirlpool: TAccountMetas[1];\n    feeAuthority: TAccountMetas[2];\n  };\n  data: SetProtocolFeeRateInstructionData;\n};\n\nexport function parseSetProtocolFeeRateInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedSetProtocolFeeRateInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpoolsConfig: getNextAccount(),\n      whirlpool: getNextAccount(),\n      feeAuthority: getNextAccount(),\n    },\n    data: getSetProtocolFeeRateInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SET_REWARD_AUTHORITY_DISCRIMINATOR = new Uint8Array([\n  34, 39, 183, 252, 83, 28, 85, 127,\n]);\n\nexport function getSetRewardAuthorityDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    SET_REWARD_AUTHORITY_DISCRIMINATOR\n  );\n}\n\nexport type SetRewardAuthorityInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountRewardAuthority extends string | IAccountMeta<string> = string,\n  TAccountNewRewardAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpool extends string\n        ? WritableAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountRewardAuthority extends string\n        ? ReadonlySignerAccount<TAccountRewardAuthority> &\n            IAccountSignerMeta<TAccountRewardAuthority>\n        : TAccountRewardAuthority,\n      TAccountNewRewardAuthority extends string\n        ? ReadonlyAccount<TAccountNewRewardAuthority>\n        : TAccountNewRewardAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetRewardAuthorityInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  rewardIndex: number;\n};\n\nexport type SetRewardAuthorityInstructionDataArgs = { rewardIndex: number };\n\nexport function getSetRewardAuthorityInstructionDataEncoder(): Encoder<SetRewardAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['rewardIndex', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: SET_REWARD_AUTHORITY_DISCRIMINATOR })\n  );\n}\n\nexport function getSetRewardAuthorityInstructionDataDecoder(): Decoder<SetRewardAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['rewardIndex', getU8Decoder()],\n  ]);\n}\n\nexport function getSetRewardAuthorityInstructionDataCodec(): Codec<\n  SetRewardAuthorityInstructionDataArgs,\n  SetRewardAuthorityInstructionData\n> {\n  return combineCodec(\n    getSetRewardAuthorityInstructionDataEncoder(),\n    getSetRewardAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type SetRewardAuthorityInput<\n  TAccountWhirlpool extends string = string,\n  TAccountRewardAuthority extends string = string,\n  TAccountNewRewardAuthority extends string = string,\n> = {\n  whirlpool: Address<TAccountWhirlpool>;\n  rewardAuthority: TransactionSigner<TAccountRewardAuthority>;\n  newRewardAuthority: Address<TAccountNewRewardAuthority>;\n  rewardIndex: SetRewardAuthorityInstructionDataArgs['rewardIndex'];\n};\n\nexport function getSetRewardAuthorityInstruction<\n  TAccountWhirlpool extends string,\n  TAccountRewardAuthority extends string,\n  TAccountNewRewardAuthority extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: SetRewardAuthorityInput<\n    TAccountWhirlpool,\n    TAccountRewardAuthority,\n    TAccountNewRewardAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): SetRewardAuthorityInstruction<\n  TProgramAddress,\n  TAccountWhirlpool,\n  TAccountRewardAuthority,\n  TAccountNewRewardAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpool: { value: input.whirlpool ?? null, isWritable: true },\n    rewardAuthority: {\n      value: input.rewardAuthority ?? null,\n      isWritable: false,\n    },\n    newRewardAuthority: {\n      value: input.newRewardAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.rewardAuthority),\n      getAccountMeta(accounts.newRewardAuthority),\n    ],\n    programAddress,\n    data: getSetRewardAuthorityInstructionDataEncoder().encode(\n      args as SetRewardAuthorityInstructionDataArgs\n    ),\n  } as SetRewardAuthorityInstruction<\n    TProgramAddress,\n    TAccountWhirlpool,\n    TAccountRewardAuthority,\n    TAccountNewRewardAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedSetRewardAuthorityInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpool: TAccountMetas[0];\n    rewardAuthority: TAccountMetas[1];\n    newRewardAuthority: TAccountMetas[2];\n  };\n  data: SetRewardAuthorityInstructionData;\n};\n\nexport function parseSetRewardAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedSetRewardAuthorityInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpool: getNextAccount(),\n      rewardAuthority: getNextAccount(),\n      newRewardAuthority: getNextAccount(),\n    },\n    data: getSetRewardAuthorityInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_DISCRIMINATOR =\n  new Uint8Array([240, 154, 201, 198, 148, 93, 56, 25]);\n\nexport function getSetRewardAuthorityBySuperAuthorityDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_DISCRIMINATOR\n  );\n}\n\nexport type SetRewardAuthorityBySuperAuthorityInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpoolsConfig extends string | IAccountMeta<string> = string,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountRewardEmissionsSuperAuthority extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountNewRewardAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpoolsConfig extends string\n        ? ReadonlyAccount<TAccountWhirlpoolsConfig>\n        : TAccountWhirlpoolsConfig,\n      TAccountWhirlpool extends string\n        ? WritableAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountRewardEmissionsSuperAuthority extends string\n        ? ReadonlySignerAccount<TAccountRewardEmissionsSuperAuthority> &\n            IAccountSignerMeta<TAccountRewardEmissionsSuperAuthority>\n        : TAccountRewardEmissionsSuperAuthority,\n      TAccountNewRewardAuthority extends string\n        ? ReadonlyAccount<TAccountNewRewardAuthority>\n        : TAccountNewRewardAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetRewardAuthorityBySuperAuthorityInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  rewardIndex: number;\n};\n\nexport type SetRewardAuthorityBySuperAuthorityInstructionDataArgs = {\n  rewardIndex: number;\n};\n\nexport function getSetRewardAuthorityBySuperAuthorityInstructionDataEncoder(): Encoder<SetRewardAuthorityBySuperAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['rewardIndex', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetRewardAuthorityBySuperAuthorityInstructionDataDecoder(): Decoder<SetRewardAuthorityBySuperAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['rewardIndex', getU8Decoder()],\n  ]);\n}\n\nexport function getSetRewardAuthorityBySuperAuthorityInstructionDataCodec(): Codec<\n  SetRewardAuthorityBySuperAuthorityInstructionDataArgs,\n  SetRewardAuthorityBySuperAuthorityInstructionData\n> {\n  return combineCodec(\n    getSetRewardAuthorityBySuperAuthorityInstructionDataEncoder(),\n    getSetRewardAuthorityBySuperAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type SetRewardAuthorityBySuperAuthorityInput<\n  TAccountWhirlpoolsConfig extends string = string,\n  TAccountWhirlpool extends string = string,\n  TAccountRewardEmissionsSuperAuthority extends string = string,\n  TAccountNewRewardAuthority extends string = string,\n> = {\n  whirlpoolsConfig: Address<TAccountWhirlpoolsConfig>;\n  whirlpool: Address<TAccountWhirlpool>;\n  rewardEmissionsSuperAuthority: TransactionSigner<TAccountRewardEmissionsSuperAuthority>;\n  newRewardAuthority: Address<TAccountNewRewardAuthority>;\n  rewardIndex: SetRewardAuthorityBySuperAuthorityInstructionDataArgs['rewardIndex'];\n};\n\nexport function getSetRewardAuthorityBySuperAuthorityInstruction<\n  TAccountWhirlpoolsConfig extends string,\n  TAccountWhirlpool extends string,\n  TAccountRewardEmissionsSuperAuthority extends string,\n  TAccountNewRewardAuthority extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: SetRewardAuthorityBySuperAuthorityInput<\n    TAccountWhirlpoolsConfig,\n    TAccountWhirlpool,\n    TAccountRewardEmissionsSuperAuthority,\n    TAccountNewRewardAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): SetRewardAuthorityBySuperAuthorityInstruction<\n  TProgramAddress,\n  TAccountWhirlpoolsConfig,\n  TAccountWhirlpool,\n  TAccountRewardEmissionsSuperAuthority,\n  TAccountNewRewardAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpoolsConfig: {\n      value: input.whirlpoolsConfig ?? null,\n      isWritable: false,\n    },\n    whirlpool: { value: input.whirlpool ?? null, isWritable: true },\n    rewardEmissionsSuperAuthority: {\n      value: input.rewardEmissionsSuperAuthority ?? null,\n      isWritable: false,\n    },\n    newRewardAuthority: {\n      value: input.newRewardAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpoolsConfig),\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.rewardEmissionsSuperAuthority),\n      getAccountMeta(accounts.newRewardAuthority),\n    ],\n    programAddress,\n    data: getSetRewardAuthorityBySuperAuthorityInstructionDataEncoder().encode(\n      args as SetRewardAuthorityBySuperAuthorityInstructionDataArgs\n    ),\n  } as SetRewardAuthorityBySuperAuthorityInstruction<\n    TProgramAddress,\n    TAccountWhirlpoolsConfig,\n    TAccountWhirlpool,\n    TAccountRewardEmissionsSuperAuthority,\n    TAccountNewRewardAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedSetRewardAuthorityBySuperAuthorityInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpoolsConfig: TAccountMetas[0];\n    whirlpool: TAccountMetas[1];\n    rewardEmissionsSuperAuthority: TAccountMetas[2];\n    newRewardAuthority: TAccountMetas[3];\n  };\n  data: SetRewardAuthorityBySuperAuthorityInstructionData;\n};\n\nexport function parseSetRewardAuthorityBySuperAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedSetRewardAuthorityBySuperAuthorityInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpoolsConfig: getNextAccount(),\n      whirlpool: getNextAccount(),\n      rewardEmissionsSuperAuthority: getNextAccount(),\n      newRewardAuthority: getNextAccount(),\n    },\n    data: getSetRewardAuthorityBySuperAuthorityInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU128Decoder,\n  getU128Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SET_REWARD_EMISSIONS_DISCRIMINATOR = new Uint8Array([\n  13, 197, 86, 168, 109, 176, 27, 244,\n]);\n\nexport function getSetRewardEmissionsDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    SET_REWARD_EMISSIONS_DISCRIMINATOR\n  );\n}\n\nexport type SetRewardEmissionsInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountRewardAuthority extends string | IAccountMeta<string> = string,\n  TAccountRewardVault extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpool extends string\n        ? WritableAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountRewardAuthority extends string\n        ? ReadonlySignerAccount<TAccountRewardAuthority> &\n            IAccountSignerMeta<TAccountRewardAuthority>\n        : TAccountRewardAuthority,\n      TAccountRewardVault extends string\n        ? ReadonlyAccount<TAccountRewardVault>\n        : TAccountRewardVault,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetRewardEmissionsInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  rewardIndex: number;\n  emissionsPerSecondX64: bigint;\n};\n\nexport type SetRewardEmissionsInstructionDataArgs = {\n  rewardIndex: number;\n  emissionsPerSecondX64: number | bigint;\n};\n\nexport function getSetRewardEmissionsInstructionDataEncoder(): Encoder<SetRewardEmissionsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['rewardIndex', getU8Encoder()],\n      ['emissionsPerSecondX64', getU128Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: SET_REWARD_EMISSIONS_DISCRIMINATOR })\n  );\n}\n\nexport function getSetRewardEmissionsInstructionDataDecoder(): Decoder<SetRewardEmissionsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['rewardIndex', getU8Decoder()],\n    ['emissionsPerSecondX64', getU128Decoder()],\n  ]);\n}\n\nexport function getSetRewardEmissionsInstructionDataCodec(): Codec<\n  SetRewardEmissionsInstructionDataArgs,\n  SetRewardEmissionsInstructionData\n> {\n  return combineCodec(\n    getSetRewardEmissionsInstructionDataEncoder(),\n    getSetRewardEmissionsInstructionDataDecoder()\n  );\n}\n\nexport type SetRewardEmissionsInput<\n  TAccountWhirlpool extends string = string,\n  TAccountRewardAuthority extends string = string,\n  TAccountRewardVault extends string = string,\n> = {\n  whirlpool: Address<TAccountWhirlpool>;\n  rewardAuthority: TransactionSigner<TAccountRewardAuthority>;\n  rewardVault: Address<TAccountRewardVault>;\n  rewardIndex: SetRewardEmissionsInstructionDataArgs['rewardIndex'];\n  emissionsPerSecondX64: SetRewardEmissionsInstructionDataArgs['emissionsPerSecondX64'];\n};\n\nexport function getSetRewardEmissionsInstruction<\n  TAccountWhirlpool extends string,\n  TAccountRewardAuthority extends string,\n  TAccountRewardVault extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: SetRewardEmissionsInput<\n    TAccountWhirlpool,\n    TAccountRewardAuthority,\n    TAccountRewardVault\n  >,\n  config?: { programAddress?: TProgramAddress }\n): SetRewardEmissionsInstruction<\n  TProgramAddress,\n  TAccountWhirlpool,\n  TAccountRewardAuthority,\n  TAccountRewardVault\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpool: { value: input.whirlpool ?? null, isWritable: true },\n    rewardAuthority: {\n      value: input.rewardAuthority ?? null,\n      isWritable: false,\n    },\n    rewardVault: { value: input.rewardVault ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.rewardAuthority),\n      getAccountMeta(accounts.rewardVault),\n    ],\n    programAddress,\n    data: getSetRewardEmissionsInstructionDataEncoder().encode(\n      args as SetRewardEmissionsInstructionDataArgs\n    ),\n  } as SetRewardEmissionsInstruction<\n    TProgramAddress,\n    TAccountWhirlpool,\n    TAccountRewardAuthority,\n    TAccountRewardVault\n  >;\n\n  return instruction;\n}\n\nexport type ParsedSetRewardEmissionsInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpool: TAccountMetas[0];\n    rewardAuthority: TAccountMetas[1];\n    rewardVault: TAccountMetas[2];\n  };\n  data: SetRewardEmissionsInstructionData;\n};\n\nexport function parseSetRewardEmissionsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedSetRewardEmissionsInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpool: getNextAccount(),\n      rewardAuthority: getNextAccount(),\n      rewardVault: getNextAccount(),\n    },\n    data: getSetRewardEmissionsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SET_REWARD_EMISSIONS_SUPER_AUTHORITY_DISCRIMINATOR =\n  new Uint8Array([207, 5, 200, 209, 122, 56, 82, 183]);\n\nexport function getSetRewardEmissionsSuperAuthorityDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    SET_REWARD_EMISSIONS_SUPER_AUTHORITY_DISCRIMINATOR\n  );\n}\n\nexport type SetRewardEmissionsSuperAuthorityInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpoolsConfig extends string | IAccountMeta<string> = string,\n  TAccountRewardEmissionsSuperAuthority extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountNewRewardEmissionsSuperAuthority extends\n    | string\n    | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpoolsConfig extends string\n        ? WritableAccount<TAccountWhirlpoolsConfig>\n        : TAccountWhirlpoolsConfig,\n      TAccountRewardEmissionsSuperAuthority extends string\n        ? ReadonlySignerAccount<TAccountRewardEmissionsSuperAuthority> &\n            IAccountSignerMeta<TAccountRewardEmissionsSuperAuthority>\n        : TAccountRewardEmissionsSuperAuthority,\n      TAccountNewRewardEmissionsSuperAuthority extends string\n        ? ReadonlyAccount<TAccountNewRewardEmissionsSuperAuthority>\n        : TAccountNewRewardEmissionsSuperAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetRewardEmissionsSuperAuthorityInstructionData = {\n  discriminator: ReadonlyUint8Array;\n};\n\nexport type SetRewardEmissionsSuperAuthorityInstructionDataArgs = {};\n\nexport function getSetRewardEmissionsSuperAuthorityInstructionDataEncoder(): Encoder<SetRewardEmissionsSuperAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]),\n    (value) => ({\n      ...value,\n      discriminator: SET_REWARD_EMISSIONS_SUPER_AUTHORITY_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetRewardEmissionsSuperAuthorityInstructionDataDecoder(): Decoder<SetRewardEmissionsSuperAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n  ]);\n}\n\nexport function getSetRewardEmissionsSuperAuthorityInstructionDataCodec(): Codec<\n  SetRewardEmissionsSuperAuthorityInstructionDataArgs,\n  SetRewardEmissionsSuperAuthorityInstructionData\n> {\n  return combineCodec(\n    getSetRewardEmissionsSuperAuthorityInstructionDataEncoder(),\n    getSetRewardEmissionsSuperAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type SetRewardEmissionsSuperAuthorityInput<\n  TAccountWhirlpoolsConfig extends string = string,\n  TAccountRewardEmissionsSuperAuthority extends string = string,\n  TAccountNewRewardEmissionsSuperAuthority extends string = string,\n> = {\n  whirlpoolsConfig: Address<TAccountWhirlpoolsConfig>;\n  rewardEmissionsSuperAuthority: TransactionSigner<TAccountRewardEmissionsSuperAuthority>;\n  newRewardEmissionsSuperAuthority: Address<TAccountNewRewardEmissionsSuperAuthority>;\n};\n\nexport function getSetRewardEmissionsSuperAuthorityInstruction<\n  TAccountWhirlpoolsConfig extends string,\n  TAccountRewardEmissionsSuperAuthority extends string,\n  TAccountNewRewardEmissionsSuperAuthority extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: SetRewardEmissionsSuperAuthorityInput<\n    TAccountWhirlpoolsConfig,\n    TAccountRewardEmissionsSuperAuthority,\n    TAccountNewRewardEmissionsSuperAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): SetRewardEmissionsSuperAuthorityInstruction<\n  TProgramAddress,\n  TAccountWhirlpoolsConfig,\n  TAccountRewardEmissionsSuperAuthority,\n  TAccountNewRewardEmissionsSuperAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpoolsConfig: {\n      value: input.whirlpoolsConfig ?? null,\n      isWritable: true,\n    },\n    rewardEmissionsSuperAuthority: {\n      value: input.rewardEmissionsSuperAuthority ?? null,\n      isWritable: false,\n    },\n    newRewardEmissionsSuperAuthority: {\n      value: input.newRewardEmissionsSuperAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpoolsConfig),\n      getAccountMeta(accounts.rewardEmissionsSuperAuthority),\n      getAccountMeta(accounts.newRewardEmissionsSuperAuthority),\n    ],\n    programAddress,\n    data: getSetRewardEmissionsSuperAuthorityInstructionDataEncoder().encode(\n      {}\n    ),\n  } as SetRewardEmissionsSuperAuthorityInstruction<\n    TProgramAddress,\n    TAccountWhirlpoolsConfig,\n    TAccountRewardEmissionsSuperAuthority,\n    TAccountNewRewardEmissionsSuperAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedSetRewardEmissionsSuperAuthorityInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpoolsConfig: TAccountMetas[0];\n    rewardEmissionsSuperAuthority: TAccountMetas[1];\n    newRewardEmissionsSuperAuthority: TAccountMetas[2];\n  };\n  data: SetRewardEmissionsSuperAuthorityInstructionData;\n};\n\nexport function parseSetRewardEmissionsSuperAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedSetRewardEmissionsSuperAuthorityInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpoolsConfig: getNextAccount(),\n      rewardEmissionsSuperAuthority: getNextAccount(),\n      newRewardEmissionsSuperAuthority: getNextAccount(),\n    },\n    data: getSetRewardEmissionsSuperAuthorityInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU128Decoder,\n  getU128Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SET_REWARD_EMISSIONS_V2_DISCRIMINATOR = new Uint8Array([\n  114, 228, 72, 32, 193, 48, 160, 102,\n]);\n\nexport function getSetRewardEmissionsV2DiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    SET_REWARD_EMISSIONS_V2_DISCRIMINATOR\n  );\n}\n\nexport type SetRewardEmissionsV2Instruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountRewardAuthority extends string | IAccountMeta<string> = string,\n  TAccountRewardVault extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpool extends string\n        ? WritableAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountRewardAuthority extends string\n        ? ReadonlySignerAccount<TAccountRewardAuthority> &\n            IAccountSignerMeta<TAccountRewardAuthority>\n        : TAccountRewardAuthority,\n      TAccountRewardVault extends string\n        ? ReadonlyAccount<TAccountRewardVault>\n        : TAccountRewardVault,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetRewardEmissionsV2InstructionData = {\n  discriminator: ReadonlyUint8Array;\n  rewardIndex: number;\n  emissionsPerSecondX64: bigint;\n};\n\nexport type SetRewardEmissionsV2InstructionDataArgs = {\n  rewardIndex: number;\n  emissionsPerSecondX64: number | bigint;\n};\n\nexport function getSetRewardEmissionsV2InstructionDataEncoder(): Encoder<SetRewardEmissionsV2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['rewardIndex', getU8Encoder()],\n      ['emissionsPerSecondX64', getU128Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: SET_REWARD_EMISSIONS_V2_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetRewardEmissionsV2InstructionDataDecoder(): Decoder<SetRewardEmissionsV2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['rewardIndex', getU8Decoder()],\n    ['emissionsPerSecondX64', getU128Decoder()],\n  ]);\n}\n\nexport function getSetRewardEmissionsV2InstructionDataCodec(): Codec<\n  SetRewardEmissionsV2InstructionDataArgs,\n  SetRewardEmissionsV2InstructionData\n> {\n  return combineCodec(\n    getSetRewardEmissionsV2InstructionDataEncoder(),\n    getSetRewardEmissionsV2InstructionDataDecoder()\n  );\n}\n\nexport type SetRewardEmissionsV2Input<\n  TAccountWhirlpool extends string = string,\n  TAccountRewardAuthority extends string = string,\n  TAccountRewardVault extends string = string,\n> = {\n  whirlpool: Address<TAccountWhirlpool>;\n  rewardAuthority: TransactionSigner<TAccountRewardAuthority>;\n  rewardVault: Address<TAccountRewardVault>;\n  rewardIndex: SetRewardEmissionsV2InstructionDataArgs['rewardIndex'];\n  emissionsPerSecondX64: SetRewardEmissionsV2InstructionDataArgs['emissionsPerSecondX64'];\n};\n\nexport function getSetRewardEmissionsV2Instruction<\n  TAccountWhirlpool extends string,\n  TAccountRewardAuthority extends string,\n  TAccountRewardVault extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: SetRewardEmissionsV2Input<\n    TAccountWhirlpool,\n    TAccountRewardAuthority,\n    TAccountRewardVault\n  >,\n  config?: { programAddress?: TProgramAddress }\n): SetRewardEmissionsV2Instruction<\n  TProgramAddress,\n  TAccountWhirlpool,\n  TAccountRewardAuthority,\n  TAccountRewardVault\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpool: { value: input.whirlpool ?? null, isWritable: true },\n    rewardAuthority: {\n      value: input.rewardAuthority ?? null,\n      isWritable: false,\n    },\n    rewardVault: { value: input.rewardVault ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.rewardAuthority),\n      getAccountMeta(accounts.rewardVault),\n    ],\n    programAddress,\n    data: getSetRewardEmissionsV2InstructionDataEncoder().encode(\n      args as SetRewardEmissionsV2InstructionDataArgs\n    ),\n  } as SetRewardEmissionsV2Instruction<\n    TProgramAddress,\n    TAccountWhirlpool,\n    TAccountRewardAuthority,\n    TAccountRewardVault\n  >;\n\n  return instruction;\n}\n\nexport type ParsedSetRewardEmissionsV2Instruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpool: TAccountMetas[0];\n    rewardAuthority: TAccountMetas[1];\n    rewardVault: TAccountMetas[2];\n  };\n  data: SetRewardEmissionsV2InstructionData;\n};\n\nexport function parseSetRewardEmissionsV2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedSetRewardEmissionsV2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpool: getNextAccount(),\n      rewardAuthority: getNextAccount(),\n      rewardVault: getNextAccount(),\n    },\n    data: getSetRewardEmissionsV2InstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SET_TOKEN_BADGE_AUTHORITY_DISCRIMINATOR = new Uint8Array([\n  207, 202, 4, 32, 205, 79, 13, 178,\n]);\n\nexport function getSetTokenBadgeAuthorityDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    SET_TOKEN_BADGE_AUTHORITY_DISCRIMINATOR\n  );\n}\n\nexport type SetTokenBadgeAuthorityInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpoolsConfig extends string | IAccountMeta<string> = string,\n  TAccountWhirlpoolsConfigExtension extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountConfigExtensionAuthority extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountNewTokenBadgeAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpoolsConfig extends string\n        ? ReadonlyAccount<TAccountWhirlpoolsConfig>\n        : TAccountWhirlpoolsConfig,\n      TAccountWhirlpoolsConfigExtension extends string\n        ? WritableAccount<TAccountWhirlpoolsConfigExtension>\n        : TAccountWhirlpoolsConfigExtension,\n      TAccountConfigExtensionAuthority extends string\n        ? ReadonlySignerAccount<TAccountConfigExtensionAuthority> &\n            IAccountSignerMeta<TAccountConfigExtensionAuthority>\n        : TAccountConfigExtensionAuthority,\n      TAccountNewTokenBadgeAuthority extends string\n        ? ReadonlyAccount<TAccountNewTokenBadgeAuthority>\n        : TAccountNewTokenBadgeAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetTokenBadgeAuthorityInstructionData = {\n  discriminator: ReadonlyUint8Array;\n};\n\nexport type SetTokenBadgeAuthorityInstructionDataArgs = {};\n\nexport function getSetTokenBadgeAuthorityInstructionDataEncoder(): Encoder<SetTokenBadgeAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]),\n    (value) => ({\n      ...value,\n      discriminator: SET_TOKEN_BADGE_AUTHORITY_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetTokenBadgeAuthorityInstructionDataDecoder(): Decoder<SetTokenBadgeAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n  ]);\n}\n\nexport function getSetTokenBadgeAuthorityInstructionDataCodec(): Codec<\n  SetTokenBadgeAuthorityInstructionDataArgs,\n  SetTokenBadgeAuthorityInstructionData\n> {\n  return combineCodec(\n    getSetTokenBadgeAuthorityInstructionDataEncoder(),\n    getSetTokenBadgeAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type SetTokenBadgeAuthorityInput<\n  TAccountWhirlpoolsConfig extends string = string,\n  TAccountWhirlpoolsConfigExtension extends string = string,\n  TAccountConfigExtensionAuthority extends string = string,\n  TAccountNewTokenBadgeAuthority extends string = string,\n> = {\n  whirlpoolsConfig: Address<TAccountWhirlpoolsConfig>;\n  whirlpoolsConfigExtension: Address<TAccountWhirlpoolsConfigExtension>;\n  configExtensionAuthority: TransactionSigner<TAccountConfigExtensionAuthority>;\n  newTokenBadgeAuthority: Address<TAccountNewTokenBadgeAuthority>;\n};\n\nexport function getSetTokenBadgeAuthorityInstruction<\n  TAccountWhirlpoolsConfig extends string,\n  TAccountWhirlpoolsConfigExtension extends string,\n  TAccountConfigExtensionAuthority extends string,\n  TAccountNewTokenBadgeAuthority extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: SetTokenBadgeAuthorityInput<\n    TAccountWhirlpoolsConfig,\n    TAccountWhirlpoolsConfigExtension,\n    TAccountConfigExtensionAuthority,\n    TAccountNewTokenBadgeAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): SetTokenBadgeAuthorityInstruction<\n  TProgramAddress,\n  TAccountWhirlpoolsConfig,\n  TAccountWhirlpoolsConfigExtension,\n  TAccountConfigExtensionAuthority,\n  TAccountNewTokenBadgeAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpoolsConfig: {\n      value: input.whirlpoolsConfig ?? null,\n      isWritable: false,\n    },\n    whirlpoolsConfigExtension: {\n      value: input.whirlpoolsConfigExtension ?? null,\n      isWritable: true,\n    },\n    configExtensionAuthority: {\n      value: input.configExtensionAuthority ?? null,\n      isWritable: false,\n    },\n    newTokenBadgeAuthority: {\n      value: input.newTokenBadgeAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpoolsConfig),\n      getAccountMeta(accounts.whirlpoolsConfigExtension),\n      getAccountMeta(accounts.configExtensionAuthority),\n      getAccountMeta(accounts.newTokenBadgeAuthority),\n    ],\n    programAddress,\n    data: getSetTokenBadgeAuthorityInstructionDataEncoder().encode({}),\n  } as SetTokenBadgeAuthorityInstruction<\n    TProgramAddress,\n    TAccountWhirlpoolsConfig,\n    TAccountWhirlpoolsConfigExtension,\n    TAccountConfigExtensionAuthority,\n    TAccountNewTokenBadgeAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedSetTokenBadgeAuthorityInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpoolsConfig: TAccountMetas[0];\n    whirlpoolsConfigExtension: TAccountMetas[1];\n    configExtensionAuthority: TAccountMetas[2];\n    newTokenBadgeAuthority: TAccountMetas[3];\n  };\n  data: SetTokenBadgeAuthorityInstructionData;\n};\n\nexport function parseSetTokenBadgeAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedSetTokenBadgeAuthorityInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpoolsConfig: getNextAccount(),\n      whirlpoolsConfigExtension: getNextAccount(),\n      configExtensionAuthority: getNextAccount(),\n      newTokenBadgeAuthority: getNextAccount(),\n    },\n    data: getSetTokenBadgeAuthorityInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU128Decoder,\n  getU128Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SWAP_DISCRIMINATOR = new Uint8Array([\n  248, 198, 158, 145, 225, 117, 135, 200,\n]);\n\nexport function getSwapDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(SWAP_DISCRIMINATOR);\n}\n\nexport type SwapInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountTokenProgram extends\n    | string\n    | IAccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  TAccountTokenAuthority extends string | IAccountMeta<string> = string,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountTokenOwnerAccountA extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultA extends string | IAccountMeta<string> = string,\n  TAccountTokenOwnerAccountB extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultB extends string | IAccountMeta<string> = string,\n  TAccountTickArray0 extends string | IAccountMeta<string> = string,\n  TAccountTickArray1 extends string | IAccountMeta<string> = string,\n  TAccountTickArray2 extends string | IAccountMeta<string> = string,\n  TAccountOracle extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      TAccountTokenAuthority extends string\n        ? ReadonlySignerAccount<TAccountTokenAuthority> &\n            IAccountSignerMeta<TAccountTokenAuthority>\n        : TAccountTokenAuthority,\n      TAccountWhirlpool extends string\n        ? WritableAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountTokenOwnerAccountA extends string\n        ? WritableAccount<TAccountTokenOwnerAccountA>\n        : TAccountTokenOwnerAccountA,\n      TAccountTokenVaultA extends string\n        ? WritableAccount<TAccountTokenVaultA>\n        : TAccountTokenVaultA,\n      TAccountTokenOwnerAccountB extends string\n        ? WritableAccount<TAccountTokenOwnerAccountB>\n        : TAccountTokenOwnerAccountB,\n      TAccountTokenVaultB extends string\n        ? WritableAccount<TAccountTokenVaultB>\n        : TAccountTokenVaultB,\n      TAccountTickArray0 extends string\n        ? WritableAccount<TAccountTickArray0>\n        : TAccountTickArray0,\n      TAccountTickArray1 extends string\n        ? WritableAccount<TAccountTickArray1>\n        : TAccountTickArray1,\n      TAccountTickArray2 extends string\n        ? WritableAccount<TAccountTickArray2>\n        : TAccountTickArray2,\n      TAccountOracle extends string\n        ? ReadonlyAccount<TAccountOracle>\n        : TAccountOracle,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SwapInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  amount: bigint;\n  otherAmountThreshold: bigint;\n  sqrtPriceLimit: bigint;\n  amountSpecifiedIsInput: boolean;\n  aToB: boolean;\n};\n\nexport type SwapInstructionDataArgs = {\n  amount: number | bigint;\n  otherAmountThreshold: number | bigint;\n  sqrtPriceLimit: number | bigint;\n  amountSpecifiedIsInput: boolean;\n  aToB: boolean;\n};\n\nexport function getSwapInstructionDataEncoder(): Encoder<SwapInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['amount', getU64Encoder()],\n      ['otherAmountThreshold', getU64Encoder()],\n      ['sqrtPriceLimit', getU128Encoder()],\n      ['amountSpecifiedIsInput', getBooleanEncoder()],\n      ['aToB', getBooleanEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: SWAP_DISCRIMINATOR })\n  );\n}\n\nexport function getSwapInstructionDataDecoder(): Decoder<SwapInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['amount', getU64Decoder()],\n    ['otherAmountThreshold', getU64Decoder()],\n    ['sqrtPriceLimit', getU128Decoder()],\n    ['amountSpecifiedIsInput', getBooleanDecoder()],\n    ['aToB', getBooleanDecoder()],\n  ]);\n}\n\nexport function getSwapInstructionDataCodec(): Codec<\n  SwapInstructionDataArgs,\n  SwapInstructionData\n> {\n  return combineCodec(\n    getSwapInstructionDataEncoder(),\n    getSwapInstructionDataDecoder()\n  );\n}\n\nexport type SwapInput<\n  TAccountTokenProgram extends string = string,\n  TAccountTokenAuthority extends string = string,\n  TAccountWhirlpool extends string = string,\n  TAccountTokenOwnerAccountA extends string = string,\n  TAccountTokenVaultA extends string = string,\n  TAccountTokenOwnerAccountB extends string = string,\n  TAccountTokenVaultB extends string = string,\n  TAccountTickArray0 extends string = string,\n  TAccountTickArray1 extends string = string,\n  TAccountTickArray2 extends string = string,\n  TAccountOracle extends string = string,\n> = {\n  tokenProgram?: Address<TAccountTokenProgram>;\n  tokenAuthority: TransactionSigner<TAccountTokenAuthority>;\n  whirlpool: Address<TAccountWhirlpool>;\n  tokenOwnerAccountA: Address<TAccountTokenOwnerAccountA>;\n  tokenVaultA: Address<TAccountTokenVaultA>;\n  tokenOwnerAccountB: Address<TAccountTokenOwnerAccountB>;\n  tokenVaultB: Address<TAccountTokenVaultB>;\n  tickArray0: Address<TAccountTickArray0>;\n  tickArray1: Address<TAccountTickArray1>;\n  tickArray2: Address<TAccountTickArray2>;\n  oracle: Address<TAccountOracle>;\n  amount: SwapInstructionDataArgs['amount'];\n  otherAmountThreshold: SwapInstructionDataArgs['otherAmountThreshold'];\n  sqrtPriceLimit: SwapInstructionDataArgs['sqrtPriceLimit'];\n  amountSpecifiedIsInput: SwapInstructionDataArgs['amountSpecifiedIsInput'];\n  aToB: SwapInstructionDataArgs['aToB'];\n};\n\nexport function getSwapInstruction<\n  TAccountTokenProgram extends string,\n  TAccountTokenAuthority extends string,\n  TAccountWhirlpool extends string,\n  TAccountTokenOwnerAccountA extends string,\n  TAccountTokenVaultA extends string,\n  TAccountTokenOwnerAccountB extends string,\n  TAccountTokenVaultB extends string,\n  TAccountTickArray0 extends string,\n  TAccountTickArray1 extends string,\n  TAccountTickArray2 extends string,\n  TAccountOracle extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: SwapInput<\n    TAccountTokenProgram,\n    TAccountTokenAuthority,\n    TAccountWhirlpool,\n    TAccountTokenOwnerAccountA,\n    TAccountTokenVaultA,\n    TAccountTokenOwnerAccountB,\n    TAccountTokenVaultB,\n    TAccountTickArray0,\n    TAccountTickArray1,\n    TAccountTickArray2,\n    TAccountOracle\n  >,\n  config?: { programAddress?: TProgramAddress }\n): SwapInstruction<\n  TProgramAddress,\n  TAccountTokenProgram,\n  TAccountTokenAuthority,\n  TAccountWhirlpool,\n  TAccountTokenOwnerAccountA,\n  TAccountTokenVaultA,\n  TAccountTokenOwnerAccountB,\n  TAccountTokenVaultB,\n  TAccountTickArray0,\n  TAccountTickArray1,\n  TAccountTickArray2,\n  TAccountOracle\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n    tokenAuthority: { value: input.tokenAuthority ?? null, isWritable: false },\n    whirlpool: { value: input.whirlpool ?? null, isWritable: true },\n    tokenOwnerAccountA: {\n      value: input.tokenOwnerAccountA ?? null,\n      isWritable: true,\n    },\n    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },\n    tokenOwnerAccountB: {\n      value: input.tokenOwnerAccountB ?? null,\n      isWritable: true,\n    },\n    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },\n    tickArray0: { value: input.tickArray0 ?? null, isWritable: true },\n    tickArray1: { value: input.tickArray1 ?? null, isWritable: true },\n    tickArray2: { value: input.tickArray2 ?? null, isWritable: true },\n    oracle: { value: input.oracle ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.tokenProgram),\n      getAccountMeta(accounts.tokenAuthority),\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.tokenOwnerAccountA),\n      getAccountMeta(accounts.tokenVaultA),\n      getAccountMeta(accounts.tokenOwnerAccountB),\n      getAccountMeta(accounts.tokenVaultB),\n      getAccountMeta(accounts.tickArray0),\n      getAccountMeta(accounts.tickArray1),\n      getAccountMeta(accounts.tickArray2),\n      getAccountMeta(accounts.oracle),\n    ],\n    programAddress,\n    data: getSwapInstructionDataEncoder().encode(\n      args as SwapInstructionDataArgs\n    ),\n  } as SwapInstruction<\n    TProgramAddress,\n    TAccountTokenProgram,\n    TAccountTokenAuthority,\n    TAccountWhirlpool,\n    TAccountTokenOwnerAccountA,\n    TAccountTokenVaultA,\n    TAccountTokenOwnerAccountB,\n    TAccountTokenVaultB,\n    TAccountTickArray0,\n    TAccountTickArray1,\n    TAccountTickArray2,\n    TAccountOracle\n  >;\n\n  return instruction;\n}\n\nexport type ParsedSwapInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    tokenProgram: TAccountMetas[0];\n    tokenAuthority: TAccountMetas[1];\n    whirlpool: TAccountMetas[2];\n    tokenOwnerAccountA: TAccountMetas[3];\n    tokenVaultA: TAccountMetas[4];\n    tokenOwnerAccountB: TAccountMetas[5];\n    tokenVaultB: TAccountMetas[6];\n    tickArray0: TAccountMetas[7];\n    tickArray1: TAccountMetas[8];\n    tickArray2: TAccountMetas[9];\n    oracle: TAccountMetas[10];\n  };\n  data: SwapInstructionData;\n};\n\nexport function parseSwapInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedSwapInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 11) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      tokenProgram: getNextAccount(),\n      tokenAuthority: getNextAccount(),\n      whirlpool: getNextAccount(),\n      tokenOwnerAccountA: getNextAccount(),\n      tokenVaultA: getNextAccount(),\n      tokenOwnerAccountB: getNextAccount(),\n      tokenVaultB: getNextAccount(),\n      tickArray0: getNextAccount(),\n      tickArray1: getNextAccount(),\n      tickArray2: getNextAccount(),\n      oracle: getNextAccount(),\n    },\n    data: getSwapInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU128Decoder,\n  getU128Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getRemainingAccountsInfoDecoder,\n  getRemainingAccountsInfoEncoder,\n  type RemainingAccountsInfo,\n  type RemainingAccountsInfoArgs,\n} from '../types';\n\nexport const SWAP_V2_DISCRIMINATOR = new Uint8Array([\n  43, 4, 237, 11, 26, 201, 30, 98,\n]);\n\nexport function getSwapV2DiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(SWAP_V2_DISCRIMINATOR);\n}\n\nexport type SwapV2Instruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountTokenProgramA extends string | IAccountMeta<string> = string,\n  TAccountTokenProgramB extends string | IAccountMeta<string> = string,\n  TAccountMemoProgram extends string | IAccountMeta<string> = string,\n  TAccountTokenAuthority extends string | IAccountMeta<string> = string,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountTokenMintA extends string | IAccountMeta<string> = string,\n  TAccountTokenMintB extends string | IAccountMeta<string> = string,\n  TAccountTokenOwnerAccountA extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultA extends string | IAccountMeta<string> = string,\n  TAccountTokenOwnerAccountB extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultB extends string | IAccountMeta<string> = string,\n  TAccountTickArray0 extends string | IAccountMeta<string> = string,\n  TAccountTickArray1 extends string | IAccountMeta<string> = string,\n  TAccountTickArray2 extends string | IAccountMeta<string> = string,\n  TAccountOracle extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountTokenProgramA extends string\n        ? ReadonlyAccount<TAccountTokenProgramA>\n        : TAccountTokenProgramA,\n      TAccountTokenProgramB extends string\n        ? ReadonlyAccount<TAccountTokenProgramB>\n        : TAccountTokenProgramB,\n      TAccountMemoProgram extends string\n        ? ReadonlyAccount<TAccountMemoProgram>\n        : TAccountMemoProgram,\n      TAccountTokenAuthority extends string\n        ? ReadonlySignerAccount<TAccountTokenAuthority> &\n            IAccountSignerMeta<TAccountTokenAuthority>\n        : TAccountTokenAuthority,\n      TAccountWhirlpool extends string\n        ? WritableAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountTokenMintA extends string\n        ? ReadonlyAccount<TAccountTokenMintA>\n        : TAccountTokenMintA,\n      TAccountTokenMintB extends string\n        ? ReadonlyAccount<TAccountTokenMintB>\n        : TAccountTokenMintB,\n      TAccountTokenOwnerAccountA extends string\n        ? WritableAccount<TAccountTokenOwnerAccountA>\n        : TAccountTokenOwnerAccountA,\n      TAccountTokenVaultA extends string\n        ? WritableAccount<TAccountTokenVaultA>\n        : TAccountTokenVaultA,\n      TAccountTokenOwnerAccountB extends string\n        ? WritableAccount<TAccountTokenOwnerAccountB>\n        : TAccountTokenOwnerAccountB,\n      TAccountTokenVaultB extends string\n        ? WritableAccount<TAccountTokenVaultB>\n        : TAccountTokenVaultB,\n      TAccountTickArray0 extends string\n        ? WritableAccount<TAccountTickArray0>\n        : TAccountTickArray0,\n      TAccountTickArray1 extends string\n        ? WritableAccount<TAccountTickArray1>\n        : TAccountTickArray1,\n      TAccountTickArray2 extends string\n        ? WritableAccount<TAccountTickArray2>\n        : TAccountTickArray2,\n      TAccountOracle extends string\n        ? WritableAccount<TAccountOracle>\n        : TAccountOracle,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SwapV2InstructionData = {\n  discriminator: ReadonlyUint8Array;\n  amount: bigint;\n  otherAmountThreshold: bigint;\n  sqrtPriceLimit: bigint;\n  amountSpecifiedIsInput: boolean;\n  aToB: boolean;\n  remainingAccountsInfo: Option<RemainingAccountsInfo>;\n};\n\nexport type SwapV2InstructionDataArgs = {\n  amount: number | bigint;\n  otherAmountThreshold: number | bigint;\n  sqrtPriceLimit: number | bigint;\n  amountSpecifiedIsInput: boolean;\n  aToB: boolean;\n  remainingAccountsInfo: OptionOrNullable<RemainingAccountsInfoArgs>;\n};\n\nexport function getSwapV2InstructionDataEncoder(): Encoder<SwapV2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['amount', getU64Encoder()],\n      ['otherAmountThreshold', getU64Encoder()],\n      ['sqrtPriceLimit', getU128Encoder()],\n      ['amountSpecifiedIsInput', getBooleanEncoder()],\n      ['aToB', getBooleanEncoder()],\n      [\n        'remainingAccountsInfo',\n        getOptionEncoder(getRemainingAccountsInfoEncoder()),\n      ],\n    ]),\n    (value) => ({ ...value, discriminator: SWAP_V2_DISCRIMINATOR })\n  );\n}\n\nexport function getSwapV2InstructionDataDecoder(): Decoder<SwapV2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['amount', getU64Decoder()],\n    ['otherAmountThreshold', getU64Decoder()],\n    ['sqrtPriceLimit', getU128Decoder()],\n    ['amountSpecifiedIsInput', getBooleanDecoder()],\n    ['aToB', getBooleanDecoder()],\n    [\n      'remainingAccountsInfo',\n      getOptionDecoder(getRemainingAccountsInfoDecoder()),\n    ],\n  ]);\n}\n\nexport function getSwapV2InstructionDataCodec(): Codec<\n  SwapV2InstructionDataArgs,\n  SwapV2InstructionData\n> {\n  return combineCodec(\n    getSwapV2InstructionDataEncoder(),\n    getSwapV2InstructionDataDecoder()\n  );\n}\n\nexport type SwapV2Input<\n  TAccountTokenProgramA extends string = string,\n  TAccountTokenProgramB extends string = string,\n  TAccountMemoProgram extends string = string,\n  TAccountTokenAuthority extends string = string,\n  TAccountWhirlpool extends string = string,\n  TAccountTokenMintA extends string = string,\n  TAccountTokenMintB extends string = string,\n  TAccountTokenOwnerAccountA extends string = string,\n  TAccountTokenVaultA extends string = string,\n  TAccountTokenOwnerAccountB extends string = string,\n  TAccountTokenVaultB extends string = string,\n  TAccountTickArray0 extends string = string,\n  TAccountTickArray1 extends string = string,\n  TAccountTickArray2 extends string = string,\n  TAccountOracle extends string = string,\n> = {\n  tokenProgramA: Address<TAccountTokenProgramA>;\n  tokenProgramB: Address<TAccountTokenProgramB>;\n  memoProgram: Address<TAccountMemoProgram>;\n  tokenAuthority: TransactionSigner<TAccountTokenAuthority>;\n  whirlpool: Address<TAccountWhirlpool>;\n  tokenMintA: Address<TAccountTokenMintA>;\n  tokenMintB: Address<TAccountTokenMintB>;\n  tokenOwnerAccountA: Address<TAccountTokenOwnerAccountA>;\n  tokenVaultA: Address<TAccountTokenVaultA>;\n  tokenOwnerAccountB: Address<TAccountTokenOwnerAccountB>;\n  tokenVaultB: Address<TAccountTokenVaultB>;\n  tickArray0: Address<TAccountTickArray0>;\n  tickArray1: Address<TAccountTickArray1>;\n  tickArray2: Address<TAccountTickArray2>;\n  oracle: Address<TAccountOracle>;\n  amount: SwapV2InstructionDataArgs['amount'];\n  otherAmountThreshold: SwapV2InstructionDataArgs['otherAmountThreshold'];\n  sqrtPriceLimit: SwapV2InstructionDataArgs['sqrtPriceLimit'];\n  amountSpecifiedIsInput: SwapV2InstructionDataArgs['amountSpecifiedIsInput'];\n  aToB: SwapV2InstructionDataArgs['aToB'];\n  remainingAccountsInfo: SwapV2InstructionDataArgs['remainingAccountsInfo'];\n};\n\nexport function getSwapV2Instruction<\n  TAccountTokenProgramA extends string,\n  TAccountTokenProgramB extends string,\n  TAccountMemoProgram extends string,\n  TAccountTokenAuthority extends string,\n  TAccountWhirlpool extends string,\n  TAccountTokenMintA extends string,\n  TAccountTokenMintB extends string,\n  TAccountTokenOwnerAccountA extends string,\n  TAccountTokenVaultA extends string,\n  TAccountTokenOwnerAccountB extends string,\n  TAccountTokenVaultB extends string,\n  TAccountTickArray0 extends string,\n  TAccountTickArray1 extends string,\n  TAccountTickArray2 extends string,\n  TAccountOracle extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: SwapV2Input<\n    TAccountTokenProgramA,\n    TAccountTokenProgramB,\n    TAccountMemoProgram,\n    TAccountTokenAuthority,\n    TAccountWhirlpool,\n    TAccountTokenMintA,\n    TAccountTokenMintB,\n    TAccountTokenOwnerAccountA,\n    TAccountTokenVaultA,\n    TAccountTokenOwnerAccountB,\n    TAccountTokenVaultB,\n    TAccountTickArray0,\n    TAccountTickArray1,\n    TAccountTickArray2,\n    TAccountOracle\n  >,\n  config?: { programAddress?: TProgramAddress }\n): SwapV2Instruction<\n  TProgramAddress,\n  TAccountTokenProgramA,\n  TAccountTokenProgramB,\n  TAccountMemoProgram,\n  TAccountTokenAuthority,\n  TAccountWhirlpool,\n  TAccountTokenMintA,\n  TAccountTokenMintB,\n  TAccountTokenOwnerAccountA,\n  TAccountTokenVaultA,\n  TAccountTokenOwnerAccountB,\n  TAccountTokenVaultB,\n  TAccountTickArray0,\n  TAccountTickArray1,\n  TAccountTickArray2,\n  TAccountOracle\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },\n    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },\n    memoProgram: { value: input.memoProgram ?? null, isWritable: false },\n    tokenAuthority: { value: input.tokenAuthority ?? null, isWritable: false },\n    whirlpool: { value: input.whirlpool ?? null, isWritable: true },\n    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },\n    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },\n    tokenOwnerAccountA: {\n      value: input.tokenOwnerAccountA ?? null,\n      isWritable: true,\n    },\n    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },\n    tokenOwnerAccountB: {\n      value: input.tokenOwnerAccountB ?? null,\n      isWritable: true,\n    },\n    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },\n    tickArray0: { value: input.tickArray0 ?? null, isWritable: true },\n    tickArray1: { value: input.tickArray1 ?? null, isWritable: true },\n    tickArray2: { value: input.tickArray2 ?? null, isWritable: true },\n    oracle: { value: input.oracle ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.tokenProgramA),\n      getAccountMeta(accounts.tokenProgramB),\n      getAccountMeta(accounts.memoProgram),\n      getAccountMeta(accounts.tokenAuthority),\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.tokenMintA),\n      getAccountMeta(accounts.tokenMintB),\n      getAccountMeta(accounts.tokenOwnerAccountA),\n      getAccountMeta(accounts.tokenVaultA),\n      getAccountMeta(accounts.tokenOwnerAccountB),\n      getAccountMeta(accounts.tokenVaultB),\n      getAccountMeta(accounts.tickArray0),\n      getAccountMeta(accounts.tickArray1),\n      getAccountMeta(accounts.tickArray2),\n      getAccountMeta(accounts.oracle),\n    ],\n    programAddress,\n    data: getSwapV2InstructionDataEncoder().encode(\n      args as SwapV2InstructionDataArgs\n    ),\n  } as SwapV2Instruction<\n    TProgramAddress,\n    TAccountTokenProgramA,\n    TAccountTokenProgramB,\n    TAccountMemoProgram,\n    TAccountTokenAuthority,\n    TAccountWhirlpool,\n    TAccountTokenMintA,\n    TAccountTokenMintB,\n    TAccountTokenOwnerAccountA,\n    TAccountTokenVaultA,\n    TAccountTokenOwnerAccountB,\n    TAccountTokenVaultB,\n    TAccountTickArray0,\n    TAccountTickArray1,\n    TAccountTickArray2,\n    TAccountOracle\n  >;\n\n  return instruction;\n}\n\nexport type ParsedSwapV2Instruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    tokenProgramA: TAccountMetas[0];\n    tokenProgramB: TAccountMetas[1];\n    memoProgram: TAccountMetas[2];\n    tokenAuthority: TAccountMetas[3];\n    whirlpool: TAccountMetas[4];\n    tokenMintA: TAccountMetas[5];\n    tokenMintB: TAccountMetas[6];\n    tokenOwnerAccountA: TAccountMetas[7];\n    tokenVaultA: TAccountMetas[8];\n    tokenOwnerAccountB: TAccountMetas[9];\n    tokenVaultB: TAccountMetas[10];\n    tickArray0: TAccountMetas[11];\n    tickArray1: TAccountMetas[12];\n    tickArray2: TAccountMetas[13];\n    oracle: TAccountMetas[14];\n  };\n  data: SwapV2InstructionData;\n};\n\nexport function parseSwapV2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedSwapV2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 15) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      tokenProgramA: getNextAccount(),\n      tokenProgramB: getNextAccount(),\n      memoProgram: getNextAccount(),\n      tokenAuthority: getNextAccount(),\n      whirlpool: getNextAccount(),\n      tokenMintA: getNextAccount(),\n      tokenMintB: getNextAccount(),\n      tokenOwnerAccountA: getNextAccount(),\n      tokenVaultA: getNextAccount(),\n      tokenOwnerAccountB: getNextAccount(),\n      tokenVaultB: getNextAccount(),\n      tickArray0: getNextAccount(),\n      tickArray1: getNextAccount(),\n      tickArray2: getNextAccount(),\n      oracle: getNextAccount(),\n    },\n    data: getSwapV2InstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const TRANSFER_LOCKED_POSITION_DISCRIMINATOR = new Uint8Array([\n  179, 121, 229, 46, 67, 138, 194, 138,\n]);\n\nexport function getTransferLockedPositionDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    TRANSFER_LOCKED_POSITION_DISCRIMINATOR\n  );\n}\n\nexport type TransferLockedPositionInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountPositionAuthority extends string | IAccountMeta<string> = string,\n  TAccountReceiver extends string | IAccountMeta<string> = string,\n  TAccountPosition extends string | IAccountMeta<string> = string,\n  TAccountPositionMint extends string | IAccountMeta<string> = string,\n  TAccountPositionTokenAccount extends string | IAccountMeta<string> = string,\n  TAccountDestinationTokenAccount extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountLockConfig extends string | IAccountMeta<string> = string,\n  TAccountToken2022Program extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountPositionAuthority extends string\n        ? ReadonlySignerAccount<TAccountPositionAuthority> &\n            IAccountSignerMeta<TAccountPositionAuthority>\n        : TAccountPositionAuthority,\n      TAccountReceiver extends string\n        ? WritableAccount<TAccountReceiver>\n        : TAccountReceiver,\n      TAccountPosition extends string\n        ? ReadonlyAccount<TAccountPosition>\n        : TAccountPosition,\n      TAccountPositionMint extends string\n        ? ReadonlyAccount<TAccountPositionMint>\n        : TAccountPositionMint,\n      TAccountPositionTokenAccount extends string\n        ? WritableAccount<TAccountPositionTokenAccount>\n        : TAccountPositionTokenAccount,\n      TAccountDestinationTokenAccount extends string\n        ? WritableAccount<TAccountDestinationTokenAccount>\n        : TAccountDestinationTokenAccount,\n      TAccountLockConfig extends string\n        ? WritableAccount<TAccountLockConfig>\n        : TAccountLockConfig,\n      TAccountToken2022Program extends string\n        ? ReadonlyAccount<TAccountToken2022Program>\n        : TAccountToken2022Program,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TransferLockedPositionInstructionData = {\n  discriminator: ReadonlyUint8Array;\n};\n\nexport type TransferLockedPositionInstructionDataArgs = {};\n\nexport function getTransferLockedPositionInstructionDataEncoder(): Encoder<TransferLockedPositionInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]),\n    (value) => ({\n      ...value,\n      discriminator: TRANSFER_LOCKED_POSITION_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getTransferLockedPositionInstructionDataDecoder(): Decoder<TransferLockedPositionInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n  ]);\n}\n\nexport function getTransferLockedPositionInstructionDataCodec(): Codec<\n  TransferLockedPositionInstructionDataArgs,\n  TransferLockedPositionInstructionData\n> {\n  return combineCodec(\n    getTransferLockedPositionInstructionDataEncoder(),\n    getTransferLockedPositionInstructionDataDecoder()\n  );\n}\n\nexport type TransferLockedPositionInput<\n  TAccountPositionAuthority extends string = string,\n  TAccountReceiver extends string = string,\n  TAccountPosition extends string = string,\n  TAccountPositionMint extends string = string,\n  TAccountPositionTokenAccount extends string = string,\n  TAccountDestinationTokenAccount extends string = string,\n  TAccountLockConfig extends string = string,\n  TAccountToken2022Program extends string = string,\n> = {\n  positionAuthority: TransactionSigner<TAccountPositionAuthority>;\n  receiver: Address<TAccountReceiver>;\n  position: Address<TAccountPosition>;\n  positionMint: Address<TAccountPositionMint>;\n  positionTokenAccount: Address<TAccountPositionTokenAccount>;\n  destinationTokenAccount: Address<TAccountDestinationTokenAccount>;\n  lockConfig: Address<TAccountLockConfig>;\n  token2022Program: Address<TAccountToken2022Program>;\n};\n\nexport function getTransferLockedPositionInstruction<\n  TAccountPositionAuthority extends string,\n  TAccountReceiver extends string,\n  TAccountPosition extends string,\n  TAccountPositionMint extends string,\n  TAccountPositionTokenAccount extends string,\n  TAccountDestinationTokenAccount extends string,\n  TAccountLockConfig extends string,\n  TAccountToken2022Program extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: TransferLockedPositionInput<\n    TAccountPositionAuthority,\n    TAccountReceiver,\n    TAccountPosition,\n    TAccountPositionMint,\n    TAccountPositionTokenAccount,\n    TAccountDestinationTokenAccount,\n    TAccountLockConfig,\n    TAccountToken2022Program\n  >,\n  config?: { programAddress?: TProgramAddress }\n): TransferLockedPositionInstruction<\n  TProgramAddress,\n  TAccountPositionAuthority,\n  TAccountReceiver,\n  TAccountPosition,\n  TAccountPositionMint,\n  TAccountPositionTokenAccount,\n  TAccountDestinationTokenAccount,\n  TAccountLockConfig,\n  TAccountToken2022Program\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    positionAuthority: {\n      value: input.positionAuthority ?? null,\n      isWritable: false,\n    },\n    receiver: { value: input.receiver ?? null, isWritable: true },\n    position: { value: input.position ?? null, isWritable: false },\n    positionMint: { value: input.positionMint ?? null, isWritable: false },\n    positionTokenAccount: {\n      value: input.positionTokenAccount ?? null,\n      isWritable: true,\n    },\n    destinationTokenAccount: {\n      value: input.destinationTokenAccount ?? null,\n      isWritable: true,\n    },\n    lockConfig: { value: input.lockConfig ?? null, isWritable: true },\n    token2022Program: {\n      value: input.token2022Program ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.positionAuthority),\n      getAccountMeta(accounts.receiver),\n      getAccountMeta(accounts.position),\n      getAccountMeta(accounts.positionMint),\n      getAccountMeta(accounts.positionTokenAccount),\n      getAccountMeta(accounts.destinationTokenAccount),\n      getAccountMeta(accounts.lockConfig),\n      getAccountMeta(accounts.token2022Program),\n    ],\n    programAddress,\n    data: getTransferLockedPositionInstructionDataEncoder().encode({}),\n  } as TransferLockedPositionInstruction<\n    TProgramAddress,\n    TAccountPositionAuthority,\n    TAccountReceiver,\n    TAccountPosition,\n    TAccountPositionMint,\n    TAccountPositionTokenAccount,\n    TAccountDestinationTokenAccount,\n    TAccountLockConfig,\n    TAccountToken2022Program\n  >;\n\n  return instruction;\n}\n\nexport type ParsedTransferLockedPositionInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    positionAuthority: TAccountMetas[0];\n    receiver: TAccountMetas[1];\n    position: TAccountMetas[2];\n    positionMint: TAccountMetas[3];\n    positionTokenAccount: TAccountMetas[4];\n    destinationTokenAccount: TAccountMetas[5];\n    lockConfig: TAccountMetas[6];\n    token2022Program: TAccountMetas[7];\n  };\n  data: TransferLockedPositionInstructionData;\n};\n\nexport function parseTransferLockedPositionInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedTransferLockedPositionInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 8) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      positionAuthority: getNextAccount(),\n      receiver: getNextAccount(),\n      position: getNextAccount(),\n      positionMint: getNextAccount(),\n      positionTokenAccount: getNextAccount(),\n      destinationTokenAccount: getNextAccount(),\n      lockConfig: getNextAccount(),\n      token2022Program: getNextAccount(),\n    },\n    data: getTransferLockedPositionInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU128Decoder,\n  getU128Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const TWO_HOP_SWAP_DISCRIMINATOR = new Uint8Array([\n  195, 96, 237, 108, 68, 162, 219, 230,\n]);\n\nexport function getTwoHopSwapDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    TWO_HOP_SWAP_DISCRIMINATOR\n  );\n}\n\nexport type TwoHopSwapInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountTokenProgram extends\n    | string\n    | IAccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  TAccountTokenAuthority extends string | IAccountMeta<string> = string,\n  TAccountWhirlpoolOne extends string | IAccountMeta<string> = string,\n  TAccountWhirlpoolTwo extends string | IAccountMeta<string> = string,\n  TAccountTokenOwnerAccountOneA extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultOneA extends string | IAccountMeta<string> = string,\n  TAccountTokenOwnerAccountOneB extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultOneB extends string | IAccountMeta<string> = string,\n  TAccountTokenOwnerAccountTwoA extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultTwoA extends string | IAccountMeta<string> = string,\n  TAccountTokenOwnerAccountTwoB extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultTwoB extends string | IAccountMeta<string> = string,\n  TAccountTickArrayOne0 extends string | IAccountMeta<string> = string,\n  TAccountTickArrayOne1 extends string | IAccountMeta<string> = string,\n  TAccountTickArrayOne2 extends string | IAccountMeta<string> = string,\n  TAccountTickArrayTwo0 extends string | IAccountMeta<string> = string,\n  TAccountTickArrayTwo1 extends string | IAccountMeta<string> = string,\n  TAccountTickArrayTwo2 extends string | IAccountMeta<string> = string,\n  TAccountOracleOne extends string | IAccountMeta<string> = string,\n  TAccountOracleTwo extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      TAccountTokenAuthority extends string\n        ? ReadonlySignerAccount<TAccountTokenAuthority> &\n            IAccountSignerMeta<TAccountTokenAuthority>\n        : TAccountTokenAuthority,\n      TAccountWhirlpoolOne extends string\n        ? WritableAccount<TAccountWhirlpoolOne>\n        : TAccountWhirlpoolOne,\n      TAccountWhirlpoolTwo extends string\n        ? WritableAccount<TAccountWhirlpoolTwo>\n        : TAccountWhirlpoolTwo,\n      TAccountTokenOwnerAccountOneA extends string\n        ? WritableAccount<TAccountTokenOwnerAccountOneA>\n        : TAccountTokenOwnerAccountOneA,\n      TAccountTokenVaultOneA extends string\n        ? WritableAccount<TAccountTokenVaultOneA>\n        : TAccountTokenVaultOneA,\n      TAccountTokenOwnerAccountOneB extends string\n        ? WritableAccount<TAccountTokenOwnerAccountOneB>\n        : TAccountTokenOwnerAccountOneB,\n      TAccountTokenVaultOneB extends string\n        ? WritableAccount<TAccountTokenVaultOneB>\n        : TAccountTokenVaultOneB,\n      TAccountTokenOwnerAccountTwoA extends string\n        ? WritableAccount<TAccountTokenOwnerAccountTwoA>\n        : TAccountTokenOwnerAccountTwoA,\n      TAccountTokenVaultTwoA extends string\n        ? WritableAccount<TAccountTokenVaultTwoA>\n        : TAccountTokenVaultTwoA,\n      TAccountTokenOwnerAccountTwoB extends string\n        ? WritableAccount<TAccountTokenOwnerAccountTwoB>\n        : TAccountTokenOwnerAccountTwoB,\n      TAccountTokenVaultTwoB extends string\n        ? WritableAccount<TAccountTokenVaultTwoB>\n        : TAccountTokenVaultTwoB,\n      TAccountTickArrayOne0 extends string\n        ? WritableAccount<TAccountTickArrayOne0>\n        : TAccountTickArrayOne0,\n      TAccountTickArrayOne1 extends string\n        ? WritableAccount<TAccountTickArrayOne1>\n        : TAccountTickArrayOne1,\n      TAccountTickArrayOne2 extends string\n        ? WritableAccount<TAccountTickArrayOne2>\n        : TAccountTickArrayOne2,\n      TAccountTickArrayTwo0 extends string\n        ? WritableAccount<TAccountTickArrayTwo0>\n        : TAccountTickArrayTwo0,\n      TAccountTickArrayTwo1 extends string\n        ? WritableAccount<TAccountTickArrayTwo1>\n        : TAccountTickArrayTwo1,\n      TAccountTickArrayTwo2 extends string\n        ? WritableAccount<TAccountTickArrayTwo2>\n        : TAccountTickArrayTwo2,\n      TAccountOracleOne extends string\n        ? ReadonlyAccount<TAccountOracleOne>\n        : TAccountOracleOne,\n      TAccountOracleTwo extends string\n        ? ReadonlyAccount<TAccountOracleTwo>\n        : TAccountOracleTwo,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TwoHopSwapInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  amount: bigint;\n  otherAmountThreshold: bigint;\n  amountSpecifiedIsInput: boolean;\n  aToBOne: boolean;\n  aToBTwo: boolean;\n  sqrtPriceLimitOne: bigint;\n  sqrtPriceLimitTwo: bigint;\n};\n\nexport type TwoHopSwapInstructionDataArgs = {\n  amount: number | bigint;\n  otherAmountThreshold: number | bigint;\n  amountSpecifiedIsInput: boolean;\n  aToBOne: boolean;\n  aToBTwo: boolean;\n  sqrtPriceLimitOne: number | bigint;\n  sqrtPriceLimitTwo: number | bigint;\n};\n\nexport function getTwoHopSwapInstructionDataEncoder(): Encoder<TwoHopSwapInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['amount', getU64Encoder()],\n      ['otherAmountThreshold', getU64Encoder()],\n      ['amountSpecifiedIsInput', getBooleanEncoder()],\n      ['aToBOne', getBooleanEncoder()],\n      ['aToBTwo', getBooleanEncoder()],\n      ['sqrtPriceLimitOne', getU128Encoder()],\n      ['sqrtPriceLimitTwo', getU128Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: TWO_HOP_SWAP_DISCRIMINATOR })\n  );\n}\n\nexport function getTwoHopSwapInstructionDataDecoder(): Decoder<TwoHopSwapInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['amount', getU64Decoder()],\n    ['otherAmountThreshold', getU64Decoder()],\n    ['amountSpecifiedIsInput', getBooleanDecoder()],\n    ['aToBOne', getBooleanDecoder()],\n    ['aToBTwo', getBooleanDecoder()],\n    ['sqrtPriceLimitOne', getU128Decoder()],\n    ['sqrtPriceLimitTwo', getU128Decoder()],\n  ]);\n}\n\nexport function getTwoHopSwapInstructionDataCodec(): Codec<\n  TwoHopSwapInstructionDataArgs,\n  TwoHopSwapInstructionData\n> {\n  return combineCodec(\n    getTwoHopSwapInstructionDataEncoder(),\n    getTwoHopSwapInstructionDataDecoder()\n  );\n}\n\nexport type TwoHopSwapInput<\n  TAccountTokenProgram extends string = string,\n  TAccountTokenAuthority extends string = string,\n  TAccountWhirlpoolOne extends string = string,\n  TAccountWhirlpoolTwo extends string = string,\n  TAccountTokenOwnerAccountOneA extends string = string,\n  TAccountTokenVaultOneA extends string = string,\n  TAccountTokenOwnerAccountOneB extends string = string,\n  TAccountTokenVaultOneB extends string = string,\n  TAccountTokenOwnerAccountTwoA extends string = string,\n  TAccountTokenVaultTwoA extends string = string,\n  TAccountTokenOwnerAccountTwoB extends string = string,\n  TAccountTokenVaultTwoB extends string = string,\n  TAccountTickArrayOne0 extends string = string,\n  TAccountTickArrayOne1 extends string = string,\n  TAccountTickArrayOne2 extends string = string,\n  TAccountTickArrayTwo0 extends string = string,\n  TAccountTickArrayTwo1 extends string = string,\n  TAccountTickArrayTwo2 extends string = string,\n  TAccountOracleOne extends string = string,\n  TAccountOracleTwo extends string = string,\n> = {\n  tokenProgram?: Address<TAccountTokenProgram>;\n  tokenAuthority: TransactionSigner<TAccountTokenAuthority>;\n  whirlpoolOne: Address<TAccountWhirlpoolOne>;\n  whirlpoolTwo: Address<TAccountWhirlpoolTwo>;\n  tokenOwnerAccountOneA: Address<TAccountTokenOwnerAccountOneA>;\n  tokenVaultOneA: Address<TAccountTokenVaultOneA>;\n  tokenOwnerAccountOneB: Address<TAccountTokenOwnerAccountOneB>;\n  tokenVaultOneB: Address<TAccountTokenVaultOneB>;\n  tokenOwnerAccountTwoA: Address<TAccountTokenOwnerAccountTwoA>;\n  tokenVaultTwoA: Address<TAccountTokenVaultTwoA>;\n  tokenOwnerAccountTwoB: Address<TAccountTokenOwnerAccountTwoB>;\n  tokenVaultTwoB: Address<TAccountTokenVaultTwoB>;\n  tickArrayOne0: Address<TAccountTickArrayOne0>;\n  tickArrayOne1: Address<TAccountTickArrayOne1>;\n  tickArrayOne2: Address<TAccountTickArrayOne2>;\n  tickArrayTwo0: Address<TAccountTickArrayTwo0>;\n  tickArrayTwo1: Address<TAccountTickArrayTwo1>;\n  tickArrayTwo2: Address<TAccountTickArrayTwo2>;\n  oracleOne: Address<TAccountOracleOne>;\n  oracleTwo: Address<TAccountOracleTwo>;\n  amount: TwoHopSwapInstructionDataArgs['amount'];\n  otherAmountThreshold: TwoHopSwapInstructionDataArgs['otherAmountThreshold'];\n  amountSpecifiedIsInput: TwoHopSwapInstructionDataArgs['amountSpecifiedIsInput'];\n  aToBOne: TwoHopSwapInstructionDataArgs['aToBOne'];\n  aToBTwo: TwoHopSwapInstructionDataArgs['aToBTwo'];\n  sqrtPriceLimitOne: TwoHopSwapInstructionDataArgs['sqrtPriceLimitOne'];\n  sqrtPriceLimitTwo: TwoHopSwapInstructionDataArgs['sqrtPriceLimitTwo'];\n};\n\nexport function getTwoHopSwapInstruction<\n  TAccountTokenProgram extends string,\n  TAccountTokenAuthority extends string,\n  TAccountWhirlpoolOne extends string,\n  TAccountWhirlpoolTwo extends string,\n  TAccountTokenOwnerAccountOneA extends string,\n  TAccountTokenVaultOneA extends string,\n  TAccountTokenOwnerAccountOneB extends string,\n  TAccountTokenVaultOneB extends string,\n  TAccountTokenOwnerAccountTwoA extends string,\n  TAccountTokenVaultTwoA extends string,\n  TAccountTokenOwnerAccountTwoB extends string,\n  TAccountTokenVaultTwoB extends string,\n  TAccountTickArrayOne0 extends string,\n  TAccountTickArrayOne1 extends string,\n  TAccountTickArrayOne2 extends string,\n  TAccountTickArrayTwo0 extends string,\n  TAccountTickArrayTwo1 extends string,\n  TAccountTickArrayTwo2 extends string,\n  TAccountOracleOne extends string,\n  TAccountOracleTwo extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: TwoHopSwapInput<\n    TAccountTokenProgram,\n    TAccountTokenAuthority,\n    TAccountWhirlpoolOne,\n    TAccountWhirlpoolTwo,\n    TAccountTokenOwnerAccountOneA,\n    TAccountTokenVaultOneA,\n    TAccountTokenOwnerAccountOneB,\n    TAccountTokenVaultOneB,\n    TAccountTokenOwnerAccountTwoA,\n    TAccountTokenVaultTwoA,\n    TAccountTokenOwnerAccountTwoB,\n    TAccountTokenVaultTwoB,\n    TAccountTickArrayOne0,\n    TAccountTickArrayOne1,\n    TAccountTickArrayOne2,\n    TAccountTickArrayTwo0,\n    TAccountTickArrayTwo1,\n    TAccountTickArrayTwo2,\n    TAccountOracleOne,\n    TAccountOracleTwo\n  >,\n  config?: { programAddress?: TProgramAddress }\n): TwoHopSwapInstruction<\n  TProgramAddress,\n  TAccountTokenProgram,\n  TAccountTokenAuthority,\n  TAccountWhirlpoolOne,\n  TAccountWhirlpoolTwo,\n  TAccountTokenOwnerAccountOneA,\n  TAccountTokenVaultOneA,\n  TAccountTokenOwnerAccountOneB,\n  TAccountTokenVaultOneB,\n  TAccountTokenOwnerAccountTwoA,\n  TAccountTokenVaultTwoA,\n  TAccountTokenOwnerAccountTwoB,\n  TAccountTokenVaultTwoB,\n  TAccountTickArrayOne0,\n  TAccountTickArrayOne1,\n  TAccountTickArrayOne2,\n  TAccountTickArrayTwo0,\n  TAccountTickArrayTwo1,\n  TAccountTickArrayTwo2,\n  TAccountOracleOne,\n  TAccountOracleTwo\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n    tokenAuthority: { value: input.tokenAuthority ?? null, isWritable: false },\n    whirlpoolOne: { value: input.whirlpoolOne ?? null, isWritable: true },\n    whirlpoolTwo: { value: input.whirlpoolTwo ?? null, isWritable: true },\n    tokenOwnerAccountOneA: {\n      value: input.tokenOwnerAccountOneA ?? null,\n      isWritable: true,\n    },\n    tokenVaultOneA: { value: input.tokenVaultOneA ?? null, isWritable: true },\n    tokenOwnerAccountOneB: {\n      value: input.tokenOwnerAccountOneB ?? null,\n      isWritable: true,\n    },\n    tokenVaultOneB: { value: input.tokenVaultOneB ?? null, isWritable: true },\n    tokenOwnerAccountTwoA: {\n      value: input.tokenOwnerAccountTwoA ?? null,\n      isWritable: true,\n    },\n    tokenVaultTwoA: { value: input.tokenVaultTwoA ?? null, isWritable: true },\n    tokenOwnerAccountTwoB: {\n      value: input.tokenOwnerAccountTwoB ?? null,\n      isWritable: true,\n    },\n    tokenVaultTwoB: { value: input.tokenVaultTwoB ?? null, isWritable: true },\n    tickArrayOne0: { value: input.tickArrayOne0 ?? null, isWritable: true },\n    tickArrayOne1: { value: input.tickArrayOne1 ?? null, isWritable: true },\n    tickArrayOne2: { value: input.tickArrayOne2 ?? null, isWritable: true },\n    tickArrayTwo0: { value: input.tickArrayTwo0 ?? null, isWritable: true },\n    tickArrayTwo1: { value: input.tickArrayTwo1 ?? null, isWritable: true },\n    tickArrayTwo2: { value: input.tickArrayTwo2 ?? null, isWritable: true },\n    oracleOne: { value: input.oracleOne ?? null, isWritable: false },\n    oracleTwo: { value: input.oracleTwo ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.tokenProgram),\n      getAccountMeta(accounts.tokenAuthority),\n      getAccountMeta(accounts.whirlpoolOne),\n      getAccountMeta(accounts.whirlpoolTwo),\n      getAccountMeta(accounts.tokenOwnerAccountOneA),\n      getAccountMeta(accounts.tokenVaultOneA),\n      getAccountMeta(accounts.tokenOwnerAccountOneB),\n      getAccountMeta(accounts.tokenVaultOneB),\n      getAccountMeta(accounts.tokenOwnerAccountTwoA),\n      getAccountMeta(accounts.tokenVaultTwoA),\n      getAccountMeta(accounts.tokenOwnerAccountTwoB),\n      getAccountMeta(accounts.tokenVaultTwoB),\n      getAccountMeta(accounts.tickArrayOne0),\n      getAccountMeta(accounts.tickArrayOne1),\n      getAccountMeta(accounts.tickArrayOne2),\n      getAccountMeta(accounts.tickArrayTwo0),\n      getAccountMeta(accounts.tickArrayTwo1),\n      getAccountMeta(accounts.tickArrayTwo2),\n      getAccountMeta(accounts.oracleOne),\n      getAccountMeta(accounts.oracleTwo),\n    ],\n    programAddress,\n    data: getTwoHopSwapInstructionDataEncoder().encode(\n      args as TwoHopSwapInstructionDataArgs\n    ),\n  } as TwoHopSwapInstruction<\n    TProgramAddress,\n    TAccountTokenProgram,\n    TAccountTokenAuthority,\n    TAccountWhirlpoolOne,\n    TAccountWhirlpoolTwo,\n    TAccountTokenOwnerAccountOneA,\n    TAccountTokenVaultOneA,\n    TAccountTokenOwnerAccountOneB,\n    TAccountTokenVaultOneB,\n    TAccountTokenOwnerAccountTwoA,\n    TAccountTokenVaultTwoA,\n    TAccountTokenOwnerAccountTwoB,\n    TAccountTokenVaultTwoB,\n    TAccountTickArrayOne0,\n    TAccountTickArrayOne1,\n    TAccountTickArrayOne2,\n    TAccountTickArrayTwo0,\n    TAccountTickArrayTwo1,\n    TAccountTickArrayTwo2,\n    TAccountOracleOne,\n    TAccountOracleTwo\n  >;\n\n  return instruction;\n}\n\nexport type ParsedTwoHopSwapInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    tokenProgram: TAccountMetas[0];\n    tokenAuthority: TAccountMetas[1];\n    whirlpoolOne: TAccountMetas[2];\n    whirlpoolTwo: TAccountMetas[3];\n    tokenOwnerAccountOneA: TAccountMetas[4];\n    tokenVaultOneA: TAccountMetas[5];\n    tokenOwnerAccountOneB: TAccountMetas[6];\n    tokenVaultOneB: TAccountMetas[7];\n    tokenOwnerAccountTwoA: TAccountMetas[8];\n    tokenVaultTwoA: TAccountMetas[9];\n    tokenOwnerAccountTwoB: TAccountMetas[10];\n    tokenVaultTwoB: TAccountMetas[11];\n    tickArrayOne0: TAccountMetas[12];\n    tickArrayOne1: TAccountMetas[13];\n    tickArrayOne2: TAccountMetas[14];\n    tickArrayTwo0: TAccountMetas[15];\n    tickArrayTwo1: TAccountMetas[16];\n    tickArrayTwo2: TAccountMetas[17];\n    oracleOne: TAccountMetas[18];\n    oracleTwo: TAccountMetas[19];\n  };\n  data: TwoHopSwapInstructionData;\n};\n\nexport function parseTwoHopSwapInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedTwoHopSwapInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 20) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      tokenProgram: getNextAccount(),\n      tokenAuthority: getNextAccount(),\n      whirlpoolOne: getNextAccount(),\n      whirlpoolTwo: getNextAccount(),\n      tokenOwnerAccountOneA: getNextAccount(),\n      tokenVaultOneA: getNextAccount(),\n      tokenOwnerAccountOneB: getNextAccount(),\n      tokenVaultOneB: getNextAccount(),\n      tokenOwnerAccountTwoA: getNextAccount(),\n      tokenVaultTwoA: getNextAccount(),\n      tokenOwnerAccountTwoB: getNextAccount(),\n      tokenVaultTwoB: getNextAccount(),\n      tickArrayOne0: getNextAccount(),\n      tickArrayOne1: getNextAccount(),\n      tickArrayOne2: getNextAccount(),\n      tickArrayTwo0: getNextAccount(),\n      tickArrayTwo1: getNextAccount(),\n      tickArrayTwo2: getNextAccount(),\n      oracleOne: getNextAccount(),\n      oracleTwo: getNextAccount(),\n    },\n    data: getTwoHopSwapInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU128Decoder,\n  getU128Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getRemainingAccountsInfoDecoder,\n  getRemainingAccountsInfoEncoder,\n  type RemainingAccountsInfo,\n  type RemainingAccountsInfoArgs,\n} from '../types';\n\nexport const TWO_HOP_SWAP_V2_DISCRIMINATOR = new Uint8Array([\n  186, 143, 209, 29, 254, 2, 194, 117,\n]);\n\nexport function getTwoHopSwapV2DiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    TWO_HOP_SWAP_V2_DISCRIMINATOR\n  );\n}\n\nexport type TwoHopSwapV2Instruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpoolOne extends string | IAccountMeta<string> = string,\n  TAccountWhirlpoolTwo extends string | IAccountMeta<string> = string,\n  TAccountTokenMintInput extends string | IAccountMeta<string> = string,\n  TAccountTokenMintIntermediate extends string | IAccountMeta<string> = string,\n  TAccountTokenMintOutput extends string | IAccountMeta<string> = string,\n  TAccountTokenProgramInput extends string | IAccountMeta<string> = string,\n  TAccountTokenProgramIntermediate extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountTokenProgramOutput extends string | IAccountMeta<string> = string,\n  TAccountTokenOwnerAccountInput extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultOneInput extends string | IAccountMeta<string> = string,\n  TAccountTokenVaultOneIntermediate extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountTokenVaultTwoIntermediate extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountTokenVaultTwoOutput extends string | IAccountMeta<string> = string,\n  TAccountTokenOwnerAccountOutput extends\n    | string\n    | IAccountMeta<string> = string,\n  TAccountTokenAuthority extends string | IAccountMeta<string> = string,\n  TAccountTickArrayOne0 extends string | IAccountMeta<string> = string,\n  TAccountTickArrayOne1 extends string | IAccountMeta<string> = string,\n  TAccountTickArrayOne2 extends string | IAccountMeta<string> = string,\n  TAccountTickArrayTwo0 extends string | IAccountMeta<string> = string,\n  TAccountTickArrayTwo1 extends string | IAccountMeta<string> = string,\n  TAccountTickArrayTwo2 extends string | IAccountMeta<string> = string,\n  TAccountOracleOne extends string | IAccountMeta<string> = string,\n  TAccountOracleTwo extends string | IAccountMeta<string> = string,\n  TAccountMemoProgram extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpoolOne extends string\n        ? WritableAccount<TAccountWhirlpoolOne>\n        : TAccountWhirlpoolOne,\n      TAccountWhirlpoolTwo extends string\n        ? WritableAccount<TAccountWhirlpoolTwo>\n        : TAccountWhirlpoolTwo,\n      TAccountTokenMintInput extends string\n        ? ReadonlyAccount<TAccountTokenMintInput>\n        : TAccountTokenMintInput,\n      TAccountTokenMintIntermediate extends string\n        ? ReadonlyAccount<TAccountTokenMintIntermediate>\n        : TAccountTokenMintIntermediate,\n      TAccountTokenMintOutput extends string\n        ? ReadonlyAccount<TAccountTokenMintOutput>\n        : TAccountTokenMintOutput,\n      TAccountTokenProgramInput extends string\n        ? ReadonlyAccount<TAccountTokenProgramInput>\n        : TAccountTokenProgramInput,\n      TAccountTokenProgramIntermediate extends string\n        ? ReadonlyAccount<TAccountTokenProgramIntermediate>\n        : TAccountTokenProgramIntermediate,\n      TAccountTokenProgramOutput extends string\n        ? ReadonlyAccount<TAccountTokenProgramOutput>\n        : TAccountTokenProgramOutput,\n      TAccountTokenOwnerAccountInput extends string\n        ? WritableAccount<TAccountTokenOwnerAccountInput>\n        : TAccountTokenOwnerAccountInput,\n      TAccountTokenVaultOneInput extends string\n        ? WritableAccount<TAccountTokenVaultOneInput>\n        : TAccountTokenVaultOneInput,\n      TAccountTokenVaultOneIntermediate extends string\n        ? WritableAccount<TAccountTokenVaultOneIntermediate>\n        : TAccountTokenVaultOneIntermediate,\n      TAccountTokenVaultTwoIntermediate extends string\n        ? WritableAccount<TAccountTokenVaultTwoIntermediate>\n        : TAccountTokenVaultTwoIntermediate,\n      TAccountTokenVaultTwoOutput extends string\n        ? WritableAccount<TAccountTokenVaultTwoOutput>\n        : TAccountTokenVaultTwoOutput,\n      TAccountTokenOwnerAccountOutput extends string\n        ? WritableAccount<TAccountTokenOwnerAccountOutput>\n        : TAccountTokenOwnerAccountOutput,\n      TAccountTokenAuthority extends string\n        ? ReadonlySignerAccount<TAccountTokenAuthority> &\n            IAccountSignerMeta<TAccountTokenAuthority>\n        : TAccountTokenAuthority,\n      TAccountTickArrayOne0 extends string\n        ? WritableAccount<TAccountTickArrayOne0>\n        : TAccountTickArrayOne0,\n      TAccountTickArrayOne1 extends string\n        ? WritableAccount<TAccountTickArrayOne1>\n        : TAccountTickArrayOne1,\n      TAccountTickArrayOne2 extends string\n        ? WritableAccount<TAccountTickArrayOne2>\n        : TAccountTickArrayOne2,\n      TAccountTickArrayTwo0 extends string\n        ? WritableAccount<TAccountTickArrayTwo0>\n        : TAccountTickArrayTwo0,\n      TAccountTickArrayTwo1 extends string\n        ? WritableAccount<TAccountTickArrayTwo1>\n        : TAccountTickArrayTwo1,\n      TAccountTickArrayTwo2 extends string\n        ? WritableAccount<TAccountTickArrayTwo2>\n        : TAccountTickArrayTwo2,\n      TAccountOracleOne extends string\n        ? WritableAccount<TAccountOracleOne>\n        : TAccountOracleOne,\n      TAccountOracleTwo extends string\n        ? WritableAccount<TAccountOracleTwo>\n        : TAccountOracleTwo,\n      TAccountMemoProgram extends string\n        ? ReadonlyAccount<TAccountMemoProgram>\n        : TAccountMemoProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TwoHopSwapV2InstructionData = {\n  discriminator: ReadonlyUint8Array;\n  amount: bigint;\n  otherAmountThreshold: bigint;\n  amountSpecifiedIsInput: boolean;\n  aToBOne: boolean;\n  aToBTwo: boolean;\n  sqrtPriceLimitOne: bigint;\n  sqrtPriceLimitTwo: bigint;\n  remainingAccountsInfo: Option<RemainingAccountsInfo>;\n};\n\nexport type TwoHopSwapV2InstructionDataArgs = {\n  amount: number | bigint;\n  otherAmountThreshold: number | bigint;\n  amountSpecifiedIsInput: boolean;\n  aToBOne: boolean;\n  aToBTwo: boolean;\n  sqrtPriceLimitOne: number | bigint;\n  sqrtPriceLimitTwo: number | bigint;\n  remainingAccountsInfo: OptionOrNullable<RemainingAccountsInfoArgs>;\n};\n\nexport function getTwoHopSwapV2InstructionDataEncoder(): Encoder<TwoHopSwapV2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],\n      ['amount', getU64Encoder()],\n      ['otherAmountThreshold', getU64Encoder()],\n      ['amountSpecifiedIsInput', getBooleanEncoder()],\n      ['aToBOne', getBooleanEncoder()],\n      ['aToBTwo', getBooleanEncoder()],\n      ['sqrtPriceLimitOne', getU128Encoder()],\n      ['sqrtPriceLimitTwo', getU128Encoder()],\n      [\n        'remainingAccountsInfo',\n        getOptionEncoder(getRemainingAccountsInfoEncoder()),\n      ],\n    ]),\n    (value) => ({ ...value, discriminator: TWO_HOP_SWAP_V2_DISCRIMINATOR })\n  );\n}\n\nexport function getTwoHopSwapV2InstructionDataDecoder(): Decoder<TwoHopSwapV2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n    ['amount', getU64Decoder()],\n    ['otherAmountThreshold', getU64Decoder()],\n    ['amountSpecifiedIsInput', getBooleanDecoder()],\n    ['aToBOne', getBooleanDecoder()],\n    ['aToBTwo', getBooleanDecoder()],\n    ['sqrtPriceLimitOne', getU128Decoder()],\n    ['sqrtPriceLimitTwo', getU128Decoder()],\n    [\n      'remainingAccountsInfo',\n      getOptionDecoder(getRemainingAccountsInfoDecoder()),\n    ],\n  ]);\n}\n\nexport function getTwoHopSwapV2InstructionDataCodec(): Codec<\n  TwoHopSwapV2InstructionDataArgs,\n  TwoHopSwapV2InstructionData\n> {\n  return combineCodec(\n    getTwoHopSwapV2InstructionDataEncoder(),\n    getTwoHopSwapV2InstructionDataDecoder()\n  );\n}\n\nexport type TwoHopSwapV2Input<\n  TAccountWhirlpoolOne extends string = string,\n  TAccountWhirlpoolTwo extends string = string,\n  TAccountTokenMintInput extends string = string,\n  TAccountTokenMintIntermediate extends string = string,\n  TAccountTokenMintOutput extends string = string,\n  TAccountTokenProgramInput extends string = string,\n  TAccountTokenProgramIntermediate extends string = string,\n  TAccountTokenProgramOutput extends string = string,\n  TAccountTokenOwnerAccountInput extends string = string,\n  TAccountTokenVaultOneInput extends string = string,\n  TAccountTokenVaultOneIntermediate extends string = string,\n  TAccountTokenVaultTwoIntermediate extends string = string,\n  TAccountTokenVaultTwoOutput extends string = string,\n  TAccountTokenOwnerAccountOutput extends string = string,\n  TAccountTokenAuthority extends string = string,\n  TAccountTickArrayOne0 extends string = string,\n  TAccountTickArrayOne1 extends string = string,\n  TAccountTickArrayOne2 extends string = string,\n  TAccountTickArrayTwo0 extends string = string,\n  TAccountTickArrayTwo1 extends string = string,\n  TAccountTickArrayTwo2 extends string = string,\n  TAccountOracleOne extends string = string,\n  TAccountOracleTwo extends string = string,\n  TAccountMemoProgram extends string = string,\n> = {\n  whirlpoolOne: Address<TAccountWhirlpoolOne>;\n  whirlpoolTwo: Address<TAccountWhirlpoolTwo>;\n  tokenMintInput: Address<TAccountTokenMintInput>;\n  tokenMintIntermediate: Address<TAccountTokenMintIntermediate>;\n  tokenMintOutput: Address<TAccountTokenMintOutput>;\n  tokenProgramInput: Address<TAccountTokenProgramInput>;\n  tokenProgramIntermediate: Address<TAccountTokenProgramIntermediate>;\n  tokenProgramOutput: Address<TAccountTokenProgramOutput>;\n  tokenOwnerAccountInput: Address<TAccountTokenOwnerAccountInput>;\n  tokenVaultOneInput: Address<TAccountTokenVaultOneInput>;\n  tokenVaultOneIntermediate: Address<TAccountTokenVaultOneIntermediate>;\n  tokenVaultTwoIntermediate: Address<TAccountTokenVaultTwoIntermediate>;\n  tokenVaultTwoOutput: Address<TAccountTokenVaultTwoOutput>;\n  tokenOwnerAccountOutput: Address<TAccountTokenOwnerAccountOutput>;\n  tokenAuthority: TransactionSigner<TAccountTokenAuthority>;\n  tickArrayOne0: Address<TAccountTickArrayOne0>;\n  tickArrayOne1: Address<TAccountTickArrayOne1>;\n  tickArrayOne2: Address<TAccountTickArrayOne2>;\n  tickArrayTwo0: Address<TAccountTickArrayTwo0>;\n  tickArrayTwo1: Address<TAccountTickArrayTwo1>;\n  tickArrayTwo2: Address<TAccountTickArrayTwo2>;\n  oracleOne: Address<TAccountOracleOne>;\n  oracleTwo: Address<TAccountOracleTwo>;\n  memoProgram: Address<TAccountMemoProgram>;\n  amount: TwoHopSwapV2InstructionDataArgs['amount'];\n  otherAmountThreshold: TwoHopSwapV2InstructionDataArgs['otherAmountThreshold'];\n  amountSpecifiedIsInput: TwoHopSwapV2InstructionDataArgs['amountSpecifiedIsInput'];\n  aToBOne: TwoHopSwapV2InstructionDataArgs['aToBOne'];\n  aToBTwo: TwoHopSwapV2InstructionDataArgs['aToBTwo'];\n  sqrtPriceLimitOne: TwoHopSwapV2InstructionDataArgs['sqrtPriceLimitOne'];\n  sqrtPriceLimitTwo: TwoHopSwapV2InstructionDataArgs['sqrtPriceLimitTwo'];\n  remainingAccountsInfo: TwoHopSwapV2InstructionDataArgs['remainingAccountsInfo'];\n};\n\nexport function getTwoHopSwapV2Instruction<\n  TAccountWhirlpoolOne extends string,\n  TAccountWhirlpoolTwo extends string,\n  TAccountTokenMintInput extends string,\n  TAccountTokenMintIntermediate extends string,\n  TAccountTokenMintOutput extends string,\n  TAccountTokenProgramInput extends string,\n  TAccountTokenProgramIntermediate extends string,\n  TAccountTokenProgramOutput extends string,\n  TAccountTokenOwnerAccountInput extends string,\n  TAccountTokenVaultOneInput extends string,\n  TAccountTokenVaultOneIntermediate extends string,\n  TAccountTokenVaultTwoIntermediate extends string,\n  TAccountTokenVaultTwoOutput extends string,\n  TAccountTokenOwnerAccountOutput extends string,\n  TAccountTokenAuthority extends string,\n  TAccountTickArrayOne0 extends string,\n  TAccountTickArrayOne1 extends string,\n  TAccountTickArrayOne2 extends string,\n  TAccountTickArrayTwo0 extends string,\n  TAccountTickArrayTwo1 extends string,\n  TAccountTickArrayTwo2 extends string,\n  TAccountOracleOne extends string,\n  TAccountOracleTwo extends string,\n  TAccountMemoProgram extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: TwoHopSwapV2Input<\n    TAccountWhirlpoolOne,\n    TAccountWhirlpoolTwo,\n    TAccountTokenMintInput,\n    TAccountTokenMintIntermediate,\n    TAccountTokenMintOutput,\n    TAccountTokenProgramInput,\n    TAccountTokenProgramIntermediate,\n    TAccountTokenProgramOutput,\n    TAccountTokenOwnerAccountInput,\n    TAccountTokenVaultOneInput,\n    TAccountTokenVaultOneIntermediate,\n    TAccountTokenVaultTwoIntermediate,\n    TAccountTokenVaultTwoOutput,\n    TAccountTokenOwnerAccountOutput,\n    TAccountTokenAuthority,\n    TAccountTickArrayOne0,\n    TAccountTickArrayOne1,\n    TAccountTickArrayOne2,\n    TAccountTickArrayTwo0,\n    TAccountTickArrayTwo1,\n    TAccountTickArrayTwo2,\n    TAccountOracleOne,\n    TAccountOracleTwo,\n    TAccountMemoProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): TwoHopSwapV2Instruction<\n  TProgramAddress,\n  TAccountWhirlpoolOne,\n  TAccountWhirlpoolTwo,\n  TAccountTokenMintInput,\n  TAccountTokenMintIntermediate,\n  TAccountTokenMintOutput,\n  TAccountTokenProgramInput,\n  TAccountTokenProgramIntermediate,\n  TAccountTokenProgramOutput,\n  TAccountTokenOwnerAccountInput,\n  TAccountTokenVaultOneInput,\n  TAccountTokenVaultOneIntermediate,\n  TAccountTokenVaultTwoIntermediate,\n  TAccountTokenVaultTwoOutput,\n  TAccountTokenOwnerAccountOutput,\n  TAccountTokenAuthority,\n  TAccountTickArrayOne0,\n  TAccountTickArrayOne1,\n  TAccountTickArrayOne2,\n  TAccountTickArrayTwo0,\n  TAccountTickArrayTwo1,\n  TAccountTickArrayTwo2,\n  TAccountOracleOne,\n  TAccountOracleTwo,\n  TAccountMemoProgram\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpoolOne: { value: input.whirlpoolOne ?? null, isWritable: true },\n    whirlpoolTwo: { value: input.whirlpoolTwo ?? null, isWritable: true },\n    tokenMintInput: { value: input.tokenMintInput ?? null, isWritable: false },\n    tokenMintIntermediate: {\n      value: input.tokenMintIntermediate ?? null,\n      isWritable: false,\n    },\n    tokenMintOutput: {\n      value: input.tokenMintOutput ?? null,\n      isWritable: false,\n    },\n    tokenProgramInput: {\n      value: input.tokenProgramInput ?? null,\n      isWritable: false,\n    },\n    tokenProgramIntermediate: {\n      value: input.tokenProgramIntermediate ?? null,\n      isWritable: false,\n    },\n    tokenProgramOutput: {\n      value: input.tokenProgramOutput ?? null,\n      isWritable: false,\n    },\n    tokenOwnerAccountInput: {\n      value: input.tokenOwnerAccountInput ?? null,\n      isWritable: true,\n    },\n    tokenVaultOneInput: {\n      value: input.tokenVaultOneInput ?? null,\n      isWritable: true,\n    },\n    tokenVaultOneIntermediate: {\n      value: input.tokenVaultOneIntermediate ?? null,\n      isWritable: true,\n    },\n    tokenVaultTwoIntermediate: {\n      value: input.tokenVaultTwoIntermediate ?? null,\n      isWritable: true,\n    },\n    tokenVaultTwoOutput: {\n      value: input.tokenVaultTwoOutput ?? null,\n      isWritable: true,\n    },\n    tokenOwnerAccountOutput: {\n      value: input.tokenOwnerAccountOutput ?? null,\n      isWritable: true,\n    },\n    tokenAuthority: { value: input.tokenAuthority ?? null, isWritable: false },\n    tickArrayOne0: { value: input.tickArrayOne0 ?? null, isWritable: true },\n    tickArrayOne1: { value: input.tickArrayOne1 ?? null, isWritable: true },\n    tickArrayOne2: { value: input.tickArrayOne2 ?? null, isWritable: true },\n    tickArrayTwo0: { value: input.tickArrayTwo0 ?? null, isWritable: true },\n    tickArrayTwo1: { value: input.tickArrayTwo1 ?? null, isWritable: true },\n    tickArrayTwo2: { value: input.tickArrayTwo2 ?? null, isWritable: true },\n    oracleOne: { value: input.oracleOne ?? null, isWritable: true },\n    oracleTwo: { value: input.oracleTwo ?? null, isWritable: true },\n    memoProgram: { value: input.memoProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpoolOne),\n      getAccountMeta(accounts.whirlpoolTwo),\n      getAccountMeta(accounts.tokenMintInput),\n      getAccountMeta(accounts.tokenMintIntermediate),\n      getAccountMeta(accounts.tokenMintOutput),\n      getAccountMeta(accounts.tokenProgramInput),\n      getAccountMeta(accounts.tokenProgramIntermediate),\n      getAccountMeta(accounts.tokenProgramOutput),\n      getAccountMeta(accounts.tokenOwnerAccountInput),\n      getAccountMeta(accounts.tokenVaultOneInput),\n      getAccountMeta(accounts.tokenVaultOneIntermediate),\n      getAccountMeta(accounts.tokenVaultTwoIntermediate),\n      getAccountMeta(accounts.tokenVaultTwoOutput),\n      getAccountMeta(accounts.tokenOwnerAccountOutput),\n      getAccountMeta(accounts.tokenAuthority),\n      getAccountMeta(accounts.tickArrayOne0),\n      getAccountMeta(accounts.tickArrayOne1),\n      getAccountMeta(accounts.tickArrayOne2),\n      getAccountMeta(accounts.tickArrayTwo0),\n      getAccountMeta(accounts.tickArrayTwo1),\n      getAccountMeta(accounts.tickArrayTwo2),\n      getAccountMeta(accounts.oracleOne),\n      getAccountMeta(accounts.oracleTwo),\n      getAccountMeta(accounts.memoProgram),\n    ],\n    programAddress,\n    data: getTwoHopSwapV2InstructionDataEncoder().encode(\n      args as TwoHopSwapV2InstructionDataArgs\n    ),\n  } as TwoHopSwapV2Instruction<\n    TProgramAddress,\n    TAccountWhirlpoolOne,\n    TAccountWhirlpoolTwo,\n    TAccountTokenMintInput,\n    TAccountTokenMintIntermediate,\n    TAccountTokenMintOutput,\n    TAccountTokenProgramInput,\n    TAccountTokenProgramIntermediate,\n    TAccountTokenProgramOutput,\n    TAccountTokenOwnerAccountInput,\n    TAccountTokenVaultOneInput,\n    TAccountTokenVaultOneIntermediate,\n    TAccountTokenVaultTwoIntermediate,\n    TAccountTokenVaultTwoOutput,\n    TAccountTokenOwnerAccountOutput,\n    TAccountTokenAuthority,\n    TAccountTickArrayOne0,\n    TAccountTickArrayOne1,\n    TAccountTickArrayOne2,\n    TAccountTickArrayTwo0,\n    TAccountTickArrayTwo1,\n    TAccountTickArrayTwo2,\n    TAccountOracleOne,\n    TAccountOracleTwo,\n    TAccountMemoProgram\n  >;\n\n  return instruction;\n}\n\nexport type ParsedTwoHopSwapV2Instruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpoolOne: TAccountMetas[0];\n    whirlpoolTwo: TAccountMetas[1];\n    tokenMintInput: TAccountMetas[2];\n    tokenMintIntermediate: TAccountMetas[3];\n    tokenMintOutput: TAccountMetas[4];\n    tokenProgramInput: TAccountMetas[5];\n    tokenProgramIntermediate: TAccountMetas[6];\n    tokenProgramOutput: TAccountMetas[7];\n    tokenOwnerAccountInput: TAccountMetas[8];\n    tokenVaultOneInput: TAccountMetas[9];\n    tokenVaultOneIntermediate: TAccountMetas[10];\n    tokenVaultTwoIntermediate: TAccountMetas[11];\n    tokenVaultTwoOutput: TAccountMetas[12];\n    tokenOwnerAccountOutput: TAccountMetas[13];\n    tokenAuthority: TAccountMetas[14];\n    tickArrayOne0: TAccountMetas[15];\n    tickArrayOne1: TAccountMetas[16];\n    tickArrayOne2: TAccountMetas[17];\n    tickArrayTwo0: TAccountMetas[18];\n    tickArrayTwo1: TAccountMetas[19];\n    tickArrayTwo2: TAccountMetas[20];\n    oracleOne: TAccountMetas[21];\n    oracleTwo: TAccountMetas[22];\n    memoProgram: TAccountMetas[23];\n  };\n  data: TwoHopSwapV2InstructionData;\n};\n\nexport function parseTwoHopSwapV2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedTwoHopSwapV2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 24) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpoolOne: getNextAccount(),\n      whirlpoolTwo: getNextAccount(),\n      tokenMintInput: getNextAccount(),\n      tokenMintIntermediate: getNextAccount(),\n      tokenMintOutput: getNextAccount(),\n      tokenProgramInput: getNextAccount(),\n      tokenProgramIntermediate: getNextAccount(),\n      tokenProgramOutput: getNextAccount(),\n      tokenOwnerAccountInput: getNextAccount(),\n      tokenVaultOneInput: getNextAccount(),\n      tokenVaultOneIntermediate: getNextAccount(),\n      tokenVaultTwoIntermediate: getNextAccount(),\n      tokenVaultTwoOutput: getNextAccount(),\n      tokenOwnerAccountOutput: getNextAccount(),\n      tokenAuthority: getNextAccount(),\n      tickArrayOne0: getNextAccount(),\n      tickArrayOne1: getNextAccount(),\n      tickArrayOne2: getNextAccount(),\n      tickArrayTwo0: getNextAccount(),\n      tickArrayTwo1: getNextAccount(),\n      tickArrayTwo2: getNextAccount(),\n      oracleOne: getNextAccount(),\n      oracleTwo: getNextAccount(),\n      memoProgram: getNextAccount(),\n    },\n    data: getTwoHopSwapV2InstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_FEES_AND_REWARDS_DISCRIMINATOR = new Uint8Array([\n  154, 230, 250, 13, 236, 209, 75, 223,\n]);\n\nexport function getUpdateFeesAndRewardsDiscriminatorBytes() {\n  return fixEncoderSize(getBytesEncoder(), 8).encode(\n    UPDATE_FEES_AND_REWARDS_DISCRIMINATOR\n  );\n}\n\nexport type UpdateFeesAndRewardsInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountWhirlpool extends string | IAccountMeta<string> = string,\n  TAccountPosition extends string | IAccountMeta<string> = string,\n  TAccountTickArrayLower extends string | IAccountMeta<string> = string,\n  TAccountTickArrayUpper extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountWhirlpool extends string\n        ? WritableAccount<TAccountWhirlpool>\n        : TAccountWhirlpool,\n      TAccountPosition extends string\n        ? WritableAccount<TAccountPosition>\n        : TAccountPosition,\n      TAccountTickArrayLower extends string\n        ? ReadonlyAccount<TAccountTickArrayLower>\n        : TAccountTickArrayLower,\n      TAccountTickArrayUpper extends string\n        ? ReadonlyAccount<TAccountTickArrayUpper>\n        : TAccountTickArrayUpper,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateFeesAndRewardsInstructionData = {\n  discriminator: ReadonlyUint8Array;\n};\n\nexport type UpdateFeesAndRewardsInstructionDataArgs = {};\n\nexport function getUpdateFeesAndRewardsInstructionDataEncoder(): Encoder<UpdateFeesAndRewardsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_FEES_AND_REWARDS_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateFeesAndRewardsInstructionDataDecoder(): Decoder<UpdateFeesAndRewardsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],\n  ]);\n}\n\nexport function getUpdateFeesAndRewardsInstructionDataCodec(): Codec<\n  UpdateFeesAndRewardsInstructionDataArgs,\n  UpdateFeesAndRewardsInstructionData\n> {\n  return combineCodec(\n    getUpdateFeesAndRewardsInstructionDataEncoder(),\n    getUpdateFeesAndRewardsInstructionDataDecoder()\n  );\n}\n\nexport type UpdateFeesAndRewardsInput<\n  TAccountWhirlpool extends string = string,\n  TAccountPosition extends string = string,\n  TAccountTickArrayLower extends string = string,\n  TAccountTickArrayUpper extends string = string,\n> = {\n  whirlpool: Address<TAccountWhirlpool>;\n  position: Address<TAccountPosition>;\n  tickArrayLower: Address<TAccountTickArrayLower>;\n  tickArrayUpper: Address<TAccountTickArrayUpper>;\n};\n\nexport function getUpdateFeesAndRewardsInstruction<\n  TAccountWhirlpool extends string,\n  TAccountPosition extends string,\n  TAccountTickArrayLower extends string,\n  TAccountTickArrayUpper extends string,\n  TProgramAddress extends Address = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n>(\n  input: UpdateFeesAndRewardsInput<\n    TAccountWhirlpool,\n    TAccountPosition,\n    TAccountTickArrayLower,\n    TAccountTickArrayUpper\n  >,\n  config?: { programAddress?: TProgramAddress }\n): UpdateFeesAndRewardsInstruction<\n  TProgramAddress,\n  TAccountWhirlpool,\n  TAccountPosition,\n  TAccountTickArrayLower,\n  TAccountTickArrayUpper\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    whirlpool: { value: input.whirlpool ?? null, isWritable: true },\n    position: { value: input.position ?? null, isWritable: true },\n    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: false },\n    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.whirlpool),\n      getAccountMeta(accounts.position),\n      getAccountMeta(accounts.tickArrayLower),\n      getAccountMeta(accounts.tickArrayUpper),\n    ],\n    programAddress,\n    data: getUpdateFeesAndRewardsInstructionDataEncoder().encode({}),\n  } as UpdateFeesAndRewardsInstruction<\n    TProgramAddress,\n    TAccountWhirlpool,\n    TAccountPosition,\n    TAccountTickArrayLower,\n    TAccountTickArrayUpper\n  >;\n\n  return instruction;\n}\n\nexport type ParsedUpdateFeesAndRewardsInstruction<\n  TProgram extends string = typeof WHIRLPOOL_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    whirlpool: TAccountMetas[0];\n    position: TAccountMetas[1];\n    tickArrayLower: TAccountMetas[2];\n    tickArrayUpper: TAccountMetas[3];\n  };\n  data: UpdateFeesAndRewardsInstructionData;\n};\n\nexport function parseUpdateFeesAndRewardsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedUpdateFeesAndRewardsInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      whirlpool: getNextAccount(),\n      position: getNextAccount(),\n      tickArrayLower: getNextAccount(),\n      tickArrayUpper: getNextAccount(),\n    },\n    data: getUpdateFeesAndRewardsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","import type {\n  Account,\n  Address,\n  GetProgramAccountsApi,\n  GetProgramAccountsMemcmpFilter,\n  Rpc,\n} from \"@solana/kit\";\nimport {\n  getAddressEncoder,\n  getBase58Decoder,\n  getU16Encoder,\n  getU32Encoder,\n} from \"@solana/kit\";\nimport { fetchDecodedProgramAccounts } from \"./utils\";\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from \"../generated/programs/whirlpool\";\nimport type { AdaptiveFeeTier } from \"../generated\";\nimport {\n  ADAPTIVE_FEE_TIER_DISCRIMINATOR,\n  getAdaptiveFeeTierDecoder,\n} from \"../generated\";\n\ntype AdaptiveFeeTierFilter = GetProgramAccountsMemcmpFilter & {\n  readonly __kind: unique symbol;\n};\n\nexport function adaptiveFeeTierWhirlpoolsConfigFilter(\n  address: Address,\n): AdaptiveFeeTierFilter {\n  return {\n    memcmp: {\n      offset: 8n,\n      bytes: getBase58Decoder().decode(getAddressEncoder().encode(address)),\n      encoding: \"base58\",\n    },\n  } as AdaptiveFeeTierFilter;\n}\n\nexport function adaptiveFeeTierFeeTierIndexFilter(\n  feeTierIndex: number,\n): AdaptiveFeeTierFilter {\n  return {\n    memcmp: {\n      offset: 40n,\n      bytes: getBase58Decoder().decode(getU16Encoder().encode(feeTierIndex)),\n      encoding: \"base58\",\n    },\n  } as AdaptiveFeeTierFilter;\n}\n\nexport function adaptiveFeeTierTickSpacingFilter(\n  tickSpacing: number,\n): AdaptiveFeeTierFilter {\n  return {\n    memcmp: {\n      offset: 42n,\n      bytes: getBase58Decoder().decode(getU16Encoder().encode(tickSpacing)),\n      encoding: \"base58\",\n    },\n  } as AdaptiveFeeTierFilter;\n}\n\nexport function adaptiveFeeTierInitializePoolAuthorityFilter(\n  address: Address,\n): AdaptiveFeeTierFilter {\n  return {\n    memcmp: {\n      offset: 44n,\n      bytes: getBase58Decoder().decode(getAddressEncoder().encode(address)),\n      encoding: \"base58\",\n    },\n  } as AdaptiveFeeTierFilter;\n}\n\nexport function adaptiveFeeTierDelegatedFeeAuthorityFilter(\n  address: Address,\n): AdaptiveFeeTierFilter {\n  return {\n    memcmp: {\n      offset: 76n,\n      bytes: getBase58Decoder().decode(getAddressEncoder().encode(address)),\n      encoding: \"base58\",\n    },\n  } as AdaptiveFeeTierFilter;\n}\n\nexport function adaptiveFeeTierDefaultBaseFeeRateFilter(\n  feeRate: number,\n): AdaptiveFeeTierFilter {\n  return {\n    memcmp: {\n      offset: 108n,\n      bytes: getBase58Decoder().decode(getU16Encoder().encode(feeRate)),\n      encoding: \"base58\",\n    },\n  } as AdaptiveFeeTierFilter;\n}\n\nexport function adaptiveFeeTierFilterPeriodFilter(\n  filterPeriod: number,\n): AdaptiveFeeTierFilter {\n  return {\n    memcmp: {\n      offset: 110n,\n      bytes: getBase58Decoder().decode(getU16Encoder().encode(filterPeriod)),\n      encoding: \"base58\",\n    },\n  } as AdaptiveFeeTierFilter;\n}\n\nexport function adaptiveFeeTierDecayPeriodFilter(\n  decayPeriod: number,\n): AdaptiveFeeTierFilter {\n  return {\n    memcmp: {\n      offset: 112n,\n      bytes: getBase58Decoder().decode(getU16Encoder().encode(decayPeriod)),\n      encoding: \"base58\",\n    },\n  } as AdaptiveFeeTierFilter;\n}\n\nexport function adaptiveFeeTierReductionFactorFilter(\n  reductionFactor: number,\n): AdaptiveFeeTierFilter {\n  return {\n    memcmp: {\n      offset: 114n,\n      bytes: getBase58Decoder().decode(getU16Encoder().encode(reductionFactor)),\n      encoding: \"base58\",\n    },\n  } as AdaptiveFeeTierFilter;\n}\n\nexport function adaptiveFeeTierAdaptiveFeeControlFactorFilter(\n  adaptiveFeeControlFactor: number,\n): AdaptiveFeeTierFilter {\n  return {\n    memcmp: {\n      offset: 116n,\n      bytes: getBase58Decoder().decode(\n        getU32Encoder().encode(adaptiveFeeControlFactor),\n      ),\n      encoding: \"base58\",\n    },\n  } as AdaptiveFeeTierFilter;\n}\n\nexport function adaptiveFeeTierMaxVolatilityFilter(\n  maxVolatility: number,\n): AdaptiveFeeTierFilter {\n  return {\n    memcmp: {\n      offset: 120n,\n      bytes: getBase58Decoder().decode(getU32Encoder().encode(maxVolatility)),\n      encoding: \"base58\",\n    },\n  } as AdaptiveFeeTierFilter;\n}\n\nexport function adaptiveFeeTierTickGroupSizeFilter(\n  tickGroupSize: number,\n): AdaptiveFeeTierFilter {\n  return {\n    memcmp: {\n      offset: 124n,\n      bytes: getBase58Decoder().decode(getU16Encoder().encode(tickGroupSize)),\n      encoding: \"base58\",\n    },\n  } as AdaptiveFeeTierFilter;\n}\n\nexport function adaptiveFeeTierMajorSwapThresholdTicksFilter(\n  majorSwapThresholdTicks: number,\n): AdaptiveFeeTierFilter {\n  return {\n    memcmp: {\n      offset: 126n,\n      bytes: getBase58Decoder().decode(\n        getU16Encoder().encode(majorSwapThresholdTicks),\n      ),\n      encoding: \"base58\",\n    },\n  } as AdaptiveFeeTierFilter;\n}\n\nexport async function fetchAllAdaptiveFeeTierWithFilter(\n  rpc: Rpc<GetProgramAccountsApi>,\n  ...filters: AdaptiveFeeTierFilter[]\n): Promise<Account<AdaptiveFeeTier>[]> {\n  const discriminator = getBase58Decoder().decode(\n    ADAPTIVE_FEE_TIER_DISCRIMINATOR,\n  );\n  const discriminatorFilter: GetProgramAccountsMemcmpFilter = {\n    memcmp: {\n      offset: 0n,\n      bytes: discriminator,\n      encoding: \"base58\",\n    },\n  };\n  return fetchDecodedProgramAccounts(\n    rpc,\n    WHIRLPOOL_PROGRAM_ADDRESS,\n    [discriminatorFilter, ...filters],\n    getAdaptiveFeeTierDecoder(),\n  );\n}\n","import type {\n  Account,\n  Address,\n  GetProgramAccountsApi,\n  GetProgramAccountsMemcmpFilter,\n  Rpc,\n  VariableSizeDecoder,\n} from \"@solana/kit\";\nimport { getBase64Encoder } from \"@solana/kit\";\n\nexport async function fetchDecodedProgramAccounts<T extends object>(\n  rpc: Rpc<GetProgramAccountsApi>,\n  programAddress: Address,\n  filters: GetProgramAccountsMemcmpFilter[],\n  decoder: VariableSizeDecoder<T>,\n): Promise<Account<T>[]> {\n  const accountInfos = await rpc\n    .getProgramAccounts(programAddress, {\n      encoding: \"base64\",\n      filters,\n    })\n    .send();\n  const encoder = getBase64Encoder();\n  const datas = accountInfos.map((x) => encoder.encode(x.account.data[0]));\n  const decoded = datas.map((x) => decoder.decode(x));\n  return decoded.map((data, i) => ({\n    ...accountInfos[i].account,\n    address: accountInfos[i].pubkey,\n    programAddress: programAddress,\n    data,\n  }));\n}\n","import type {\n  Account,\n  Address,\n  GetProgramAccountsApi,\n  GetProgramAccountsMemcmpFilter,\n  Rpc,\n} from \"@solana/kit\";\nimport {\n  getAddressEncoder,\n  getBase58Decoder,\n  getU16Encoder,\n} from \"@solana/kit\";\nimport type { FeeTier } from \"../generated/accounts/feeTier\";\nimport {\n  FEE_TIER_DISCRIMINATOR,\n  getFeeTierDecoder,\n} from \"../generated/accounts/feeTier\";\nimport { fetchDecodedProgramAccounts } from \"./utils\";\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from \"../generated/programs/whirlpool\";\n\ntype FeeTierFilter = GetProgramAccountsMemcmpFilter & {\n  readonly __kind: unique symbol;\n};\n\nexport function feeTierWhirlpoolsConfigFilter(address: Address): FeeTierFilter {\n  return {\n    memcmp: {\n      offset: 8n,\n      bytes: getBase58Decoder().decode(getAddressEncoder().encode(address)),\n      encoding: \"base58\",\n    },\n  } as FeeTierFilter;\n}\n\nexport function feeTierTickSpacingFilter(tickSpacing: number): FeeTierFilter {\n  return {\n    memcmp: {\n      offset: 40n,\n      bytes: getBase58Decoder().decode(getU16Encoder().encode(tickSpacing)),\n      encoding: \"base58\",\n    },\n  } as FeeTierFilter;\n}\n\nexport function feeTierFeeRateFilter(defaultFeeRate: number): FeeTierFilter {\n  return {\n    memcmp: {\n      offset: 42n,\n      bytes: getBase58Decoder().decode(getU16Encoder().encode(defaultFeeRate)),\n      encoding: \"base58\",\n    },\n  } as FeeTierFilter;\n}\n\nexport async function fetchAllFeeTierWithFilter(\n  rpc: Rpc<GetProgramAccountsApi>,\n  ...filters: FeeTierFilter[]\n): Promise<Account<FeeTier>[]> {\n  const discriminator = getBase58Decoder().decode(FEE_TIER_DISCRIMINATOR);\n  const discriminatorFilter: GetProgramAccountsMemcmpFilter = {\n    memcmp: {\n      offset: 0n,\n      bytes: discriminator,\n      encoding: \"base58\",\n    },\n  };\n  return fetchDecodedProgramAccounts(\n    rpc,\n    WHIRLPOOL_PROGRAM_ADDRESS,\n    [discriminatorFilter, ...filters],\n    getFeeTierDecoder(),\n  );\n}\n","import type {\n  Account,\n  Address,\n  GetProgramAccountsApi,\n  GetProgramAccountsMemcmpFilter,\n  Rpc,\n} from \"@solana/kit\";\nimport {\n  getAddressEncoder,\n  getBase58Decoder,\n  getU16Encoder,\n  getU32Encoder,\n  getU64Encoder,\n} from \"@solana/kit\";\nimport { fetchDecodedProgramAccounts } from \"./utils\";\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from \"../generated/programs/whirlpool\";\nimport type { Oracle } from \"../generated\";\nimport { getOracleDecoder, ORACLE_DISCRIMINATOR } from \"../generated\";\n\ntype OracleFilter = GetProgramAccountsMemcmpFilter & {\n  readonly __kind: unique symbol;\n};\n\nexport function oracleWhirlpoolFilter(address: Address): OracleFilter {\n  return {\n    memcmp: {\n      offset: 8n,\n      bytes: getBase58Decoder().decode(getAddressEncoder().encode(address)),\n      encoding: \"base58\",\n    },\n  } as OracleFilter;\n}\n\nexport function oracleTradeEnableTimestampFilter(\n  timestamp: number | bigint,\n): OracleFilter {\n  return {\n    memcmp: {\n      offset: 40n,\n      bytes: getBase58Decoder().decode(getU64Encoder().encode(timestamp)),\n      encoding: \"base58\",\n    },\n  } as OracleFilter;\n}\n\nexport function oracleFilterPeriodFilter(filterPeriod: number): OracleFilter {\n  return {\n    memcmp: {\n      offset: 48n,\n      bytes: getBase58Decoder().decode(getU16Encoder().encode(filterPeriod)),\n      encoding: \"base58\",\n    },\n  } as OracleFilter;\n}\n\nexport function oracleDecayPeriodFilter(decayPeriod: number): OracleFilter {\n  return {\n    memcmp: {\n      offset: 50n,\n      bytes: getBase58Decoder().decode(getU16Encoder().encode(decayPeriod)),\n      encoding: \"base58\",\n    },\n  } as OracleFilter;\n}\n\nexport function oracleReductionFactorFilter(\n  reductionFactor: number,\n): OracleFilter {\n  return {\n    memcmp: {\n      offset: 52n,\n      bytes: getBase58Decoder().decode(getU16Encoder().encode(reductionFactor)),\n      encoding: \"base58\",\n    },\n  } as OracleFilter;\n}\n\nexport function oracleAdaptiveFeeControlFactorFilter(\n  adaptiveFeeControlFactor: number,\n): OracleFilter {\n  return {\n    memcmp: {\n      offset: 54n,\n      bytes: getBase58Decoder().decode(\n        getU32Encoder().encode(adaptiveFeeControlFactor),\n      ),\n      encoding: \"base58\",\n    },\n  } as OracleFilter;\n}\n\nexport function oracleMaxVolatilityFilter(maxVolatility: number): OracleFilter {\n  return {\n    memcmp: {\n      offset: 58n,\n      bytes: getBase58Decoder().decode(getU32Encoder().encode(maxVolatility)),\n      encoding: \"base58\",\n    },\n  } as OracleFilter;\n}\n\nexport function oracleTickGroupSizeFilter(tickGroupSize: number): OracleFilter {\n  return {\n    memcmp: {\n      offset: 62n,\n      bytes: getBase58Decoder().decode(getU16Encoder().encode(tickGroupSize)),\n      encoding: \"base58\",\n    },\n  } as OracleFilter;\n}\n\nexport function oracleMajorSwapThresholdTicksFilter(\n  majorSwapThresholdTicks: number,\n): OracleFilter {\n  return {\n    memcmp: {\n      offset: 64n,\n      bytes: getBase58Decoder().decode(\n        getU16Encoder().encode(majorSwapThresholdTicks),\n      ),\n      encoding: \"base58\",\n    },\n  } as OracleFilter;\n}\n\nexport async function fetchAllOracleWithFilter(\n  rpc: Rpc<GetProgramAccountsApi>,\n  ...filters: OracleFilter[]\n): Promise<Account<Oracle>[]> {\n  const discriminator = getBase58Decoder().decode(ORACLE_DISCRIMINATOR);\n  const discriminatorFilter: GetProgramAccountsMemcmpFilter = {\n    memcmp: {\n      offset: 0n,\n      bytes: discriminator,\n      encoding: \"base58\",\n    },\n  };\n  return fetchDecodedProgramAccounts(\n    rpc,\n    WHIRLPOOL_PROGRAM_ADDRESS,\n    [discriminatorFilter, ...filters],\n    getOracleDecoder(),\n  );\n}\n","import type {\n  GetProgramAccountsMemcmpFilter,\n  Account,\n  GetProgramAccountsApi,\n  Rpc,\n  Address,\n} from \"@solana/kit\";\nimport {\n  getBase58Decoder,\n  getAddressEncoder,\n  getI32Encoder,\n} from \"@solana/kit\";\nimport type { Position } from \"../generated/accounts/position\";\nimport {\n  POSITION_DISCRIMINATOR,\n  getPositionDecoder,\n} from \"../generated/accounts/position\";\nimport { fetchDecodedProgramAccounts } from \"./utils\";\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from \"../generated/programs/whirlpool\";\n\ntype PositionFilter = GetProgramAccountsMemcmpFilter & {\n  readonly __kind: unique symbol;\n};\n\nexport function positionWhirlpoolFilter(address: Address): PositionFilter {\n  return {\n    memcmp: {\n      offset: 8n,\n      bytes: getBase58Decoder().decode(getAddressEncoder().encode(address)),\n      encoding: \"base58\",\n    },\n  } as PositionFilter;\n}\n\nexport function positionMintFilter(address: Address): PositionFilter {\n  return {\n    memcmp: {\n      offset: 40n,\n      bytes: getBase58Decoder().decode(getAddressEncoder().encode(address)),\n      encoding: \"base58\",\n    },\n  } as PositionFilter;\n}\n\nexport function positionTickLowerIndexFilter(\n  tickLowerIndex: number,\n): PositionFilter {\n  return {\n    memcmp: {\n      offset: 88n,\n      bytes: getBase58Decoder().decode(getI32Encoder().encode(tickLowerIndex)),\n      encoding: \"base58\",\n    },\n  } as PositionFilter;\n}\n\nexport function positionTickUpperIndexFilter(\n  tickUpperIndex: number,\n): PositionFilter {\n  return {\n    memcmp: {\n      offset: 92n,\n      bytes: getBase58Decoder().decode(getI32Encoder().encode(tickUpperIndex)),\n      encoding: \"base58\",\n    },\n  } as PositionFilter;\n}\n\nexport async function fetchAllPositionWithFilter(\n  rpc: Rpc<GetProgramAccountsApi>,\n  ...filters: PositionFilter[]\n): Promise<Account<Position>[]> {\n  const discriminator = getBase58Decoder().decode(POSITION_DISCRIMINATOR);\n  const discriminatorFilter: GetProgramAccountsMemcmpFilter = {\n    memcmp: {\n      offset: 0n,\n      bytes: discriminator,\n      encoding: \"base58\",\n    },\n  };\n  return fetchDecodedProgramAccounts(\n    rpc,\n    WHIRLPOOL_PROGRAM_ADDRESS,\n    [discriminatorFilter, ...filters],\n    getPositionDecoder(),\n  );\n}\n","import type {\n  Account,\n  Address,\n  GetProgramAccountsApi,\n  GetProgramAccountsMemcmpFilter,\n  Rpc,\n} from \"@solana/kit\";\nimport { getAddressEncoder, getBase58Decoder } from \"@solana/kit\";\nimport type { PositionBundle } from \"../generated/accounts/positionBundle\";\nimport {\n  POSITION_BUNDLE_DISCRIMINATOR,\n  getPositionBundleDecoder,\n} from \"../generated/accounts/positionBundle\";\nimport { fetchDecodedProgramAccounts } from \"./utils\";\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from \"../generated/programs/whirlpool\";\n\nexport type PositionBundleFilter = GetProgramAccountsMemcmpFilter & {\n  readonly __kind: unique symbol;\n};\n\nexport function positionBundleMintFilter(\n  address: Address,\n): PositionBundleFilter {\n  return {\n    memcmp: {\n      offset: 8n,\n      bytes: getBase58Decoder().decode(getAddressEncoder().encode(address)),\n      encoding: \"base58\",\n    },\n  } as PositionBundleFilter;\n}\n\nexport async function fetchAllPositionBundleWithFilter(\n  rpc: Rpc<GetProgramAccountsApi>,\n  ...filters: PositionBundleFilter[]\n): Promise<Account<PositionBundle>[]> {\n  const discriminator = getBase58Decoder().decode(\n    POSITION_BUNDLE_DISCRIMINATOR,\n  );\n  const discriminatorFilter: GetProgramAccountsMemcmpFilter = {\n    memcmp: {\n      offset: 0n,\n      bytes: discriminator,\n      encoding: \"base58\",\n    },\n  };\n  return fetchDecodedProgramAccounts(\n    rpc,\n    WHIRLPOOL_PROGRAM_ADDRESS,\n    [discriminatorFilter, ...filters],\n    getPositionBundleDecoder(),\n  );\n}\n","import type {\n  Account,\n  Address,\n  GetProgramAccountsApi,\n  GetProgramAccountsMemcmpFilter,\n  Rpc,\n} from \"@solana/kit\";\nimport {\n  getAddressEncoder,\n  getBase58Decoder,\n  getI32Encoder,\n} from \"@solana/kit\";\nimport type { TickArray } from \"../generated/accounts/tickArray\";\nimport {\n  TICK_ARRAY_DISCRIMINATOR,\n  getTickArrayDecoder,\n} from \"../generated/accounts/tickArray\";\nimport { fetchDecodedProgramAccounts } from \"./utils\";\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from \"../generated/programs/whirlpool\";\n\nexport type TickArrayFilter = GetProgramAccountsMemcmpFilter & {\n  readonly __kind: unique symbol;\n};\n\nexport function tickArrayStartTickIndexFilter(\n  startTickIndex: number,\n): TickArrayFilter {\n  return {\n    memcmp: {\n      offset: 8n,\n      bytes: getBase58Decoder().decode(getI32Encoder().encode(startTickIndex)),\n      encoding: \"base58\",\n    },\n  } as TickArrayFilter;\n}\n\nexport function tickArrayWhirlpoolFilter(address: Address): TickArrayFilter {\n  return {\n    memcmp: {\n      offset: 9956n,\n      bytes: getBase58Decoder().decode(getAddressEncoder().encode(address)),\n      encoding: \"base58\",\n    },\n  } as TickArrayFilter;\n}\n\nexport async function fetchAllTickArrayWithFilter(\n  rpc: Rpc<GetProgramAccountsApi>,\n  ...filters: TickArrayFilter[]\n): Promise<Account<TickArray>[]> {\n  const discriminator = getBase58Decoder().decode(TICK_ARRAY_DISCRIMINATOR);\n  const discriminatorFilter: GetProgramAccountsMemcmpFilter = {\n    memcmp: {\n      offset: 0n,\n      bytes: discriminator,\n      encoding: \"base58\",\n    },\n  };\n  return fetchDecodedProgramAccounts(\n    rpc,\n    WHIRLPOOL_PROGRAM_ADDRESS,\n    [discriminatorFilter, ...filters],\n    getTickArrayDecoder(),\n  );\n}\n","import type {\n  GetProgramAccountsMemcmpFilter,\n  Address,\n  Account,\n  GetProgramAccountsApi,\n  Rpc,\n} from \"@solana/kit\";\nimport { getBase58Decoder, getAddressEncoder } from \"@solana/kit\";\nimport type { TokenBadge } from \"../generated/accounts/tokenBadge\";\nimport {\n  TOKEN_BADGE_DISCRIMINATOR,\n  getTokenBadgeDecoder,\n} from \"../generated/accounts/tokenBadge\";\nimport { fetchDecodedProgramAccounts } from \"./utils\";\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from \"../generated/programs/whirlpool\";\n\nexport type TokenBadgeFilter = GetProgramAccountsMemcmpFilter & {\n  readonly __kind: unique symbol;\n};\n\nexport function tokenBadgeWhirlpoolsConfigFilter(\n  address: Address,\n): TokenBadgeFilter {\n  return {\n    memcmp: {\n      offset: 8n,\n      bytes: getBase58Decoder().decode(getAddressEncoder().encode(address)),\n      encoding: \"base58\",\n    },\n  } as TokenBadgeFilter;\n}\n\nexport function tokenBadgeTokenMintFilter(address: Address): TokenBadgeFilter {\n  return {\n    memcmp: {\n      offset: 40n,\n      bytes: getBase58Decoder().decode(getAddressEncoder().encode(address)),\n      encoding: \"base58\",\n    },\n  } as TokenBadgeFilter;\n}\n\nexport async function fetchAllTokenBadgeWithFilter(\n  rpc: Rpc<GetProgramAccountsApi>,\n  ...filters: TokenBadgeFilter[]\n): Promise<Account<TokenBadge>[]> {\n  const discriminator = getBase58Decoder().decode(TOKEN_BADGE_DISCRIMINATOR);\n  const discriminatorFilter: GetProgramAccountsMemcmpFilter = {\n    memcmp: {\n      offset: 0n,\n      bytes: discriminator,\n      encoding: \"base58\",\n    },\n  };\n  return fetchDecodedProgramAccounts(\n    rpc,\n    WHIRLPOOL_PROGRAM_ADDRESS,\n    [discriminatorFilter, ...filters],\n    getTokenBadgeDecoder(),\n  );\n}\n","import type {\n  Account,\n  Address,\n  GetProgramAccountsApi,\n  GetProgramAccountsMemcmpFilter,\n  Rpc,\n} from \"@solana/kit\";\nimport {\n  getAddressEncoder,\n  getBase58Decoder,\n  getU16Encoder,\n} from \"@solana/kit\";\nimport type { Whirlpool } from \"../generated/accounts/whirlpool\";\nimport {\n  WHIRLPOOL_DISCRIMINATOR,\n  getWhirlpoolDecoder,\n} from \"../generated/accounts/whirlpool\";\nimport { fetchDecodedProgramAccounts } from \"./utils\";\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from \"../generated/programs/whirlpool\";\n\nexport type WhirlpoolFilter = GetProgramAccountsMemcmpFilter & {\n  readonly __kind: unique symbol;\n};\n\nexport function whirlpoolWhirlpoolConfigFilter(\n  address: Address,\n): WhirlpoolFilter {\n  return {\n    memcmp: {\n      offset: 8n,\n      bytes: getBase58Decoder().decode(getAddressEncoder().encode(address)),\n      encoding: \"base58\",\n    },\n  } as WhirlpoolFilter;\n}\n\nexport function whirlpoolTickSpacingFilter(\n  tickSpacing: number,\n): WhirlpoolFilter {\n  return {\n    memcmp: {\n      offset: 41n,\n      bytes: getBase58Decoder().decode(getU16Encoder().encode(tickSpacing)),\n      encoding: \"base58\",\n    },\n  } as WhirlpoolFilter;\n}\n\nexport function whirlpoolFeeRateFilter(\n  defaultFeeRate: number,\n): WhirlpoolFilter {\n  return {\n    memcmp: {\n      offset: 45n,\n      bytes: getBase58Decoder().decode(getU16Encoder().encode(defaultFeeRate)),\n      encoding: \"base58\",\n    },\n  } as WhirlpoolFilter;\n}\n\nexport function whirlpoolProtocolFeeRateFilter(\n  protocolFeeRate: number,\n): WhirlpoolFilter {\n  return {\n    memcmp: {\n      offset: 47n,\n      bytes: getBase58Decoder().decode(getU16Encoder().encode(protocolFeeRate)),\n      encoding: \"base58\",\n    },\n  } as WhirlpoolFilter;\n}\n\nexport function whirlpoolTokenMintAFilter(\n  tokenMintA: Address,\n): WhirlpoolFilter {\n  return {\n    memcmp: {\n      offset: 101n,\n      bytes: getBase58Decoder().decode(getAddressEncoder().encode(tokenMintA)),\n      encoding: \"base58\",\n    },\n  } as WhirlpoolFilter;\n}\n\nexport function whirlpoolTokenVaultAFilter(\n  tokenVaultA: Address,\n): WhirlpoolFilter {\n  return {\n    memcmp: {\n      offset: 133n,\n      bytes: getBase58Decoder().decode(getAddressEncoder().encode(tokenVaultA)),\n      encoding: \"base58\",\n    },\n  } as WhirlpoolFilter;\n}\n\nexport function whirlpoolTokenMintBFilter(\n  tokenMintB: Address,\n): WhirlpoolFilter {\n  return {\n    memcmp: {\n      offset: 181n,\n      bytes: getBase58Decoder().decode(getAddressEncoder().encode(tokenMintB)),\n      encoding: \"base58\",\n    },\n  } as WhirlpoolFilter;\n}\n\nexport function whirlpoolTokenVaultBFilter(\n  tokenVaultB: Address,\n): WhirlpoolFilter {\n  return {\n    memcmp: {\n      offset: 213n,\n      bytes: getBase58Decoder().decode(getAddressEncoder().encode(tokenVaultB)),\n      encoding: \"base58\",\n    },\n  } as WhirlpoolFilter;\n}\n\nexport function whirlpoolRewardMint1Filter(\n  rewardMint1: Address,\n): WhirlpoolFilter {\n  return {\n    memcmp: {\n      offset: 269n,\n      bytes: getBase58Decoder().decode(getAddressEncoder().encode(rewardMint1)),\n      encoding: \"base58\",\n    },\n  } as WhirlpoolFilter;\n}\n\nexport function whirlpoolRewardVault1Filter(\n  rewardVault1: Address,\n): WhirlpoolFilter {\n  return {\n    memcmp: {\n      offset: 301n,\n      bytes: getBase58Decoder().decode(\n        getAddressEncoder().encode(rewardVault1),\n      ),\n      encoding: \"base58\",\n    },\n  } as WhirlpoolFilter;\n}\n\nexport function whirlpoolRewardMint2Filter(\n  rewardMint2: Address,\n): WhirlpoolFilter {\n  return {\n    memcmp: {\n      offset: 397n,\n      bytes: getBase58Decoder().decode(getAddressEncoder().encode(rewardMint2)),\n      encoding: \"base58\",\n    },\n  } as WhirlpoolFilter;\n}\n\nexport function whirlpoolRewardVault2Filter(\n  rewardVault2: Address,\n): WhirlpoolFilter {\n  return {\n    memcmp: {\n      offset: 429n,\n      bytes: getBase58Decoder().decode(\n        getAddressEncoder().encode(rewardVault2),\n      ),\n      encoding: \"base58\",\n    },\n  } as WhirlpoolFilter;\n}\n\nexport function whirlpoolRewardMint3Filter(\n  rewardMint3: Address,\n): WhirlpoolFilter {\n  return {\n    memcmp: {\n      offset: 525n,\n      bytes: getBase58Decoder().decode(getAddressEncoder().encode(rewardMint3)),\n      encoding: \"base58\",\n    },\n  } as WhirlpoolFilter;\n}\n\nexport function whirlpoolRewardVault3Filter(\n  rewardVault3: Address,\n): WhirlpoolFilter {\n  return {\n    memcmp: {\n      offset: 557n,\n      bytes: getBase58Decoder().decode(\n        getAddressEncoder().encode(rewardVault3),\n      ),\n      encoding: \"base58\",\n    },\n  } as WhirlpoolFilter;\n}\n\n/**\n * Fetches all Whirlpool accounts with the specified filters.\n *\n * This function fetches all Whirlpool accounts from the blockchain that match the specified filters.\n * It uses the Whirlpool discriminator to identify Whirlpool accounts and applies additional filters\n * provided as arguments.\n *\n * @param {Rpc<GetProgramAccountsApi>} rpc - The Solana RPC client to fetch program accounts.\n * @param {...WhirlpoolFilter[]} filters - The filters to apply when fetching Whirlpool accounts.\n * @returns {Promise<Account<Whirlpool>[]>} A promise that resolves to an array of Whirlpool accounts.\n *\n * @example\n * import { address, createSolanaRpc, devnet } from \"@solana/kit\";\n * import { fetchAllWhirlpoolWithFilter, whirlpoolWhirlpoolConfigFilter } from \"@orca-so/whirlpools-client\";\n *\n * const rpcDevnet = createSolanaRpc(devnet(\"https://api.devnet.solana.com\"));\n * const WHIRLPOOLS_CONFIG_ADDRESS_DEVNET = address(\"FcrweFY1G9HJAHG5inkGB6pKg1HZ6x9UC2WioAfWrGkR\");\n * const whirlpools = await fetchAllWhirlpoolWithFilter(rpcDevnet, whirlpoolWhirlpoolConfigFilter(WHIRLPOOLS_CONFIG_ADDRESS_DEVNET));\n */\nexport async function fetchAllWhirlpoolWithFilter(\n  rpc: Rpc<GetProgramAccountsApi>,\n  ...filters: WhirlpoolFilter[]\n): Promise<Account<Whirlpool>[]> {\n  const discriminator = getBase58Decoder().decode(WHIRLPOOL_DISCRIMINATOR);\n  const discriminatorFilter: GetProgramAccountsMemcmpFilter = {\n    memcmp: {\n      offset: 0n,\n      bytes: discriminator,\n      encoding: \"base58\",\n    },\n  };\n  return fetchDecodedProgramAccounts(\n    rpc,\n    WHIRLPOOL_PROGRAM_ADDRESS,\n    [discriminatorFilter, ...filters],\n    getWhirlpoolDecoder(),\n  );\n}\n","import type {\n  GetProgramAccountsMemcmpFilter,\n  Address,\n  Account,\n  GetProgramAccountsApi,\n  Rpc,\n} from \"@solana/kit\";\nimport {\n  getBase58Decoder,\n  getAddressEncoder,\n  getU16Encoder,\n} from \"@solana/kit\";\nimport type { WhirlpoolsConfig } from \"../generated/accounts/whirlpoolsConfig\";\nimport {\n  WHIRLPOOLS_CONFIG_DISCRIMINATOR,\n  getWhirlpoolsConfigDecoder,\n} from \"../generated/accounts/whirlpoolsConfig\";\nimport { fetchDecodedProgramAccounts } from \"./utils\";\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from \"../generated/programs/whirlpool\";\n\nexport type WhirlpoolsConfigFilter = GetProgramAccountsMemcmpFilter & {\n  readonly __kind: unique symbol;\n};\n\nexport function whirlpoolsConfigFeeAuthorityFilter(\n  feeAuthority: Address,\n): WhirlpoolsConfigFilter {\n  return {\n    memcmp: {\n      offset: 8n,\n      bytes: getBase58Decoder().decode(\n        getAddressEncoder().encode(feeAuthority),\n      ),\n      encoding: \"base58\",\n    },\n  } as WhirlpoolsConfigFilter;\n}\n\nexport function whirlpoolsConfigCollectProtocolFeesAuthorityFilter(\n  collectProtocolFeesAuthority: Address,\n): WhirlpoolsConfigFilter {\n  return {\n    memcmp: {\n      offset: 40n,\n      bytes: getBase58Decoder().decode(\n        getAddressEncoder().encode(collectProtocolFeesAuthority),\n      ),\n      encoding: \"base58\",\n    },\n  } as WhirlpoolsConfigFilter;\n}\n\nexport function whirlpoolsConfigRewardEmissionsSuperAuthorityFilter(\n  rewardEmissionsSuperAuthority: Address,\n): WhirlpoolsConfigFilter {\n  return {\n    memcmp: {\n      offset: 72n,\n      bytes: getBase58Decoder().decode(\n        getAddressEncoder().encode(rewardEmissionsSuperAuthority),\n      ),\n      encoding: \"base58\",\n    },\n  } as WhirlpoolsConfigFilter;\n}\n\nexport function whirlpoolsConfigDefaultProtocolFeeRateFilter(\n  defaultFeeRate: number,\n): WhirlpoolsConfigFilter {\n  return {\n    memcmp: {\n      offset: 104n,\n      bytes: getBase58Decoder().decode(getU16Encoder().encode(defaultFeeRate)),\n      encoding: \"base58\",\n    },\n  } as WhirlpoolsConfigFilter;\n}\n\nexport async function fetchAllWhirlpoolsConfigWithFilter(\n  rpc: Rpc<GetProgramAccountsApi>,\n  ...filters: WhirlpoolsConfigFilter[]\n): Promise<Account<WhirlpoolsConfig>[]> {\n  const discriminator = getBase58Decoder().decode(\n    WHIRLPOOLS_CONFIG_DISCRIMINATOR,\n  );\n  const discriminatorFilter: GetProgramAccountsMemcmpFilter = {\n    memcmp: {\n      offset: 0n,\n      bytes: discriminator,\n      encoding: \"base58\",\n    },\n  };\n  return fetchDecodedProgramAccounts(\n    rpc,\n    WHIRLPOOL_PROGRAM_ADDRESS,\n    [discriminatorFilter, ...filters],\n    getWhirlpoolsConfigDecoder(),\n  );\n}\n","import type {\n  GetProgramAccountsMemcmpFilter,\n  Address,\n  Account,\n  GetProgramAccountsApi,\n  Rpc,\n} from \"@solana/kit\";\nimport { getBase58Decoder, getAddressEncoder } from \"@solana/kit\";\nimport type { WhirlpoolsConfigExtension } from \"../generated/accounts/whirlpoolsConfigExtension\";\nimport {\n  WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR,\n  getWhirlpoolsConfigExtensionDecoder,\n} from \"../generated/accounts/whirlpoolsConfigExtension\";\nimport { fetchDecodedProgramAccounts } from \"./utils\";\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from \"../generated/programs/whirlpool\";\n\nexport type WhirlpoolsConfigExtensionFilter = GetProgramAccountsMemcmpFilter & {\n  readonly __kind: unique symbol;\n};\n\nexport function whirlpoolsConfigExtensionWhirlpoolsConfigFilter(\n  address: Address,\n): WhirlpoolsConfigExtensionFilter {\n  return {\n    memcmp: {\n      offset: 8n,\n      bytes: getBase58Decoder().decode(getAddressEncoder().encode(address)),\n      encoding: \"base58\",\n    },\n  } as WhirlpoolsConfigExtensionFilter;\n}\n\nexport function whirlpoolsConfigExtensionConfigExtensionAuthorityFilter(\n  configExtensionAuthority: Address,\n): WhirlpoolsConfigExtensionFilter {\n  return {\n    memcmp: {\n      offset: 40n,\n      bytes: getBase58Decoder().decode(\n        getAddressEncoder().encode(configExtensionAuthority),\n      ),\n      encoding: \"base58\",\n    },\n  } as WhirlpoolsConfigExtensionFilter;\n}\n\nexport function whirlpoolsConfigExtensionConfigTokenBadgeAuthorityFilter(\n  configTokenBadgeAuthority: Address,\n): WhirlpoolsConfigExtensionFilter {\n  return {\n    memcmp: {\n      offset: 72n,\n      bytes: getBase58Decoder().decode(\n        getAddressEncoder().encode(configTokenBadgeAuthority),\n      ),\n      encoding: \"base58\",\n    },\n  } as WhirlpoolsConfigExtensionFilter;\n}\n\nexport async function fetchAllWhirlpoolsConfigExtensionWithFilter(\n  rpc: Rpc<GetProgramAccountsApi>,\n  ...filters: WhirlpoolsConfigExtensionFilter[]\n): Promise<Account<WhirlpoolsConfigExtension>[]> {\n  const discriminator = getBase58Decoder().decode(\n    WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR,\n  );\n  const discriminatorFilter: GetProgramAccountsMemcmpFilter = {\n    memcmp: {\n      offset: 0n,\n      bytes: discriminator,\n      encoding: \"base58\",\n    },\n  };\n  return fetchDecodedProgramAccounts(\n    rpc,\n    WHIRLPOOL_PROGRAM_ADDRESS,\n    [discriminatorFilter, ...filters],\n    getWhirlpoolsConfigExtensionDecoder(),\n  );\n}\n","import type { Address, ProgramDerivedAddress } from \"@solana/kit\";\nimport {\n  getAddressEncoder,\n  getProgramDerivedAddress,\n  getU16Encoder,\n} from \"@solana/kit\";\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from \"../generated/programs/whirlpool\";\n\nexport async function getFeeTierAddress(\n  whirlpoolsConfig: Address,\n  feeTierIndex: number,\n): Promise<ProgramDerivedAddress> {\n  return await getProgramDerivedAddress({\n    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,\n    seeds: [\n      \"fee_tier\",\n      getAddressEncoder().encode(whirlpoolsConfig),\n      getU16Encoder().encode(feeTierIndex),\n    ],\n  });\n}\n","import type { Address, ProgramDerivedAddress } from \"@solana/kit\";\nimport { getAddressEncoder, getProgramDerivedAddress } from \"@solana/kit\";\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from \"../generated/programs/whirlpool\";\n\nexport async function getOracleAddress(\n  whirlpool: Address,\n): Promise<ProgramDerivedAddress> {\n  return await getProgramDerivedAddress({\n    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,\n    seeds: [\"oracle\", getAddressEncoder().encode(whirlpool)],\n  });\n}\n","import type { Address, ProgramDerivedAddress } from \"@solana/kit\";\nimport { getAddressEncoder, getProgramDerivedAddress } from \"@solana/kit\";\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from \"../generated/programs/whirlpool\";\n\nexport async function getPositionAddress(\n  positionMint: Address,\n): Promise<ProgramDerivedAddress> {\n  return await getProgramDerivedAddress({\n    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,\n    seeds: [\"position\", getAddressEncoder().encode(positionMint)],\n  });\n}\n","import type { Address, ProgramDerivedAddress } from \"@solana/kit\";\nimport { getAddressEncoder, getProgramDerivedAddress } from \"@solana/kit\";\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from \"../generated/programs/whirlpool\";\n\nexport async function getPositionBundleAddress(\n  positionBundleMint: Address,\n): Promise<ProgramDerivedAddress> {\n  return await getProgramDerivedAddress({\n    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,\n    seeds: [\"position_bundle\", getAddressEncoder().encode(positionBundleMint)],\n  });\n}\n\nexport async function getBundledPositionAddress(\n  positionBundleAddress: Address,\n  bundleIndex: number,\n): Promise<ProgramDerivedAddress> {\n  return await getProgramDerivedAddress({\n    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,\n    seeds: [\n      \"bundled_position\",\n      getAddressEncoder().encode(positionBundleAddress),\n      Buffer.from(bundleIndex.toString()),\n    ],\n  });\n}\n","import type { Address, ProgramDerivedAddress } from \"@solana/kit\";\nimport { getAddressEncoder, getProgramDerivedAddress } from \"@solana/kit\";\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from \"../generated/programs/whirlpool\";\n\nexport async function getTickArrayAddress(\n  whirlpool: Address,\n  startTickIndex: number,\n): Promise<ProgramDerivedAddress> {\n  return await getProgramDerivedAddress({\n    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,\n    seeds: [\n      \"tick_array\",\n      getAddressEncoder().encode(whirlpool),\n      `${startTickIndex}`,\n    ],\n  });\n}\n","import type { Address, ProgramDerivedAddress } from \"@solana/kit\";\nimport { getAddressEncoder, getProgramDerivedAddress } from \"@solana/kit\";\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from \"../generated/programs/whirlpool\";\n\nexport async function getTokenBadgeAddress(\n  whirlpoolsConfig: Address,\n  tokenMint: Address,\n): Promise<ProgramDerivedAddress> {\n  return await getProgramDerivedAddress({\n    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,\n    seeds: [\n      \"token_badge\",\n      getAddressEncoder().encode(whirlpoolsConfig),\n      getAddressEncoder().encode(tokenMint),\n    ],\n  });\n}\n","import type { Address, ProgramDerivedAddress } from \"@solana/kit\";\nimport {\n  getAddressEncoder,\n  getProgramDerivedAddress,\n  getU16Encoder,\n} from \"@solana/kit\";\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from \"../generated/programs/whirlpool\";\n\nexport async function getWhirlpoolAddress(\n  whirlpoolsConfig: Address,\n  tokenMintA: Address,\n  tokenMintB: Address,\n  feeTierIndex: number,\n): Promise<ProgramDerivedAddress> {\n  return await getProgramDerivedAddress({\n    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,\n    seeds: [\n      \"whirlpool\",\n      getAddressEncoder().encode(whirlpoolsConfig),\n      getAddressEncoder().encode(tokenMintA),\n      getAddressEncoder().encode(tokenMintB),\n      getU16Encoder().encode(feeTierIndex),\n    ],\n  });\n}\n","import type { Address, ProgramDerivedAddress } from \"@solana/kit\";\nimport { getAddressEncoder, getProgramDerivedAddress } from \"@solana/kit\";\nimport { WHIRLPOOL_PROGRAM_ADDRESS } from \"../generated/programs/whirlpool\";\n\nexport async function getWhirlpoolsConfigExtensionAddress(\n  configAddress: Address,\n): Promise<ProgramDerivedAddress> {\n  return await getProgramDerivedAddress({\n    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,\n    seeds: [\"config_extension\", getAddressEncoder().encode(configAddress)],\n  });\n}\n"],"mappings":"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","names":["assertAccountExists","assertAccountsExist","combineCodec","decodeAccount","fetchEncodedAccount","fetchEncodedAccounts","fixDecoderSize","fixEncoderSize","getAddressDecoder","getAddressEncoder","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU16Decoder","getU16Encoder","transformEncoder","assertAccountExists","assertAccountsExist","combineCodec","decodeAccount","fetchEncodedAccount","fetchEncodedAccounts","fixDecoderSize","fixEncoderSize","getAddressDecoder","getAddressEncoder","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU64Decoder","getU64Encoder","transformEncoder","combineCodec","AccountsType","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU16Decoder","getU16Encoder","getU32Decoder","getU32Encoder","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU32Decoder","getU32Encoder","combineCodec","getEnumDecoder","getEnumEncoder","LockType","combineCodec","getEnumDecoder","getEnumEncoder","LockTypeLabel","combineCodec","getStructDecoder","getStructEncoder","getU64Decoder","getU64Encoder","combineCodec","getStructDecoder","getStructEncoder","getStructEncoder","getStructDecoder","combineCodec","combineCodec","getStructDecoder","getStructEncoder","getStructEncoder","getStructDecoder","combineCodec","combineCodec","getArrayDecoder","getArrayEncoder","getStructDecoder","getStructEncoder","getU128Decoder","getU128Encoder","combineCodec","getAddressDecoder","getAddressEncoder","getStructDecoder","getStructEncoder","getU128Decoder","getU128Encoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getAddressEncoder","getU64Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getAddressDecoder","getU64Decoder","combineCodec","decodeAccount","assertAccountExists","fetchEncodedAccount","assertAccountsExist","fetchEncodedAccounts","assertAccountExists","assertAccountsExist","combineCodec","decodeAccount","fetchEncodedAccount","fetchEncodedAccounts","fixDecoderSize","fixEncoderSize","getAddressDecoder","getAddressEncoder","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU64Decoder","getU64Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getAddressEncoder","getU64Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getAddressDecoder","getU64Decoder","combineCodec","decodeAccount","assertAccountExists","fetchEncodedAccount","assertAccountsExist","fetchEncodedAccounts","assertAccountExists","assertAccountsExist","combineCodec","decodeAccount","fetchEncodedAccount","fetchEncodedAccounts","fixDecoderSize","fixEncoderSize","getAddressDecoder","getAddressEncoder","getArrayDecoder","getArrayEncoder","getBytesDecoder","getBytesEncoder","getI32Decoder","getI32Encoder","getStructDecoder","getStructEncoder","getU128Decoder","getU128Encoder","getU64Decoder","getU64Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getAddressEncoder","getU128Encoder","getI32Encoder","getU64Encoder","getArrayEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getAddressDecoder","getU128Decoder","getI32Decoder","getU64Decoder","getArrayDecoder","combineCodec","decodeAccount","assertAccountExists","fetchEncodedAccount","assertAccountsExist","fetchEncodedAccounts","assertAccountExists","assertAccountsExist","combineCodec","decodeAccount","fetchEncodedAccount","fetchEncodedAccounts","fixDecoderSize","fixEncoderSize","getAddressDecoder","getAddressEncoder","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","transformEncoder","assertAccountExists","assertAccountsExist","combineCodec","decodeAccount","fetchEncodedAccount","fetchEncodedAccounts","fixDecoderSize","fixEncoderSize","getAddressDecoder","getAddressEncoder","getArrayDecoder","getArrayEncoder","getBytesDecoder","getBytesEncoder","getI32Decoder","getI32Encoder","getStructDecoder","getStructEncoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getI32Encoder","getArrayEncoder","getAddressEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getI32Decoder","getArrayDecoder","getAddressDecoder","combineCodec","decodeAccount","assertAccountExists","fetchEncodedAccount","assertAccountsExist","fetchEncodedAccounts","assertAccountExists","assertAccountsExist","combineCodec","decodeAccount","fetchEncodedAccount","fetchEncodedAccounts","fixDecoderSize","fixEncoderSize","getAddressDecoder","getAddressEncoder","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","transformEncoder","assertAccountExists","assertAccountsExist","combineCodec","decodeAccount","fetchEncodedAccount","fetchEncodedAccounts","fixDecoderSize","fixEncoderSize","getAddressDecoder","getAddressEncoder","getArrayDecoder","getArrayEncoder","getBytesDecoder","getBytesEncoder","getI32Decoder","getI32Encoder","getStructDecoder","getStructEncoder","getU128Decoder","getU128Encoder","getU16Decoder","getU16Encoder","getU64Decoder","getU64Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getAddressEncoder","getU16Encoder","getU128Encoder","getI32Encoder","getU64Encoder","getArrayEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getAddressDecoder","getU16Decoder","getU128Decoder","getI32Decoder","getU64Decoder","getArrayDecoder","combineCodec","decodeAccount","assertAccountExists","fetchEncodedAccount","assertAccountsExist","fetchEncodedAccounts","assertAccountExists","assertAccountsExist","combineCodec","decodeAccount","fetchEncodedAccount","fetchEncodedAccounts","fixDecoderSize","fixEncoderSize","getAddressDecoder","getAddressEncoder","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU16Decoder","getU16Encoder","transformEncoder","assertAccountExists","assertAccountsExist","combineCodec","decodeAccount","fetchEncodedAccount","fetchEncodedAccounts","fixDecoderSize","fixEncoderSize","getAddressDecoder","getAddressEncoder","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","transformEncoder","fixEncoderSize","getBytesEncoder","WhirlpoolAccount","WhirlpoolInstruction","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU16Decoder","getU16Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU16Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU16Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getOptionDecoder","getOptionEncoder","getStructDecoder","getStructEncoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getOptionEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getOptionDecoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU8Decoder","getU8Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU8Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU8Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getOptionDecoder","getOptionEncoder","getStructDecoder","getStructEncoder","getU8Decoder","getU8Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU8Encoder","getOptionEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU8Decoder","getOptionDecoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU128Decoder","getU128Encoder","getU64Decoder","getU64Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU128Encoder","getU64Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU128Decoder","getU64Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getOptionDecoder","getOptionEncoder","getStructDecoder","getStructEncoder","getU128Decoder","getU128Encoder","getU64Decoder","getU64Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU128Encoder","getU64Encoder","getOptionEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU128Decoder","getU64Decoder","getOptionDecoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU128Decoder","getU128Encoder","getU64Decoder","getU64Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU128Encoder","getU64Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU128Decoder","getU64Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getOptionDecoder","getOptionEncoder","getStructDecoder","getStructEncoder","getU128Decoder","getU128Encoder","getU64Decoder","getU64Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU128Encoder","getU64Encoder","getOptionEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU128Decoder","getU64Decoder","getOptionDecoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getAddressDecoder","getAddressEncoder","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU16Decoder","getU16Encoder","getU32Decoder","getU32Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU16Encoder","getAddressEncoder","getU32Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU16Decoder","getAddressDecoder","getU32Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getAddressDecoder","getAddressEncoder","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU16Decoder","getU16Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getAddressEncoder","getU16Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getAddressDecoder","getU16Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU16Decoder","getU16Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU16Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU16Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU128Decoder","getU128Encoder","getU16Decoder","getU16Encoder","getU8Decoder","getU8Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU8Encoder","getU16Encoder","getU128Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU8Decoder","getU16Decoder","getU128Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU128Decoder","getU128Encoder","getU16Decoder","getU16Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU16Encoder","getU128Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU16Decoder","getU128Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getOptionDecoder","getOptionEncoder","getStructDecoder","getStructEncoder","getU128Decoder","getU128Encoder","getU64Decoder","getU64Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU128Encoder","getOptionEncoder","getU64Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU128Decoder","getOptionDecoder","getU64Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU8Decoder","getU8Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU8Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU8Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU8Decoder","getU8Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU8Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU8Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getI32Decoder","getI32Encoder","getStructDecoder","getStructEncoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getI32Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getI32Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getI32Decoder","getI32Encoder","getStructDecoder","getStructEncoder","getU16Decoder","getU16Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU16Encoder","getI32Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU16Decoder","getI32Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getI32Decoder","getI32Encoder","getStructDecoder","getStructEncoder","getU8Decoder","getU8Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU8Encoder","getI32Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU8Decoder","getI32Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getI32Decoder","getI32Encoder","getStructDecoder","getStructEncoder","getU8Decoder","getU8Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU8Encoder","getI32Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU8Decoder","getI32Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBooleanDecoder","getBooleanEncoder","getBytesDecoder","getBytesEncoder","getI32Decoder","getI32Encoder","getStructDecoder","getStructEncoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getI32Encoder","getBooleanEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getI32Decoder","getBooleanDecoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getI32Decoder","getI32Encoder","getStructDecoder","getStructEncoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getI32Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getI32Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU16Decoder","getU16Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU16Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU16Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU16Decoder","getU16Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU16Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU16Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU16Decoder","getU16Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU16Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU16Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU16Decoder","getU16Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU16Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU16Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU16Decoder","getU16Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU16Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU16Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU16Decoder","getU16Encoder","getU32Decoder","getU32Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU16Encoder","getU32Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU16Decoder","getU32Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU16Decoder","getU16Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU16Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU16Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU8Decoder","getU8Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU8Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU8Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU8Decoder","getU8Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU8Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU8Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU128Decoder","getU128Encoder","getU8Decoder","getU8Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU8Encoder","getU128Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU8Decoder","getU128Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU128Decoder","getU128Encoder","getU8Decoder","getU8Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU8Encoder","getU128Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU8Decoder","getU128Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBooleanDecoder","getBooleanEncoder","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU128Decoder","getU128Encoder","getU64Decoder","getU64Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU64Encoder","getU128Encoder","getBooleanEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU64Decoder","getU128Decoder","getBooleanDecoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBooleanDecoder","getBooleanEncoder","getBytesDecoder","getBytesEncoder","getOptionDecoder","getOptionEncoder","getStructDecoder","getStructEncoder","getU128Decoder","getU128Encoder","getU64Decoder","getU64Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU64Encoder","getU128Encoder","getBooleanEncoder","getOptionEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU64Decoder","getU128Decoder","getBooleanDecoder","getOptionDecoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBooleanDecoder","getBooleanEncoder","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","getU128Decoder","getU128Encoder","getU64Decoder","getU64Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU64Encoder","getBooleanEncoder","getU128Encoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU64Decoder","getBooleanDecoder","getU128Decoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBooleanDecoder","getBooleanEncoder","getBytesDecoder","getBytesEncoder","getOptionDecoder","getOptionEncoder","getStructDecoder","getStructEncoder","getU128Decoder","getU128Encoder","getU64Decoder","getU64Encoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getU64Encoder","getBooleanEncoder","getU128Encoder","getOptionEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","getU64Decoder","getBooleanDecoder","getU128Decoder","getOptionDecoder","combineCodec","combineCodec","fixDecoderSize","fixEncoderSize","getBytesDecoder","getBytesEncoder","getStructDecoder","getStructEncoder","transformEncoder","fixEncoderSize","getBytesEncoder","transformEncoder","getStructEncoder","getStructDecoder","fixDecoderSize","getBytesDecoder","combineCodec","getAddressEncoder","getU16Encoder","getU32Encoder","getAddressEncoder","getU16Encoder","getU32Encoder","getAddressEncoder","getBase58Decoder","getU16Encoder","getBase58Decoder","getAddressEncoder","getU16Encoder","getAddressEncoder","getBase58Decoder","getU16Encoder","getU32Encoder","getU64Encoder","getBase58Decoder","getAddressEncoder","getU64Encoder","getU16Encoder","getU32Encoder","getBase58Decoder","getAddressEncoder","getI32Encoder","getBase58Decoder","getAddressEncoder","getI32Encoder","getAddressEncoder","getBase58Decoder","getBase58Decoder","getAddressEncoder","getAddressEncoder","getBase58Decoder","getI32Encoder","getBase58Decoder","getI32Encoder","getAddressEncoder","getBase58Decoder","getAddressEncoder","getBase58Decoder","getAddressEncoder","getAddressEncoder","getBase58Decoder","getU16Encoder","getBase58Decoder","getAddressEncoder","getU16Encoder","getBase58Decoder","getAddressEncoder","getU16Encoder","getBase58Decoder","getAddressEncoder","getU16Encoder","getBase58Decoder","getAddressEncoder","getBase58Decoder","getAddressEncoder","getAddressEncoder","getU16Encoder","getAddressEncoder","getU16Encoder","getAddressEncoder","getProgramDerivedAddress","getProgramDerivedAddress","getAddressEncoder","getAddressEncoder","getProgramDerivedAddress","getProgramDerivedAddress","getAddressEncoder","getAddressEncoder","getProgramDerivedAddress","getProgramDerivedAddress","getAddressEncoder","getAddressEncoder","getProgramDerivedAddress","getProgramDerivedAddress","getAddressEncoder","getAddressEncoder","getProgramDerivedAddress","getProgramDerivedAddress","getAddressEncoder","getAddressEncoder","getProgramDerivedAddress","getU16Encoder","getProgramDerivedAddress","getAddressEncoder","getU16Encoder","getAddressEncoder","getProgramDerivedAddress","getProgramDerivedAddress","getAddressEncoder"]}
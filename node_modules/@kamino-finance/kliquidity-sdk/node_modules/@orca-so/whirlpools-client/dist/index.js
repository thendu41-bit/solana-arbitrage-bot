// src/generated/accounts/adaptiveFeeTier.ts
import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU16Decoder,
  getU16Encoder,
  getU32Decoder,
  getU32Encoder,
  transformEncoder
} from "@solana/kit";
var ADAPTIVE_FEE_TIER_DISCRIMINATOR = new Uint8Array([
  147,
  16,
  144,
  116,
  47,
  146,
  149,
  46
]);
function getAdaptiveFeeTierDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    ADAPTIVE_FEE_TIER_DISCRIMINATOR
  );
}
function getAdaptiveFeeTierEncoder() {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
      ["whirlpoolsConfig", getAddressEncoder()],
      ["feeTierIndex", getU16Encoder()],
      ["tickSpacing", getU16Encoder()],
      ["initializePoolAuthority", getAddressEncoder()],
      ["delegatedFeeAuthority", getAddressEncoder()],
      ["defaultBaseFeeRate", getU16Encoder()],
      ["filterPeriod", getU16Encoder()],
      ["decayPeriod", getU16Encoder()],
      ["reductionFactor", getU16Encoder()],
      ["adaptiveFeeControlFactor", getU32Encoder()],
      ["maxVolatilityAccumulator", getU32Encoder()],
      ["tickGroupSize", getU16Encoder()],
      ["majorSwapThresholdTicks", getU16Encoder()]
    ]),
    (value) => ({ ...value, discriminator: ADAPTIVE_FEE_TIER_DISCRIMINATOR })
  );
}
function getAdaptiveFeeTierDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["whirlpoolsConfig", getAddressDecoder()],
    ["feeTierIndex", getU16Decoder()],
    ["tickSpacing", getU16Decoder()],
    ["initializePoolAuthority", getAddressDecoder()],
    ["delegatedFeeAuthority", getAddressDecoder()],
    ["defaultBaseFeeRate", getU16Decoder()],
    ["filterPeriod", getU16Decoder()],
    ["decayPeriod", getU16Decoder()],
    ["reductionFactor", getU16Decoder()],
    ["adaptiveFeeControlFactor", getU32Decoder()],
    ["maxVolatilityAccumulator", getU32Decoder()],
    ["tickGroupSize", getU16Decoder()],
    ["majorSwapThresholdTicks", getU16Decoder()]
  ]);
}
function getAdaptiveFeeTierCodec() {
  return combineCodec(getAdaptiveFeeTierEncoder(), getAdaptiveFeeTierDecoder());
}
function decodeAdaptiveFeeTier(encodedAccount) {
  return decodeAccount(
    encodedAccount,
    getAdaptiveFeeTierDecoder()
  );
}
async function fetchAdaptiveFeeTier(rpc, address, config) {
  const maybeAccount = await fetchMaybeAdaptiveFeeTier(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeAdaptiveFeeTier(rpc, address, config) {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeAdaptiveFeeTier(maybeAccount);
}
async function fetchAllAdaptiveFeeTier(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeAdaptiveFeeTier(
    rpc,
    addresses,
    config
  );
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeAdaptiveFeeTier(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map(
    (maybeAccount) => decodeAdaptiveFeeTier(maybeAccount)
  );
}
function getAdaptiveFeeTierSize() {
  return 128;
}

// src/generated/accounts/feeTier.ts
import {
  assertAccountExists as assertAccountExists2,
  assertAccountsExist as assertAccountsExist2,
  combineCodec as combineCodec2,
  decodeAccount as decodeAccount2,
  fetchEncodedAccount as fetchEncodedAccount2,
  fetchEncodedAccounts as fetchEncodedAccounts2,
  fixDecoderSize as fixDecoderSize2,
  fixEncoderSize as fixEncoderSize2,
  getAddressDecoder as getAddressDecoder2,
  getAddressEncoder as getAddressEncoder2,
  getBytesDecoder as getBytesDecoder2,
  getBytesEncoder as getBytesEncoder2,
  getStructDecoder as getStructDecoder2,
  getStructEncoder as getStructEncoder2,
  getU16Decoder as getU16Decoder2,
  getU16Encoder as getU16Encoder2,
  transformEncoder as transformEncoder2
} from "@solana/kit";
var FEE_TIER_DISCRIMINATOR = new Uint8Array([
  56,
  75,
  159,
  76,
  142,
  68,
  190,
  105
]);
function getFeeTierDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder2(), 8).encode(FEE_TIER_DISCRIMINATOR);
}
function getFeeTierEncoder() {
  return transformEncoder2(
    getStructEncoder2([
      ["discriminator", fixEncoderSize2(getBytesEncoder2(), 8)],
      ["whirlpoolsConfig", getAddressEncoder2()],
      ["tickSpacing", getU16Encoder2()],
      ["defaultFeeRate", getU16Encoder2()]
    ]),
    (value) => ({ ...value, discriminator: FEE_TIER_DISCRIMINATOR })
  );
}
function getFeeTierDecoder() {
  return getStructDecoder2([
    ["discriminator", fixDecoderSize2(getBytesDecoder2(), 8)],
    ["whirlpoolsConfig", getAddressDecoder2()],
    ["tickSpacing", getU16Decoder2()],
    ["defaultFeeRate", getU16Decoder2()]
  ]);
}
function getFeeTierCodec() {
  return combineCodec2(getFeeTierEncoder(), getFeeTierDecoder());
}
function decodeFeeTier(encodedAccount) {
  return decodeAccount2(
    encodedAccount,
    getFeeTierDecoder()
  );
}
async function fetchFeeTier(rpc, address, config) {
  const maybeAccount = await fetchMaybeFeeTier(rpc, address, config);
  assertAccountExists2(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeFeeTier(rpc, address, config) {
  const maybeAccount = await fetchEncodedAccount2(rpc, address, config);
  return decodeFeeTier(maybeAccount);
}
async function fetchAllFeeTier(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeFeeTier(rpc, addresses, config);
  assertAccountsExist2(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeFeeTier(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts2(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeFeeTier(maybeAccount));
}
function getFeeTierSize() {
  return 44;
}

// src/generated/accounts/lockConfig.ts
import {
  assertAccountExists as assertAccountExists3,
  assertAccountsExist as assertAccountsExist3,
  combineCodec as combineCodec13,
  decodeAccount as decodeAccount3,
  fetchEncodedAccount as fetchEncodedAccount3,
  fetchEncodedAccounts as fetchEncodedAccounts3,
  fixDecoderSize as fixDecoderSize5,
  fixEncoderSize as fixEncoderSize5,
  getAddressDecoder as getAddressDecoder4,
  getAddressEncoder as getAddressEncoder4,
  getBytesDecoder as getBytesDecoder5,
  getBytesEncoder as getBytesEncoder5,
  getStructDecoder as getStructDecoder10,
  getStructEncoder as getStructEncoder10,
  getU64Decoder as getU64Decoder3,
  getU64Encoder as getU64Encoder3,
  transformEncoder as transformEncoder3
} from "@solana/kit";

// src/generated/types/accountsType.ts
import {
  combineCodec as combineCodec3,
  getEnumDecoder,
  getEnumEncoder
} from "@solana/kit";
var AccountsType = /* @__PURE__ */ ((AccountsType2) => {
  AccountsType2[AccountsType2["TransferHookA"] = 0] = "TransferHookA";
  AccountsType2[AccountsType2["TransferHookB"] = 1] = "TransferHookB";
  AccountsType2[AccountsType2["TransferHookReward"] = 2] = "TransferHookReward";
  AccountsType2[AccountsType2["TransferHookInput"] = 3] = "TransferHookInput";
  AccountsType2[AccountsType2["TransferHookIntermediate"] = 4] = "TransferHookIntermediate";
  AccountsType2[AccountsType2["TransferHookOutput"] = 5] = "TransferHookOutput";
  AccountsType2[AccountsType2["SupplementalTickArrays"] = 6] = "SupplementalTickArrays";
  AccountsType2[AccountsType2["SupplementalTickArraysOne"] = 7] = "SupplementalTickArraysOne";
  AccountsType2[AccountsType2["SupplementalTickArraysTwo"] = 8] = "SupplementalTickArraysTwo";
  return AccountsType2;
})(AccountsType || {});
function getAccountsTypeEncoder() {
  return getEnumEncoder(AccountsType);
}
function getAccountsTypeDecoder() {
  return getEnumDecoder(AccountsType);
}
function getAccountsTypeCodec() {
  return combineCodec3(getAccountsTypeEncoder(), getAccountsTypeDecoder());
}

// src/generated/types/adaptiveFeeConstants.ts
import {
  combineCodec as combineCodec4,
  fixDecoderSize as fixDecoderSize3,
  fixEncoderSize as fixEncoderSize3,
  getBytesDecoder as getBytesDecoder3,
  getBytesEncoder as getBytesEncoder3,
  getStructDecoder as getStructDecoder3,
  getStructEncoder as getStructEncoder3,
  getU16Decoder as getU16Decoder3,
  getU16Encoder as getU16Encoder3,
  getU32Decoder as getU32Decoder2,
  getU32Encoder as getU32Encoder2
} from "@solana/kit";
function getAdaptiveFeeConstantsEncoder() {
  return getStructEncoder3([
    ["filterPeriod", getU16Encoder3()],
    ["decayPeriod", getU16Encoder3()],
    ["reductionFactor", getU16Encoder3()],
    ["adaptiveFeeControlFactor", getU32Encoder2()],
    ["maxVolatilityAccumulator", getU32Encoder2()],
    ["tickGroupSize", getU16Encoder3()],
    ["majorSwapThresholdTicks", getU16Encoder3()],
    ["reserved", fixEncoderSize3(getBytesEncoder3(), 16)]
  ]);
}
function getAdaptiveFeeConstantsDecoder() {
  return getStructDecoder3([
    ["filterPeriod", getU16Decoder3()],
    ["decayPeriod", getU16Decoder3()],
    ["reductionFactor", getU16Decoder3()],
    ["adaptiveFeeControlFactor", getU32Decoder2()],
    ["maxVolatilityAccumulator", getU32Decoder2()],
    ["tickGroupSize", getU16Decoder3()],
    ["majorSwapThresholdTicks", getU16Decoder3()],
    ["reserved", fixDecoderSize3(getBytesDecoder3(), 16)]
  ]);
}
function getAdaptiveFeeConstantsCodec() {
  return combineCodec4(
    getAdaptiveFeeConstantsEncoder(),
    getAdaptiveFeeConstantsDecoder()
  );
}

// src/generated/types/adaptiveFeeVariables.ts
import {
  combineCodec as combineCodec5,
  fixDecoderSize as fixDecoderSize4,
  fixEncoderSize as fixEncoderSize4,
  getBytesDecoder as getBytesDecoder4,
  getBytesEncoder as getBytesEncoder4,
  getI32Decoder,
  getI32Encoder,
  getStructDecoder as getStructDecoder4,
  getStructEncoder as getStructEncoder4,
  getU32Decoder as getU32Decoder3,
  getU32Encoder as getU32Encoder3,
  getU64Decoder,
  getU64Encoder
} from "@solana/kit";
function getAdaptiveFeeVariablesEncoder() {
  return getStructEncoder4([
    ["lastReferenceUpdateTimestamp", getU64Encoder()],
    ["lastMajorSwapTimestamp", getU64Encoder()],
    ["volatilityReference", getU32Encoder3()],
    ["tickGroupIndexReference", getI32Encoder()],
    ["volatilityAccumulator", getU32Encoder3()],
    ["reserved", fixEncoderSize4(getBytesEncoder4(), 16)]
  ]);
}
function getAdaptiveFeeVariablesDecoder() {
  return getStructDecoder4([
    ["lastReferenceUpdateTimestamp", getU64Decoder()],
    ["lastMajorSwapTimestamp", getU64Decoder()],
    ["volatilityReference", getU32Decoder3()],
    ["tickGroupIndexReference", getI32Decoder()],
    ["volatilityAccumulator", getU32Decoder3()],
    ["reserved", fixDecoderSize4(getBytesDecoder4(), 16)]
  ]);
}
function getAdaptiveFeeVariablesCodec() {
  return combineCodec5(
    getAdaptiveFeeVariablesEncoder(),
    getAdaptiveFeeVariablesDecoder()
  );
}

// src/generated/types/lockType.ts
import {
  combineCodec as combineCodec6,
  getEnumDecoder as getEnumDecoder2,
  getEnumEncoder as getEnumEncoder2
} from "@solana/kit";
var LockType = /* @__PURE__ */ ((LockType2) => {
  LockType2[LockType2["Permanent"] = 0] = "Permanent";
  return LockType2;
})(LockType || {});
function getLockTypeEncoder() {
  return getEnumEncoder2(LockType);
}
function getLockTypeDecoder() {
  return getEnumDecoder2(LockType);
}
function getLockTypeCodec() {
  return combineCodec6(getLockTypeEncoder(), getLockTypeDecoder());
}

// src/generated/types/lockTypeLabel.ts
import {
  combineCodec as combineCodec7,
  getEnumDecoder as getEnumDecoder3,
  getEnumEncoder as getEnumEncoder3
} from "@solana/kit";
var LockTypeLabel = /* @__PURE__ */ ((LockTypeLabel2) => {
  LockTypeLabel2[LockTypeLabel2["Permanent"] = 0] = "Permanent";
  return LockTypeLabel2;
})(LockTypeLabel || {});
function getLockTypeLabelEncoder() {
  return getEnumEncoder3(LockTypeLabel);
}
function getLockTypeLabelDecoder() {
  return getEnumDecoder3(LockTypeLabel);
}
function getLockTypeLabelCodec() {
  return combineCodec7(getLockTypeLabelEncoder(), getLockTypeLabelDecoder());
}

// src/generated/types/positionRewardInfo.ts
import {
  combineCodec as combineCodec8,
  getStructDecoder as getStructDecoder5,
  getStructEncoder as getStructEncoder5,
  getU128Decoder,
  getU128Encoder,
  getU64Decoder as getU64Decoder2,
  getU64Encoder as getU64Encoder2
} from "@solana/kit";
function getPositionRewardInfoEncoder() {
  return getStructEncoder5([
    ["growthInsideCheckpoint", getU128Encoder()],
    ["amountOwed", getU64Encoder2()]
  ]);
}
function getPositionRewardInfoDecoder() {
  return getStructDecoder5([
    ["growthInsideCheckpoint", getU128Decoder()],
    ["amountOwed", getU64Decoder2()]
  ]);
}
function getPositionRewardInfoCodec() {
  return combineCodec8(
    getPositionRewardInfoEncoder(),
    getPositionRewardInfoDecoder()
  );
}

// src/generated/types/remainingAccountsInfo.ts
import {
  combineCodec as combineCodec9,
  getArrayDecoder,
  getArrayEncoder,
  getStructDecoder as getStructDecoder6,
  getStructEncoder as getStructEncoder6
} from "@solana/kit";
function getRemainingAccountsInfoEncoder() {
  return getStructEncoder6([
    ["slices", getArrayEncoder(getRemainingAccountsSliceEncoder())]
  ]);
}
function getRemainingAccountsInfoDecoder() {
  return getStructDecoder6([
    ["slices", getArrayDecoder(getRemainingAccountsSliceDecoder())]
  ]);
}
function getRemainingAccountsInfoCodec() {
  return combineCodec9(
    getRemainingAccountsInfoEncoder(),
    getRemainingAccountsInfoDecoder()
  );
}

// src/generated/types/remainingAccountsSlice.ts
import {
  combineCodec as combineCodec10,
  getStructDecoder as getStructDecoder7,
  getStructEncoder as getStructEncoder7,
  getU8Decoder,
  getU8Encoder
} from "@solana/kit";
function getRemainingAccountsSliceEncoder() {
  return getStructEncoder7([
    ["accountsType", getAccountsTypeEncoder()],
    ["length", getU8Encoder()]
  ]);
}
function getRemainingAccountsSliceDecoder() {
  return getStructDecoder7([
    ["accountsType", getAccountsTypeDecoder()],
    ["length", getU8Decoder()]
  ]);
}
function getRemainingAccountsSliceCodec() {
  return combineCodec10(
    getRemainingAccountsSliceEncoder(),
    getRemainingAccountsSliceDecoder()
  );
}

// src/generated/types/tick.ts
import {
  combineCodec as combineCodec11,
  getArrayDecoder as getArrayDecoder2,
  getArrayEncoder as getArrayEncoder2,
  getBooleanDecoder,
  getBooleanEncoder,
  getI128Decoder,
  getI128Encoder,
  getStructDecoder as getStructDecoder8,
  getStructEncoder as getStructEncoder8,
  getU128Decoder as getU128Decoder2,
  getU128Encoder as getU128Encoder2
} from "@solana/kit";
function getTickEncoder() {
  return getStructEncoder8([
    ["initialized", getBooleanEncoder()],
    ["liquidityNet", getI128Encoder()],
    ["liquidityGross", getU128Encoder2()],
    ["feeGrowthOutsideA", getU128Encoder2()],
    ["feeGrowthOutsideB", getU128Encoder2()],
    ["rewardGrowthsOutside", getArrayEncoder2(getU128Encoder2(), { size: 3 })]
  ]);
}
function getTickDecoder() {
  return getStructDecoder8([
    ["initialized", getBooleanDecoder()],
    ["liquidityNet", getI128Decoder()],
    ["liquidityGross", getU128Decoder2()],
    ["feeGrowthOutsideA", getU128Decoder2()],
    ["feeGrowthOutsideB", getU128Decoder2()],
    ["rewardGrowthsOutside", getArrayDecoder2(getU128Decoder2(), { size: 3 })]
  ]);
}
function getTickCodec() {
  return combineCodec11(getTickEncoder(), getTickDecoder());
}

// src/generated/types/whirlpoolRewardInfo.ts
import {
  combineCodec as combineCodec12,
  getAddressDecoder as getAddressDecoder3,
  getAddressEncoder as getAddressEncoder3,
  getStructDecoder as getStructDecoder9,
  getStructEncoder as getStructEncoder9,
  getU128Decoder as getU128Decoder3,
  getU128Encoder as getU128Encoder3
} from "@solana/kit";
function getWhirlpoolRewardInfoEncoder() {
  return getStructEncoder9([
    ["mint", getAddressEncoder3()],
    ["vault", getAddressEncoder3()],
    ["authority", getAddressEncoder3()],
    ["emissionsPerSecondX64", getU128Encoder3()],
    ["growthGlobalX64", getU128Encoder3()]
  ]);
}
function getWhirlpoolRewardInfoDecoder() {
  return getStructDecoder9([
    ["mint", getAddressDecoder3()],
    ["vault", getAddressDecoder3()],
    ["authority", getAddressDecoder3()],
    ["emissionsPerSecondX64", getU128Decoder3()],
    ["growthGlobalX64", getU128Decoder3()]
  ]);
}
function getWhirlpoolRewardInfoCodec() {
  return combineCodec12(
    getWhirlpoolRewardInfoEncoder(),
    getWhirlpoolRewardInfoDecoder()
  );
}

// src/generated/accounts/lockConfig.ts
var LOCK_CONFIG_DISCRIMINATOR = new Uint8Array([
  106,
  47,
  238,
  159,
  124,
  12,
  160,
  192
]);
function getLockConfigDiscriminatorBytes() {
  return fixEncoderSize5(getBytesEncoder5(), 8).encode(LOCK_CONFIG_DISCRIMINATOR);
}
function getLockConfigEncoder() {
  return transformEncoder3(
    getStructEncoder10([
      ["discriminator", fixEncoderSize5(getBytesEncoder5(), 8)],
      ["position", getAddressEncoder4()],
      ["positionOwner", getAddressEncoder4()],
      ["whirlpool", getAddressEncoder4()],
      ["lockedTimestamp", getU64Encoder3()],
      ["lockType", getLockTypeLabelEncoder()]
    ]),
    (value) => ({ ...value, discriminator: LOCK_CONFIG_DISCRIMINATOR })
  );
}
function getLockConfigDecoder() {
  return getStructDecoder10([
    ["discriminator", fixDecoderSize5(getBytesDecoder5(), 8)],
    ["position", getAddressDecoder4()],
    ["positionOwner", getAddressDecoder4()],
    ["whirlpool", getAddressDecoder4()],
    ["lockedTimestamp", getU64Decoder3()],
    ["lockType", getLockTypeLabelDecoder()]
  ]);
}
function getLockConfigCodec() {
  return combineCodec13(getLockConfigEncoder(), getLockConfigDecoder());
}
function decodeLockConfig(encodedAccount) {
  return decodeAccount3(
    encodedAccount,
    getLockConfigDecoder()
  );
}
async function fetchLockConfig(rpc, address, config) {
  const maybeAccount = await fetchMaybeLockConfig(rpc, address, config);
  assertAccountExists3(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeLockConfig(rpc, address, config) {
  const maybeAccount = await fetchEncodedAccount3(rpc, address, config);
  return decodeLockConfig(maybeAccount);
}
async function fetchAllLockConfig(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeLockConfig(rpc, addresses, config);
  assertAccountsExist3(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeLockConfig(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts3(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeLockConfig(maybeAccount));
}
function getLockConfigSize() {
  return 113;
}

// src/generated/accounts/oracle.ts
import {
  assertAccountExists as assertAccountExists4,
  assertAccountsExist as assertAccountsExist4,
  combineCodec as combineCodec14,
  decodeAccount as decodeAccount4,
  fetchEncodedAccount as fetchEncodedAccount4,
  fetchEncodedAccounts as fetchEncodedAccounts4,
  fixDecoderSize as fixDecoderSize6,
  fixEncoderSize as fixEncoderSize6,
  getAddressDecoder as getAddressDecoder5,
  getAddressEncoder as getAddressEncoder5,
  getBytesDecoder as getBytesDecoder6,
  getBytesEncoder as getBytesEncoder6,
  getStructDecoder as getStructDecoder11,
  getStructEncoder as getStructEncoder11,
  getU64Decoder as getU64Decoder4,
  getU64Encoder as getU64Encoder4,
  transformEncoder as transformEncoder4
} from "@solana/kit";
var ORACLE_DISCRIMINATOR = new Uint8Array([
  139,
  194,
  131,
  179,
  140,
  179,
  229,
  244
]);
function getOracleDiscriminatorBytes() {
  return fixEncoderSize6(getBytesEncoder6(), 8).encode(ORACLE_DISCRIMINATOR);
}
function getOracleEncoder() {
  return transformEncoder4(
    getStructEncoder11([
      ["discriminator", fixEncoderSize6(getBytesEncoder6(), 8)],
      ["whirlpool", getAddressEncoder5()],
      ["tradeEnableTimestamp", getU64Encoder4()],
      ["adaptiveFeeConstants", getAdaptiveFeeConstantsEncoder()],
      ["adaptiveFeeVariables", getAdaptiveFeeVariablesEncoder()],
      ["reserved", fixEncoderSize6(getBytesEncoder6(), 128)]
    ]),
    (value) => ({ ...value, discriminator: ORACLE_DISCRIMINATOR })
  );
}
function getOracleDecoder() {
  return getStructDecoder11([
    ["discriminator", fixDecoderSize6(getBytesDecoder6(), 8)],
    ["whirlpool", getAddressDecoder5()],
    ["tradeEnableTimestamp", getU64Decoder4()],
    ["adaptiveFeeConstants", getAdaptiveFeeConstantsDecoder()],
    ["adaptiveFeeVariables", getAdaptiveFeeVariablesDecoder()],
    ["reserved", fixDecoderSize6(getBytesDecoder6(), 128)]
  ]);
}
function getOracleCodec() {
  return combineCodec14(getOracleEncoder(), getOracleDecoder());
}
function decodeOracle(encodedAccount) {
  return decodeAccount4(
    encodedAccount,
    getOracleDecoder()
  );
}
async function fetchOracle(rpc, address, config) {
  const maybeAccount = await fetchMaybeOracle(rpc, address, config);
  assertAccountExists4(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeOracle(rpc, address, config) {
  const maybeAccount = await fetchEncodedAccount4(rpc, address, config);
  return decodeOracle(maybeAccount);
}
async function fetchAllOracle(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeOracle(rpc, addresses, config);
  assertAccountsExist4(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeOracle(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts4(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeOracle(maybeAccount));
}
function getOracleSize() {
  return 254;
}

// src/generated/accounts/position.ts
import {
  assertAccountExists as assertAccountExists5,
  assertAccountsExist as assertAccountsExist5,
  combineCodec as combineCodec15,
  decodeAccount as decodeAccount5,
  fetchEncodedAccount as fetchEncodedAccount5,
  fetchEncodedAccounts as fetchEncodedAccounts5,
  fixDecoderSize as fixDecoderSize7,
  fixEncoderSize as fixEncoderSize7,
  getAddressDecoder as getAddressDecoder6,
  getAddressEncoder as getAddressEncoder6,
  getArrayDecoder as getArrayDecoder3,
  getArrayEncoder as getArrayEncoder3,
  getBytesDecoder as getBytesDecoder7,
  getBytesEncoder as getBytesEncoder7,
  getI32Decoder as getI32Decoder2,
  getI32Encoder as getI32Encoder2,
  getStructDecoder as getStructDecoder12,
  getStructEncoder as getStructEncoder12,
  getU128Decoder as getU128Decoder4,
  getU128Encoder as getU128Encoder4,
  getU64Decoder as getU64Decoder5,
  getU64Encoder as getU64Encoder5,
  transformEncoder as transformEncoder5
} from "@solana/kit";
var POSITION_DISCRIMINATOR = new Uint8Array([
  170,
  188,
  143,
  228,
  122,
  64,
  247,
  208
]);
function getPositionDiscriminatorBytes() {
  return fixEncoderSize7(getBytesEncoder7(), 8).encode(POSITION_DISCRIMINATOR);
}
function getPositionEncoder() {
  return transformEncoder5(
    getStructEncoder12([
      ["discriminator", fixEncoderSize7(getBytesEncoder7(), 8)],
      ["whirlpool", getAddressEncoder6()],
      ["positionMint", getAddressEncoder6()],
      ["liquidity", getU128Encoder4()],
      ["tickLowerIndex", getI32Encoder2()],
      ["tickUpperIndex", getI32Encoder2()],
      ["feeGrowthCheckpointA", getU128Encoder4()],
      ["feeOwedA", getU64Encoder5()],
      ["feeGrowthCheckpointB", getU128Encoder4()],
      ["feeOwedB", getU64Encoder5()],
      [
        "rewardInfos",
        getArrayEncoder3(getPositionRewardInfoEncoder(), { size: 3 })
      ]
    ]),
    (value) => ({ ...value, discriminator: POSITION_DISCRIMINATOR })
  );
}
function getPositionDecoder() {
  return getStructDecoder12([
    ["discriminator", fixDecoderSize7(getBytesDecoder7(), 8)],
    ["whirlpool", getAddressDecoder6()],
    ["positionMint", getAddressDecoder6()],
    ["liquidity", getU128Decoder4()],
    ["tickLowerIndex", getI32Decoder2()],
    ["tickUpperIndex", getI32Decoder2()],
    ["feeGrowthCheckpointA", getU128Decoder4()],
    ["feeOwedA", getU64Decoder5()],
    ["feeGrowthCheckpointB", getU128Decoder4()],
    ["feeOwedB", getU64Decoder5()],
    [
      "rewardInfos",
      getArrayDecoder3(getPositionRewardInfoDecoder(), { size: 3 })
    ]
  ]);
}
function getPositionCodec() {
  return combineCodec15(getPositionEncoder(), getPositionDecoder());
}
function decodePosition(encodedAccount) {
  return decodeAccount5(
    encodedAccount,
    getPositionDecoder()
  );
}
async function fetchPosition(rpc, address, config) {
  const maybeAccount = await fetchMaybePosition(rpc, address, config);
  assertAccountExists5(maybeAccount);
  return maybeAccount;
}
async function fetchMaybePosition(rpc, address, config) {
  const maybeAccount = await fetchEncodedAccount5(rpc, address, config);
  return decodePosition(maybeAccount);
}
async function fetchAllPosition(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybePosition(rpc, addresses, config);
  assertAccountsExist5(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybePosition(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts5(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodePosition(maybeAccount));
}
function getPositionSize() {
  return 216;
}

// src/generated/accounts/positionBundle.ts
import {
  assertAccountExists as assertAccountExists6,
  assertAccountsExist as assertAccountsExist6,
  combineCodec as combineCodec16,
  decodeAccount as decodeAccount6,
  fetchEncodedAccount as fetchEncodedAccount6,
  fetchEncodedAccounts as fetchEncodedAccounts6,
  fixDecoderSize as fixDecoderSize8,
  fixEncoderSize as fixEncoderSize8,
  getAddressDecoder as getAddressDecoder7,
  getAddressEncoder as getAddressEncoder7,
  getBytesDecoder as getBytesDecoder8,
  getBytesEncoder as getBytesEncoder8,
  getStructDecoder as getStructDecoder13,
  getStructEncoder as getStructEncoder13,
  transformEncoder as transformEncoder6
} from "@solana/kit";
var POSITION_BUNDLE_DISCRIMINATOR = new Uint8Array([
  129,
  169,
  175,
  65,
  185,
  95,
  32,
  100
]);
function getPositionBundleDiscriminatorBytes() {
  return fixEncoderSize8(getBytesEncoder8(), 8).encode(
    POSITION_BUNDLE_DISCRIMINATOR
  );
}
function getPositionBundleEncoder() {
  return transformEncoder6(
    getStructEncoder13([
      ["discriminator", fixEncoderSize8(getBytesEncoder8(), 8)],
      ["positionBundleMint", getAddressEncoder7()],
      ["positionBitmap", fixEncoderSize8(getBytesEncoder8(), 32)]
    ]),
    (value) => ({ ...value, discriminator: POSITION_BUNDLE_DISCRIMINATOR })
  );
}
function getPositionBundleDecoder() {
  return getStructDecoder13([
    ["discriminator", fixDecoderSize8(getBytesDecoder8(), 8)],
    ["positionBundleMint", getAddressDecoder7()],
    ["positionBitmap", fixDecoderSize8(getBytesDecoder8(), 32)]
  ]);
}
function getPositionBundleCodec() {
  return combineCodec16(getPositionBundleEncoder(), getPositionBundleDecoder());
}
function decodePositionBundle(encodedAccount) {
  return decodeAccount6(
    encodedAccount,
    getPositionBundleDecoder()
  );
}
async function fetchPositionBundle(rpc, address, config) {
  const maybeAccount = await fetchMaybePositionBundle(rpc, address, config);
  assertAccountExists6(maybeAccount);
  return maybeAccount;
}
async function fetchMaybePositionBundle(rpc, address, config) {
  const maybeAccount = await fetchEncodedAccount6(rpc, address, config);
  return decodePositionBundle(maybeAccount);
}
async function fetchAllPositionBundle(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybePositionBundle(
    rpc,
    addresses,
    config
  );
  assertAccountsExist6(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybePositionBundle(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts6(rpc, addresses, config);
  return maybeAccounts.map(
    (maybeAccount) => decodePositionBundle(maybeAccount)
  );
}
function getPositionBundleSize() {
  return 72;
}

// src/generated/accounts/tickArray.ts
import {
  assertAccountExists as assertAccountExists7,
  assertAccountsExist as assertAccountsExist7,
  combineCodec as combineCodec17,
  decodeAccount as decodeAccount7,
  fetchEncodedAccount as fetchEncodedAccount7,
  fetchEncodedAccounts as fetchEncodedAccounts7,
  fixDecoderSize as fixDecoderSize9,
  fixEncoderSize as fixEncoderSize9,
  getAddressDecoder as getAddressDecoder8,
  getAddressEncoder as getAddressEncoder8,
  getArrayDecoder as getArrayDecoder4,
  getArrayEncoder as getArrayEncoder4,
  getBytesDecoder as getBytesDecoder9,
  getBytesEncoder as getBytesEncoder9,
  getI32Decoder as getI32Decoder3,
  getI32Encoder as getI32Encoder3,
  getStructDecoder as getStructDecoder14,
  getStructEncoder as getStructEncoder14,
  transformEncoder as transformEncoder7
} from "@solana/kit";
var TICK_ARRAY_DISCRIMINATOR = new Uint8Array([
  69,
  97,
  189,
  190,
  110,
  7,
  66,
  187
]);
function getTickArrayDiscriminatorBytes() {
  return fixEncoderSize9(getBytesEncoder9(), 8).encode(TICK_ARRAY_DISCRIMINATOR);
}
function getTickArrayEncoder() {
  return transformEncoder7(
    getStructEncoder14([
      ["discriminator", fixEncoderSize9(getBytesEncoder9(), 8)],
      ["startTickIndex", getI32Encoder3()],
      ["ticks", getArrayEncoder4(getTickEncoder(), { size: 88 })],
      ["whirlpool", getAddressEncoder8()]
    ]),
    (value) => ({ ...value, discriminator: TICK_ARRAY_DISCRIMINATOR })
  );
}
function getTickArrayDecoder() {
  return getStructDecoder14([
    ["discriminator", fixDecoderSize9(getBytesDecoder9(), 8)],
    ["startTickIndex", getI32Decoder3()],
    ["ticks", getArrayDecoder4(getTickDecoder(), { size: 88 })],
    ["whirlpool", getAddressDecoder8()]
  ]);
}
function getTickArrayCodec() {
  return combineCodec17(getTickArrayEncoder(), getTickArrayDecoder());
}
function decodeTickArray(encodedAccount) {
  return decodeAccount7(
    encodedAccount,
    getTickArrayDecoder()
  );
}
async function fetchTickArray(rpc, address, config) {
  const maybeAccount = await fetchMaybeTickArray(rpc, address, config);
  assertAccountExists7(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeTickArray(rpc, address, config) {
  const maybeAccount = await fetchEncodedAccount7(rpc, address, config);
  return decodeTickArray(maybeAccount);
}
async function fetchAllTickArray(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeTickArray(rpc, addresses, config);
  assertAccountsExist7(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeTickArray(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts7(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeTickArray(maybeAccount));
}
function getTickArraySize() {
  return 9988;
}

// src/generated/accounts/tokenBadge.ts
import {
  assertAccountExists as assertAccountExists8,
  assertAccountsExist as assertAccountsExist8,
  combineCodec as combineCodec18,
  decodeAccount as decodeAccount8,
  fetchEncodedAccount as fetchEncodedAccount8,
  fetchEncodedAccounts as fetchEncodedAccounts8,
  fixDecoderSize as fixDecoderSize10,
  fixEncoderSize as fixEncoderSize10,
  getAddressDecoder as getAddressDecoder9,
  getAddressEncoder as getAddressEncoder9,
  getBytesDecoder as getBytesDecoder10,
  getBytesEncoder as getBytesEncoder10,
  getStructDecoder as getStructDecoder15,
  getStructEncoder as getStructEncoder15,
  transformEncoder as transformEncoder8
} from "@solana/kit";
var TOKEN_BADGE_DISCRIMINATOR = new Uint8Array([
  116,
  219,
  204,
  229,
  249,
  116,
  255,
  150
]);
function getTokenBadgeDiscriminatorBytes() {
  return fixEncoderSize10(getBytesEncoder10(), 8).encode(TOKEN_BADGE_DISCRIMINATOR);
}
function getTokenBadgeEncoder() {
  return transformEncoder8(
    getStructEncoder15([
      ["discriminator", fixEncoderSize10(getBytesEncoder10(), 8)],
      ["whirlpoolsConfig", getAddressEncoder9()],
      ["tokenMint", getAddressEncoder9()]
    ]),
    (value) => ({ ...value, discriminator: TOKEN_BADGE_DISCRIMINATOR })
  );
}
function getTokenBadgeDecoder() {
  return getStructDecoder15([
    ["discriminator", fixDecoderSize10(getBytesDecoder10(), 8)],
    ["whirlpoolsConfig", getAddressDecoder9()],
    ["tokenMint", getAddressDecoder9()]
  ]);
}
function getTokenBadgeCodec() {
  return combineCodec18(getTokenBadgeEncoder(), getTokenBadgeDecoder());
}
function decodeTokenBadge(encodedAccount) {
  return decodeAccount8(
    encodedAccount,
    getTokenBadgeDecoder()
  );
}
async function fetchTokenBadge(rpc, address, config) {
  const maybeAccount = await fetchMaybeTokenBadge(rpc, address, config);
  assertAccountExists8(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeTokenBadge(rpc, address, config) {
  const maybeAccount = await fetchEncodedAccount8(rpc, address, config);
  return decodeTokenBadge(maybeAccount);
}
async function fetchAllTokenBadge(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeTokenBadge(rpc, addresses, config);
  assertAccountsExist8(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeTokenBadge(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts8(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeTokenBadge(maybeAccount));
}
function getTokenBadgeSize() {
  return 72;
}

// src/generated/accounts/whirlpool.ts
import {
  assertAccountExists as assertAccountExists9,
  assertAccountsExist as assertAccountsExist9,
  combineCodec as combineCodec19,
  decodeAccount as decodeAccount9,
  fetchEncodedAccount as fetchEncodedAccount9,
  fetchEncodedAccounts as fetchEncodedAccounts9,
  fixDecoderSize as fixDecoderSize11,
  fixEncoderSize as fixEncoderSize11,
  getAddressDecoder as getAddressDecoder10,
  getAddressEncoder as getAddressEncoder10,
  getArrayDecoder as getArrayDecoder5,
  getArrayEncoder as getArrayEncoder5,
  getBytesDecoder as getBytesDecoder11,
  getBytesEncoder as getBytesEncoder11,
  getI32Decoder as getI32Decoder4,
  getI32Encoder as getI32Encoder4,
  getStructDecoder as getStructDecoder16,
  getStructEncoder as getStructEncoder16,
  getU128Decoder as getU128Decoder5,
  getU128Encoder as getU128Encoder5,
  getU16Decoder as getU16Decoder4,
  getU16Encoder as getU16Encoder4,
  getU64Decoder as getU64Decoder6,
  getU64Encoder as getU64Encoder6,
  transformEncoder as transformEncoder9
} from "@solana/kit";
var WHIRLPOOL_DISCRIMINATOR = new Uint8Array([
  63,
  149,
  209,
  12,
  225,
  128,
  99,
  9
]);
function getWhirlpoolDiscriminatorBytes() {
  return fixEncoderSize11(getBytesEncoder11(), 8).encode(WHIRLPOOL_DISCRIMINATOR);
}
function getWhirlpoolEncoder() {
  return transformEncoder9(
    getStructEncoder16([
      ["discriminator", fixEncoderSize11(getBytesEncoder11(), 8)],
      ["whirlpoolsConfig", getAddressEncoder10()],
      ["whirlpoolBump", fixEncoderSize11(getBytesEncoder11(), 1)],
      ["tickSpacing", getU16Encoder4()],
      ["feeTierIndexSeed", fixEncoderSize11(getBytesEncoder11(), 2)],
      ["feeRate", getU16Encoder4()],
      ["protocolFeeRate", getU16Encoder4()],
      ["liquidity", getU128Encoder5()],
      ["sqrtPrice", getU128Encoder5()],
      ["tickCurrentIndex", getI32Encoder4()],
      ["protocolFeeOwedA", getU64Encoder6()],
      ["protocolFeeOwedB", getU64Encoder6()],
      ["tokenMintA", getAddressEncoder10()],
      ["tokenVaultA", getAddressEncoder10()],
      ["feeGrowthGlobalA", getU128Encoder5()],
      ["tokenMintB", getAddressEncoder10()],
      ["tokenVaultB", getAddressEncoder10()],
      ["feeGrowthGlobalB", getU128Encoder5()],
      ["rewardLastUpdatedTimestamp", getU64Encoder6()],
      [
        "rewardInfos",
        getArrayEncoder5(getWhirlpoolRewardInfoEncoder(), { size: 3 })
      ]
    ]),
    (value) => ({ ...value, discriminator: WHIRLPOOL_DISCRIMINATOR })
  );
}
function getWhirlpoolDecoder() {
  return getStructDecoder16([
    ["discriminator", fixDecoderSize11(getBytesDecoder11(), 8)],
    ["whirlpoolsConfig", getAddressDecoder10()],
    ["whirlpoolBump", fixDecoderSize11(getBytesDecoder11(), 1)],
    ["tickSpacing", getU16Decoder4()],
    ["feeTierIndexSeed", fixDecoderSize11(getBytesDecoder11(), 2)],
    ["feeRate", getU16Decoder4()],
    ["protocolFeeRate", getU16Decoder4()],
    ["liquidity", getU128Decoder5()],
    ["sqrtPrice", getU128Decoder5()],
    ["tickCurrentIndex", getI32Decoder4()],
    ["protocolFeeOwedA", getU64Decoder6()],
    ["protocolFeeOwedB", getU64Decoder6()],
    ["tokenMintA", getAddressDecoder10()],
    ["tokenVaultA", getAddressDecoder10()],
    ["feeGrowthGlobalA", getU128Decoder5()],
    ["tokenMintB", getAddressDecoder10()],
    ["tokenVaultB", getAddressDecoder10()],
    ["feeGrowthGlobalB", getU128Decoder5()],
    ["rewardLastUpdatedTimestamp", getU64Decoder6()],
    [
      "rewardInfos",
      getArrayDecoder5(getWhirlpoolRewardInfoDecoder(), { size: 3 })
    ]
  ]);
}
function getWhirlpoolCodec() {
  return combineCodec19(getWhirlpoolEncoder(), getWhirlpoolDecoder());
}
function decodeWhirlpool(encodedAccount) {
  return decodeAccount9(
    encodedAccount,
    getWhirlpoolDecoder()
  );
}
async function fetchWhirlpool(rpc, address, config) {
  const maybeAccount = await fetchMaybeWhirlpool(rpc, address, config);
  assertAccountExists9(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeWhirlpool(rpc, address, config) {
  const maybeAccount = await fetchEncodedAccount9(rpc, address, config);
  return decodeWhirlpool(maybeAccount);
}
async function fetchAllWhirlpool(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeWhirlpool(rpc, addresses, config);
  assertAccountsExist9(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeWhirlpool(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts9(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeWhirlpool(maybeAccount));
}
function getWhirlpoolSize() {
  return 653;
}

// src/generated/accounts/whirlpoolsConfig.ts
import {
  assertAccountExists as assertAccountExists10,
  assertAccountsExist as assertAccountsExist10,
  combineCodec as combineCodec20,
  decodeAccount as decodeAccount10,
  fetchEncodedAccount as fetchEncodedAccount10,
  fetchEncodedAccounts as fetchEncodedAccounts10,
  fixDecoderSize as fixDecoderSize12,
  fixEncoderSize as fixEncoderSize12,
  getAddressDecoder as getAddressDecoder11,
  getAddressEncoder as getAddressEncoder11,
  getBytesDecoder as getBytesDecoder12,
  getBytesEncoder as getBytesEncoder12,
  getStructDecoder as getStructDecoder17,
  getStructEncoder as getStructEncoder17,
  getU16Decoder as getU16Decoder5,
  getU16Encoder as getU16Encoder5,
  transformEncoder as transformEncoder10
} from "@solana/kit";
var WHIRLPOOLS_CONFIG_DISCRIMINATOR = new Uint8Array([
  157,
  20,
  49,
  224,
  217,
  87,
  193,
  254
]);
function getWhirlpoolsConfigDiscriminatorBytes() {
  return fixEncoderSize12(getBytesEncoder12(), 8).encode(
    WHIRLPOOLS_CONFIG_DISCRIMINATOR
  );
}
function getWhirlpoolsConfigEncoder() {
  return transformEncoder10(
    getStructEncoder17([
      ["discriminator", fixEncoderSize12(getBytesEncoder12(), 8)],
      ["feeAuthority", getAddressEncoder11()],
      ["collectProtocolFeesAuthority", getAddressEncoder11()],
      ["rewardEmissionsSuperAuthority", getAddressEncoder11()],
      ["defaultProtocolFeeRate", getU16Encoder5()]
    ]),
    (value) => ({ ...value, discriminator: WHIRLPOOLS_CONFIG_DISCRIMINATOR })
  );
}
function getWhirlpoolsConfigDecoder() {
  return getStructDecoder17([
    ["discriminator", fixDecoderSize12(getBytesDecoder12(), 8)],
    ["feeAuthority", getAddressDecoder11()],
    ["collectProtocolFeesAuthority", getAddressDecoder11()],
    ["rewardEmissionsSuperAuthority", getAddressDecoder11()],
    ["defaultProtocolFeeRate", getU16Decoder5()]
  ]);
}
function getWhirlpoolsConfigCodec() {
  return combineCodec20(
    getWhirlpoolsConfigEncoder(),
    getWhirlpoolsConfigDecoder()
  );
}
function decodeWhirlpoolsConfig(encodedAccount) {
  return decodeAccount10(
    encodedAccount,
    getWhirlpoolsConfigDecoder()
  );
}
async function fetchWhirlpoolsConfig(rpc, address, config) {
  const maybeAccount = await fetchMaybeWhirlpoolsConfig(rpc, address, config);
  assertAccountExists10(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeWhirlpoolsConfig(rpc, address, config) {
  const maybeAccount = await fetchEncodedAccount10(rpc, address, config);
  return decodeWhirlpoolsConfig(maybeAccount);
}
async function fetchAllWhirlpoolsConfig(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeWhirlpoolsConfig(
    rpc,
    addresses,
    config
  );
  assertAccountsExist10(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeWhirlpoolsConfig(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts10(rpc, addresses, config);
  return maybeAccounts.map(
    (maybeAccount) => decodeWhirlpoolsConfig(maybeAccount)
  );
}
function getWhirlpoolsConfigSize() {
  return 106;
}

// src/generated/accounts/whirlpoolsConfigExtension.ts
import {
  assertAccountExists as assertAccountExists11,
  assertAccountsExist as assertAccountsExist11,
  combineCodec as combineCodec21,
  decodeAccount as decodeAccount11,
  fetchEncodedAccount as fetchEncodedAccount11,
  fetchEncodedAccounts as fetchEncodedAccounts11,
  fixDecoderSize as fixDecoderSize13,
  fixEncoderSize as fixEncoderSize13,
  getAddressDecoder as getAddressDecoder12,
  getAddressEncoder as getAddressEncoder12,
  getBytesDecoder as getBytesDecoder13,
  getBytesEncoder as getBytesEncoder13,
  getStructDecoder as getStructDecoder18,
  getStructEncoder as getStructEncoder18,
  transformEncoder as transformEncoder11
} from "@solana/kit";
var WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR = new Uint8Array([
  2,
  99,
  215,
  163,
  240,
  26,
  153,
  58
]);
function getWhirlpoolsConfigExtensionDiscriminatorBytes() {
  return fixEncoderSize13(getBytesEncoder13(), 8).encode(
    WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR
  );
}
function getWhirlpoolsConfigExtensionEncoder() {
  return transformEncoder11(
    getStructEncoder18([
      ["discriminator", fixEncoderSize13(getBytesEncoder13(), 8)],
      ["whirlpoolsConfig", getAddressEncoder12()],
      ["configExtensionAuthority", getAddressEncoder12()],
      ["tokenBadgeAuthority", getAddressEncoder12()]
    ]),
    (value) => ({
      ...value,
      discriminator: WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR
    })
  );
}
function getWhirlpoolsConfigExtensionDecoder() {
  return getStructDecoder18([
    ["discriminator", fixDecoderSize13(getBytesDecoder13(), 8)],
    ["whirlpoolsConfig", getAddressDecoder12()],
    ["configExtensionAuthority", getAddressDecoder12()],
    ["tokenBadgeAuthority", getAddressDecoder12()]
  ]);
}
function getWhirlpoolsConfigExtensionCodec() {
  return combineCodec21(
    getWhirlpoolsConfigExtensionEncoder(),
    getWhirlpoolsConfigExtensionDecoder()
  );
}
function decodeWhirlpoolsConfigExtension(encodedAccount) {
  return decodeAccount11(
    encodedAccount,
    getWhirlpoolsConfigExtensionDecoder()
  );
}
async function fetchWhirlpoolsConfigExtension(rpc, address, config) {
  const maybeAccount = await fetchMaybeWhirlpoolsConfigExtension(
    rpc,
    address,
    config
  );
  assertAccountExists11(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeWhirlpoolsConfigExtension(rpc, address, config) {
  const maybeAccount = await fetchEncodedAccount11(rpc, address, config);
  return decodeWhirlpoolsConfigExtension(maybeAccount);
}
async function fetchAllWhirlpoolsConfigExtension(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeWhirlpoolsConfigExtension(
    rpc,
    addresses,
    config
  );
  assertAccountsExist11(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeWhirlpoolsConfigExtension(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts11(rpc, addresses, config);
  return maybeAccounts.map(
    (maybeAccount) => decodeWhirlpoolsConfigExtension(maybeAccount)
  );
}
function getWhirlpoolsConfigExtensionSize() {
  return 104;
}

// src/generated/errors/whirlpool.ts
import {
  isProgramError
} from "@solana/kit";

// src/generated/programs/whirlpool.ts
import {
  containsBytes,
  fixEncoderSize as fixEncoderSize14,
  getBytesEncoder as getBytesEncoder14
} from "@solana/kit";
var WHIRLPOOL_PROGRAM_ADDRESS = "whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc";
var WhirlpoolAccount = /* @__PURE__ */ ((WhirlpoolAccount2) => {
  WhirlpoolAccount2[WhirlpoolAccount2["AdaptiveFeeTier"] = 0] = "AdaptiveFeeTier";
  WhirlpoolAccount2[WhirlpoolAccount2["WhirlpoolsConfig"] = 1] = "WhirlpoolsConfig";
  WhirlpoolAccount2[WhirlpoolAccount2["WhirlpoolsConfigExtension"] = 2] = "WhirlpoolsConfigExtension";
  WhirlpoolAccount2[WhirlpoolAccount2["FeeTier"] = 3] = "FeeTier";
  WhirlpoolAccount2[WhirlpoolAccount2["LockConfig"] = 4] = "LockConfig";
  WhirlpoolAccount2[WhirlpoolAccount2["Oracle"] = 5] = "Oracle";
  WhirlpoolAccount2[WhirlpoolAccount2["Position"] = 6] = "Position";
  WhirlpoolAccount2[WhirlpoolAccount2["PositionBundle"] = 7] = "PositionBundle";
  WhirlpoolAccount2[WhirlpoolAccount2["TickArray"] = 8] = "TickArray";
  WhirlpoolAccount2[WhirlpoolAccount2["TokenBadge"] = 9] = "TokenBadge";
  WhirlpoolAccount2[WhirlpoolAccount2["Whirlpool"] = 10] = "Whirlpool";
  return WhirlpoolAccount2;
})(WhirlpoolAccount || {});
function identifyWhirlpoolAccount(account) {
  const data = "data" in account ? account.data : account;
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([147, 16, 144, 116, 47, 146, 149, 46])
    ),
    0
  )) {
    return 0 /* AdaptiveFeeTier */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([157, 20, 49, 224, 217, 87, 193, 254])
    ),
    0
  )) {
    return 1 /* WhirlpoolsConfig */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([2, 99, 215, 163, 240, 26, 153, 58])
    ),
    0
  )) {
    return 2 /* WhirlpoolsConfigExtension */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([56, 75, 159, 76, 142, 68, 190, 105])
    ),
    0
  )) {
    return 3 /* FeeTier */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([106, 47, 238, 159, 124, 12, 160, 192])
    ),
    0
  )) {
    return 4 /* LockConfig */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([139, 194, 131, 179, 140, 179, 229, 244])
    ),
    0
  )) {
    return 5 /* Oracle */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([170, 188, 143, 228, 122, 64, 247, 208])
    ),
    0
  )) {
    return 6 /* Position */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([129, 169, 175, 65, 185, 95, 32, 100])
    ),
    0
  )) {
    return 7 /* PositionBundle */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([69, 97, 189, 190, 110, 7, 66, 187])
    ),
    0
  )) {
    return 8 /* TickArray */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([116, 219, 204, 229, 249, 116, 255, 150])
    ),
    0
  )) {
    return 9 /* TokenBadge */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([63, 149, 209, 12, 225, 128, 99, 9])
    ),
    0
  )) {
    return 10 /* Whirlpool */;
  }
  throw new Error(
    "The provided account could not be identified as a whirlpool account."
  );
}
var WhirlpoolInstruction = /* @__PURE__ */ ((WhirlpoolInstruction2) => {
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeConfig"] = 0] = "InitializeConfig";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializePool"] = 1] = "InitializePool";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeTickArray"] = 2] = "InitializeTickArray";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeFeeTier"] = 3] = "InitializeFeeTier";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeReward"] = 4] = "InitializeReward";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetRewardEmissions"] = 5] = "SetRewardEmissions";
  WhirlpoolInstruction2[WhirlpoolInstruction2["OpenPosition"] = 6] = "OpenPosition";
  WhirlpoolInstruction2[WhirlpoolInstruction2["OpenPositionWithMetadata"] = 7] = "OpenPositionWithMetadata";
  WhirlpoolInstruction2[WhirlpoolInstruction2["IncreaseLiquidity"] = 8] = "IncreaseLiquidity";
  WhirlpoolInstruction2[WhirlpoolInstruction2["DecreaseLiquidity"] = 9] = "DecreaseLiquidity";
  WhirlpoolInstruction2[WhirlpoolInstruction2["UpdateFeesAndRewards"] = 10] = "UpdateFeesAndRewards";
  WhirlpoolInstruction2[WhirlpoolInstruction2["CollectFees"] = 11] = "CollectFees";
  WhirlpoolInstruction2[WhirlpoolInstruction2["CollectReward"] = 12] = "CollectReward";
  WhirlpoolInstruction2[WhirlpoolInstruction2["CollectProtocolFees"] = 13] = "CollectProtocolFees";
  WhirlpoolInstruction2[WhirlpoolInstruction2["Swap"] = 14] = "Swap";
  WhirlpoolInstruction2[WhirlpoolInstruction2["ClosePosition"] = 15] = "ClosePosition";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetDefaultFeeRate"] = 16] = "SetDefaultFeeRate";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetDefaultProtocolFeeRate"] = 17] = "SetDefaultProtocolFeeRate";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetFeeRate"] = 18] = "SetFeeRate";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetProtocolFeeRate"] = 19] = "SetProtocolFeeRate";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetFeeAuthority"] = 20] = "SetFeeAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetCollectProtocolFeesAuthority"] = 21] = "SetCollectProtocolFeesAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetRewardAuthority"] = 22] = "SetRewardAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetRewardAuthorityBySuperAuthority"] = 23] = "SetRewardAuthorityBySuperAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetRewardEmissionsSuperAuthority"] = 24] = "SetRewardEmissionsSuperAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["TwoHopSwap"] = 25] = "TwoHopSwap";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializePositionBundle"] = 26] = "InitializePositionBundle";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializePositionBundleWithMetadata"] = 27] = "InitializePositionBundleWithMetadata";
  WhirlpoolInstruction2[WhirlpoolInstruction2["DeletePositionBundle"] = 28] = "DeletePositionBundle";
  WhirlpoolInstruction2[WhirlpoolInstruction2["OpenBundledPosition"] = 29] = "OpenBundledPosition";
  WhirlpoolInstruction2[WhirlpoolInstruction2["CloseBundledPosition"] = 30] = "CloseBundledPosition";
  WhirlpoolInstruction2[WhirlpoolInstruction2["OpenPositionWithTokenExtensions"] = 31] = "OpenPositionWithTokenExtensions";
  WhirlpoolInstruction2[WhirlpoolInstruction2["ClosePositionWithTokenExtensions"] = 32] = "ClosePositionWithTokenExtensions";
  WhirlpoolInstruction2[WhirlpoolInstruction2["LockPosition"] = 33] = "LockPosition";
  WhirlpoolInstruction2[WhirlpoolInstruction2["ResetPositionRange"] = 34] = "ResetPositionRange";
  WhirlpoolInstruction2[WhirlpoolInstruction2["TransferLockedPosition"] = 35] = "TransferLockedPosition";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeAdaptiveFeeTier"] = 36] = "InitializeAdaptiveFeeTier";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetDefaultBaseFeeRate"] = 37] = "SetDefaultBaseFeeRate";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetDelegatedFeeAuthority"] = 38] = "SetDelegatedFeeAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetInitializePoolAuthority"] = 39] = "SetInitializePoolAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetPresetAdaptiveFeeConstants"] = 40] = "SetPresetAdaptiveFeeConstants";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializePoolWithAdaptiveFee"] = 41] = "InitializePoolWithAdaptiveFee";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetFeeRateByDelegatedFeeAuthority"] = 42] = "SetFeeRateByDelegatedFeeAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["CollectFeesV2"] = 43] = "CollectFeesV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["CollectProtocolFeesV2"] = 44] = "CollectProtocolFeesV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["CollectRewardV2"] = 45] = "CollectRewardV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["DecreaseLiquidityV2"] = 46] = "DecreaseLiquidityV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["IncreaseLiquidityV2"] = 47] = "IncreaseLiquidityV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializePoolV2"] = 48] = "InitializePoolV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeRewardV2"] = 49] = "InitializeRewardV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetRewardEmissionsV2"] = 50] = "SetRewardEmissionsV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SwapV2"] = 51] = "SwapV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["TwoHopSwapV2"] = 52] = "TwoHopSwapV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeConfigExtension"] = 53] = "InitializeConfigExtension";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetConfigExtensionAuthority"] = 54] = "SetConfigExtensionAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetTokenBadgeAuthority"] = 55] = "SetTokenBadgeAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeTokenBadge"] = 56] = "InitializeTokenBadge";
  WhirlpoolInstruction2[WhirlpoolInstruction2["DeleteTokenBadge"] = 57] = "DeleteTokenBadge";
  return WhirlpoolInstruction2;
})(WhirlpoolInstruction || {});
function identifyWhirlpoolInstruction(instruction) {
  const data = "data" in instruction ? instruction.data : instruction;
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([208, 127, 21, 1, 194, 190, 196, 70])
    ),
    0
  )) {
    return 0 /* InitializeConfig */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([95, 180, 10, 172, 84, 174, 232, 40])
    ),
    0
  )) {
    return 1 /* InitializePool */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([11, 188, 193, 214, 141, 91, 149, 184])
    ),
    0
  )) {
    return 2 /* InitializeTickArray */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([183, 74, 156, 160, 112, 2, 42, 30])
    ),
    0
  )) {
    return 3 /* InitializeFeeTier */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([95, 135, 192, 196, 242, 129, 230, 68])
    ),
    0
  )) {
    return 4 /* InitializeReward */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([13, 197, 86, 168, 109, 176, 27, 244])
    ),
    0
  )) {
    return 5 /* SetRewardEmissions */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([135, 128, 47, 77, 15, 152, 240, 49])
    ),
    0
  )) {
    return 6 /* OpenPosition */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([242, 29, 134, 48, 58, 110, 14, 60])
    ),
    0
  )) {
    return 7 /* OpenPositionWithMetadata */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([46, 156, 243, 118, 13, 205, 251, 178])
    ),
    0
  )) {
    return 8 /* IncreaseLiquidity */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([160, 38, 208, 111, 104, 91, 44, 1])
    ),
    0
  )) {
    return 9 /* DecreaseLiquidity */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([154, 230, 250, 13, 236, 209, 75, 223])
    ),
    0
  )) {
    return 10 /* UpdateFeesAndRewards */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([164, 152, 207, 99, 30, 186, 19, 182])
    ),
    0
  )) {
    return 11 /* CollectFees */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([70, 5, 132, 87, 86, 235, 177, 34])
    ),
    0
  )) {
    return 12 /* CollectReward */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([22, 67, 23, 98, 150, 178, 70, 220])
    ),
    0
  )) {
    return 13 /* CollectProtocolFees */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([248, 198, 158, 145, 225, 117, 135, 200])
    ),
    0
  )) {
    return 14 /* Swap */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([123, 134, 81, 0, 49, 68, 98, 98])
    ),
    0
  )) {
    return 15 /* ClosePosition */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([118, 215, 214, 157, 182, 229, 208, 228])
    ),
    0
  )) {
    return 16 /* SetDefaultFeeRate */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([107, 205, 249, 226, 151, 35, 86, 0])
    ),
    0
  )) {
    return 17 /* SetDefaultProtocolFeeRate */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([53, 243, 137, 65, 8, 140, 158, 6])
    ),
    0
  )) {
    return 18 /* SetFeeRate */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([95, 7, 4, 50, 154, 79, 156, 131])
    ),
    0
  )) {
    return 19 /* SetProtocolFeeRate */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([31, 1, 50, 87, 237, 101, 97, 132])
    ),
    0
  )) {
    return 20 /* SetFeeAuthority */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([34, 150, 93, 244, 139, 225, 233, 67])
    ),
    0
  )) {
    return 21 /* SetCollectProtocolFeesAuthority */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([34, 39, 183, 252, 83, 28, 85, 127])
    ),
    0
  )) {
    return 22 /* SetRewardAuthority */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([240, 154, 201, 198, 148, 93, 56, 25])
    ),
    0
  )) {
    return 23 /* SetRewardAuthorityBySuperAuthority */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([207, 5, 200, 209, 122, 56, 82, 183])
    ),
    0
  )) {
    return 24 /* SetRewardEmissionsSuperAuthority */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([195, 96, 237, 108, 68, 162, 219, 230])
    ),
    0
  )) {
    return 25 /* TwoHopSwap */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([117, 45, 241, 149, 24, 18, 194, 65])
    ),
    0
  )) {
    return 26 /* InitializePositionBundle */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([93, 124, 16, 179, 249, 131, 115, 245])
    ),
    0
  )) {
    return 27 /* InitializePositionBundleWithMetadata */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([100, 25, 99, 2, 217, 239, 124, 173])
    ),
    0
  )) {
    return 28 /* DeletePositionBundle */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([169, 113, 126, 171, 213, 172, 212, 49])
    ),
    0
  )) {
    return 29 /* OpenBundledPosition */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([41, 36, 216, 245, 27, 85, 103, 67])
    ),
    0
  )) {
    return 30 /* CloseBundledPosition */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([212, 47, 95, 92, 114, 102, 131, 250])
    ),
    0
  )) {
    return 31 /* OpenPositionWithTokenExtensions */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([1, 182, 135, 59, 155, 25, 99, 223])
    ),
    0
  )) {
    return 32 /* ClosePositionWithTokenExtensions */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([227, 62, 2, 252, 247, 10, 171, 185])
    ),
    0
  )) {
    return 33 /* LockPosition */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([164, 123, 180, 141, 194, 100, 160, 175])
    ),
    0
  )) {
    return 34 /* ResetPositionRange */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([179, 121, 229, 46, 67, 138, 194, 138])
    ),
    0
  )) {
    return 35 /* TransferLockedPosition */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([77, 99, 208, 200, 141, 123, 117, 48])
    ),
    0
  )) {
    return 36 /* InitializeAdaptiveFeeTier */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([229, 66, 84, 251, 164, 134, 183, 7])
    ),
    0
  )) {
    return 37 /* SetDefaultBaseFeeRate */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([193, 234, 231, 147, 138, 57, 3, 122])
    ),
    0
  )) {
    return 38 /* SetDelegatedFeeAuthority */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([125, 43, 127, 235, 149, 26, 106, 236])
    ),
    0
  )) {
    return 39 /* SetInitializePoolAuthority */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([132, 185, 66, 148, 83, 88, 134, 198])
    ),
    0
  )) {
    return 40 /* SetPresetAdaptiveFeeConstants */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([143, 94, 96, 76, 172, 124, 119, 199])
    ),
    0
  )) {
    return 41 /* InitializePoolWithAdaptiveFee */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([121, 121, 54, 114, 131, 230, 162, 104])
    ),
    0
  )) {
    return 42 /* SetFeeRateByDelegatedFeeAuthority */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([207, 117, 95, 191, 229, 180, 226, 15])
    ),
    0
  )) {
    return 43 /* CollectFeesV2 */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([103, 128, 222, 134, 114, 200, 22, 200])
    ),
    0
  )) {
    return 44 /* CollectProtocolFeesV2 */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([177, 107, 37, 180, 160, 19, 49, 209])
    ),
    0
  )) {
    return 45 /* CollectRewardV2 */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([58, 127, 188, 62, 79, 82, 196, 96])
    ),
    0
  )) {
    return 46 /* DecreaseLiquidityV2 */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([133, 29, 89, 223, 69, 238, 176, 10])
    ),
    0
  )) {
    return 47 /* IncreaseLiquidityV2 */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([207, 45, 87, 242, 27, 63, 204, 67])
    ),
    0
  )) {
    return 48 /* InitializePoolV2 */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([91, 1, 77, 50, 235, 229, 133, 49])
    ),
    0
  )) {
    return 49 /* InitializeRewardV2 */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([114, 228, 72, 32, 193, 48, 160, 102])
    ),
    0
  )) {
    return 50 /* SetRewardEmissionsV2 */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([43, 4, 237, 11, 26, 201, 30, 98])
    ),
    0
  )) {
    return 51 /* SwapV2 */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([186, 143, 209, 29, 254, 2, 194, 117])
    ),
    0
  )) {
    return 52 /* TwoHopSwapV2 */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([55, 9, 53, 9, 114, 57, 209, 52])
    ),
    0
  )) {
    return 53 /* InitializeConfigExtension */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([44, 94, 241, 116, 24, 188, 60, 143])
    ),
    0
  )) {
    return 54 /* SetConfigExtensionAuthority */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([207, 202, 4, 32, 205, 79, 13, 178])
    ),
    0
  )) {
    return 55 /* SetTokenBadgeAuthority */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([253, 77, 205, 95, 27, 224, 89, 223])
    ),
    0
  )) {
    return 56 /* InitializeTokenBadge */;
  }
  if (containsBytes(
    data,
    fixEncoderSize14(getBytesEncoder14(), 8).encode(
      new Uint8Array([53, 146, 68, 8, 18, 117, 17, 185])
    ),
    0
  )) {
    return 57 /* DeleteTokenBadge */;
  }
  throw new Error(
    "The provided instruction could not be identified as a whirlpool instruction."
  );
}

// src/generated/errors/whirlpool.ts
var WHIRLPOOL_ERROR__INVALID_ENUM = 6e3;
var WHIRLPOOL_ERROR__INVALID_START_TICK = 6001;
var WHIRLPOOL_ERROR__TICK_ARRAY_EXIST_IN_POOL = 6002;
var WHIRLPOOL_ERROR__TICK_ARRAY_INDEX_OUTOF_BOUNDS = 6003;
var WHIRLPOOL_ERROR__INVALID_TICK_SPACING = 6004;
var WHIRLPOOL_ERROR__CLOSE_POSITION_NOT_EMPTY = 6005;
var WHIRLPOOL_ERROR__DIVIDE_BY_ZERO = 6006;
var WHIRLPOOL_ERROR__NUMBER_CAST_ERROR = 6007;
var WHIRLPOOL_ERROR__NUMBER_DOWN_CAST_ERROR = 6008;
var WHIRLPOOL_ERROR__TICK_NOT_FOUND = 6009;
var WHIRLPOOL_ERROR__INVALID_TICK_INDEX = 6010;
var WHIRLPOOL_ERROR__SQRT_PRICE_OUT_OF_BOUNDS = 6011;
var WHIRLPOOL_ERROR__LIQUIDITY_ZERO = 6012;
var WHIRLPOOL_ERROR__LIQUIDITY_TOO_HIGH = 6013;
var WHIRLPOOL_ERROR__LIQUIDITY_OVERFLOW = 6014;
var WHIRLPOOL_ERROR__LIQUIDITY_UNDERFLOW = 6015;
var WHIRLPOOL_ERROR__LIQUIDITY_NET_ERROR = 6016;
var WHIRLPOOL_ERROR__TOKEN_MAX_EXCEEDED = 6017;
var WHIRLPOOL_ERROR__TOKEN_MIN_SUBCEEDED = 6018;
var WHIRLPOOL_ERROR__MISSING_OR_INVALID_DELEGATE = 6019;
var WHIRLPOOL_ERROR__INVALID_POSITION_TOKEN_AMOUNT = 6020;
var WHIRLPOOL_ERROR__INVALID_TIMESTAMP_CONVERSION = 6021;
var WHIRLPOOL_ERROR__INVALID_TIMESTAMP = 6022;
var WHIRLPOOL_ERROR__INVALID_TICK_ARRAY_SEQUENCE = 6023;
var WHIRLPOOL_ERROR__INVALID_TOKEN_MINT_ORDER = 6024;
var WHIRLPOOL_ERROR__REWARD_NOT_INITIALIZED = 6025;
var WHIRLPOOL_ERROR__INVALID_REWARD_INDEX = 6026;
var WHIRLPOOL_ERROR__REWARD_VAULT_AMOUNT_INSUFFICIENT = 6027;
var WHIRLPOOL_ERROR__FEE_RATE_MAX_EXCEEDED = 6028;
var WHIRLPOOL_ERROR__PROTOCOL_FEE_RATE_MAX_EXCEEDED = 6029;
var WHIRLPOOL_ERROR__MULTIPLICATION_SHIFT_RIGHT_OVERFLOW = 6030;
var WHIRLPOOL_ERROR__MUL_DIV_OVERFLOW = 6031;
var WHIRLPOOL_ERROR__MUL_DIV_INVALID_INPUT = 6032;
var WHIRLPOOL_ERROR__MULTIPLICATION_OVERFLOW = 6033;
var WHIRLPOOL_ERROR__INVALID_SQRT_PRICE_LIMIT_DIRECTION = 6034;
var WHIRLPOOL_ERROR__ZERO_TRADABLE_AMOUNT = 6035;
var WHIRLPOOL_ERROR__AMOUNT_OUT_BELOW_MINIMUM = 6036;
var WHIRLPOOL_ERROR__AMOUNT_IN_ABOVE_MAXIMUM = 6037;
var WHIRLPOOL_ERROR__TICK_ARRAY_SEQUENCE_INVALID_INDEX = 6038;
var WHIRLPOOL_ERROR__AMOUNT_CALC_OVERFLOW = 6039;
var WHIRLPOOL_ERROR__AMOUNT_REMAINING_OVERFLOW = 6040;
var WHIRLPOOL_ERROR__INVALID_INTERMEDIARY_MINT = 6041;
var WHIRLPOOL_ERROR__DUPLICATE_TWO_HOP_POOL = 6042;
var WHIRLPOOL_ERROR__INVALID_BUNDLE_INDEX = 6043;
var WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_OPENED = 6044;
var WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_CLOSED = 6045;
var WHIRLPOOL_ERROR__POSITION_BUNDLE_NOT_DELETABLE = 6046;
var WHIRLPOOL_ERROR__UNSUPPORTED_TOKEN_MINT = 6047;
var WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INVALID_SLICE = 6048;
var WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INSUFFICIENT = 6049;
var WHIRLPOOL_ERROR__NO_EXTRA_ACCOUNTS_FOR_TRANSFER_HOOK = 6050;
var WHIRLPOOL_ERROR__INTERMEDIATE_TOKEN_AMOUNT_MISMATCH = 6051;
var WHIRLPOOL_ERROR__TRANSFER_FEE_CALCULATION_ERROR = 6052;
var WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_DUPLICATED_ACCOUNTS_TYPE = 6053;
var WHIRLPOOL_ERROR__FULL_RANGE_ONLY_POOL = 6054;
var WHIRLPOOL_ERROR__TOO_MANY_SUPPLEMENTAL_TICK_ARRAYS = 6055;
var WHIRLPOOL_ERROR__DIFFERENT_WHIRLPOOL_TICK_ARRAY_ACCOUNT = 6056;
var WHIRLPOOL_ERROR__PARTIAL_FILL_ERROR = 6057;
var WHIRLPOOL_ERROR__POSITION_NOT_LOCKABLE = 6058;
var WHIRLPOOL_ERROR__OPERATION_NOT_ALLOWED_ON_LOCKED_POSITION = 6059;
var WHIRLPOOL_ERROR__SAME_TICK_RANGE_NOT_ALLOWED = 6060;
var WHIRLPOOL_ERROR__INVALID_ADAPTIVE_FEE_CONSTANTS = 6061;
var WHIRLPOOL_ERROR__INVALID_FEE_TIER_INDEX = 6062;
var WHIRLPOOL_ERROR__INVALID_TRADE_ENABLE_TIMESTAMP = 6063;
var WHIRLPOOL_ERROR__TRADE_IS_NOT_ENABLED = 6064;
var whirlpoolErrorMessages;
if (process.env.NODE_ENV !== "production") {
  whirlpoolErrorMessages = {
    [WHIRLPOOL_ERROR__AMOUNT_CALC_OVERFLOW]: `Amount calculated overflows`,
    [WHIRLPOOL_ERROR__AMOUNT_IN_ABOVE_MAXIMUM]: `Amount in above maximum threshold`,
    [WHIRLPOOL_ERROR__AMOUNT_OUT_BELOW_MINIMUM]: `Amount out below minimum threshold`,
    [WHIRLPOOL_ERROR__AMOUNT_REMAINING_OVERFLOW]: `Amount remaining overflows`,
    [WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_CLOSED]: `Position has already been closed`,
    [WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_OPENED]: `Position has already been opened`,
    [WHIRLPOOL_ERROR__CLOSE_POSITION_NOT_EMPTY]: `Position is not empty It cannot be closed`,
    [WHIRLPOOL_ERROR__DIFFERENT_WHIRLPOOL_TICK_ARRAY_ACCOUNT]: `TickArray account for different whirlpool provided`,
    [WHIRLPOOL_ERROR__DIVIDE_BY_ZERO]: `Unable to divide by zero`,
    [WHIRLPOOL_ERROR__DUPLICATE_TWO_HOP_POOL]: `Duplicate two hop pool`,
    [WHIRLPOOL_ERROR__FEE_RATE_MAX_EXCEEDED]: `Exceeded max fee rate`,
    [WHIRLPOOL_ERROR__FULL_RANGE_ONLY_POOL]: `This whirlpool only supports full-range positions`,
    [WHIRLPOOL_ERROR__INTERMEDIATE_TOKEN_AMOUNT_MISMATCH]: `Output and input amount mismatch`,
    [WHIRLPOOL_ERROR__INVALID_ADAPTIVE_FEE_CONSTANTS]: `Invalid adaptive fee constants`,
    [WHIRLPOOL_ERROR__INVALID_BUNDLE_INDEX]: `Bundle index is out of bounds`,
    [WHIRLPOOL_ERROR__INVALID_ENUM]: `Enum value could not be converted`,
    [WHIRLPOOL_ERROR__INVALID_FEE_TIER_INDEX]: `Invalid fee tier index`,
    [WHIRLPOOL_ERROR__INVALID_INTERMEDIARY_MINT]: `Invalid intermediary mint`,
    [WHIRLPOOL_ERROR__INVALID_POSITION_TOKEN_AMOUNT]: `Position token amount must be 1`,
    [WHIRLPOOL_ERROR__INVALID_REWARD_INDEX]: `Invalid reward index`,
    [WHIRLPOOL_ERROR__INVALID_SQRT_PRICE_LIMIT_DIRECTION]: `Provided SqrtPriceLimit not in the same direction as the swap.`,
    [WHIRLPOOL_ERROR__INVALID_START_TICK]: `Invalid start tick index provided.`,
    [WHIRLPOOL_ERROR__INVALID_TICK_ARRAY_SEQUENCE]: `Invalid tick array sequence provided for instruction.`,
    [WHIRLPOOL_ERROR__INVALID_TICK_INDEX]: `Provided tick index is either out of bounds or uninitializable`,
    [WHIRLPOOL_ERROR__INVALID_TICK_SPACING]: `Tick-spacing is not supported`,
    [WHIRLPOOL_ERROR__INVALID_TIMESTAMP]: `Timestamp should be greater than the last updated timestamp`,
    [WHIRLPOOL_ERROR__INVALID_TIMESTAMP_CONVERSION]: `Timestamp should be convertible from i64 to u64`,
    [WHIRLPOOL_ERROR__INVALID_TOKEN_MINT_ORDER]: `Token Mint in wrong order`,
    [WHIRLPOOL_ERROR__INVALID_TRADE_ENABLE_TIMESTAMP]: `Invalid trade enable timestamp`,
    [WHIRLPOOL_ERROR__LIQUIDITY_NET_ERROR]: `Tick liquidity net underflowed or overflowed`,
    [WHIRLPOOL_ERROR__LIQUIDITY_OVERFLOW]: `Liquidity overflow`,
    [WHIRLPOOL_ERROR__LIQUIDITY_TOO_HIGH]: `Liquidity amount must be less than i64::MAX`,
    [WHIRLPOOL_ERROR__LIQUIDITY_UNDERFLOW]: `Liquidity underflow`,
    [WHIRLPOOL_ERROR__LIQUIDITY_ZERO]: `Liquidity amount must be greater than zero`,
    [WHIRLPOOL_ERROR__MISSING_OR_INVALID_DELEGATE]: `Position token account has a missing or invalid delegate`,
    [WHIRLPOOL_ERROR__MUL_DIV_INVALID_INPUT]: `Invalid div_u256 input`,
    [WHIRLPOOL_ERROR__MUL_DIV_OVERFLOW]: `Muldiv overflow`,
    [WHIRLPOOL_ERROR__MULTIPLICATION_OVERFLOW]: `Multiplication overflow`,
    [WHIRLPOOL_ERROR__MULTIPLICATION_SHIFT_RIGHT_OVERFLOW]: `Multiplication with shift right overflow`,
    [WHIRLPOOL_ERROR__NO_EXTRA_ACCOUNTS_FOR_TRANSFER_HOOK]: `Unable to call transfer hook without extra accounts`,
    [WHIRLPOOL_ERROR__NUMBER_CAST_ERROR]: `Unable to cast number into BigInt`,
    [WHIRLPOOL_ERROR__NUMBER_DOWN_CAST_ERROR]: `Unable to down cast number`,
    [WHIRLPOOL_ERROR__OPERATION_NOT_ALLOWED_ON_LOCKED_POSITION]: `Operation not allowed on locked position`,
    [WHIRLPOOL_ERROR__PARTIAL_FILL_ERROR]: `Trade resulted in partial fill`,
    [WHIRLPOOL_ERROR__POSITION_BUNDLE_NOT_DELETABLE]: `Unable to delete PositionBundle with open positions`,
    [WHIRLPOOL_ERROR__POSITION_NOT_LOCKABLE]: `Position is not lockable`,
    [WHIRLPOOL_ERROR__PROTOCOL_FEE_RATE_MAX_EXCEEDED]: `Exceeded max protocol fee rate`,
    [WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_DUPLICATED_ACCOUNTS_TYPE]: `Same accounts type is provided more than once`,
    [WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INSUFFICIENT]: `Insufficient remaining accounts`,
    [WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INVALID_SLICE]: `Invalid remaining accounts`,
    [WHIRLPOOL_ERROR__REWARD_NOT_INITIALIZED]: `Reward not initialized`,
    [WHIRLPOOL_ERROR__REWARD_VAULT_AMOUNT_INSUFFICIENT]: `Reward vault requires amount to support emissions for at least one day`,
    [WHIRLPOOL_ERROR__SAME_TICK_RANGE_NOT_ALLOWED]: `Cannot reset position range with same tick range`,
    [WHIRLPOOL_ERROR__SQRT_PRICE_OUT_OF_BOUNDS]: `Provided sqrt price out of bounds`,
    [WHIRLPOOL_ERROR__TICK_ARRAY_EXIST_IN_POOL]: `Tick-array already exists in this whirlpool`,
    [WHIRLPOOL_ERROR__TICK_ARRAY_INDEX_OUTOF_BOUNDS]: `Attempt to search for a tick-array failed`,
    [WHIRLPOOL_ERROR__TICK_ARRAY_SEQUENCE_INVALID_INDEX]: `Invalid index for tick array sequence`,
    [WHIRLPOOL_ERROR__TICK_NOT_FOUND]: `Tick not found within tick array`,
    [WHIRLPOOL_ERROR__TOKEN_MAX_EXCEEDED]: `Exceeded token max`,
    [WHIRLPOOL_ERROR__TOKEN_MIN_SUBCEEDED]: `Did not meet token min`,
    [WHIRLPOOL_ERROR__TOO_MANY_SUPPLEMENTAL_TICK_ARRAYS]: `Too many supplemental tick arrays provided`,
    [WHIRLPOOL_ERROR__TRADE_IS_NOT_ENABLED]: `Trade is not enabled yet`,
    [WHIRLPOOL_ERROR__TRANSFER_FEE_CALCULATION_ERROR]: `Transfer fee calculation failed`,
    [WHIRLPOOL_ERROR__UNSUPPORTED_TOKEN_MINT]: `Token mint has unsupported attributes`,
    [WHIRLPOOL_ERROR__ZERO_TRADABLE_AMOUNT]: `There are no tradable amount to swap.`
  };
}
function getWhirlpoolErrorMessage(code) {
  if (process.env.NODE_ENV !== "production") {
    return whirlpoolErrorMessages[code];
  }
  return "Error message not available in production bundles.";
}
function isWhirlpoolError(error, transactionMessage, code) {
  return isProgramError(
    error,
    transactionMessage,
    WHIRLPOOL_PROGRAM_ADDRESS,
    code
  );
}

// src/generated/instructions/closeBundledPosition.ts
import {
  combineCodec as combineCodec22,
  fixDecoderSize as fixDecoderSize14,
  fixEncoderSize as fixEncoderSize15,
  getBytesDecoder as getBytesDecoder14,
  getBytesEncoder as getBytesEncoder15,
  getStructDecoder as getStructDecoder19,
  getStructEncoder as getStructEncoder19,
  getU16Decoder as getU16Decoder6,
  getU16Encoder as getU16Encoder6,
  transformEncoder as transformEncoder12
} from "@solana/kit";

// src/generated/shared/index.ts
import {
  AccountRole,
  isProgramDerivedAddress,
  isTransactionSigner as kitIsTransactionSigner,
  upgradeRoleToSigner
} from "@solana/kit";
function expectAddress(value) {
  if (!value) {
    throw new Error("Expected a Address.");
  }
  if (typeof value === "object" && "address" in value) {
    return value.address;
  }
  if (Array.isArray(value)) {
    return value[0];
  }
  return value;
}
function getAccountMetaFactory(programAddress, optionalAccountStrategy) {
  return (account) => {
    if (!account.value) {
      if (optionalAccountStrategy === "omitted") return;
      return Object.freeze({
        address: programAddress,
        role: AccountRole.READONLY
      });
    }
    const writableRole = account.isWritable ? AccountRole.WRITABLE : AccountRole.READONLY;
    return Object.freeze({
      address: expectAddress(account.value),
      role: isTransactionSigner(account.value) ? upgradeRoleToSigner(writableRole) : writableRole,
      ...isTransactionSigner(account.value) ? { signer: account.value } : {}
    });
  };
}
function isTransactionSigner(value) {
  return !!value && typeof value === "object" && "address" in value && kitIsTransactionSigner(value);
}

// src/generated/instructions/closeBundledPosition.ts
var CLOSE_BUNDLED_POSITION_DISCRIMINATOR = new Uint8Array([
  41,
  36,
  216,
  245,
  27,
  85,
  103,
  67
]);
function getCloseBundledPositionDiscriminatorBytes() {
  return fixEncoderSize15(getBytesEncoder15(), 8).encode(
    CLOSE_BUNDLED_POSITION_DISCRIMINATOR
  );
}
function getCloseBundledPositionInstructionDataEncoder() {
  return transformEncoder12(
    getStructEncoder19([
      ["discriminator", fixEncoderSize15(getBytesEncoder15(), 8)],
      ["bundleIndex", getU16Encoder6()]
    ]),
    (value) => ({
      ...value,
      discriminator: CLOSE_BUNDLED_POSITION_DISCRIMINATOR
    })
  );
}
function getCloseBundledPositionInstructionDataDecoder() {
  return getStructDecoder19([
    ["discriminator", fixDecoderSize14(getBytesDecoder14(), 8)],
    ["bundleIndex", getU16Decoder6()]
  ]);
}
function getCloseBundledPositionInstructionDataCodec() {
  return combineCodec22(
    getCloseBundledPositionInstructionDataEncoder(),
    getCloseBundledPositionInstructionDataDecoder()
  );
}
function getCloseBundledPositionInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    bundledPosition: { value: input.bundledPosition ?? null, isWritable: true },
    positionBundle: { value: input.positionBundle ?? null, isWritable: true },
    positionBundleTokenAccount: {
      value: input.positionBundleTokenAccount ?? null,
      isWritable: false
    },
    positionBundleAuthority: {
      value: input.positionBundleAuthority ?? null,
      isWritable: false
    },
    receiver: { value: input.receiver ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.bundledPosition),
      getAccountMeta(accounts.positionBundle),
      getAccountMeta(accounts.positionBundleTokenAccount),
      getAccountMeta(accounts.positionBundleAuthority),
      getAccountMeta(accounts.receiver)
    ],
    programAddress,
    data: getCloseBundledPositionInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseCloseBundledPositionInstruction(instruction) {
  if (instruction.accounts.length < 5) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      bundledPosition: getNextAccount(),
      positionBundle: getNextAccount(),
      positionBundleTokenAccount: getNextAccount(),
      positionBundleAuthority: getNextAccount(),
      receiver: getNextAccount()
    },
    data: getCloseBundledPositionInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/closePosition.ts
import {
  combineCodec as combineCodec23,
  fixDecoderSize as fixDecoderSize15,
  fixEncoderSize as fixEncoderSize16,
  getBytesDecoder as getBytesDecoder15,
  getBytesEncoder as getBytesEncoder16,
  getStructDecoder as getStructDecoder20,
  getStructEncoder as getStructEncoder20,
  transformEncoder as transformEncoder13
} from "@solana/kit";
var CLOSE_POSITION_DISCRIMINATOR = new Uint8Array([
  123,
  134,
  81,
  0,
  49,
  68,
  98,
  98
]);
function getClosePositionDiscriminatorBytes() {
  return fixEncoderSize16(getBytesEncoder16(), 8).encode(
    CLOSE_POSITION_DISCRIMINATOR
  );
}
function getClosePositionInstructionDataEncoder() {
  return transformEncoder13(
    getStructEncoder20([["discriminator", fixEncoderSize16(getBytesEncoder16(), 8)]]),
    (value) => ({ ...value, discriminator: CLOSE_POSITION_DISCRIMINATOR })
  );
}
function getClosePositionInstructionDataDecoder() {
  return getStructDecoder20([
    ["discriminator", fixDecoderSize15(getBytesDecoder15(), 8)]
  ]);
}
function getClosePositionInstructionDataCodec() {
  return combineCodec23(
    getClosePositionInstructionDataEncoder(),
    getClosePositionInstructionDataDecoder()
  );
}
function getClosePositionInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    receiver: { value: input.receiver ?? null, isWritable: true },
    position: { value: input.position ?? null, isWritable: true },
    positionMint: { value: input.positionMint ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: true
    },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.receiver),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionMint),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.tokenProgram)
    ],
    programAddress,
    data: getClosePositionInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseClosePositionInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      positionAuthority: getNextAccount(),
      receiver: getNextAccount(),
      position: getNextAccount(),
      positionMint: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getClosePositionInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/closePositionWithTokenExtensions.ts
import {
  combineCodec as combineCodec24,
  fixDecoderSize as fixDecoderSize16,
  fixEncoderSize as fixEncoderSize17,
  getBytesDecoder as getBytesDecoder16,
  getBytesEncoder as getBytesEncoder17,
  getStructDecoder as getStructDecoder21,
  getStructEncoder as getStructEncoder21,
  transformEncoder as transformEncoder14
} from "@solana/kit";
var CLOSE_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR = new Uint8Array([1, 182, 135, 59, 155, 25, 99, 223]);
function getClosePositionWithTokenExtensionsDiscriminatorBytes() {
  return fixEncoderSize17(getBytesEncoder17(), 8).encode(
    CLOSE_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR
  );
}
function getClosePositionWithTokenExtensionsInstructionDataEncoder() {
  return transformEncoder14(
    getStructEncoder21([["discriminator", fixEncoderSize17(getBytesEncoder17(), 8)]]),
    (value) => ({
      ...value,
      discriminator: CLOSE_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR
    })
  );
}
function getClosePositionWithTokenExtensionsInstructionDataDecoder() {
  return getStructDecoder21([
    ["discriminator", fixDecoderSize16(getBytesDecoder16(), 8)]
  ]);
}
function getClosePositionWithTokenExtensionsInstructionDataCodec() {
  return combineCodec24(
    getClosePositionWithTokenExtensionsInstructionDataEncoder(),
    getClosePositionWithTokenExtensionsInstructionDataDecoder()
  );
}
function getClosePositionWithTokenExtensionsInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    receiver: { value: input.receiver ?? null, isWritable: true },
    position: { value: input.position ?? null, isWritable: true },
    positionMint: { value: input.positionMint ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: true
    },
    token2022Program: {
      value: input.token2022Program ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.receiver),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionMint),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.token2022Program)
    ],
    programAddress,
    data: getClosePositionWithTokenExtensionsInstructionDataEncoder().encode(
      {}
    )
  };
  return instruction;
}
function parseClosePositionWithTokenExtensionsInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      positionAuthority: getNextAccount(),
      receiver: getNextAccount(),
      position: getNextAccount(),
      positionMint: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      token2022Program: getNextAccount()
    },
    data: getClosePositionWithTokenExtensionsInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/collectFees.ts
import {
  combineCodec as combineCodec25,
  fixDecoderSize as fixDecoderSize17,
  fixEncoderSize as fixEncoderSize18,
  getBytesDecoder as getBytesDecoder17,
  getBytesEncoder as getBytesEncoder18,
  getStructDecoder as getStructDecoder22,
  getStructEncoder as getStructEncoder22,
  transformEncoder as transformEncoder15
} from "@solana/kit";
var COLLECT_FEES_DISCRIMINATOR = new Uint8Array([
  164,
  152,
  207,
  99,
  30,
  186,
  19,
  182
]);
function getCollectFeesDiscriminatorBytes() {
  return fixEncoderSize18(getBytesEncoder18(), 8).encode(
    COLLECT_FEES_DISCRIMINATOR
  );
}
function getCollectFeesInstructionDataEncoder() {
  return transformEncoder15(
    getStructEncoder22([["discriminator", fixEncoderSize18(getBytesEncoder18(), 8)]]),
    (value) => ({ ...value, discriminator: COLLECT_FEES_DISCRIMINATOR })
  );
}
function getCollectFeesInstructionDataDecoder() {
  return getStructDecoder22([
    ["discriminator", fixDecoderSize17(getBytesDecoder17(), 8)]
  ]);
}
function getCollectFeesInstructionDataCodec() {
  return combineCodec25(
    getCollectFeesInstructionDataEncoder(),
    getCollectFeesInstructionDataDecoder()
  );
}
function getCollectFeesInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tokenProgram)
    ],
    programAddress,
    data: getCollectFeesInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseCollectFeesInstruction(instruction) {
  if (instruction.accounts.length < 9) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getCollectFeesInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/collectFeesV2.ts
import {
  combineCodec as combineCodec26,
  fixDecoderSize as fixDecoderSize18,
  fixEncoderSize as fixEncoderSize19,
  getBytesDecoder as getBytesDecoder18,
  getBytesEncoder as getBytesEncoder19,
  getOptionDecoder,
  getOptionEncoder,
  getStructDecoder as getStructDecoder23,
  getStructEncoder as getStructEncoder23,
  transformEncoder as transformEncoder16
} from "@solana/kit";
var COLLECT_FEES_V2_DISCRIMINATOR = new Uint8Array([
  207,
  117,
  95,
  191,
  229,
  180,
  226,
  15
]);
function getCollectFeesV2DiscriminatorBytes() {
  return fixEncoderSize19(getBytesEncoder19(), 8).encode(
    COLLECT_FEES_V2_DISCRIMINATOR
  );
}
function getCollectFeesV2InstructionDataEncoder() {
  return transformEncoder16(
    getStructEncoder23([
      ["discriminator", fixEncoderSize19(getBytesEncoder19(), 8)],
      [
        "remainingAccountsInfo",
        getOptionEncoder(getRemainingAccountsInfoEncoder())
      ]
    ]),
    (value) => ({ ...value, discriminator: COLLECT_FEES_V2_DISCRIMINATOR })
  );
}
function getCollectFeesV2InstructionDataDecoder() {
  return getStructDecoder23([
    ["discriminator", fixDecoderSize18(getBytesDecoder18(), 8)],
    [
      "remainingAccountsInfo",
      getOptionDecoder(getRemainingAccountsInfoDecoder())
    ]
  ]);
}
function getCollectFeesV2InstructionDataCodec() {
  return combineCodec26(
    getCollectFeesV2InstructionDataEncoder(),
    getCollectFeesV2InstructionDataDecoder()
  );
}
function getCollectFeesV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },
    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tokenProgramA),
      getAccountMeta(accounts.tokenProgramB),
      getAccountMeta(accounts.memoProgram)
    ],
    programAddress,
    data: getCollectFeesV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseCollectFeesV2Instruction(instruction) {
  if (instruction.accounts.length < 13) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tokenProgramA: getNextAccount(),
      tokenProgramB: getNextAccount(),
      memoProgram: getNextAccount()
    },
    data: getCollectFeesV2InstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/collectProtocolFees.ts
import {
  combineCodec as combineCodec27,
  fixDecoderSize as fixDecoderSize19,
  fixEncoderSize as fixEncoderSize20,
  getBytesDecoder as getBytesDecoder19,
  getBytesEncoder as getBytesEncoder20,
  getStructDecoder as getStructDecoder24,
  getStructEncoder as getStructEncoder24,
  transformEncoder as transformEncoder17
} from "@solana/kit";
var COLLECT_PROTOCOL_FEES_DISCRIMINATOR = new Uint8Array([
  22,
  67,
  23,
  98,
  150,
  178,
  70,
  220
]);
function getCollectProtocolFeesDiscriminatorBytes() {
  return fixEncoderSize20(getBytesEncoder20(), 8).encode(
    COLLECT_PROTOCOL_FEES_DISCRIMINATOR
  );
}
function getCollectProtocolFeesInstructionDataEncoder() {
  return transformEncoder17(
    getStructEncoder24([["discriminator", fixEncoderSize20(getBytesEncoder20(), 8)]]),
    (value) => ({
      ...value,
      discriminator: COLLECT_PROTOCOL_FEES_DISCRIMINATOR
    })
  );
}
function getCollectProtocolFeesInstructionDataDecoder() {
  return getStructDecoder24([
    ["discriminator", fixDecoderSize19(getBytesDecoder19(), 8)]
  ]);
}
function getCollectProtocolFeesInstructionDataCodec() {
  return combineCodec27(
    getCollectProtocolFeesInstructionDataEncoder(),
    getCollectProtocolFeesInstructionDataDecoder()
  );
}
function getCollectProtocolFeesInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    collectProtocolFeesAuthority: {
      value: input.collectProtocolFeesAuthority ?? null,
      isWritable: false
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tokenDestinationA: {
      value: input.tokenDestinationA ?? null,
      isWritable: true
    },
    tokenDestinationB: {
      value: input.tokenDestinationB ?? null,
      isWritable: true
    },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.collectProtocolFeesAuthority),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tokenDestinationA),
      getAccountMeta(accounts.tokenDestinationB),
      getAccountMeta(accounts.tokenProgram)
    ],
    programAddress,
    data: getCollectProtocolFeesInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseCollectProtocolFeesInstruction(instruction) {
  if (instruction.accounts.length < 8) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpool: getNextAccount(),
      collectProtocolFeesAuthority: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tokenDestinationA: getNextAccount(),
      tokenDestinationB: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getCollectProtocolFeesInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/collectProtocolFeesV2.ts
import {
  combineCodec as combineCodec28,
  fixDecoderSize as fixDecoderSize20,
  fixEncoderSize as fixEncoderSize21,
  getBytesDecoder as getBytesDecoder20,
  getBytesEncoder as getBytesEncoder21,
  getOptionDecoder as getOptionDecoder2,
  getOptionEncoder as getOptionEncoder2,
  getStructDecoder as getStructDecoder25,
  getStructEncoder as getStructEncoder25,
  transformEncoder as transformEncoder18
} from "@solana/kit";
var COLLECT_PROTOCOL_FEES_V2_DISCRIMINATOR = new Uint8Array([
  103,
  128,
  222,
  134,
  114,
  200,
  22,
  200
]);
function getCollectProtocolFeesV2DiscriminatorBytes() {
  return fixEncoderSize21(getBytesEncoder21(), 8).encode(
    COLLECT_PROTOCOL_FEES_V2_DISCRIMINATOR
  );
}
function getCollectProtocolFeesV2InstructionDataEncoder() {
  return transformEncoder18(
    getStructEncoder25([
      ["discriminator", fixEncoderSize21(getBytesEncoder21(), 8)],
      [
        "remainingAccountsInfo",
        getOptionEncoder2(getRemainingAccountsInfoEncoder())
      ]
    ]),
    (value) => ({
      ...value,
      discriminator: COLLECT_PROTOCOL_FEES_V2_DISCRIMINATOR
    })
  );
}
function getCollectProtocolFeesV2InstructionDataDecoder() {
  return getStructDecoder25([
    ["discriminator", fixDecoderSize20(getBytesDecoder20(), 8)],
    [
      "remainingAccountsInfo",
      getOptionDecoder2(getRemainingAccountsInfoDecoder())
    ]
  ]);
}
function getCollectProtocolFeesV2InstructionDataCodec() {
  return combineCodec28(
    getCollectProtocolFeesV2InstructionDataEncoder(),
    getCollectProtocolFeesV2InstructionDataDecoder()
  );
}
function getCollectProtocolFeesV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    collectProtocolFeesAuthority: {
      value: input.collectProtocolFeesAuthority ?? null,
      isWritable: false
    },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tokenDestinationA: {
      value: input.tokenDestinationA ?? null,
      isWritable: true
    },
    tokenDestinationB: {
      value: input.tokenDestinationB ?? null,
      isWritable: true
    },
    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },
    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.collectProtocolFeesAuthority),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tokenDestinationA),
      getAccountMeta(accounts.tokenDestinationB),
      getAccountMeta(accounts.tokenProgramA),
      getAccountMeta(accounts.tokenProgramB),
      getAccountMeta(accounts.memoProgram)
    ],
    programAddress,
    data: getCollectProtocolFeesV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseCollectProtocolFeesV2Instruction(instruction) {
  if (instruction.accounts.length < 12) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpool: getNextAccount(),
      collectProtocolFeesAuthority: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tokenDestinationA: getNextAccount(),
      tokenDestinationB: getNextAccount(),
      tokenProgramA: getNextAccount(),
      tokenProgramB: getNextAccount(),
      memoProgram: getNextAccount()
    },
    data: getCollectProtocolFeesV2InstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/collectReward.ts
import {
  combineCodec as combineCodec29,
  fixDecoderSize as fixDecoderSize21,
  fixEncoderSize as fixEncoderSize22,
  getBytesDecoder as getBytesDecoder21,
  getBytesEncoder as getBytesEncoder22,
  getStructDecoder as getStructDecoder26,
  getStructEncoder as getStructEncoder26,
  getU8Decoder as getU8Decoder2,
  getU8Encoder as getU8Encoder2,
  transformEncoder as transformEncoder19
} from "@solana/kit";
var COLLECT_REWARD_DISCRIMINATOR = new Uint8Array([
  70,
  5,
  132,
  87,
  86,
  235,
  177,
  34
]);
function getCollectRewardDiscriminatorBytes() {
  return fixEncoderSize22(getBytesEncoder22(), 8).encode(
    COLLECT_REWARD_DISCRIMINATOR
  );
}
function getCollectRewardInstructionDataEncoder() {
  return transformEncoder19(
    getStructEncoder26([
      ["discriminator", fixEncoderSize22(getBytesEncoder22(), 8)],
      ["rewardIndex", getU8Encoder2()]
    ]),
    (value) => ({ ...value, discriminator: COLLECT_REWARD_DISCRIMINATOR })
  );
}
function getCollectRewardInstructionDataDecoder() {
  return getStructDecoder26([
    ["discriminator", fixDecoderSize21(getBytesDecoder21(), 8)],
    ["rewardIndex", getU8Decoder2()]
  ]);
}
function getCollectRewardInstructionDataCodec() {
  return combineCodec29(
    getCollectRewardInstructionDataEncoder(),
    getCollectRewardInstructionDataDecoder()
  );
}
function getCollectRewardInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    rewardOwnerAccount: {
      value: input.rewardOwnerAccount ?? null,
      isWritable: true
    },
    rewardVault: { value: input.rewardVault ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.rewardOwnerAccount),
      getAccountMeta(accounts.rewardVault),
      getAccountMeta(accounts.tokenProgram)
    ],
    programAddress,
    data: getCollectRewardInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseCollectRewardInstruction(instruction) {
  if (instruction.accounts.length < 7) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      rewardOwnerAccount: getNextAccount(),
      rewardVault: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getCollectRewardInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/collectRewardV2.ts
import {
  combineCodec as combineCodec30,
  fixDecoderSize as fixDecoderSize22,
  fixEncoderSize as fixEncoderSize23,
  getBytesDecoder as getBytesDecoder22,
  getBytesEncoder as getBytesEncoder23,
  getOptionDecoder as getOptionDecoder3,
  getOptionEncoder as getOptionEncoder3,
  getStructDecoder as getStructDecoder27,
  getStructEncoder as getStructEncoder27,
  getU8Decoder as getU8Decoder3,
  getU8Encoder as getU8Encoder3,
  transformEncoder as transformEncoder20
} from "@solana/kit";
var COLLECT_REWARD_V2_DISCRIMINATOR = new Uint8Array([
  177,
  107,
  37,
  180,
  160,
  19,
  49,
  209
]);
function getCollectRewardV2DiscriminatorBytes() {
  return fixEncoderSize23(getBytesEncoder23(), 8).encode(
    COLLECT_REWARD_V2_DISCRIMINATOR
  );
}
function getCollectRewardV2InstructionDataEncoder() {
  return transformEncoder20(
    getStructEncoder27([
      ["discriminator", fixEncoderSize23(getBytesEncoder23(), 8)],
      ["rewardIndex", getU8Encoder3()],
      [
        "remainingAccountsInfo",
        getOptionEncoder3(getRemainingAccountsInfoEncoder())
      ]
    ]),
    (value) => ({ ...value, discriminator: COLLECT_REWARD_V2_DISCRIMINATOR })
  );
}
function getCollectRewardV2InstructionDataDecoder() {
  return getStructDecoder27([
    ["discriminator", fixDecoderSize22(getBytesDecoder22(), 8)],
    ["rewardIndex", getU8Decoder3()],
    [
      "remainingAccountsInfo",
      getOptionDecoder3(getRemainingAccountsInfoDecoder())
    ]
  ]);
}
function getCollectRewardV2InstructionDataCodec() {
  return combineCodec30(
    getCollectRewardV2InstructionDataEncoder(),
    getCollectRewardV2InstructionDataDecoder()
  );
}
function getCollectRewardV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    rewardOwnerAccount: {
      value: input.rewardOwnerAccount ?? null,
      isWritable: true
    },
    rewardMint: { value: input.rewardMint ?? null, isWritable: false },
    rewardVault: { value: input.rewardVault ?? null, isWritable: true },
    rewardTokenProgram: {
      value: input.rewardTokenProgram ?? null,
      isWritable: false
    },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.rewardOwnerAccount),
      getAccountMeta(accounts.rewardMint),
      getAccountMeta(accounts.rewardVault),
      getAccountMeta(accounts.rewardTokenProgram),
      getAccountMeta(accounts.memoProgram)
    ],
    programAddress,
    data: getCollectRewardV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseCollectRewardV2Instruction(instruction) {
  if (instruction.accounts.length < 9) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      rewardOwnerAccount: getNextAccount(),
      rewardMint: getNextAccount(),
      rewardVault: getNextAccount(),
      rewardTokenProgram: getNextAccount(),
      memoProgram: getNextAccount()
    },
    data: getCollectRewardV2InstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/decreaseLiquidity.ts
import {
  combineCodec as combineCodec31,
  fixDecoderSize as fixDecoderSize23,
  fixEncoderSize as fixEncoderSize24,
  getBytesDecoder as getBytesDecoder23,
  getBytesEncoder as getBytesEncoder24,
  getStructDecoder as getStructDecoder28,
  getStructEncoder as getStructEncoder28,
  getU128Decoder as getU128Decoder6,
  getU128Encoder as getU128Encoder6,
  getU64Decoder as getU64Decoder7,
  getU64Encoder as getU64Encoder7,
  transformEncoder as transformEncoder21
} from "@solana/kit";
var DECREASE_LIQUIDITY_DISCRIMINATOR = new Uint8Array([
  160,
  38,
  208,
  111,
  104,
  91,
  44,
  1
]);
function getDecreaseLiquidityDiscriminatorBytes() {
  return fixEncoderSize24(getBytesEncoder24(), 8).encode(
    DECREASE_LIQUIDITY_DISCRIMINATOR
  );
}
function getDecreaseLiquidityInstructionDataEncoder() {
  return transformEncoder21(
    getStructEncoder28([
      ["discriminator", fixEncoderSize24(getBytesEncoder24(), 8)],
      ["liquidityAmount", getU128Encoder6()],
      ["tokenMinA", getU64Encoder7()],
      ["tokenMinB", getU64Encoder7()]
    ]),
    (value) => ({ ...value, discriminator: DECREASE_LIQUIDITY_DISCRIMINATOR })
  );
}
function getDecreaseLiquidityInstructionDataDecoder() {
  return getStructDecoder28([
    ["discriminator", fixDecoderSize23(getBytesDecoder23(), 8)],
    ["liquidityAmount", getU128Decoder6()],
    ["tokenMinA", getU64Decoder7()],
    ["tokenMinB", getU64Decoder7()]
  ]);
}
function getDecreaseLiquidityInstructionDataCodec() {
  return combineCodec31(
    getDecreaseLiquidityInstructionDataEncoder(),
    getDecreaseLiquidityInstructionDataDecoder()
  );
}
function getDecreaseLiquidityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper)
    ],
    programAddress,
    data: getDecreaseLiquidityInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseDecreaseLiquidityInstruction(instruction) {
  if (instruction.accounts.length < 11) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      tokenProgram: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tickArrayLower: getNextAccount(),
      tickArrayUpper: getNextAccount()
    },
    data: getDecreaseLiquidityInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/decreaseLiquidityV2.ts
import {
  combineCodec as combineCodec32,
  fixDecoderSize as fixDecoderSize24,
  fixEncoderSize as fixEncoderSize25,
  getBytesDecoder as getBytesDecoder24,
  getBytesEncoder as getBytesEncoder25,
  getOptionDecoder as getOptionDecoder4,
  getOptionEncoder as getOptionEncoder4,
  getStructDecoder as getStructDecoder29,
  getStructEncoder as getStructEncoder29,
  getU128Decoder as getU128Decoder7,
  getU128Encoder as getU128Encoder7,
  getU64Decoder as getU64Decoder8,
  getU64Encoder as getU64Encoder8,
  transformEncoder as transformEncoder22
} from "@solana/kit";
var DECREASE_LIQUIDITY_V2_DISCRIMINATOR = new Uint8Array([
  58,
  127,
  188,
  62,
  79,
  82,
  196,
  96
]);
function getDecreaseLiquidityV2DiscriminatorBytes() {
  return fixEncoderSize25(getBytesEncoder25(), 8).encode(
    DECREASE_LIQUIDITY_V2_DISCRIMINATOR
  );
}
function getDecreaseLiquidityV2InstructionDataEncoder() {
  return transformEncoder22(
    getStructEncoder29([
      ["discriminator", fixEncoderSize25(getBytesEncoder25(), 8)],
      ["liquidityAmount", getU128Encoder7()],
      ["tokenMinA", getU64Encoder8()],
      ["tokenMinB", getU64Encoder8()],
      [
        "remainingAccountsInfo",
        getOptionEncoder4(getRemainingAccountsInfoEncoder())
      ]
    ]),
    (value) => ({
      ...value,
      discriminator: DECREASE_LIQUIDITY_V2_DISCRIMINATOR
    })
  );
}
function getDecreaseLiquidityV2InstructionDataDecoder() {
  return getStructDecoder29([
    ["discriminator", fixDecoderSize24(getBytesDecoder24(), 8)],
    ["liquidityAmount", getU128Decoder7()],
    ["tokenMinA", getU64Decoder8()],
    ["tokenMinB", getU64Decoder8()],
    [
      "remainingAccountsInfo",
      getOptionDecoder4(getRemainingAccountsInfoDecoder())
    ]
  ]);
}
function getDecreaseLiquidityV2InstructionDataCodec() {
  return combineCodec32(
    getDecreaseLiquidityV2InstructionDataEncoder(),
    getDecreaseLiquidityV2InstructionDataDecoder()
  );
}
function getDecreaseLiquidityV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },
    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenProgramA),
      getAccountMeta(accounts.tokenProgramB),
      getAccountMeta(accounts.memoProgram),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper)
    ],
    programAddress,
    data: getDecreaseLiquidityV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseDecreaseLiquidityV2Instruction(instruction) {
  if (instruction.accounts.length < 15) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      tokenProgramA: getNextAccount(),
      tokenProgramB: getNextAccount(),
      memoProgram: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tickArrayLower: getNextAccount(),
      tickArrayUpper: getNextAccount()
    },
    data: getDecreaseLiquidityV2InstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/deletePositionBundle.ts
import {
  combineCodec as combineCodec33,
  fixDecoderSize as fixDecoderSize25,
  fixEncoderSize as fixEncoderSize26,
  getBytesDecoder as getBytesDecoder25,
  getBytesEncoder as getBytesEncoder26,
  getStructDecoder as getStructDecoder30,
  getStructEncoder as getStructEncoder30,
  transformEncoder as transformEncoder23
} from "@solana/kit";
var DELETE_POSITION_BUNDLE_DISCRIMINATOR = new Uint8Array([
  100,
  25,
  99,
  2,
  217,
  239,
  124,
  173
]);
function getDeletePositionBundleDiscriminatorBytes() {
  return fixEncoderSize26(getBytesEncoder26(), 8).encode(
    DELETE_POSITION_BUNDLE_DISCRIMINATOR
  );
}
function getDeletePositionBundleInstructionDataEncoder() {
  return transformEncoder23(
    getStructEncoder30([["discriminator", fixEncoderSize26(getBytesEncoder26(), 8)]]),
    (value) => ({
      ...value,
      discriminator: DELETE_POSITION_BUNDLE_DISCRIMINATOR
    })
  );
}
function getDeletePositionBundleInstructionDataDecoder() {
  return getStructDecoder30([
    ["discriminator", fixDecoderSize25(getBytesDecoder25(), 8)]
  ]);
}
function getDeletePositionBundleInstructionDataCodec() {
  return combineCodec33(
    getDeletePositionBundleInstructionDataEncoder(),
    getDeletePositionBundleInstructionDataDecoder()
  );
}
function getDeletePositionBundleInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    positionBundle: { value: input.positionBundle ?? null, isWritable: true },
    positionBundleMint: {
      value: input.positionBundleMint ?? null,
      isWritable: true
    },
    positionBundleTokenAccount: {
      value: input.positionBundleTokenAccount ?? null,
      isWritable: true
    },
    positionBundleOwner: {
      value: input.positionBundleOwner ?? null,
      isWritable: false
    },
    receiver: { value: input.receiver ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.positionBundle),
      getAccountMeta(accounts.positionBundleMint),
      getAccountMeta(accounts.positionBundleTokenAccount),
      getAccountMeta(accounts.positionBundleOwner),
      getAccountMeta(accounts.receiver),
      getAccountMeta(accounts.tokenProgram)
    ],
    programAddress,
    data: getDeletePositionBundleInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseDeletePositionBundleInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      positionBundle: getNextAccount(),
      positionBundleMint: getNextAccount(),
      positionBundleTokenAccount: getNextAccount(),
      positionBundleOwner: getNextAccount(),
      receiver: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getDeletePositionBundleInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/deleteTokenBadge.ts
import {
  combineCodec as combineCodec34,
  fixDecoderSize as fixDecoderSize26,
  fixEncoderSize as fixEncoderSize27,
  getBytesDecoder as getBytesDecoder26,
  getBytesEncoder as getBytesEncoder27,
  getStructDecoder as getStructDecoder31,
  getStructEncoder as getStructEncoder31,
  transformEncoder as transformEncoder24
} from "@solana/kit";
var DELETE_TOKEN_BADGE_DISCRIMINATOR = new Uint8Array([
  53,
  146,
  68,
  8,
  18,
  117,
  17,
  185
]);
function getDeleteTokenBadgeDiscriminatorBytes() {
  return fixEncoderSize27(getBytesEncoder27(), 8).encode(
    DELETE_TOKEN_BADGE_DISCRIMINATOR
  );
}
function getDeleteTokenBadgeInstructionDataEncoder() {
  return transformEncoder24(
    getStructEncoder31([["discriminator", fixEncoderSize27(getBytesEncoder27(), 8)]]),
    (value) => ({ ...value, discriminator: DELETE_TOKEN_BADGE_DISCRIMINATOR })
  );
}
function getDeleteTokenBadgeInstructionDataDecoder() {
  return getStructDecoder31([
    ["discriminator", fixDecoderSize26(getBytesDecoder26(), 8)]
  ]);
}
function getDeleteTokenBadgeInstructionDataCodec() {
  return combineCodec34(
    getDeleteTokenBadgeInstructionDataEncoder(),
    getDeleteTokenBadgeInstructionDataDecoder()
  );
}
function getDeleteTokenBadgeInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpoolsConfigExtension: {
      value: input.whirlpoolsConfigExtension ?? null,
      isWritable: false
    },
    tokenBadgeAuthority: {
      value: input.tokenBadgeAuthority ?? null,
      isWritable: false
    },
    tokenMint: { value: input.tokenMint ?? null, isWritable: false },
    tokenBadge: { value: input.tokenBadge ?? null, isWritable: true },
    receiver: { value: input.receiver ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpoolsConfigExtension),
      getAccountMeta(accounts.tokenBadgeAuthority),
      getAccountMeta(accounts.tokenMint),
      getAccountMeta(accounts.tokenBadge),
      getAccountMeta(accounts.receiver)
    ],
    programAddress,
    data: getDeleteTokenBadgeInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseDeleteTokenBadgeInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpoolsConfigExtension: getNextAccount(),
      tokenBadgeAuthority: getNextAccount(),
      tokenMint: getNextAccount(),
      tokenBadge: getNextAccount(),
      receiver: getNextAccount()
    },
    data: getDeleteTokenBadgeInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/increaseLiquidity.ts
import {
  combineCodec as combineCodec35,
  fixDecoderSize as fixDecoderSize27,
  fixEncoderSize as fixEncoderSize28,
  getBytesDecoder as getBytesDecoder27,
  getBytesEncoder as getBytesEncoder28,
  getStructDecoder as getStructDecoder32,
  getStructEncoder as getStructEncoder32,
  getU128Decoder as getU128Decoder8,
  getU128Encoder as getU128Encoder8,
  getU64Decoder as getU64Decoder9,
  getU64Encoder as getU64Encoder9,
  transformEncoder as transformEncoder25
} from "@solana/kit";
var INCREASE_LIQUIDITY_DISCRIMINATOR = new Uint8Array([
  46,
  156,
  243,
  118,
  13,
  205,
  251,
  178
]);
function getIncreaseLiquidityDiscriminatorBytes() {
  return fixEncoderSize28(getBytesEncoder28(), 8).encode(
    INCREASE_LIQUIDITY_DISCRIMINATOR
  );
}
function getIncreaseLiquidityInstructionDataEncoder() {
  return transformEncoder25(
    getStructEncoder32([
      ["discriminator", fixEncoderSize28(getBytesEncoder28(), 8)],
      ["liquidityAmount", getU128Encoder8()],
      ["tokenMaxA", getU64Encoder9()],
      ["tokenMaxB", getU64Encoder9()]
    ]),
    (value) => ({ ...value, discriminator: INCREASE_LIQUIDITY_DISCRIMINATOR })
  );
}
function getIncreaseLiquidityInstructionDataDecoder() {
  return getStructDecoder32([
    ["discriminator", fixDecoderSize27(getBytesDecoder27(), 8)],
    ["liquidityAmount", getU128Decoder8()],
    ["tokenMaxA", getU64Decoder9()],
    ["tokenMaxB", getU64Decoder9()]
  ]);
}
function getIncreaseLiquidityInstructionDataCodec() {
  return combineCodec35(
    getIncreaseLiquidityInstructionDataEncoder(),
    getIncreaseLiquidityInstructionDataDecoder()
  );
}
function getIncreaseLiquidityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper)
    ],
    programAddress,
    data: getIncreaseLiquidityInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseIncreaseLiquidityInstruction(instruction) {
  if (instruction.accounts.length < 11) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      tokenProgram: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tickArrayLower: getNextAccount(),
      tickArrayUpper: getNextAccount()
    },
    data: getIncreaseLiquidityInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/increaseLiquidityV2.ts
import {
  combineCodec as combineCodec36,
  fixDecoderSize as fixDecoderSize28,
  fixEncoderSize as fixEncoderSize29,
  getBytesDecoder as getBytesDecoder28,
  getBytesEncoder as getBytesEncoder29,
  getOptionDecoder as getOptionDecoder5,
  getOptionEncoder as getOptionEncoder5,
  getStructDecoder as getStructDecoder33,
  getStructEncoder as getStructEncoder33,
  getU128Decoder as getU128Decoder9,
  getU128Encoder as getU128Encoder9,
  getU64Decoder as getU64Decoder10,
  getU64Encoder as getU64Encoder10,
  transformEncoder as transformEncoder26
} from "@solana/kit";
var INCREASE_LIQUIDITY_V2_DISCRIMINATOR = new Uint8Array([
  133,
  29,
  89,
  223,
  69,
  238,
  176,
  10
]);
function getIncreaseLiquidityV2DiscriminatorBytes() {
  return fixEncoderSize29(getBytesEncoder29(), 8).encode(
    INCREASE_LIQUIDITY_V2_DISCRIMINATOR
  );
}
function getIncreaseLiquidityV2InstructionDataEncoder() {
  return transformEncoder26(
    getStructEncoder33([
      ["discriminator", fixEncoderSize29(getBytesEncoder29(), 8)],
      ["liquidityAmount", getU128Encoder9()],
      ["tokenMaxA", getU64Encoder10()],
      ["tokenMaxB", getU64Encoder10()],
      [
        "remainingAccountsInfo",
        getOptionEncoder5(getRemainingAccountsInfoEncoder())
      ]
    ]),
    (value) => ({
      ...value,
      discriminator: INCREASE_LIQUIDITY_V2_DISCRIMINATOR
    })
  );
}
function getIncreaseLiquidityV2InstructionDataDecoder() {
  return getStructDecoder33([
    ["discriminator", fixDecoderSize28(getBytesDecoder28(), 8)],
    ["liquidityAmount", getU128Decoder9()],
    ["tokenMaxA", getU64Decoder10()],
    ["tokenMaxB", getU64Decoder10()],
    [
      "remainingAccountsInfo",
      getOptionDecoder5(getRemainingAccountsInfoDecoder())
    ]
  ]);
}
function getIncreaseLiquidityV2InstructionDataCodec() {
  return combineCodec36(
    getIncreaseLiquidityV2InstructionDataEncoder(),
    getIncreaseLiquidityV2InstructionDataDecoder()
  );
}
function getIncreaseLiquidityV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },
    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenProgramA),
      getAccountMeta(accounts.tokenProgramB),
      getAccountMeta(accounts.memoProgram),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper)
    ],
    programAddress,
    data: getIncreaseLiquidityV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseIncreaseLiquidityV2Instruction(instruction) {
  if (instruction.accounts.length < 15) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      tokenProgramA: getNextAccount(),
      tokenProgramB: getNextAccount(),
      memoProgram: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tickArrayLower: getNextAccount(),
      tickArrayUpper: getNextAccount()
    },
    data: getIncreaseLiquidityV2InstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializeAdaptiveFeeTier.ts
import {
  combineCodec as combineCodec37,
  fixDecoderSize as fixDecoderSize29,
  fixEncoderSize as fixEncoderSize30,
  getAddressDecoder as getAddressDecoder13,
  getAddressEncoder as getAddressEncoder13,
  getBytesDecoder as getBytesDecoder29,
  getBytesEncoder as getBytesEncoder30,
  getStructDecoder as getStructDecoder34,
  getStructEncoder as getStructEncoder34,
  getU16Decoder as getU16Decoder7,
  getU16Encoder as getU16Encoder7,
  getU32Decoder as getU32Decoder4,
  getU32Encoder as getU32Encoder4,
  transformEncoder as transformEncoder27
} from "@solana/kit";
var INITIALIZE_ADAPTIVE_FEE_TIER_DISCRIMINATOR = new Uint8Array([
  77,
  99,
  208,
  200,
  141,
  123,
  117,
  48
]);
function getInitializeAdaptiveFeeTierDiscriminatorBytes() {
  return fixEncoderSize30(getBytesEncoder30(), 8).encode(
    INITIALIZE_ADAPTIVE_FEE_TIER_DISCRIMINATOR
  );
}
function getInitializeAdaptiveFeeTierInstructionDataEncoder() {
  return transformEncoder27(
    getStructEncoder34([
      ["discriminator", fixEncoderSize30(getBytesEncoder30(), 8)],
      ["feeTierIndex", getU16Encoder7()],
      ["tickSpacing", getU16Encoder7()],
      ["initializePoolAuthority", getAddressEncoder13()],
      ["delegatedFeeAuthority", getAddressEncoder13()],
      ["defaultBaseFeeRate", getU16Encoder7()],
      ["filterPeriod", getU16Encoder7()],
      ["decayPeriod", getU16Encoder7()],
      ["reductionFactor", getU16Encoder7()],
      ["adaptiveFeeControlFactor", getU32Encoder4()],
      ["maxVolatilityAccumulator", getU32Encoder4()],
      ["tickGroupSize", getU16Encoder7()],
      ["majorSwapThresholdTicks", getU16Encoder7()]
    ]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_ADAPTIVE_FEE_TIER_DISCRIMINATOR
    })
  );
}
function getInitializeAdaptiveFeeTierInstructionDataDecoder() {
  return getStructDecoder34([
    ["discriminator", fixDecoderSize29(getBytesDecoder29(), 8)],
    ["feeTierIndex", getU16Decoder7()],
    ["tickSpacing", getU16Decoder7()],
    ["initializePoolAuthority", getAddressDecoder13()],
    ["delegatedFeeAuthority", getAddressDecoder13()],
    ["defaultBaseFeeRate", getU16Decoder7()],
    ["filterPeriod", getU16Decoder7()],
    ["decayPeriod", getU16Decoder7()],
    ["reductionFactor", getU16Decoder7()],
    ["adaptiveFeeControlFactor", getU32Decoder4()],
    ["maxVolatilityAccumulator", getU32Decoder4()],
    ["tickGroupSize", getU16Decoder7()],
    ["majorSwapThresholdTicks", getU16Decoder7()]
  ]);
}
function getInitializeAdaptiveFeeTierInstructionDataCodec() {
  return combineCodec37(
    getInitializeAdaptiveFeeTierInstructionDataEncoder(),
    getInitializeAdaptiveFeeTierInstructionDataDecoder()
  );
}
function getInitializeAdaptiveFeeTierInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    adaptiveFeeTier: { value: input.adaptiveFeeTier ?? null, isWritable: true },
    funder: { value: input.funder ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.adaptiveFeeTier),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.feeAuthority),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getInitializeAdaptiveFeeTierInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeAdaptiveFeeTierInstruction(instruction) {
  if (instruction.accounts.length < 5) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      adaptiveFeeTier: getNextAccount(),
      funder: getNextAccount(),
      feeAuthority: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeAdaptiveFeeTierInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializeConfig.ts
import {
  combineCodec as combineCodec38,
  fixDecoderSize as fixDecoderSize30,
  fixEncoderSize as fixEncoderSize31,
  getAddressDecoder as getAddressDecoder14,
  getAddressEncoder as getAddressEncoder14,
  getBytesDecoder as getBytesDecoder30,
  getBytesEncoder as getBytesEncoder31,
  getStructDecoder as getStructDecoder35,
  getStructEncoder as getStructEncoder35,
  getU16Decoder as getU16Decoder8,
  getU16Encoder as getU16Encoder8,
  transformEncoder as transformEncoder28
} from "@solana/kit";
var INITIALIZE_CONFIG_DISCRIMINATOR = new Uint8Array([
  208,
  127,
  21,
  1,
  194,
  190,
  196,
  70
]);
function getInitializeConfigDiscriminatorBytes() {
  return fixEncoderSize31(getBytesEncoder31(), 8).encode(
    INITIALIZE_CONFIG_DISCRIMINATOR
  );
}
function getInitializeConfigInstructionDataEncoder() {
  return transformEncoder28(
    getStructEncoder35([
      ["discriminator", fixEncoderSize31(getBytesEncoder31(), 8)],
      ["feeAuthority", getAddressEncoder14()],
      ["collectProtocolFeesAuthority", getAddressEncoder14()],
      ["rewardEmissionsSuperAuthority", getAddressEncoder14()],
      ["defaultProtocolFeeRate", getU16Encoder8()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_CONFIG_DISCRIMINATOR })
  );
}
function getInitializeConfigInstructionDataDecoder() {
  return getStructDecoder35([
    ["discriminator", fixDecoderSize30(getBytesDecoder30(), 8)],
    ["feeAuthority", getAddressDecoder14()],
    ["collectProtocolFeesAuthority", getAddressDecoder14()],
    ["rewardEmissionsSuperAuthority", getAddressDecoder14()],
    ["defaultProtocolFeeRate", getU16Decoder8()]
  ]);
}
function getInitializeConfigInstructionDataCodec() {
  return combineCodec38(
    getInitializeConfigInstructionDataEncoder(),
    getInitializeConfigInstructionDataDecoder()
  );
}
function getInitializeConfigInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: true },
    funder: { value: input.funder ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.config),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getInitializeConfigInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeConfigInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      config: getNextAccount(),
      funder: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeConfigInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/initializeConfigExtension.ts
import {
  combineCodec as combineCodec39,
  fixDecoderSize as fixDecoderSize31,
  fixEncoderSize as fixEncoderSize32,
  getBytesDecoder as getBytesDecoder31,
  getBytesEncoder as getBytesEncoder32,
  getStructDecoder as getStructDecoder36,
  getStructEncoder as getStructEncoder36,
  transformEncoder as transformEncoder29
} from "@solana/kit";
var INITIALIZE_CONFIG_EXTENSION_DISCRIMINATOR = new Uint8Array([
  55,
  9,
  53,
  9,
  114,
  57,
  209,
  52
]);
function getInitializeConfigExtensionDiscriminatorBytes() {
  return fixEncoderSize32(getBytesEncoder32(), 8).encode(
    INITIALIZE_CONFIG_EXTENSION_DISCRIMINATOR
  );
}
function getInitializeConfigExtensionInstructionDataEncoder() {
  return transformEncoder29(
    getStructEncoder36([["discriminator", fixEncoderSize32(getBytesEncoder32(), 8)]]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_CONFIG_EXTENSION_DISCRIMINATOR
    })
  );
}
function getInitializeConfigExtensionInstructionDataDecoder() {
  return getStructDecoder36([
    ["discriminator", fixDecoderSize31(getBytesDecoder31(), 8)]
  ]);
}
function getInitializeConfigExtensionInstructionDataCodec() {
  return combineCodec39(
    getInitializeConfigExtensionInstructionDataEncoder(),
    getInitializeConfigExtensionInstructionDataDecoder()
  );
}
function getInitializeConfigExtensionInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: false },
    configExtension: { value: input.configExtension ?? null, isWritable: true },
    funder: { value: input.funder ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.config),
      getAccountMeta(accounts.configExtension),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.feeAuthority),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getInitializeConfigExtensionInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseInitializeConfigExtensionInstruction(instruction) {
  if (instruction.accounts.length < 5) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      config: getNextAccount(),
      configExtension: getNextAccount(),
      funder: getNextAccount(),
      feeAuthority: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeConfigExtensionInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializeFeeTier.ts
import {
  combineCodec as combineCodec40,
  fixDecoderSize as fixDecoderSize32,
  fixEncoderSize as fixEncoderSize33,
  getBytesDecoder as getBytesDecoder32,
  getBytesEncoder as getBytesEncoder33,
  getStructDecoder as getStructDecoder37,
  getStructEncoder as getStructEncoder37,
  getU16Decoder as getU16Decoder9,
  getU16Encoder as getU16Encoder9,
  transformEncoder as transformEncoder30
} from "@solana/kit";
var INITIALIZE_FEE_TIER_DISCRIMINATOR = new Uint8Array([
  183,
  74,
  156,
  160,
  112,
  2,
  42,
  30
]);
function getInitializeFeeTierDiscriminatorBytes() {
  return fixEncoderSize33(getBytesEncoder33(), 8).encode(
    INITIALIZE_FEE_TIER_DISCRIMINATOR
  );
}
function getInitializeFeeTierInstructionDataEncoder() {
  return transformEncoder30(
    getStructEncoder37([
      ["discriminator", fixEncoderSize33(getBytesEncoder33(), 8)],
      ["tickSpacing", getU16Encoder9()],
      ["defaultFeeRate", getU16Encoder9()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_FEE_TIER_DISCRIMINATOR })
  );
}
function getInitializeFeeTierInstructionDataDecoder() {
  return getStructDecoder37([
    ["discriminator", fixDecoderSize32(getBytesDecoder32(), 8)],
    ["tickSpacing", getU16Decoder9()],
    ["defaultFeeRate", getU16Decoder9()]
  ]);
}
function getInitializeFeeTierInstructionDataCodec() {
  return combineCodec40(
    getInitializeFeeTierInstructionDataEncoder(),
    getInitializeFeeTierInstructionDataDecoder()
  );
}
function getInitializeFeeTierInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: false },
    feeTier: { value: input.feeTier ?? null, isWritable: true },
    funder: { value: input.funder ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.config),
      getAccountMeta(accounts.feeTier),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.feeAuthority),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getInitializeFeeTierInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeFeeTierInstruction(instruction) {
  if (instruction.accounts.length < 5) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      config: getNextAccount(),
      feeTier: getNextAccount(),
      funder: getNextAccount(),
      feeAuthority: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeFeeTierInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/initializePool.ts
import {
  combineCodec as combineCodec41,
  fixDecoderSize as fixDecoderSize33,
  fixEncoderSize as fixEncoderSize34,
  getBytesDecoder as getBytesDecoder33,
  getBytesEncoder as getBytesEncoder34,
  getStructDecoder as getStructDecoder38,
  getStructEncoder as getStructEncoder38,
  getU128Decoder as getU128Decoder10,
  getU128Encoder as getU128Encoder10,
  getU16Decoder as getU16Decoder10,
  getU16Encoder as getU16Encoder10,
  getU8Decoder as getU8Decoder4,
  getU8Encoder as getU8Encoder4,
  transformEncoder as transformEncoder31
} from "@solana/kit";
var INITIALIZE_POOL_DISCRIMINATOR = new Uint8Array([
  95,
  180,
  10,
  172,
  84,
  174,
  232,
  40
]);
function getInitializePoolDiscriminatorBytes() {
  return fixEncoderSize34(getBytesEncoder34(), 8).encode(
    INITIALIZE_POOL_DISCRIMINATOR
  );
}
function getInitializePoolInstructionDataEncoder() {
  return transformEncoder31(
    getStructEncoder38([
      ["discriminator", fixEncoderSize34(getBytesEncoder34(), 8)],
      ["whirlpoolBump", getU8Encoder4()],
      ["tickSpacing", getU16Encoder10()],
      ["initialSqrtPrice", getU128Encoder10()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_POOL_DISCRIMINATOR })
  );
}
function getInitializePoolInstructionDataDecoder() {
  return getStructDecoder38([
    ["discriminator", fixDecoderSize33(getBytesDecoder33(), 8)],
    ["whirlpoolBump", getU8Decoder4()],
    ["tickSpacing", getU16Decoder10()],
    ["initialSqrtPrice", getU128Decoder10()]
  ]);
}
function getInitializePoolInstructionDataCodec() {
  return combineCodec41(
    getInitializePoolInstructionDataEncoder(),
    getInitializePoolInstructionDataDecoder()
  );
}
function getInitializePoolInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    funder: { value: input.funder ?? null, isWritable: true },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    feeTier: { value: input.feeTier ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.feeTier),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent)
    ],
    programAddress,
    data: getInitializePoolInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializePoolInstruction(instruction) {
  if (instruction.accounts.length < 11) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      funder: getNextAccount(),
      whirlpool: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      feeTier: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount()
    },
    data: getInitializePoolInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/initializePoolV2.ts
import {
  combineCodec as combineCodec42,
  fixDecoderSize as fixDecoderSize34,
  fixEncoderSize as fixEncoderSize35,
  getBytesDecoder as getBytesDecoder34,
  getBytesEncoder as getBytesEncoder35,
  getStructDecoder as getStructDecoder39,
  getStructEncoder as getStructEncoder39,
  getU128Decoder as getU128Decoder11,
  getU128Encoder as getU128Encoder11,
  getU16Decoder as getU16Decoder11,
  getU16Encoder as getU16Encoder11,
  transformEncoder as transformEncoder32
} from "@solana/kit";
var INITIALIZE_POOL_V2_DISCRIMINATOR = new Uint8Array([
  207,
  45,
  87,
  242,
  27,
  63,
  204,
  67
]);
function getInitializePoolV2DiscriminatorBytes() {
  return fixEncoderSize35(getBytesEncoder35(), 8).encode(
    INITIALIZE_POOL_V2_DISCRIMINATOR
  );
}
function getInitializePoolV2InstructionDataEncoder() {
  return transformEncoder32(
    getStructEncoder39([
      ["discriminator", fixEncoderSize35(getBytesEncoder35(), 8)],
      ["tickSpacing", getU16Encoder11()],
      ["initialSqrtPrice", getU128Encoder11()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_POOL_V2_DISCRIMINATOR })
  );
}
function getInitializePoolV2InstructionDataDecoder() {
  return getStructDecoder39([
    ["discriminator", fixDecoderSize34(getBytesDecoder34(), 8)],
    ["tickSpacing", getU16Decoder11()],
    ["initialSqrtPrice", getU128Decoder11()]
  ]);
}
function getInitializePoolV2InstructionDataCodec() {
  return combineCodec42(
    getInitializePoolV2InstructionDataEncoder(),
    getInitializePoolV2InstructionDataDecoder()
  );
}
function getInitializePoolV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    tokenBadgeA: { value: input.tokenBadgeA ?? null, isWritable: false },
    tokenBadgeB: { value: input.tokenBadgeB ?? null, isWritable: false },
    funder: { value: input.funder ?? null, isWritable: true },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    feeTier: { value: input.feeTier ?? null, isWritable: false },
    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },
    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.tokenBadgeA),
      getAccountMeta(accounts.tokenBadgeB),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.feeTier),
      getAccountMeta(accounts.tokenProgramA),
      getAccountMeta(accounts.tokenProgramB),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent)
    ],
    programAddress,
    data: getInitializePoolV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializePoolV2Instruction(instruction) {
  if (instruction.accounts.length < 14) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      tokenBadgeA: getNextAccount(),
      tokenBadgeB: getNextAccount(),
      funder: getNextAccount(),
      whirlpool: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      feeTier: getNextAccount(),
      tokenProgramA: getNextAccount(),
      tokenProgramB: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount()
    },
    data: getInitializePoolV2InstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/initializePoolWithAdaptiveFee.ts
import {
  combineCodec as combineCodec43,
  fixDecoderSize as fixDecoderSize35,
  fixEncoderSize as fixEncoderSize36,
  getBytesDecoder as getBytesDecoder35,
  getBytesEncoder as getBytesEncoder36,
  getOptionDecoder as getOptionDecoder6,
  getOptionEncoder as getOptionEncoder6,
  getStructDecoder as getStructDecoder40,
  getStructEncoder as getStructEncoder40,
  getU128Decoder as getU128Decoder12,
  getU128Encoder as getU128Encoder12,
  getU64Decoder as getU64Decoder11,
  getU64Encoder as getU64Encoder11,
  transformEncoder as transformEncoder33
} from "@solana/kit";
var INITIALIZE_POOL_WITH_ADAPTIVE_FEE_DISCRIMINATOR = new Uint8Array([
  143,
  94,
  96,
  76,
  172,
  124,
  119,
  199
]);
function getInitializePoolWithAdaptiveFeeDiscriminatorBytes() {
  return fixEncoderSize36(getBytesEncoder36(), 8).encode(
    INITIALIZE_POOL_WITH_ADAPTIVE_FEE_DISCRIMINATOR
  );
}
function getInitializePoolWithAdaptiveFeeInstructionDataEncoder() {
  return transformEncoder33(
    getStructEncoder40([
      ["discriminator", fixEncoderSize36(getBytesEncoder36(), 8)],
      ["initialSqrtPrice", getU128Encoder12()],
      ["tradeEnableTimestamp", getOptionEncoder6(getU64Encoder11())]
    ]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_POOL_WITH_ADAPTIVE_FEE_DISCRIMINATOR
    })
  );
}
function getInitializePoolWithAdaptiveFeeInstructionDataDecoder() {
  return getStructDecoder40([
    ["discriminator", fixDecoderSize35(getBytesDecoder35(), 8)],
    ["initialSqrtPrice", getU128Decoder12()],
    ["tradeEnableTimestamp", getOptionDecoder6(getU64Decoder11())]
  ]);
}
function getInitializePoolWithAdaptiveFeeInstructionDataCodec() {
  return combineCodec43(
    getInitializePoolWithAdaptiveFeeInstructionDataEncoder(),
    getInitializePoolWithAdaptiveFeeInstructionDataDecoder()
  );
}
function getInitializePoolWithAdaptiveFeeInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    tokenBadgeA: { value: input.tokenBadgeA ?? null, isWritable: false },
    tokenBadgeB: { value: input.tokenBadgeB ?? null, isWritable: false },
    funder: { value: input.funder ?? null, isWritable: true },
    initializePoolAuthority: {
      value: input.initializePoolAuthority ?? null,
      isWritable: false
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    oracle: { value: input.oracle ?? null, isWritable: true },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    adaptiveFeeTier: {
      value: input.adaptiveFeeTier ?? null,
      isWritable: false
    },
    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },
    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.tokenBadgeA),
      getAccountMeta(accounts.tokenBadgeB),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.initializePoolAuthority),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.oracle),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.adaptiveFeeTier),
      getAccountMeta(accounts.tokenProgramA),
      getAccountMeta(accounts.tokenProgramB),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent)
    ],
    programAddress,
    data: getInitializePoolWithAdaptiveFeeInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializePoolWithAdaptiveFeeInstruction(instruction) {
  if (instruction.accounts.length < 16) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      tokenBadgeA: getNextAccount(),
      tokenBadgeB: getNextAccount(),
      funder: getNextAccount(),
      initializePoolAuthority: getNextAccount(),
      whirlpool: getNextAccount(),
      oracle: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      adaptiveFeeTier: getNextAccount(),
      tokenProgramA: getNextAccount(),
      tokenProgramB: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount()
    },
    data: getInitializePoolWithAdaptiveFeeInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializePositionBundle.ts
import {
  combineCodec as combineCodec44,
  fixDecoderSize as fixDecoderSize36,
  fixEncoderSize as fixEncoderSize37,
  getBytesDecoder as getBytesDecoder36,
  getBytesEncoder as getBytesEncoder37,
  getStructDecoder as getStructDecoder41,
  getStructEncoder as getStructEncoder41,
  transformEncoder as transformEncoder34
} from "@solana/kit";
var INITIALIZE_POSITION_BUNDLE_DISCRIMINATOR = new Uint8Array([
  117,
  45,
  241,
  149,
  24,
  18,
  194,
  65
]);
function getInitializePositionBundleDiscriminatorBytes() {
  return fixEncoderSize37(getBytesEncoder37(), 8).encode(
    INITIALIZE_POSITION_BUNDLE_DISCRIMINATOR
  );
}
function getInitializePositionBundleInstructionDataEncoder() {
  return transformEncoder34(
    getStructEncoder41([["discriminator", fixEncoderSize37(getBytesEncoder37(), 8)]]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_POSITION_BUNDLE_DISCRIMINATOR
    })
  );
}
function getInitializePositionBundleInstructionDataDecoder() {
  return getStructDecoder41([
    ["discriminator", fixDecoderSize36(getBytesDecoder36(), 8)]
  ]);
}
function getInitializePositionBundleInstructionDataCodec() {
  return combineCodec44(
    getInitializePositionBundleInstructionDataEncoder(),
    getInitializePositionBundleInstructionDataDecoder()
  );
}
function getInitializePositionBundleInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    positionBundle: { value: input.positionBundle ?? null, isWritable: true },
    positionBundleMint: {
      value: input.positionBundleMint ?? null,
      isWritable: true
    },
    positionBundleTokenAccount: {
      value: input.positionBundleTokenAccount ?? null,
      isWritable: true
    },
    positionBundleOwner: {
      value: input.positionBundleOwner ?? null,
      isWritable: false
    },
    funder: { value: input.funder ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.positionBundle),
      getAccountMeta(accounts.positionBundleMint),
      getAccountMeta(accounts.positionBundleTokenAccount),
      getAccountMeta(accounts.positionBundleOwner),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.associatedTokenProgram)
    ],
    programAddress,
    data: getInitializePositionBundleInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseInitializePositionBundleInstruction(instruction) {
  if (instruction.accounts.length < 9) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      positionBundle: getNextAccount(),
      positionBundleMint: getNextAccount(),
      positionBundleTokenAccount: getNextAccount(),
      positionBundleOwner: getNextAccount(),
      funder: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount(),
      associatedTokenProgram: getNextAccount()
    },
    data: getInitializePositionBundleInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializePositionBundleWithMetadata.ts
import {
  combineCodec as combineCodec45,
  fixDecoderSize as fixDecoderSize37,
  fixEncoderSize as fixEncoderSize38,
  getBytesDecoder as getBytesDecoder37,
  getBytesEncoder as getBytesEncoder38,
  getStructDecoder as getStructDecoder42,
  getStructEncoder as getStructEncoder42,
  transformEncoder as transformEncoder35
} from "@solana/kit";
var INITIALIZE_POSITION_BUNDLE_WITH_METADATA_DISCRIMINATOR = new Uint8Array([93, 124, 16, 179, 249, 131, 115, 245]);
function getInitializePositionBundleWithMetadataDiscriminatorBytes() {
  return fixEncoderSize38(getBytesEncoder38(), 8).encode(
    INITIALIZE_POSITION_BUNDLE_WITH_METADATA_DISCRIMINATOR
  );
}
function getInitializePositionBundleWithMetadataInstructionDataEncoder() {
  return transformEncoder35(
    getStructEncoder42([["discriminator", fixEncoderSize38(getBytesEncoder38(), 8)]]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_POSITION_BUNDLE_WITH_METADATA_DISCRIMINATOR
    })
  );
}
function getInitializePositionBundleWithMetadataInstructionDataDecoder() {
  return getStructDecoder42([
    ["discriminator", fixDecoderSize37(getBytesDecoder37(), 8)]
  ]);
}
function getInitializePositionBundleWithMetadataInstructionDataCodec() {
  return combineCodec45(
    getInitializePositionBundleWithMetadataInstructionDataEncoder(),
    getInitializePositionBundleWithMetadataInstructionDataDecoder()
  );
}
function getInitializePositionBundleWithMetadataInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    positionBundle: { value: input.positionBundle ?? null, isWritable: true },
    positionBundleMint: {
      value: input.positionBundleMint ?? null,
      isWritable: true
    },
    positionBundleMetadata: {
      value: input.positionBundleMetadata ?? null,
      isWritable: true
    },
    positionBundleTokenAccount: {
      value: input.positionBundleTokenAccount ?? null,
      isWritable: true
    },
    positionBundleOwner: {
      value: input.positionBundleOwner ?? null,
      isWritable: false
    },
    funder: { value: input.funder ?? null, isWritable: true },
    metadataUpdateAuth: {
      value: input.metadataUpdateAuth ?? null,
      isWritable: false
    },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false
    },
    metadataProgram: {
      value: input.metadataProgram ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.positionBundle),
      getAccountMeta(accounts.positionBundleMint),
      getAccountMeta(accounts.positionBundleMetadata),
      getAccountMeta(accounts.positionBundleTokenAccount),
      getAccountMeta(accounts.positionBundleOwner),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.metadataUpdateAuth),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.metadataProgram)
    ],
    programAddress,
    data: getInitializePositionBundleWithMetadataInstructionDataEncoder().encode(
      {}
    )
  };
  return instruction;
}
function parseInitializePositionBundleWithMetadataInstruction(instruction) {
  if (instruction.accounts.length < 12) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      positionBundle: getNextAccount(),
      positionBundleMint: getNextAccount(),
      positionBundleMetadata: getNextAccount(),
      positionBundleTokenAccount: getNextAccount(),
      positionBundleOwner: getNextAccount(),
      funder: getNextAccount(),
      metadataUpdateAuth: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount(),
      associatedTokenProgram: getNextAccount(),
      metadataProgram: getNextAccount()
    },
    data: getInitializePositionBundleWithMetadataInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializeReward.ts
import {
  combineCodec as combineCodec46,
  fixDecoderSize as fixDecoderSize38,
  fixEncoderSize as fixEncoderSize39,
  getBytesDecoder as getBytesDecoder38,
  getBytesEncoder as getBytesEncoder39,
  getStructDecoder as getStructDecoder43,
  getStructEncoder as getStructEncoder43,
  getU8Decoder as getU8Decoder5,
  getU8Encoder as getU8Encoder5,
  transformEncoder as transformEncoder36
} from "@solana/kit";
var INITIALIZE_REWARD_DISCRIMINATOR = new Uint8Array([
  95,
  135,
  192,
  196,
  242,
  129,
  230,
  68
]);
function getInitializeRewardDiscriminatorBytes() {
  return fixEncoderSize39(getBytesEncoder39(), 8).encode(
    INITIALIZE_REWARD_DISCRIMINATOR
  );
}
function getInitializeRewardInstructionDataEncoder() {
  return transformEncoder36(
    getStructEncoder43([
      ["discriminator", fixEncoderSize39(getBytesEncoder39(), 8)],
      ["rewardIndex", getU8Encoder5()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_REWARD_DISCRIMINATOR })
  );
}
function getInitializeRewardInstructionDataDecoder() {
  return getStructDecoder43([
    ["discriminator", fixDecoderSize38(getBytesDecoder38(), 8)],
    ["rewardIndex", getU8Decoder5()]
  ]);
}
function getInitializeRewardInstructionDataCodec() {
  return combineCodec46(
    getInitializeRewardInstructionDataEncoder(),
    getInitializeRewardInstructionDataDecoder()
  );
}
function getInitializeRewardInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    rewardAuthority: {
      value: input.rewardAuthority ?? null,
      isWritable: false
    },
    funder: { value: input.funder ?? null, isWritable: true },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    rewardMint: { value: input.rewardMint ?? null, isWritable: false },
    rewardVault: { value: input.rewardVault ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.rewardAuthority),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.rewardMint),
      getAccountMeta(accounts.rewardVault),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent)
    ],
    programAddress,
    data: getInitializeRewardInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeRewardInstruction(instruction) {
  if (instruction.accounts.length < 8) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      rewardAuthority: getNextAccount(),
      funder: getNextAccount(),
      whirlpool: getNextAccount(),
      rewardMint: getNextAccount(),
      rewardVault: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount()
    },
    data: getInitializeRewardInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/initializeRewardV2.ts
import {
  combineCodec as combineCodec47,
  fixDecoderSize as fixDecoderSize39,
  fixEncoderSize as fixEncoderSize40,
  getBytesDecoder as getBytesDecoder39,
  getBytesEncoder as getBytesEncoder40,
  getStructDecoder as getStructDecoder44,
  getStructEncoder as getStructEncoder44,
  getU8Decoder as getU8Decoder6,
  getU8Encoder as getU8Encoder6,
  transformEncoder as transformEncoder37
} from "@solana/kit";
var INITIALIZE_REWARD_V2_DISCRIMINATOR = new Uint8Array([
  91,
  1,
  77,
  50,
  235,
  229,
  133,
  49
]);
function getInitializeRewardV2DiscriminatorBytes() {
  return fixEncoderSize40(getBytesEncoder40(), 8).encode(
    INITIALIZE_REWARD_V2_DISCRIMINATOR
  );
}
function getInitializeRewardV2InstructionDataEncoder() {
  return transformEncoder37(
    getStructEncoder44([
      ["discriminator", fixEncoderSize40(getBytesEncoder40(), 8)],
      ["rewardIndex", getU8Encoder6()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_REWARD_V2_DISCRIMINATOR })
  );
}
function getInitializeRewardV2InstructionDataDecoder() {
  return getStructDecoder44([
    ["discriminator", fixDecoderSize39(getBytesDecoder39(), 8)],
    ["rewardIndex", getU8Decoder6()]
  ]);
}
function getInitializeRewardV2InstructionDataCodec() {
  return combineCodec47(
    getInitializeRewardV2InstructionDataEncoder(),
    getInitializeRewardV2InstructionDataDecoder()
  );
}
function getInitializeRewardV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    rewardAuthority: {
      value: input.rewardAuthority ?? null,
      isWritable: false
    },
    funder: { value: input.funder ?? null, isWritable: true },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    rewardMint: { value: input.rewardMint ?? null, isWritable: false },
    rewardTokenBadge: {
      value: input.rewardTokenBadge ?? null,
      isWritable: false
    },
    rewardVault: { value: input.rewardVault ?? null, isWritable: true },
    rewardTokenProgram: {
      value: input.rewardTokenProgram ?? null,
      isWritable: false
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.rewardAuthority),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.rewardMint),
      getAccountMeta(accounts.rewardTokenBadge),
      getAccountMeta(accounts.rewardVault),
      getAccountMeta(accounts.rewardTokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent)
    ],
    programAddress,
    data: getInitializeRewardV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeRewardV2Instruction(instruction) {
  if (instruction.accounts.length < 9) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      rewardAuthority: getNextAccount(),
      funder: getNextAccount(),
      whirlpool: getNextAccount(),
      rewardMint: getNextAccount(),
      rewardTokenBadge: getNextAccount(),
      rewardVault: getNextAccount(),
      rewardTokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount()
    },
    data: getInitializeRewardV2InstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializeTickArray.ts
import {
  combineCodec as combineCodec48,
  fixDecoderSize as fixDecoderSize40,
  fixEncoderSize as fixEncoderSize41,
  getBytesDecoder as getBytesDecoder40,
  getBytesEncoder as getBytesEncoder41,
  getI32Decoder as getI32Decoder5,
  getI32Encoder as getI32Encoder5,
  getStructDecoder as getStructDecoder45,
  getStructEncoder as getStructEncoder45,
  transformEncoder as transformEncoder38
} from "@solana/kit";
var INITIALIZE_TICK_ARRAY_DISCRIMINATOR = new Uint8Array([
  11,
  188,
  193,
  214,
  141,
  91,
  149,
  184
]);
function getInitializeTickArrayDiscriminatorBytes() {
  return fixEncoderSize41(getBytesEncoder41(), 8).encode(
    INITIALIZE_TICK_ARRAY_DISCRIMINATOR
  );
}
function getInitializeTickArrayInstructionDataEncoder() {
  return transformEncoder38(
    getStructEncoder45([
      ["discriminator", fixEncoderSize41(getBytesEncoder41(), 8)],
      ["startTickIndex", getI32Encoder5()]
    ]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_TICK_ARRAY_DISCRIMINATOR
    })
  );
}
function getInitializeTickArrayInstructionDataDecoder() {
  return getStructDecoder45([
    ["discriminator", fixDecoderSize40(getBytesDecoder40(), 8)],
    ["startTickIndex", getI32Decoder5()]
  ]);
}
function getInitializeTickArrayInstructionDataCodec() {
  return combineCodec48(
    getInitializeTickArrayInstructionDataEncoder(),
    getInitializeTickArrayInstructionDataDecoder()
  );
}
function getInitializeTickArrayInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    funder: { value: input.funder ?? null, isWritable: true },
    tickArray: { value: input.tickArray ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.tickArray),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getInitializeTickArrayInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeTickArrayInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      funder: getNextAccount(),
      tickArray: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeTickArrayInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializeTokenBadge.ts
import {
  combineCodec as combineCodec49,
  fixDecoderSize as fixDecoderSize41,
  fixEncoderSize as fixEncoderSize42,
  getBytesDecoder as getBytesDecoder41,
  getBytesEncoder as getBytesEncoder42,
  getStructDecoder as getStructDecoder46,
  getStructEncoder as getStructEncoder46,
  transformEncoder as transformEncoder39
} from "@solana/kit";
var INITIALIZE_TOKEN_BADGE_DISCRIMINATOR = new Uint8Array([
  253,
  77,
  205,
  95,
  27,
  224,
  89,
  223
]);
function getInitializeTokenBadgeDiscriminatorBytes() {
  return fixEncoderSize42(getBytesEncoder42(), 8).encode(
    INITIALIZE_TOKEN_BADGE_DISCRIMINATOR
  );
}
function getInitializeTokenBadgeInstructionDataEncoder() {
  return transformEncoder39(
    getStructEncoder46([["discriminator", fixEncoderSize42(getBytesEncoder42(), 8)]]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_TOKEN_BADGE_DISCRIMINATOR
    })
  );
}
function getInitializeTokenBadgeInstructionDataDecoder() {
  return getStructDecoder46([
    ["discriminator", fixDecoderSize41(getBytesDecoder41(), 8)]
  ]);
}
function getInitializeTokenBadgeInstructionDataCodec() {
  return combineCodec49(
    getInitializeTokenBadgeInstructionDataEncoder(),
    getInitializeTokenBadgeInstructionDataDecoder()
  );
}
function getInitializeTokenBadgeInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpoolsConfigExtension: {
      value: input.whirlpoolsConfigExtension ?? null,
      isWritable: false
    },
    tokenBadgeAuthority: {
      value: input.tokenBadgeAuthority ?? null,
      isWritable: false
    },
    tokenMint: { value: input.tokenMint ?? null, isWritable: false },
    tokenBadge: { value: input.tokenBadge ?? null, isWritable: true },
    funder: { value: input.funder ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpoolsConfigExtension),
      getAccountMeta(accounts.tokenBadgeAuthority),
      getAccountMeta(accounts.tokenMint),
      getAccountMeta(accounts.tokenBadge),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getInitializeTokenBadgeInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseInitializeTokenBadgeInstruction(instruction) {
  if (instruction.accounts.length < 7) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpoolsConfigExtension: getNextAccount(),
      tokenBadgeAuthority: getNextAccount(),
      tokenMint: getNextAccount(),
      tokenBadge: getNextAccount(),
      funder: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeTokenBadgeInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/lockPosition.ts
import {
  combineCodec as combineCodec50,
  fixDecoderSize as fixDecoderSize42,
  fixEncoderSize as fixEncoderSize43,
  getBytesDecoder as getBytesDecoder42,
  getBytesEncoder as getBytesEncoder43,
  getStructDecoder as getStructDecoder47,
  getStructEncoder as getStructEncoder47,
  transformEncoder as transformEncoder40
} from "@solana/kit";
var LOCK_POSITION_DISCRIMINATOR = new Uint8Array([
  227,
  62,
  2,
  252,
  247,
  10,
  171,
  185
]);
function getLockPositionDiscriminatorBytes() {
  return fixEncoderSize43(getBytesEncoder43(), 8).encode(
    LOCK_POSITION_DISCRIMINATOR
  );
}
function getLockPositionInstructionDataEncoder() {
  return transformEncoder40(
    getStructEncoder47([
      ["discriminator", fixEncoderSize43(getBytesEncoder43(), 8)],
      ["lockType", getLockTypeEncoder()]
    ]),
    (value) => ({ ...value, discriminator: LOCK_POSITION_DISCRIMINATOR })
  );
}
function getLockPositionInstructionDataDecoder() {
  return getStructDecoder47([
    ["discriminator", fixDecoderSize42(getBytesDecoder42(), 8)],
    ["lockType", getLockTypeDecoder()]
  ]);
}
function getLockPositionInstructionDataCodec() {
  return combineCodec50(
    getLockPositionInstructionDataEncoder(),
    getLockPositionInstructionDataDecoder()
  );
}
function getLockPositionInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    funder: { value: input.funder ?? null, isWritable: true },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: false },
    positionMint: { value: input.positionMint ?? null, isWritable: false },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: true
    },
    lockConfig: { value: input.lockConfig ?? null, isWritable: true },
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    token2022Program: {
      value: input.token2022Program ?? null,
      isWritable: false
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionMint),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.lockConfig),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.token2022Program),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getLockPositionInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseLockPositionInstruction(instruction) {
  if (instruction.accounts.length < 9) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      funder: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionMint: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      lockConfig: getNextAccount(),
      whirlpool: getNextAccount(),
      token2022Program: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getLockPositionInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/openBundledPosition.ts
import {
  combineCodec as combineCodec51,
  fixDecoderSize as fixDecoderSize43,
  fixEncoderSize as fixEncoderSize44,
  getBytesDecoder as getBytesDecoder43,
  getBytesEncoder as getBytesEncoder44,
  getI32Decoder as getI32Decoder6,
  getI32Encoder as getI32Encoder6,
  getStructDecoder as getStructDecoder48,
  getStructEncoder as getStructEncoder48,
  getU16Decoder as getU16Decoder12,
  getU16Encoder as getU16Encoder12,
  transformEncoder as transformEncoder41
} from "@solana/kit";
var OPEN_BUNDLED_POSITION_DISCRIMINATOR = new Uint8Array([
  169,
  113,
  126,
  171,
  213,
  172,
  212,
  49
]);
function getOpenBundledPositionDiscriminatorBytes() {
  return fixEncoderSize44(getBytesEncoder44(), 8).encode(
    OPEN_BUNDLED_POSITION_DISCRIMINATOR
  );
}
function getOpenBundledPositionInstructionDataEncoder() {
  return transformEncoder41(
    getStructEncoder48([
      ["discriminator", fixEncoderSize44(getBytesEncoder44(), 8)],
      ["bundleIndex", getU16Encoder12()],
      ["tickLowerIndex", getI32Encoder6()],
      ["tickUpperIndex", getI32Encoder6()]
    ]),
    (value) => ({
      ...value,
      discriminator: OPEN_BUNDLED_POSITION_DISCRIMINATOR
    })
  );
}
function getOpenBundledPositionInstructionDataDecoder() {
  return getStructDecoder48([
    ["discriminator", fixDecoderSize43(getBytesDecoder43(), 8)],
    ["bundleIndex", getU16Decoder12()],
    ["tickLowerIndex", getI32Decoder6()],
    ["tickUpperIndex", getI32Decoder6()]
  ]);
}
function getOpenBundledPositionInstructionDataCodec() {
  return combineCodec51(
    getOpenBundledPositionInstructionDataEncoder(),
    getOpenBundledPositionInstructionDataDecoder()
  );
}
function getOpenBundledPositionInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    bundledPosition: { value: input.bundledPosition ?? null, isWritable: true },
    positionBundle: { value: input.positionBundle ?? null, isWritable: true },
    positionBundleTokenAccount: {
      value: input.positionBundleTokenAccount ?? null,
      isWritable: false
    },
    positionBundleAuthority: {
      value: input.positionBundleAuthority ?? null,
      isWritable: false
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    funder: { value: input.funder ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.bundledPosition),
      getAccountMeta(accounts.positionBundle),
      getAccountMeta(accounts.positionBundleTokenAccount),
      getAccountMeta(accounts.positionBundleAuthority),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent)
    ],
    programAddress,
    data: getOpenBundledPositionInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseOpenBundledPositionInstruction(instruction) {
  if (instruction.accounts.length < 8) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      bundledPosition: getNextAccount(),
      positionBundle: getNextAccount(),
      positionBundleTokenAccount: getNextAccount(),
      positionBundleAuthority: getNextAccount(),
      whirlpool: getNextAccount(),
      funder: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount()
    },
    data: getOpenBundledPositionInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/openPosition.ts
import {
  combineCodec as combineCodec52,
  fixDecoderSize as fixDecoderSize44,
  fixEncoderSize as fixEncoderSize45,
  getBytesDecoder as getBytesDecoder44,
  getBytesEncoder as getBytesEncoder45,
  getI32Decoder as getI32Decoder7,
  getI32Encoder as getI32Encoder7,
  getStructDecoder as getStructDecoder49,
  getStructEncoder as getStructEncoder49,
  getU8Decoder as getU8Decoder7,
  getU8Encoder as getU8Encoder7,
  transformEncoder as transformEncoder42
} from "@solana/kit";
var OPEN_POSITION_DISCRIMINATOR = new Uint8Array([
  135,
  128,
  47,
  77,
  15,
  152,
  240,
  49
]);
function getOpenPositionDiscriminatorBytes() {
  return fixEncoderSize45(getBytesEncoder45(), 8).encode(
    OPEN_POSITION_DISCRIMINATOR
  );
}
function getOpenPositionInstructionDataEncoder() {
  return transformEncoder42(
    getStructEncoder49([
      ["discriminator", fixEncoderSize45(getBytesEncoder45(), 8)],
      ["positionBump", getU8Encoder7()],
      ["tickLowerIndex", getI32Encoder7()],
      ["tickUpperIndex", getI32Encoder7()]
    ]),
    (value) => ({ ...value, discriminator: OPEN_POSITION_DISCRIMINATOR })
  );
}
function getOpenPositionInstructionDataDecoder() {
  return getStructDecoder49([
    ["discriminator", fixDecoderSize44(getBytesDecoder44(), 8)],
    ["positionBump", getU8Decoder7()],
    ["tickLowerIndex", getI32Decoder7()],
    ["tickUpperIndex", getI32Decoder7()]
  ]);
}
function getOpenPositionInstructionDataCodec() {
  return combineCodec52(
    getOpenPositionInstructionDataEncoder(),
    getOpenPositionInstructionDataDecoder()
  );
}
function getOpenPositionInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    funder: { value: input.funder ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false },
    position: { value: input.position ?? null, isWritable: true },
    positionMint: { value: input.positionMint ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: true
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionMint),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.associatedTokenProgram)
    ],
    programAddress,
    data: getOpenPositionInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseOpenPositionInstruction(instruction) {
  if (instruction.accounts.length < 10) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      funder: getNextAccount(),
      owner: getNextAccount(),
      position: getNextAccount(),
      positionMint: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      whirlpool: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount(),
      associatedTokenProgram: getNextAccount()
    },
    data: getOpenPositionInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/openPositionWithMetadata.ts
import {
  combineCodec as combineCodec53,
  fixDecoderSize as fixDecoderSize45,
  fixEncoderSize as fixEncoderSize46,
  getBytesDecoder as getBytesDecoder45,
  getBytesEncoder as getBytesEncoder46,
  getI32Decoder as getI32Decoder8,
  getI32Encoder as getI32Encoder8,
  getStructDecoder as getStructDecoder50,
  getStructEncoder as getStructEncoder50,
  getU8Decoder as getU8Decoder8,
  getU8Encoder as getU8Encoder8,
  transformEncoder as transformEncoder43
} from "@solana/kit";
var OPEN_POSITION_WITH_METADATA_DISCRIMINATOR = new Uint8Array([
  242,
  29,
  134,
  48,
  58,
  110,
  14,
  60
]);
function getOpenPositionWithMetadataDiscriminatorBytes() {
  return fixEncoderSize46(getBytesEncoder46(), 8).encode(
    OPEN_POSITION_WITH_METADATA_DISCRIMINATOR
  );
}
function getOpenPositionWithMetadataInstructionDataEncoder() {
  return transformEncoder43(
    getStructEncoder50([
      ["discriminator", fixEncoderSize46(getBytesEncoder46(), 8)],
      ["positionBump", getU8Encoder8()],
      ["metadataBump", getU8Encoder8()],
      ["tickLowerIndex", getI32Encoder8()],
      ["tickUpperIndex", getI32Encoder8()]
    ]),
    (value) => ({
      ...value,
      discriminator: OPEN_POSITION_WITH_METADATA_DISCRIMINATOR
    })
  );
}
function getOpenPositionWithMetadataInstructionDataDecoder() {
  return getStructDecoder50([
    ["discriminator", fixDecoderSize45(getBytesDecoder45(), 8)],
    ["positionBump", getU8Decoder8()],
    ["metadataBump", getU8Decoder8()],
    ["tickLowerIndex", getI32Decoder8()],
    ["tickUpperIndex", getI32Decoder8()]
  ]);
}
function getOpenPositionWithMetadataInstructionDataCodec() {
  return combineCodec53(
    getOpenPositionWithMetadataInstructionDataEncoder(),
    getOpenPositionWithMetadataInstructionDataDecoder()
  );
}
function getOpenPositionWithMetadataInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    funder: { value: input.funder ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false },
    position: { value: input.position ?? null, isWritable: true },
    positionMint: { value: input.positionMint ?? null, isWritable: true },
    positionMetadataAccount: {
      value: input.positionMetadataAccount ?? null,
      isWritable: true
    },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: true
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false
    },
    metadataProgram: {
      value: input.metadataProgram ?? null,
      isWritable: false
    },
    metadataUpdateAuth: {
      value: input.metadataUpdateAuth ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionMint),
      getAccountMeta(accounts.positionMetadataAccount),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.metadataProgram),
      getAccountMeta(accounts.metadataUpdateAuth)
    ],
    programAddress,
    data: getOpenPositionWithMetadataInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseOpenPositionWithMetadataInstruction(instruction) {
  if (instruction.accounts.length < 13) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      funder: getNextAccount(),
      owner: getNextAccount(),
      position: getNextAccount(),
      positionMint: getNextAccount(),
      positionMetadataAccount: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      whirlpool: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount(),
      associatedTokenProgram: getNextAccount(),
      metadataProgram: getNextAccount(),
      metadataUpdateAuth: getNextAccount()
    },
    data: getOpenPositionWithMetadataInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/openPositionWithTokenExtensions.ts
import {
  combineCodec as combineCodec54,
  fixDecoderSize as fixDecoderSize46,
  fixEncoderSize as fixEncoderSize47,
  getBooleanDecoder as getBooleanDecoder2,
  getBooleanEncoder as getBooleanEncoder2,
  getBytesDecoder as getBytesDecoder46,
  getBytesEncoder as getBytesEncoder47,
  getI32Decoder as getI32Decoder9,
  getI32Encoder as getI32Encoder9,
  getStructDecoder as getStructDecoder51,
  getStructEncoder as getStructEncoder51,
  transformEncoder as transformEncoder44
} from "@solana/kit";
var OPEN_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR = new Uint8Array(
  [212, 47, 95, 92, 114, 102, 131, 250]
);
function getOpenPositionWithTokenExtensionsDiscriminatorBytes() {
  return fixEncoderSize47(getBytesEncoder47(), 8).encode(
    OPEN_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR
  );
}
function getOpenPositionWithTokenExtensionsInstructionDataEncoder() {
  return transformEncoder44(
    getStructEncoder51([
      ["discriminator", fixEncoderSize47(getBytesEncoder47(), 8)],
      ["tickLowerIndex", getI32Encoder9()],
      ["tickUpperIndex", getI32Encoder9()],
      ["withTokenMetadataExtension", getBooleanEncoder2()]
    ]),
    (value) => ({
      ...value,
      discriminator: OPEN_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR
    })
  );
}
function getOpenPositionWithTokenExtensionsInstructionDataDecoder() {
  return getStructDecoder51([
    ["discriminator", fixDecoderSize46(getBytesDecoder46(), 8)],
    ["tickLowerIndex", getI32Decoder9()],
    ["tickUpperIndex", getI32Decoder9()],
    ["withTokenMetadataExtension", getBooleanDecoder2()]
  ]);
}
function getOpenPositionWithTokenExtensionsInstructionDataCodec() {
  return combineCodec54(
    getOpenPositionWithTokenExtensionsInstructionDataEncoder(),
    getOpenPositionWithTokenExtensionsInstructionDataDecoder()
  );
}
function getOpenPositionWithTokenExtensionsInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    funder: { value: input.funder ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false },
    position: { value: input.position ?? null, isWritable: true },
    positionMint: { value: input.positionMint ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: true
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    token2022Program: {
      value: input.token2022Program ?? null,
      isWritable: false
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false
    },
    metadataUpdateAuth: {
      value: input.metadataUpdateAuth ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionMint),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.token2022Program),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.metadataUpdateAuth)
    ],
    programAddress,
    data: getOpenPositionWithTokenExtensionsInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseOpenPositionWithTokenExtensionsInstruction(instruction) {
  if (instruction.accounts.length < 10) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      funder: getNextAccount(),
      owner: getNextAccount(),
      position: getNextAccount(),
      positionMint: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      whirlpool: getNextAccount(),
      token2022Program: getNextAccount(),
      systemProgram: getNextAccount(),
      associatedTokenProgram: getNextAccount(),
      metadataUpdateAuth: getNextAccount()
    },
    data: getOpenPositionWithTokenExtensionsInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/resetPositionRange.ts
import {
  combineCodec as combineCodec55,
  fixDecoderSize as fixDecoderSize47,
  fixEncoderSize as fixEncoderSize48,
  getBytesDecoder as getBytesDecoder47,
  getBytesEncoder as getBytesEncoder48,
  getI32Decoder as getI32Decoder10,
  getI32Encoder as getI32Encoder10,
  getStructDecoder as getStructDecoder52,
  getStructEncoder as getStructEncoder52,
  transformEncoder as transformEncoder45
} from "@solana/kit";
var RESET_POSITION_RANGE_DISCRIMINATOR = new Uint8Array([
  164,
  123,
  180,
  141,
  194,
  100,
  160,
  175
]);
function getResetPositionRangeDiscriminatorBytes() {
  return fixEncoderSize48(getBytesEncoder48(), 8).encode(
    RESET_POSITION_RANGE_DISCRIMINATOR
  );
}
function getResetPositionRangeInstructionDataEncoder() {
  return transformEncoder45(
    getStructEncoder52([
      ["discriminator", fixEncoderSize48(getBytesEncoder48(), 8)],
      ["newTickLowerIndex", getI32Encoder10()],
      ["newTickUpperIndex", getI32Encoder10()]
    ]),
    (value) => ({ ...value, discriminator: RESET_POSITION_RANGE_DISCRIMINATOR })
  );
}
function getResetPositionRangeInstructionDataDecoder() {
  return getStructDecoder52([
    ["discriminator", fixDecoderSize47(getBytesDecoder47(), 8)],
    ["newTickLowerIndex", getI32Decoder10()],
    ["newTickUpperIndex", getI32Decoder10()]
  ]);
}
function getResetPositionRangeInstructionDataCodec() {
  return combineCodec55(
    getResetPositionRangeInstructionDataEncoder(),
    getResetPositionRangeInstructionDataDecoder()
  );
}
function getResetPositionRangeInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    funder: { value: input.funder ?? null, isWritable: true },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getResetPositionRangeInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseResetPositionRangeInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      funder: getNextAccount(),
      positionAuthority: getNextAccount(),
      whirlpool: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getResetPositionRangeInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setCollectProtocolFeesAuthority.ts
import {
  combineCodec as combineCodec56,
  fixDecoderSize as fixDecoderSize48,
  fixEncoderSize as fixEncoderSize49,
  getBytesDecoder as getBytesDecoder48,
  getBytesEncoder as getBytesEncoder49,
  getStructDecoder as getStructDecoder53,
  getStructEncoder as getStructEncoder53,
  transformEncoder as transformEncoder46
} from "@solana/kit";
var SET_COLLECT_PROTOCOL_FEES_AUTHORITY_DISCRIMINATOR = new Uint8Array(
  [34, 150, 93, 244, 139, 225, 233, 67]
);
function getSetCollectProtocolFeesAuthorityDiscriminatorBytes() {
  return fixEncoderSize49(getBytesEncoder49(), 8).encode(
    SET_COLLECT_PROTOCOL_FEES_AUTHORITY_DISCRIMINATOR
  );
}
function getSetCollectProtocolFeesAuthorityInstructionDataEncoder() {
  return transformEncoder46(
    getStructEncoder53([["discriminator", fixEncoderSize49(getBytesEncoder49(), 8)]]),
    (value) => ({
      ...value,
      discriminator: SET_COLLECT_PROTOCOL_FEES_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getSetCollectProtocolFeesAuthorityInstructionDataDecoder() {
  return getStructDecoder53([
    ["discriminator", fixDecoderSize48(getBytesDecoder48(), 8)]
  ]);
}
function getSetCollectProtocolFeesAuthorityInstructionDataCodec() {
  return combineCodec56(
    getSetCollectProtocolFeesAuthorityInstructionDataEncoder(),
    getSetCollectProtocolFeesAuthorityInstructionDataDecoder()
  );
}
function getSetCollectProtocolFeesAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: true
    },
    collectProtocolFeesAuthority: {
      value: input.collectProtocolFeesAuthority ?? null,
      isWritable: false
    },
    newCollectProtocolFeesAuthority: {
      value: input.newCollectProtocolFeesAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.collectProtocolFeesAuthority),
      getAccountMeta(accounts.newCollectProtocolFeesAuthority)
    ],
    programAddress,
    data: getSetCollectProtocolFeesAuthorityInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseSetCollectProtocolFeesAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      collectProtocolFeesAuthority: getNextAccount(),
      newCollectProtocolFeesAuthority: getNextAccount()
    },
    data: getSetCollectProtocolFeesAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setConfigExtensionAuthority.ts
import {
  combineCodec as combineCodec57,
  fixDecoderSize as fixDecoderSize49,
  fixEncoderSize as fixEncoderSize50,
  getBytesDecoder as getBytesDecoder49,
  getBytesEncoder as getBytesEncoder50,
  getStructDecoder as getStructDecoder54,
  getStructEncoder as getStructEncoder54,
  transformEncoder as transformEncoder47
} from "@solana/kit";
var SET_CONFIG_EXTENSION_AUTHORITY_DISCRIMINATOR = new Uint8Array([
  44,
  94,
  241,
  116,
  24,
  188,
  60,
  143
]);
function getSetConfigExtensionAuthorityDiscriminatorBytes() {
  return fixEncoderSize50(getBytesEncoder50(), 8).encode(
    SET_CONFIG_EXTENSION_AUTHORITY_DISCRIMINATOR
  );
}
function getSetConfigExtensionAuthorityInstructionDataEncoder() {
  return transformEncoder47(
    getStructEncoder54([["discriminator", fixEncoderSize50(getBytesEncoder50(), 8)]]),
    (value) => ({
      ...value,
      discriminator: SET_CONFIG_EXTENSION_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getSetConfigExtensionAuthorityInstructionDataDecoder() {
  return getStructDecoder54([
    ["discriminator", fixDecoderSize49(getBytesDecoder49(), 8)]
  ]);
}
function getSetConfigExtensionAuthorityInstructionDataCodec() {
  return combineCodec57(
    getSetConfigExtensionAuthorityInstructionDataEncoder(),
    getSetConfigExtensionAuthorityInstructionDataDecoder()
  );
}
function getSetConfigExtensionAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpoolsConfigExtension: {
      value: input.whirlpoolsConfigExtension ?? null,
      isWritable: true
    },
    configExtensionAuthority: {
      value: input.configExtensionAuthority ?? null,
      isWritable: false
    },
    newConfigExtensionAuthority: {
      value: input.newConfigExtensionAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpoolsConfigExtension),
      getAccountMeta(accounts.configExtensionAuthority),
      getAccountMeta(accounts.newConfigExtensionAuthority)
    ],
    programAddress,
    data: getSetConfigExtensionAuthorityInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseSetConfigExtensionAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpoolsConfigExtension: getNextAccount(),
      configExtensionAuthority: getNextAccount(),
      newConfigExtensionAuthority: getNextAccount()
    },
    data: getSetConfigExtensionAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setDefaultBaseFeeRate.ts
import {
  combineCodec as combineCodec58,
  fixDecoderSize as fixDecoderSize50,
  fixEncoderSize as fixEncoderSize51,
  getBytesDecoder as getBytesDecoder50,
  getBytesEncoder as getBytesEncoder51,
  getStructDecoder as getStructDecoder55,
  getStructEncoder as getStructEncoder55,
  getU16Decoder as getU16Decoder13,
  getU16Encoder as getU16Encoder13,
  transformEncoder as transformEncoder48
} from "@solana/kit";
var SET_DEFAULT_BASE_FEE_RATE_DISCRIMINATOR = new Uint8Array([
  229,
  66,
  84,
  251,
  164,
  134,
  183,
  7
]);
function getSetDefaultBaseFeeRateDiscriminatorBytes() {
  return fixEncoderSize51(getBytesEncoder51(), 8).encode(
    SET_DEFAULT_BASE_FEE_RATE_DISCRIMINATOR
  );
}
function getSetDefaultBaseFeeRateInstructionDataEncoder() {
  return transformEncoder48(
    getStructEncoder55([
      ["discriminator", fixEncoderSize51(getBytesEncoder51(), 8)],
      ["defaultBaseFeeRate", getU16Encoder13()]
    ]),
    (value) => ({
      ...value,
      discriminator: SET_DEFAULT_BASE_FEE_RATE_DISCRIMINATOR
    })
  );
}
function getSetDefaultBaseFeeRateInstructionDataDecoder() {
  return getStructDecoder55([
    ["discriminator", fixDecoderSize50(getBytesDecoder50(), 8)],
    ["defaultBaseFeeRate", getU16Decoder13()]
  ]);
}
function getSetDefaultBaseFeeRateInstructionDataCodec() {
  return combineCodec58(
    getSetDefaultBaseFeeRateInstructionDataEncoder(),
    getSetDefaultBaseFeeRateInstructionDataDecoder()
  );
}
function getSetDefaultBaseFeeRateInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    adaptiveFeeTier: { value: input.adaptiveFeeTier ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.adaptiveFeeTier),
      getAccountMeta(accounts.feeAuthority)
    ],
    programAddress,
    data: getSetDefaultBaseFeeRateInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetDefaultBaseFeeRateInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      adaptiveFeeTier: getNextAccount(),
      feeAuthority: getNextAccount()
    },
    data: getSetDefaultBaseFeeRateInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setDefaultFeeRate.ts
import {
  combineCodec as combineCodec59,
  fixDecoderSize as fixDecoderSize51,
  fixEncoderSize as fixEncoderSize52,
  getBytesDecoder as getBytesDecoder51,
  getBytesEncoder as getBytesEncoder52,
  getStructDecoder as getStructDecoder56,
  getStructEncoder as getStructEncoder56,
  getU16Decoder as getU16Decoder14,
  getU16Encoder as getU16Encoder14,
  transformEncoder as transformEncoder49
} from "@solana/kit";
var SET_DEFAULT_FEE_RATE_DISCRIMINATOR = new Uint8Array([
  118,
  215,
  214,
  157,
  182,
  229,
  208,
  228
]);
function getSetDefaultFeeRateDiscriminatorBytes() {
  return fixEncoderSize52(getBytesEncoder52(), 8).encode(
    SET_DEFAULT_FEE_RATE_DISCRIMINATOR
  );
}
function getSetDefaultFeeRateInstructionDataEncoder() {
  return transformEncoder49(
    getStructEncoder56([
      ["discriminator", fixEncoderSize52(getBytesEncoder52(), 8)],
      ["defaultFeeRate", getU16Encoder14()]
    ]),
    (value) => ({ ...value, discriminator: SET_DEFAULT_FEE_RATE_DISCRIMINATOR })
  );
}
function getSetDefaultFeeRateInstructionDataDecoder() {
  return getStructDecoder56([
    ["discriminator", fixDecoderSize51(getBytesDecoder51(), 8)],
    ["defaultFeeRate", getU16Decoder14()]
  ]);
}
function getSetDefaultFeeRateInstructionDataCodec() {
  return combineCodec59(
    getSetDefaultFeeRateInstructionDataEncoder(),
    getSetDefaultFeeRateInstructionDataDecoder()
  );
}
function getSetDefaultFeeRateInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    feeTier: { value: input.feeTier ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.feeTier),
      getAccountMeta(accounts.feeAuthority)
    ],
    programAddress,
    data: getSetDefaultFeeRateInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetDefaultFeeRateInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      feeTier: getNextAccount(),
      feeAuthority: getNextAccount()
    },
    data: getSetDefaultFeeRateInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/setDefaultProtocolFeeRate.ts
import {
  combineCodec as combineCodec60,
  fixDecoderSize as fixDecoderSize52,
  fixEncoderSize as fixEncoderSize53,
  getBytesDecoder as getBytesDecoder52,
  getBytesEncoder as getBytesEncoder53,
  getStructDecoder as getStructDecoder57,
  getStructEncoder as getStructEncoder57,
  getU16Decoder as getU16Decoder15,
  getU16Encoder as getU16Encoder15,
  transformEncoder as transformEncoder50
} from "@solana/kit";
var SET_DEFAULT_PROTOCOL_FEE_RATE_DISCRIMINATOR = new Uint8Array([
  107,
  205,
  249,
  226,
  151,
  35,
  86,
  0
]);
function getSetDefaultProtocolFeeRateDiscriminatorBytes() {
  return fixEncoderSize53(getBytesEncoder53(), 8).encode(
    SET_DEFAULT_PROTOCOL_FEE_RATE_DISCRIMINATOR
  );
}
function getSetDefaultProtocolFeeRateInstructionDataEncoder() {
  return transformEncoder50(
    getStructEncoder57([
      ["discriminator", fixEncoderSize53(getBytesEncoder53(), 8)],
      ["defaultProtocolFeeRate", getU16Encoder15()]
    ]),
    (value) => ({
      ...value,
      discriminator: SET_DEFAULT_PROTOCOL_FEE_RATE_DISCRIMINATOR
    })
  );
}
function getSetDefaultProtocolFeeRateInstructionDataDecoder() {
  return getStructDecoder57([
    ["discriminator", fixDecoderSize52(getBytesDecoder52(), 8)],
    ["defaultProtocolFeeRate", getU16Decoder15()]
  ]);
}
function getSetDefaultProtocolFeeRateInstructionDataCodec() {
  return combineCodec60(
    getSetDefaultProtocolFeeRateInstructionDataEncoder(),
    getSetDefaultProtocolFeeRateInstructionDataDecoder()
  );
}
function getSetDefaultProtocolFeeRateInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: true
    },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.feeAuthority)
    ],
    programAddress,
    data: getSetDefaultProtocolFeeRateInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetDefaultProtocolFeeRateInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      feeAuthority: getNextAccount()
    },
    data: getSetDefaultProtocolFeeRateInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setDelegatedFeeAuthority.ts
import {
  combineCodec as combineCodec61,
  fixDecoderSize as fixDecoderSize53,
  fixEncoderSize as fixEncoderSize54,
  getBytesDecoder as getBytesDecoder53,
  getBytesEncoder as getBytesEncoder54,
  getStructDecoder as getStructDecoder58,
  getStructEncoder as getStructEncoder58,
  transformEncoder as transformEncoder51
} from "@solana/kit";
var SET_DELEGATED_FEE_AUTHORITY_DISCRIMINATOR = new Uint8Array([
  193,
  234,
  231,
  147,
  138,
  57,
  3,
  122
]);
function getSetDelegatedFeeAuthorityDiscriminatorBytes() {
  return fixEncoderSize54(getBytesEncoder54(), 8).encode(
    SET_DELEGATED_FEE_AUTHORITY_DISCRIMINATOR
  );
}
function getSetDelegatedFeeAuthorityInstructionDataEncoder() {
  return transformEncoder51(
    getStructEncoder58([["discriminator", fixEncoderSize54(getBytesEncoder54(), 8)]]),
    (value) => ({
      ...value,
      discriminator: SET_DELEGATED_FEE_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getSetDelegatedFeeAuthorityInstructionDataDecoder() {
  return getStructDecoder58([
    ["discriminator", fixDecoderSize53(getBytesDecoder53(), 8)]
  ]);
}
function getSetDelegatedFeeAuthorityInstructionDataCodec() {
  return combineCodec61(
    getSetDelegatedFeeAuthorityInstructionDataEncoder(),
    getSetDelegatedFeeAuthorityInstructionDataDecoder()
  );
}
function getSetDelegatedFeeAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    adaptiveFeeTier: { value: input.adaptiveFeeTier ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },
    newDelegatedFeeAuthority: {
      value: input.newDelegatedFeeAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.adaptiveFeeTier),
      getAccountMeta(accounts.feeAuthority),
      getAccountMeta(accounts.newDelegatedFeeAuthority)
    ],
    programAddress,
    data: getSetDelegatedFeeAuthorityInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseSetDelegatedFeeAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      adaptiveFeeTier: getNextAccount(),
      feeAuthority: getNextAccount(),
      newDelegatedFeeAuthority: getNextAccount()
    },
    data: getSetDelegatedFeeAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setFeeAuthority.ts
import {
  combineCodec as combineCodec62,
  fixDecoderSize as fixDecoderSize54,
  fixEncoderSize as fixEncoderSize55,
  getBytesDecoder as getBytesDecoder54,
  getBytesEncoder as getBytesEncoder55,
  getStructDecoder as getStructDecoder59,
  getStructEncoder as getStructEncoder59,
  transformEncoder as transformEncoder52
} from "@solana/kit";
var SET_FEE_AUTHORITY_DISCRIMINATOR = new Uint8Array([
  31,
  1,
  50,
  87,
  237,
  101,
  97,
  132
]);
function getSetFeeAuthorityDiscriminatorBytes() {
  return fixEncoderSize55(getBytesEncoder55(), 8).encode(
    SET_FEE_AUTHORITY_DISCRIMINATOR
  );
}
function getSetFeeAuthorityInstructionDataEncoder() {
  return transformEncoder52(
    getStructEncoder59([["discriminator", fixEncoderSize55(getBytesEncoder55(), 8)]]),
    (value) => ({ ...value, discriminator: SET_FEE_AUTHORITY_DISCRIMINATOR })
  );
}
function getSetFeeAuthorityInstructionDataDecoder() {
  return getStructDecoder59([
    ["discriminator", fixDecoderSize54(getBytesDecoder54(), 8)]
  ]);
}
function getSetFeeAuthorityInstructionDataCodec() {
  return combineCodec62(
    getSetFeeAuthorityInstructionDataEncoder(),
    getSetFeeAuthorityInstructionDataDecoder()
  );
}
function getSetFeeAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: true
    },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },
    newFeeAuthority: {
      value: input.newFeeAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.feeAuthority),
      getAccountMeta(accounts.newFeeAuthority)
    ],
    programAddress,
    data: getSetFeeAuthorityInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseSetFeeAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      feeAuthority: getNextAccount(),
      newFeeAuthority: getNextAccount()
    },
    data: getSetFeeAuthorityInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/setFeeRate.ts
import {
  combineCodec as combineCodec63,
  fixDecoderSize as fixDecoderSize55,
  fixEncoderSize as fixEncoderSize56,
  getBytesDecoder as getBytesDecoder55,
  getBytesEncoder as getBytesEncoder56,
  getStructDecoder as getStructDecoder60,
  getStructEncoder as getStructEncoder60,
  getU16Decoder as getU16Decoder16,
  getU16Encoder as getU16Encoder16,
  transformEncoder as transformEncoder53
} from "@solana/kit";
var SET_FEE_RATE_DISCRIMINATOR = new Uint8Array([
  53,
  243,
  137,
  65,
  8,
  140,
  158,
  6
]);
function getSetFeeRateDiscriminatorBytes() {
  return fixEncoderSize56(getBytesEncoder56(), 8).encode(
    SET_FEE_RATE_DISCRIMINATOR
  );
}
function getSetFeeRateInstructionDataEncoder() {
  return transformEncoder53(
    getStructEncoder60([
      ["discriminator", fixEncoderSize56(getBytesEncoder56(), 8)],
      ["feeRate", getU16Encoder16()]
    ]),
    (value) => ({ ...value, discriminator: SET_FEE_RATE_DISCRIMINATOR })
  );
}
function getSetFeeRateInstructionDataDecoder() {
  return getStructDecoder60([
    ["discriminator", fixDecoderSize55(getBytesDecoder55(), 8)],
    ["feeRate", getU16Decoder16()]
  ]);
}
function getSetFeeRateInstructionDataCodec() {
  return combineCodec63(
    getSetFeeRateInstructionDataEncoder(),
    getSetFeeRateInstructionDataDecoder()
  );
}
function getSetFeeRateInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.feeAuthority)
    ],
    programAddress,
    data: getSetFeeRateInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetFeeRateInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpool: getNextAccount(),
      feeAuthority: getNextAccount()
    },
    data: getSetFeeRateInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/setFeeRateByDelegatedFeeAuthority.ts
import {
  combineCodec as combineCodec64,
  fixDecoderSize as fixDecoderSize56,
  fixEncoderSize as fixEncoderSize57,
  getBytesDecoder as getBytesDecoder56,
  getBytesEncoder as getBytesEncoder57,
  getStructDecoder as getStructDecoder61,
  getStructEncoder as getStructEncoder61,
  getU16Decoder as getU16Decoder17,
  getU16Encoder as getU16Encoder17,
  transformEncoder as transformEncoder54
} from "@solana/kit";
var SET_FEE_RATE_BY_DELEGATED_FEE_AUTHORITY_DISCRIMINATOR = new Uint8Array([121, 121, 54, 114, 131, 230, 162, 104]);
function getSetFeeRateByDelegatedFeeAuthorityDiscriminatorBytes() {
  return fixEncoderSize57(getBytesEncoder57(), 8).encode(
    SET_FEE_RATE_BY_DELEGATED_FEE_AUTHORITY_DISCRIMINATOR
  );
}
function getSetFeeRateByDelegatedFeeAuthorityInstructionDataEncoder() {
  return transformEncoder54(
    getStructEncoder61([
      ["discriminator", fixEncoderSize57(getBytesEncoder57(), 8)],
      ["feeRate", getU16Encoder17()]
    ]),
    (value) => ({
      ...value,
      discriminator: SET_FEE_RATE_BY_DELEGATED_FEE_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getSetFeeRateByDelegatedFeeAuthorityInstructionDataDecoder() {
  return getStructDecoder61([
    ["discriminator", fixDecoderSize56(getBytesDecoder56(), 8)],
    ["feeRate", getU16Decoder17()]
  ]);
}
function getSetFeeRateByDelegatedFeeAuthorityInstructionDataCodec() {
  return combineCodec64(
    getSetFeeRateByDelegatedFeeAuthorityInstructionDataEncoder(),
    getSetFeeRateByDelegatedFeeAuthorityInstructionDataDecoder()
  );
}
function getSetFeeRateByDelegatedFeeAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    adaptiveFeeTier: {
      value: input.adaptiveFeeTier ?? null,
      isWritable: false
    },
    delegatedFeeAuthority: {
      value: input.delegatedFeeAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.adaptiveFeeTier),
      getAccountMeta(accounts.delegatedFeeAuthority)
    ],
    programAddress,
    data: getSetFeeRateByDelegatedFeeAuthorityInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetFeeRateByDelegatedFeeAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      adaptiveFeeTier: getNextAccount(),
      delegatedFeeAuthority: getNextAccount()
    },
    data: getSetFeeRateByDelegatedFeeAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setInitializePoolAuthority.ts
import {
  combineCodec as combineCodec65,
  fixDecoderSize as fixDecoderSize57,
  fixEncoderSize as fixEncoderSize58,
  getBytesDecoder as getBytesDecoder57,
  getBytesEncoder as getBytesEncoder58,
  getStructDecoder as getStructDecoder62,
  getStructEncoder as getStructEncoder62,
  transformEncoder as transformEncoder55
} from "@solana/kit";
var SET_INITIALIZE_POOL_AUTHORITY_DISCRIMINATOR = new Uint8Array([
  125,
  43,
  127,
  235,
  149,
  26,
  106,
  236
]);
function getSetInitializePoolAuthorityDiscriminatorBytes() {
  return fixEncoderSize58(getBytesEncoder58(), 8).encode(
    SET_INITIALIZE_POOL_AUTHORITY_DISCRIMINATOR
  );
}
function getSetInitializePoolAuthorityInstructionDataEncoder() {
  return transformEncoder55(
    getStructEncoder62([["discriminator", fixEncoderSize58(getBytesEncoder58(), 8)]]),
    (value) => ({
      ...value,
      discriminator: SET_INITIALIZE_POOL_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getSetInitializePoolAuthorityInstructionDataDecoder() {
  return getStructDecoder62([
    ["discriminator", fixDecoderSize57(getBytesDecoder57(), 8)]
  ]);
}
function getSetInitializePoolAuthorityInstructionDataCodec() {
  return combineCodec65(
    getSetInitializePoolAuthorityInstructionDataEncoder(),
    getSetInitializePoolAuthorityInstructionDataDecoder()
  );
}
function getSetInitializePoolAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    adaptiveFeeTier: { value: input.adaptiveFeeTier ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },
    newInitializePoolAuthority: {
      value: input.newInitializePoolAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.adaptiveFeeTier),
      getAccountMeta(accounts.feeAuthority),
      getAccountMeta(accounts.newInitializePoolAuthority)
    ],
    programAddress,
    data: getSetInitializePoolAuthorityInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseSetInitializePoolAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      adaptiveFeeTier: getNextAccount(),
      feeAuthority: getNextAccount(),
      newInitializePoolAuthority: getNextAccount()
    },
    data: getSetInitializePoolAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setPresetAdaptiveFeeConstants.ts
import {
  combineCodec as combineCodec66,
  fixDecoderSize as fixDecoderSize58,
  fixEncoderSize as fixEncoderSize59,
  getBytesDecoder as getBytesDecoder58,
  getBytesEncoder as getBytesEncoder59,
  getStructDecoder as getStructDecoder63,
  getStructEncoder as getStructEncoder63,
  getU16Decoder as getU16Decoder18,
  getU16Encoder as getU16Encoder18,
  getU32Decoder as getU32Decoder5,
  getU32Encoder as getU32Encoder5,
  transformEncoder as transformEncoder56
} from "@solana/kit";
var SET_PRESET_ADAPTIVE_FEE_CONSTANTS_DISCRIMINATOR = new Uint8Array([
  132,
  185,
  66,
  148,
  83,
  88,
  134,
  198
]);
function getSetPresetAdaptiveFeeConstantsDiscriminatorBytes() {
  return fixEncoderSize59(getBytesEncoder59(), 8).encode(
    SET_PRESET_ADAPTIVE_FEE_CONSTANTS_DISCRIMINATOR
  );
}
function getSetPresetAdaptiveFeeConstantsInstructionDataEncoder() {
  return transformEncoder56(
    getStructEncoder63([
      ["discriminator", fixEncoderSize59(getBytesEncoder59(), 8)],
      ["filterPeriod", getU16Encoder18()],
      ["decayPeriod", getU16Encoder18()],
      ["reductionFactor", getU16Encoder18()],
      ["adaptiveFeeControlFactor", getU32Encoder5()],
      ["maxVolatilityAccumulator", getU32Encoder5()],
      ["tickGroupSize", getU16Encoder18()],
      ["majorSwapThresholdTicks", getU16Encoder18()]
    ]),
    (value) => ({
      ...value,
      discriminator: SET_PRESET_ADAPTIVE_FEE_CONSTANTS_DISCRIMINATOR
    })
  );
}
function getSetPresetAdaptiveFeeConstantsInstructionDataDecoder() {
  return getStructDecoder63([
    ["discriminator", fixDecoderSize58(getBytesDecoder58(), 8)],
    ["filterPeriod", getU16Decoder18()],
    ["decayPeriod", getU16Decoder18()],
    ["reductionFactor", getU16Decoder18()],
    ["adaptiveFeeControlFactor", getU32Decoder5()],
    ["maxVolatilityAccumulator", getU32Decoder5()],
    ["tickGroupSize", getU16Decoder18()],
    ["majorSwapThresholdTicks", getU16Decoder18()]
  ]);
}
function getSetPresetAdaptiveFeeConstantsInstructionDataCodec() {
  return combineCodec66(
    getSetPresetAdaptiveFeeConstantsInstructionDataEncoder(),
    getSetPresetAdaptiveFeeConstantsInstructionDataDecoder()
  );
}
function getSetPresetAdaptiveFeeConstantsInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    adaptiveFeeTier: { value: input.adaptiveFeeTier ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.adaptiveFeeTier),
      getAccountMeta(accounts.feeAuthority)
    ],
    programAddress,
    data: getSetPresetAdaptiveFeeConstantsInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetPresetAdaptiveFeeConstantsInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      adaptiveFeeTier: getNextAccount(),
      feeAuthority: getNextAccount()
    },
    data: getSetPresetAdaptiveFeeConstantsInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setProtocolFeeRate.ts
import {
  combineCodec as combineCodec67,
  fixDecoderSize as fixDecoderSize59,
  fixEncoderSize as fixEncoderSize60,
  getBytesDecoder as getBytesDecoder59,
  getBytesEncoder as getBytesEncoder60,
  getStructDecoder as getStructDecoder64,
  getStructEncoder as getStructEncoder64,
  getU16Decoder as getU16Decoder19,
  getU16Encoder as getU16Encoder19,
  transformEncoder as transformEncoder57
} from "@solana/kit";
var SET_PROTOCOL_FEE_RATE_DISCRIMINATOR = new Uint8Array([
  95,
  7,
  4,
  50,
  154,
  79,
  156,
  131
]);
function getSetProtocolFeeRateDiscriminatorBytes() {
  return fixEncoderSize60(getBytesEncoder60(), 8).encode(
    SET_PROTOCOL_FEE_RATE_DISCRIMINATOR
  );
}
function getSetProtocolFeeRateInstructionDataEncoder() {
  return transformEncoder57(
    getStructEncoder64([
      ["discriminator", fixEncoderSize60(getBytesEncoder60(), 8)],
      ["protocolFeeRate", getU16Encoder19()]
    ]),
    (value) => ({
      ...value,
      discriminator: SET_PROTOCOL_FEE_RATE_DISCRIMINATOR
    })
  );
}
function getSetProtocolFeeRateInstructionDataDecoder() {
  return getStructDecoder64([
    ["discriminator", fixDecoderSize59(getBytesDecoder59(), 8)],
    ["protocolFeeRate", getU16Decoder19()]
  ]);
}
function getSetProtocolFeeRateInstructionDataCodec() {
  return combineCodec67(
    getSetProtocolFeeRateInstructionDataEncoder(),
    getSetProtocolFeeRateInstructionDataDecoder()
  );
}
function getSetProtocolFeeRateInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.feeAuthority)
    ],
    programAddress,
    data: getSetProtocolFeeRateInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetProtocolFeeRateInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpool: getNextAccount(),
      feeAuthority: getNextAccount()
    },
    data: getSetProtocolFeeRateInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setRewardAuthority.ts
import {
  combineCodec as combineCodec68,
  fixDecoderSize as fixDecoderSize60,
  fixEncoderSize as fixEncoderSize61,
  getBytesDecoder as getBytesDecoder60,
  getBytesEncoder as getBytesEncoder61,
  getStructDecoder as getStructDecoder65,
  getStructEncoder as getStructEncoder65,
  getU8Decoder as getU8Decoder9,
  getU8Encoder as getU8Encoder9,
  transformEncoder as transformEncoder58
} from "@solana/kit";
var SET_REWARD_AUTHORITY_DISCRIMINATOR = new Uint8Array([
  34,
  39,
  183,
  252,
  83,
  28,
  85,
  127
]);
function getSetRewardAuthorityDiscriminatorBytes() {
  return fixEncoderSize61(getBytesEncoder61(), 8).encode(
    SET_REWARD_AUTHORITY_DISCRIMINATOR
  );
}
function getSetRewardAuthorityInstructionDataEncoder() {
  return transformEncoder58(
    getStructEncoder65([
      ["discriminator", fixEncoderSize61(getBytesEncoder61(), 8)],
      ["rewardIndex", getU8Encoder9()]
    ]),
    (value) => ({ ...value, discriminator: SET_REWARD_AUTHORITY_DISCRIMINATOR })
  );
}
function getSetRewardAuthorityInstructionDataDecoder() {
  return getStructDecoder65([
    ["discriminator", fixDecoderSize60(getBytesDecoder60(), 8)],
    ["rewardIndex", getU8Decoder9()]
  ]);
}
function getSetRewardAuthorityInstructionDataCodec() {
  return combineCodec68(
    getSetRewardAuthorityInstructionDataEncoder(),
    getSetRewardAuthorityInstructionDataDecoder()
  );
}
function getSetRewardAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    rewardAuthority: {
      value: input.rewardAuthority ?? null,
      isWritable: false
    },
    newRewardAuthority: {
      value: input.newRewardAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.rewardAuthority),
      getAccountMeta(accounts.newRewardAuthority)
    ],
    programAddress,
    data: getSetRewardAuthorityInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetRewardAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      rewardAuthority: getNextAccount(),
      newRewardAuthority: getNextAccount()
    },
    data: getSetRewardAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setRewardAuthorityBySuperAuthority.ts
import {
  combineCodec as combineCodec69,
  fixDecoderSize as fixDecoderSize61,
  fixEncoderSize as fixEncoderSize62,
  getBytesDecoder as getBytesDecoder61,
  getBytesEncoder as getBytesEncoder62,
  getStructDecoder as getStructDecoder66,
  getStructEncoder as getStructEncoder66,
  getU8Decoder as getU8Decoder10,
  getU8Encoder as getU8Encoder10,
  transformEncoder as transformEncoder59
} from "@solana/kit";
var SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_DISCRIMINATOR = new Uint8Array([240, 154, 201, 198, 148, 93, 56, 25]);
function getSetRewardAuthorityBySuperAuthorityDiscriminatorBytes() {
  return fixEncoderSize62(getBytesEncoder62(), 8).encode(
    SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_DISCRIMINATOR
  );
}
function getSetRewardAuthorityBySuperAuthorityInstructionDataEncoder() {
  return transformEncoder59(
    getStructEncoder66([
      ["discriminator", fixEncoderSize62(getBytesEncoder62(), 8)],
      ["rewardIndex", getU8Encoder10()]
    ]),
    (value) => ({
      ...value,
      discriminator: SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getSetRewardAuthorityBySuperAuthorityInstructionDataDecoder() {
  return getStructDecoder66([
    ["discriminator", fixDecoderSize61(getBytesDecoder61(), 8)],
    ["rewardIndex", getU8Decoder10()]
  ]);
}
function getSetRewardAuthorityBySuperAuthorityInstructionDataCodec() {
  return combineCodec69(
    getSetRewardAuthorityBySuperAuthorityInstructionDataEncoder(),
    getSetRewardAuthorityBySuperAuthorityInstructionDataDecoder()
  );
}
function getSetRewardAuthorityBySuperAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    rewardEmissionsSuperAuthority: {
      value: input.rewardEmissionsSuperAuthority ?? null,
      isWritable: false
    },
    newRewardAuthority: {
      value: input.newRewardAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.rewardEmissionsSuperAuthority),
      getAccountMeta(accounts.newRewardAuthority)
    ],
    programAddress,
    data: getSetRewardAuthorityBySuperAuthorityInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetRewardAuthorityBySuperAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpool: getNextAccount(),
      rewardEmissionsSuperAuthority: getNextAccount(),
      newRewardAuthority: getNextAccount()
    },
    data: getSetRewardAuthorityBySuperAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setRewardEmissions.ts
import {
  combineCodec as combineCodec70,
  fixDecoderSize as fixDecoderSize62,
  fixEncoderSize as fixEncoderSize63,
  getBytesDecoder as getBytesDecoder62,
  getBytesEncoder as getBytesEncoder63,
  getStructDecoder as getStructDecoder67,
  getStructEncoder as getStructEncoder67,
  getU128Decoder as getU128Decoder13,
  getU128Encoder as getU128Encoder13,
  getU8Decoder as getU8Decoder11,
  getU8Encoder as getU8Encoder11,
  transformEncoder as transformEncoder60
} from "@solana/kit";
var SET_REWARD_EMISSIONS_DISCRIMINATOR = new Uint8Array([
  13,
  197,
  86,
  168,
  109,
  176,
  27,
  244
]);
function getSetRewardEmissionsDiscriminatorBytes() {
  return fixEncoderSize63(getBytesEncoder63(), 8).encode(
    SET_REWARD_EMISSIONS_DISCRIMINATOR
  );
}
function getSetRewardEmissionsInstructionDataEncoder() {
  return transformEncoder60(
    getStructEncoder67([
      ["discriminator", fixEncoderSize63(getBytesEncoder63(), 8)],
      ["rewardIndex", getU8Encoder11()],
      ["emissionsPerSecondX64", getU128Encoder13()]
    ]),
    (value) => ({ ...value, discriminator: SET_REWARD_EMISSIONS_DISCRIMINATOR })
  );
}
function getSetRewardEmissionsInstructionDataDecoder() {
  return getStructDecoder67([
    ["discriminator", fixDecoderSize62(getBytesDecoder62(), 8)],
    ["rewardIndex", getU8Decoder11()],
    ["emissionsPerSecondX64", getU128Decoder13()]
  ]);
}
function getSetRewardEmissionsInstructionDataCodec() {
  return combineCodec70(
    getSetRewardEmissionsInstructionDataEncoder(),
    getSetRewardEmissionsInstructionDataDecoder()
  );
}
function getSetRewardEmissionsInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    rewardAuthority: {
      value: input.rewardAuthority ?? null,
      isWritable: false
    },
    rewardVault: { value: input.rewardVault ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.rewardAuthority),
      getAccountMeta(accounts.rewardVault)
    ],
    programAddress,
    data: getSetRewardEmissionsInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetRewardEmissionsInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      rewardAuthority: getNextAccount(),
      rewardVault: getNextAccount()
    },
    data: getSetRewardEmissionsInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setRewardEmissionsSuperAuthority.ts
import {
  combineCodec as combineCodec71,
  fixDecoderSize as fixDecoderSize63,
  fixEncoderSize as fixEncoderSize64,
  getBytesDecoder as getBytesDecoder63,
  getBytesEncoder as getBytesEncoder64,
  getStructDecoder as getStructDecoder68,
  getStructEncoder as getStructEncoder68,
  transformEncoder as transformEncoder61
} from "@solana/kit";
var SET_REWARD_EMISSIONS_SUPER_AUTHORITY_DISCRIMINATOR = new Uint8Array([207, 5, 200, 209, 122, 56, 82, 183]);
function getSetRewardEmissionsSuperAuthorityDiscriminatorBytes() {
  return fixEncoderSize64(getBytesEncoder64(), 8).encode(
    SET_REWARD_EMISSIONS_SUPER_AUTHORITY_DISCRIMINATOR
  );
}
function getSetRewardEmissionsSuperAuthorityInstructionDataEncoder() {
  return transformEncoder61(
    getStructEncoder68([["discriminator", fixEncoderSize64(getBytesEncoder64(), 8)]]),
    (value) => ({
      ...value,
      discriminator: SET_REWARD_EMISSIONS_SUPER_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getSetRewardEmissionsSuperAuthorityInstructionDataDecoder() {
  return getStructDecoder68([
    ["discriminator", fixDecoderSize63(getBytesDecoder63(), 8)]
  ]);
}
function getSetRewardEmissionsSuperAuthorityInstructionDataCodec() {
  return combineCodec71(
    getSetRewardEmissionsSuperAuthorityInstructionDataEncoder(),
    getSetRewardEmissionsSuperAuthorityInstructionDataDecoder()
  );
}
function getSetRewardEmissionsSuperAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: true
    },
    rewardEmissionsSuperAuthority: {
      value: input.rewardEmissionsSuperAuthority ?? null,
      isWritable: false
    },
    newRewardEmissionsSuperAuthority: {
      value: input.newRewardEmissionsSuperAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.rewardEmissionsSuperAuthority),
      getAccountMeta(accounts.newRewardEmissionsSuperAuthority)
    ],
    programAddress,
    data: getSetRewardEmissionsSuperAuthorityInstructionDataEncoder().encode(
      {}
    )
  };
  return instruction;
}
function parseSetRewardEmissionsSuperAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      rewardEmissionsSuperAuthority: getNextAccount(),
      newRewardEmissionsSuperAuthority: getNextAccount()
    },
    data: getSetRewardEmissionsSuperAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setRewardEmissionsV2.ts
import {
  combineCodec as combineCodec72,
  fixDecoderSize as fixDecoderSize64,
  fixEncoderSize as fixEncoderSize65,
  getBytesDecoder as getBytesDecoder64,
  getBytesEncoder as getBytesEncoder65,
  getStructDecoder as getStructDecoder69,
  getStructEncoder as getStructEncoder69,
  getU128Decoder as getU128Decoder14,
  getU128Encoder as getU128Encoder14,
  getU8Decoder as getU8Decoder12,
  getU8Encoder as getU8Encoder12,
  transformEncoder as transformEncoder62
} from "@solana/kit";
var SET_REWARD_EMISSIONS_V2_DISCRIMINATOR = new Uint8Array([
  114,
  228,
  72,
  32,
  193,
  48,
  160,
  102
]);
function getSetRewardEmissionsV2DiscriminatorBytes() {
  return fixEncoderSize65(getBytesEncoder65(), 8).encode(
    SET_REWARD_EMISSIONS_V2_DISCRIMINATOR
  );
}
function getSetRewardEmissionsV2InstructionDataEncoder() {
  return transformEncoder62(
    getStructEncoder69([
      ["discriminator", fixEncoderSize65(getBytesEncoder65(), 8)],
      ["rewardIndex", getU8Encoder12()],
      ["emissionsPerSecondX64", getU128Encoder14()]
    ]),
    (value) => ({
      ...value,
      discriminator: SET_REWARD_EMISSIONS_V2_DISCRIMINATOR
    })
  );
}
function getSetRewardEmissionsV2InstructionDataDecoder() {
  return getStructDecoder69([
    ["discriminator", fixDecoderSize64(getBytesDecoder64(), 8)],
    ["rewardIndex", getU8Decoder12()],
    ["emissionsPerSecondX64", getU128Decoder14()]
  ]);
}
function getSetRewardEmissionsV2InstructionDataCodec() {
  return combineCodec72(
    getSetRewardEmissionsV2InstructionDataEncoder(),
    getSetRewardEmissionsV2InstructionDataDecoder()
  );
}
function getSetRewardEmissionsV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    rewardAuthority: {
      value: input.rewardAuthority ?? null,
      isWritable: false
    },
    rewardVault: { value: input.rewardVault ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.rewardAuthority),
      getAccountMeta(accounts.rewardVault)
    ],
    programAddress,
    data: getSetRewardEmissionsV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetRewardEmissionsV2Instruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      rewardAuthority: getNextAccount(),
      rewardVault: getNextAccount()
    },
    data: getSetRewardEmissionsV2InstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setTokenBadgeAuthority.ts
import {
  combineCodec as combineCodec73,
  fixDecoderSize as fixDecoderSize65,
  fixEncoderSize as fixEncoderSize66,
  getBytesDecoder as getBytesDecoder65,
  getBytesEncoder as getBytesEncoder66,
  getStructDecoder as getStructDecoder70,
  getStructEncoder as getStructEncoder70,
  transformEncoder as transformEncoder63
} from "@solana/kit";
var SET_TOKEN_BADGE_AUTHORITY_DISCRIMINATOR = new Uint8Array([
  207,
  202,
  4,
  32,
  205,
  79,
  13,
  178
]);
function getSetTokenBadgeAuthorityDiscriminatorBytes() {
  return fixEncoderSize66(getBytesEncoder66(), 8).encode(
    SET_TOKEN_BADGE_AUTHORITY_DISCRIMINATOR
  );
}
function getSetTokenBadgeAuthorityInstructionDataEncoder() {
  return transformEncoder63(
    getStructEncoder70([["discriminator", fixEncoderSize66(getBytesEncoder66(), 8)]]),
    (value) => ({
      ...value,
      discriminator: SET_TOKEN_BADGE_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getSetTokenBadgeAuthorityInstructionDataDecoder() {
  return getStructDecoder70([
    ["discriminator", fixDecoderSize65(getBytesDecoder65(), 8)]
  ]);
}
function getSetTokenBadgeAuthorityInstructionDataCodec() {
  return combineCodec73(
    getSetTokenBadgeAuthorityInstructionDataEncoder(),
    getSetTokenBadgeAuthorityInstructionDataDecoder()
  );
}
function getSetTokenBadgeAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpoolsConfigExtension: {
      value: input.whirlpoolsConfigExtension ?? null,
      isWritable: true
    },
    configExtensionAuthority: {
      value: input.configExtensionAuthority ?? null,
      isWritable: false
    },
    newTokenBadgeAuthority: {
      value: input.newTokenBadgeAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpoolsConfigExtension),
      getAccountMeta(accounts.configExtensionAuthority),
      getAccountMeta(accounts.newTokenBadgeAuthority)
    ],
    programAddress,
    data: getSetTokenBadgeAuthorityInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseSetTokenBadgeAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpoolsConfigExtension: getNextAccount(),
      configExtensionAuthority: getNextAccount(),
      newTokenBadgeAuthority: getNextAccount()
    },
    data: getSetTokenBadgeAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/swap.ts
import {
  combineCodec as combineCodec74,
  fixDecoderSize as fixDecoderSize66,
  fixEncoderSize as fixEncoderSize67,
  getBooleanDecoder as getBooleanDecoder3,
  getBooleanEncoder as getBooleanEncoder3,
  getBytesDecoder as getBytesDecoder66,
  getBytesEncoder as getBytesEncoder67,
  getStructDecoder as getStructDecoder71,
  getStructEncoder as getStructEncoder71,
  getU128Decoder as getU128Decoder15,
  getU128Encoder as getU128Encoder15,
  getU64Decoder as getU64Decoder12,
  getU64Encoder as getU64Encoder12,
  transformEncoder as transformEncoder64
} from "@solana/kit";
var SWAP_DISCRIMINATOR = new Uint8Array([
  248,
  198,
  158,
  145,
  225,
  117,
  135,
  200
]);
function getSwapDiscriminatorBytes() {
  return fixEncoderSize67(getBytesEncoder67(), 8).encode(SWAP_DISCRIMINATOR);
}
function getSwapInstructionDataEncoder() {
  return transformEncoder64(
    getStructEncoder71([
      ["discriminator", fixEncoderSize67(getBytesEncoder67(), 8)],
      ["amount", getU64Encoder12()],
      ["otherAmountThreshold", getU64Encoder12()],
      ["sqrtPriceLimit", getU128Encoder15()],
      ["amountSpecifiedIsInput", getBooleanEncoder3()],
      ["aToB", getBooleanEncoder3()]
    ]),
    (value) => ({ ...value, discriminator: SWAP_DISCRIMINATOR })
  );
}
function getSwapInstructionDataDecoder() {
  return getStructDecoder71([
    ["discriminator", fixDecoderSize66(getBytesDecoder66(), 8)],
    ["amount", getU64Decoder12()],
    ["otherAmountThreshold", getU64Decoder12()],
    ["sqrtPriceLimit", getU128Decoder15()],
    ["amountSpecifiedIsInput", getBooleanDecoder3()],
    ["aToB", getBooleanDecoder3()]
  ]);
}
function getSwapInstructionDataCodec() {
  return combineCodec74(
    getSwapInstructionDataEncoder(),
    getSwapInstructionDataDecoder()
  );
}
function getSwapInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    tokenAuthority: { value: input.tokenAuthority ?? null, isWritable: false },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tickArray0: { value: input.tickArray0 ?? null, isWritable: true },
    tickArray1: { value: input.tickArray1 ?? null, isWritable: true },
    tickArray2: { value: input.tickArray2 ?? null, isWritable: true },
    oracle: { value: input.oracle ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.tokenAuthority),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tickArray0),
      getAccountMeta(accounts.tickArray1),
      getAccountMeta(accounts.tickArray2),
      getAccountMeta(accounts.oracle)
    ],
    programAddress,
    data: getSwapInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSwapInstruction(instruction) {
  if (instruction.accounts.length < 11) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      tokenProgram: getNextAccount(),
      tokenAuthority: getNextAccount(),
      whirlpool: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tickArray0: getNextAccount(),
      tickArray1: getNextAccount(),
      tickArray2: getNextAccount(),
      oracle: getNextAccount()
    },
    data: getSwapInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/swapV2.ts
import {
  combineCodec as combineCodec75,
  fixDecoderSize as fixDecoderSize67,
  fixEncoderSize as fixEncoderSize68,
  getBooleanDecoder as getBooleanDecoder4,
  getBooleanEncoder as getBooleanEncoder4,
  getBytesDecoder as getBytesDecoder67,
  getBytesEncoder as getBytesEncoder68,
  getOptionDecoder as getOptionDecoder7,
  getOptionEncoder as getOptionEncoder7,
  getStructDecoder as getStructDecoder72,
  getStructEncoder as getStructEncoder72,
  getU128Decoder as getU128Decoder16,
  getU128Encoder as getU128Encoder16,
  getU64Decoder as getU64Decoder13,
  getU64Encoder as getU64Encoder13,
  transformEncoder as transformEncoder65
} from "@solana/kit";
var SWAP_V2_DISCRIMINATOR = new Uint8Array([
  43,
  4,
  237,
  11,
  26,
  201,
  30,
  98
]);
function getSwapV2DiscriminatorBytes() {
  return fixEncoderSize68(getBytesEncoder68(), 8).encode(SWAP_V2_DISCRIMINATOR);
}
function getSwapV2InstructionDataEncoder() {
  return transformEncoder65(
    getStructEncoder72([
      ["discriminator", fixEncoderSize68(getBytesEncoder68(), 8)],
      ["amount", getU64Encoder13()],
      ["otherAmountThreshold", getU64Encoder13()],
      ["sqrtPriceLimit", getU128Encoder16()],
      ["amountSpecifiedIsInput", getBooleanEncoder4()],
      ["aToB", getBooleanEncoder4()],
      [
        "remainingAccountsInfo",
        getOptionEncoder7(getRemainingAccountsInfoEncoder())
      ]
    ]),
    (value) => ({ ...value, discriminator: SWAP_V2_DISCRIMINATOR })
  );
}
function getSwapV2InstructionDataDecoder() {
  return getStructDecoder72([
    ["discriminator", fixDecoderSize67(getBytesDecoder67(), 8)],
    ["amount", getU64Decoder13()],
    ["otherAmountThreshold", getU64Decoder13()],
    ["sqrtPriceLimit", getU128Decoder16()],
    ["amountSpecifiedIsInput", getBooleanDecoder4()],
    ["aToB", getBooleanDecoder4()],
    [
      "remainingAccountsInfo",
      getOptionDecoder7(getRemainingAccountsInfoDecoder())
    ]
  ]);
}
function getSwapV2InstructionDataCodec() {
  return combineCodec75(
    getSwapV2InstructionDataEncoder(),
    getSwapV2InstructionDataDecoder()
  );
}
function getSwapV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },
    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false },
    tokenAuthority: { value: input.tokenAuthority ?? null, isWritable: false },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tickArray0: { value: input.tickArray0 ?? null, isWritable: true },
    tickArray1: { value: input.tickArray1 ?? null, isWritable: true },
    tickArray2: { value: input.tickArray2 ?? null, isWritable: true },
    oracle: { value: input.oracle ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.tokenProgramA),
      getAccountMeta(accounts.tokenProgramB),
      getAccountMeta(accounts.memoProgram),
      getAccountMeta(accounts.tokenAuthority),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tickArray0),
      getAccountMeta(accounts.tickArray1),
      getAccountMeta(accounts.tickArray2),
      getAccountMeta(accounts.oracle)
    ],
    programAddress,
    data: getSwapV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSwapV2Instruction(instruction) {
  if (instruction.accounts.length < 15) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      tokenProgramA: getNextAccount(),
      tokenProgramB: getNextAccount(),
      memoProgram: getNextAccount(),
      tokenAuthority: getNextAccount(),
      whirlpool: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tickArray0: getNextAccount(),
      tickArray1: getNextAccount(),
      tickArray2: getNextAccount(),
      oracle: getNextAccount()
    },
    data: getSwapV2InstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/transferLockedPosition.ts
import {
  combineCodec as combineCodec76,
  fixDecoderSize as fixDecoderSize68,
  fixEncoderSize as fixEncoderSize69,
  getBytesDecoder as getBytesDecoder68,
  getBytesEncoder as getBytesEncoder69,
  getStructDecoder as getStructDecoder73,
  getStructEncoder as getStructEncoder73,
  transformEncoder as transformEncoder66
} from "@solana/kit";
var TRANSFER_LOCKED_POSITION_DISCRIMINATOR = new Uint8Array([
  179,
  121,
  229,
  46,
  67,
  138,
  194,
  138
]);
function getTransferLockedPositionDiscriminatorBytes() {
  return fixEncoderSize69(getBytesEncoder69(), 8).encode(
    TRANSFER_LOCKED_POSITION_DISCRIMINATOR
  );
}
function getTransferLockedPositionInstructionDataEncoder() {
  return transformEncoder66(
    getStructEncoder73([["discriminator", fixEncoderSize69(getBytesEncoder69(), 8)]]),
    (value) => ({
      ...value,
      discriminator: TRANSFER_LOCKED_POSITION_DISCRIMINATOR
    })
  );
}
function getTransferLockedPositionInstructionDataDecoder() {
  return getStructDecoder73([
    ["discriminator", fixDecoderSize68(getBytesDecoder68(), 8)]
  ]);
}
function getTransferLockedPositionInstructionDataCodec() {
  return combineCodec76(
    getTransferLockedPositionInstructionDataEncoder(),
    getTransferLockedPositionInstructionDataDecoder()
  );
}
function getTransferLockedPositionInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    receiver: { value: input.receiver ?? null, isWritable: true },
    position: { value: input.position ?? null, isWritable: false },
    positionMint: { value: input.positionMint ?? null, isWritable: false },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: true
    },
    destinationTokenAccount: {
      value: input.destinationTokenAccount ?? null,
      isWritable: true
    },
    lockConfig: { value: input.lockConfig ?? null, isWritable: true },
    token2022Program: {
      value: input.token2022Program ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.receiver),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionMint),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.destinationTokenAccount),
      getAccountMeta(accounts.lockConfig),
      getAccountMeta(accounts.token2022Program)
    ],
    programAddress,
    data: getTransferLockedPositionInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseTransferLockedPositionInstruction(instruction) {
  if (instruction.accounts.length < 8) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      positionAuthority: getNextAccount(),
      receiver: getNextAccount(),
      position: getNextAccount(),
      positionMint: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      destinationTokenAccount: getNextAccount(),
      lockConfig: getNextAccount(),
      token2022Program: getNextAccount()
    },
    data: getTransferLockedPositionInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/twoHopSwap.ts
import {
  combineCodec as combineCodec77,
  fixDecoderSize as fixDecoderSize69,
  fixEncoderSize as fixEncoderSize70,
  getBooleanDecoder as getBooleanDecoder5,
  getBooleanEncoder as getBooleanEncoder5,
  getBytesDecoder as getBytesDecoder69,
  getBytesEncoder as getBytesEncoder70,
  getStructDecoder as getStructDecoder74,
  getStructEncoder as getStructEncoder74,
  getU128Decoder as getU128Decoder17,
  getU128Encoder as getU128Encoder17,
  getU64Decoder as getU64Decoder14,
  getU64Encoder as getU64Encoder14,
  transformEncoder as transformEncoder67
} from "@solana/kit";
var TWO_HOP_SWAP_DISCRIMINATOR = new Uint8Array([
  195,
  96,
  237,
  108,
  68,
  162,
  219,
  230
]);
function getTwoHopSwapDiscriminatorBytes() {
  return fixEncoderSize70(getBytesEncoder70(), 8).encode(
    TWO_HOP_SWAP_DISCRIMINATOR
  );
}
function getTwoHopSwapInstructionDataEncoder() {
  return transformEncoder67(
    getStructEncoder74([
      ["discriminator", fixEncoderSize70(getBytesEncoder70(), 8)],
      ["amount", getU64Encoder14()],
      ["otherAmountThreshold", getU64Encoder14()],
      ["amountSpecifiedIsInput", getBooleanEncoder5()],
      ["aToBOne", getBooleanEncoder5()],
      ["aToBTwo", getBooleanEncoder5()],
      ["sqrtPriceLimitOne", getU128Encoder17()],
      ["sqrtPriceLimitTwo", getU128Encoder17()]
    ]),
    (value) => ({ ...value, discriminator: TWO_HOP_SWAP_DISCRIMINATOR })
  );
}
function getTwoHopSwapInstructionDataDecoder() {
  return getStructDecoder74([
    ["discriminator", fixDecoderSize69(getBytesDecoder69(), 8)],
    ["amount", getU64Decoder14()],
    ["otherAmountThreshold", getU64Decoder14()],
    ["amountSpecifiedIsInput", getBooleanDecoder5()],
    ["aToBOne", getBooleanDecoder5()],
    ["aToBTwo", getBooleanDecoder5()],
    ["sqrtPriceLimitOne", getU128Decoder17()],
    ["sqrtPriceLimitTwo", getU128Decoder17()]
  ]);
}
function getTwoHopSwapInstructionDataCodec() {
  return combineCodec77(
    getTwoHopSwapInstructionDataEncoder(),
    getTwoHopSwapInstructionDataDecoder()
  );
}
function getTwoHopSwapInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    tokenAuthority: { value: input.tokenAuthority ?? null, isWritable: false },
    whirlpoolOne: { value: input.whirlpoolOne ?? null, isWritable: true },
    whirlpoolTwo: { value: input.whirlpoolTwo ?? null, isWritable: true },
    tokenOwnerAccountOneA: {
      value: input.tokenOwnerAccountOneA ?? null,
      isWritable: true
    },
    tokenVaultOneA: { value: input.tokenVaultOneA ?? null, isWritable: true },
    tokenOwnerAccountOneB: {
      value: input.tokenOwnerAccountOneB ?? null,
      isWritable: true
    },
    tokenVaultOneB: { value: input.tokenVaultOneB ?? null, isWritable: true },
    tokenOwnerAccountTwoA: {
      value: input.tokenOwnerAccountTwoA ?? null,
      isWritable: true
    },
    tokenVaultTwoA: { value: input.tokenVaultTwoA ?? null, isWritable: true },
    tokenOwnerAccountTwoB: {
      value: input.tokenOwnerAccountTwoB ?? null,
      isWritable: true
    },
    tokenVaultTwoB: { value: input.tokenVaultTwoB ?? null, isWritable: true },
    tickArrayOne0: { value: input.tickArrayOne0 ?? null, isWritable: true },
    tickArrayOne1: { value: input.tickArrayOne1 ?? null, isWritable: true },
    tickArrayOne2: { value: input.tickArrayOne2 ?? null, isWritable: true },
    tickArrayTwo0: { value: input.tickArrayTwo0 ?? null, isWritable: true },
    tickArrayTwo1: { value: input.tickArrayTwo1 ?? null, isWritable: true },
    tickArrayTwo2: { value: input.tickArrayTwo2 ?? null, isWritable: true },
    oracleOne: { value: input.oracleOne ?? null, isWritable: false },
    oracleTwo: { value: input.oracleTwo ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.tokenAuthority),
      getAccountMeta(accounts.whirlpoolOne),
      getAccountMeta(accounts.whirlpoolTwo),
      getAccountMeta(accounts.tokenOwnerAccountOneA),
      getAccountMeta(accounts.tokenVaultOneA),
      getAccountMeta(accounts.tokenOwnerAccountOneB),
      getAccountMeta(accounts.tokenVaultOneB),
      getAccountMeta(accounts.tokenOwnerAccountTwoA),
      getAccountMeta(accounts.tokenVaultTwoA),
      getAccountMeta(accounts.tokenOwnerAccountTwoB),
      getAccountMeta(accounts.tokenVaultTwoB),
      getAccountMeta(accounts.tickArrayOne0),
      getAccountMeta(accounts.tickArrayOne1),
      getAccountMeta(accounts.tickArrayOne2),
      getAccountMeta(accounts.tickArrayTwo0),
      getAccountMeta(accounts.tickArrayTwo1),
      getAccountMeta(accounts.tickArrayTwo2),
      getAccountMeta(accounts.oracleOne),
      getAccountMeta(accounts.oracleTwo)
    ],
    programAddress,
    data: getTwoHopSwapInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseTwoHopSwapInstruction(instruction) {
  if (instruction.accounts.length < 20) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      tokenProgram: getNextAccount(),
      tokenAuthority: getNextAccount(),
      whirlpoolOne: getNextAccount(),
      whirlpoolTwo: getNextAccount(),
      tokenOwnerAccountOneA: getNextAccount(),
      tokenVaultOneA: getNextAccount(),
      tokenOwnerAccountOneB: getNextAccount(),
      tokenVaultOneB: getNextAccount(),
      tokenOwnerAccountTwoA: getNextAccount(),
      tokenVaultTwoA: getNextAccount(),
      tokenOwnerAccountTwoB: getNextAccount(),
      tokenVaultTwoB: getNextAccount(),
      tickArrayOne0: getNextAccount(),
      tickArrayOne1: getNextAccount(),
      tickArrayOne2: getNextAccount(),
      tickArrayTwo0: getNextAccount(),
      tickArrayTwo1: getNextAccount(),
      tickArrayTwo2: getNextAccount(),
      oracleOne: getNextAccount(),
      oracleTwo: getNextAccount()
    },
    data: getTwoHopSwapInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/twoHopSwapV2.ts
import {
  combineCodec as combineCodec78,
  fixDecoderSize as fixDecoderSize70,
  fixEncoderSize as fixEncoderSize71,
  getBooleanDecoder as getBooleanDecoder6,
  getBooleanEncoder as getBooleanEncoder6,
  getBytesDecoder as getBytesDecoder70,
  getBytesEncoder as getBytesEncoder71,
  getOptionDecoder as getOptionDecoder8,
  getOptionEncoder as getOptionEncoder8,
  getStructDecoder as getStructDecoder75,
  getStructEncoder as getStructEncoder75,
  getU128Decoder as getU128Decoder18,
  getU128Encoder as getU128Encoder18,
  getU64Decoder as getU64Decoder15,
  getU64Encoder as getU64Encoder15,
  transformEncoder as transformEncoder68
} from "@solana/kit";
var TWO_HOP_SWAP_V2_DISCRIMINATOR = new Uint8Array([
  186,
  143,
  209,
  29,
  254,
  2,
  194,
  117
]);
function getTwoHopSwapV2DiscriminatorBytes() {
  return fixEncoderSize71(getBytesEncoder71(), 8).encode(
    TWO_HOP_SWAP_V2_DISCRIMINATOR
  );
}
function getTwoHopSwapV2InstructionDataEncoder() {
  return transformEncoder68(
    getStructEncoder75([
      ["discriminator", fixEncoderSize71(getBytesEncoder71(), 8)],
      ["amount", getU64Encoder15()],
      ["otherAmountThreshold", getU64Encoder15()],
      ["amountSpecifiedIsInput", getBooleanEncoder6()],
      ["aToBOne", getBooleanEncoder6()],
      ["aToBTwo", getBooleanEncoder6()],
      ["sqrtPriceLimitOne", getU128Encoder18()],
      ["sqrtPriceLimitTwo", getU128Encoder18()],
      [
        "remainingAccountsInfo",
        getOptionEncoder8(getRemainingAccountsInfoEncoder())
      ]
    ]),
    (value) => ({ ...value, discriminator: TWO_HOP_SWAP_V2_DISCRIMINATOR })
  );
}
function getTwoHopSwapV2InstructionDataDecoder() {
  return getStructDecoder75([
    ["discriminator", fixDecoderSize70(getBytesDecoder70(), 8)],
    ["amount", getU64Decoder15()],
    ["otherAmountThreshold", getU64Decoder15()],
    ["amountSpecifiedIsInput", getBooleanDecoder6()],
    ["aToBOne", getBooleanDecoder6()],
    ["aToBTwo", getBooleanDecoder6()],
    ["sqrtPriceLimitOne", getU128Decoder18()],
    ["sqrtPriceLimitTwo", getU128Decoder18()],
    [
      "remainingAccountsInfo",
      getOptionDecoder8(getRemainingAccountsInfoDecoder())
    ]
  ]);
}
function getTwoHopSwapV2InstructionDataCodec() {
  return combineCodec78(
    getTwoHopSwapV2InstructionDataEncoder(),
    getTwoHopSwapV2InstructionDataDecoder()
  );
}
function getTwoHopSwapV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolOne: { value: input.whirlpoolOne ?? null, isWritable: true },
    whirlpoolTwo: { value: input.whirlpoolTwo ?? null, isWritable: true },
    tokenMintInput: { value: input.tokenMintInput ?? null, isWritable: false },
    tokenMintIntermediate: {
      value: input.tokenMintIntermediate ?? null,
      isWritable: false
    },
    tokenMintOutput: {
      value: input.tokenMintOutput ?? null,
      isWritable: false
    },
    tokenProgramInput: {
      value: input.tokenProgramInput ?? null,
      isWritable: false
    },
    tokenProgramIntermediate: {
      value: input.tokenProgramIntermediate ?? null,
      isWritable: false
    },
    tokenProgramOutput: {
      value: input.tokenProgramOutput ?? null,
      isWritable: false
    },
    tokenOwnerAccountInput: {
      value: input.tokenOwnerAccountInput ?? null,
      isWritable: true
    },
    tokenVaultOneInput: {
      value: input.tokenVaultOneInput ?? null,
      isWritable: true
    },
    tokenVaultOneIntermediate: {
      value: input.tokenVaultOneIntermediate ?? null,
      isWritable: true
    },
    tokenVaultTwoIntermediate: {
      value: input.tokenVaultTwoIntermediate ?? null,
      isWritable: true
    },
    tokenVaultTwoOutput: {
      value: input.tokenVaultTwoOutput ?? null,
      isWritable: true
    },
    tokenOwnerAccountOutput: {
      value: input.tokenOwnerAccountOutput ?? null,
      isWritable: true
    },
    tokenAuthority: { value: input.tokenAuthority ?? null, isWritable: false },
    tickArrayOne0: { value: input.tickArrayOne0 ?? null, isWritable: true },
    tickArrayOne1: { value: input.tickArrayOne1 ?? null, isWritable: true },
    tickArrayOne2: { value: input.tickArrayOne2 ?? null, isWritable: true },
    tickArrayTwo0: { value: input.tickArrayTwo0 ?? null, isWritable: true },
    tickArrayTwo1: { value: input.tickArrayTwo1 ?? null, isWritable: true },
    tickArrayTwo2: { value: input.tickArrayTwo2 ?? null, isWritable: true },
    oracleOne: { value: input.oracleOne ?? null, isWritable: true },
    oracleTwo: { value: input.oracleTwo ?? null, isWritable: true },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolOne),
      getAccountMeta(accounts.whirlpoolTwo),
      getAccountMeta(accounts.tokenMintInput),
      getAccountMeta(accounts.tokenMintIntermediate),
      getAccountMeta(accounts.tokenMintOutput),
      getAccountMeta(accounts.tokenProgramInput),
      getAccountMeta(accounts.tokenProgramIntermediate),
      getAccountMeta(accounts.tokenProgramOutput),
      getAccountMeta(accounts.tokenOwnerAccountInput),
      getAccountMeta(accounts.tokenVaultOneInput),
      getAccountMeta(accounts.tokenVaultOneIntermediate),
      getAccountMeta(accounts.tokenVaultTwoIntermediate),
      getAccountMeta(accounts.tokenVaultTwoOutput),
      getAccountMeta(accounts.tokenOwnerAccountOutput),
      getAccountMeta(accounts.tokenAuthority),
      getAccountMeta(accounts.tickArrayOne0),
      getAccountMeta(accounts.tickArrayOne1),
      getAccountMeta(accounts.tickArrayOne2),
      getAccountMeta(accounts.tickArrayTwo0),
      getAccountMeta(accounts.tickArrayTwo1),
      getAccountMeta(accounts.tickArrayTwo2),
      getAccountMeta(accounts.oracleOne),
      getAccountMeta(accounts.oracleTwo),
      getAccountMeta(accounts.memoProgram)
    ],
    programAddress,
    data: getTwoHopSwapV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseTwoHopSwapV2Instruction(instruction) {
  if (instruction.accounts.length < 24) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolOne: getNextAccount(),
      whirlpoolTwo: getNextAccount(),
      tokenMintInput: getNextAccount(),
      tokenMintIntermediate: getNextAccount(),
      tokenMintOutput: getNextAccount(),
      tokenProgramInput: getNextAccount(),
      tokenProgramIntermediate: getNextAccount(),
      tokenProgramOutput: getNextAccount(),
      tokenOwnerAccountInput: getNextAccount(),
      tokenVaultOneInput: getNextAccount(),
      tokenVaultOneIntermediate: getNextAccount(),
      tokenVaultTwoIntermediate: getNextAccount(),
      tokenVaultTwoOutput: getNextAccount(),
      tokenOwnerAccountOutput: getNextAccount(),
      tokenAuthority: getNextAccount(),
      tickArrayOne0: getNextAccount(),
      tickArrayOne1: getNextAccount(),
      tickArrayOne2: getNextAccount(),
      tickArrayTwo0: getNextAccount(),
      tickArrayTwo1: getNextAccount(),
      tickArrayTwo2: getNextAccount(),
      oracleOne: getNextAccount(),
      oracleTwo: getNextAccount(),
      memoProgram: getNextAccount()
    },
    data: getTwoHopSwapV2InstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/updateFeesAndRewards.ts
import {
  combineCodec as combineCodec79,
  fixDecoderSize as fixDecoderSize71,
  fixEncoderSize as fixEncoderSize72,
  getBytesDecoder as getBytesDecoder71,
  getBytesEncoder as getBytesEncoder72,
  getStructDecoder as getStructDecoder76,
  getStructEncoder as getStructEncoder76,
  transformEncoder as transformEncoder69
} from "@solana/kit";
var UPDATE_FEES_AND_REWARDS_DISCRIMINATOR = new Uint8Array([
  154,
  230,
  250,
  13,
  236,
  209,
  75,
  223
]);
function getUpdateFeesAndRewardsDiscriminatorBytes() {
  return fixEncoderSize72(getBytesEncoder72(), 8).encode(
    UPDATE_FEES_AND_REWARDS_DISCRIMINATOR
  );
}
function getUpdateFeesAndRewardsInstructionDataEncoder() {
  return transformEncoder69(
    getStructEncoder76([["discriminator", fixEncoderSize72(getBytesEncoder72(), 8)]]),
    (value) => ({
      ...value,
      discriminator: UPDATE_FEES_AND_REWARDS_DISCRIMINATOR
    })
  );
}
function getUpdateFeesAndRewardsInstructionDataDecoder() {
  return getStructDecoder76([
    ["discriminator", fixDecoderSize71(getBytesDecoder71(), 8)]
  ]);
}
function getUpdateFeesAndRewardsInstructionDataCodec() {
  return combineCodec79(
    getUpdateFeesAndRewardsInstructionDataEncoder(),
    getUpdateFeesAndRewardsInstructionDataDecoder()
  );
}
function getUpdateFeesAndRewardsInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    position: { value: input.position ?? null, isWritable: true },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: false },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper)
    ],
    programAddress,
    data: getUpdateFeesAndRewardsInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseUpdateFeesAndRewardsInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      position: getNextAccount(),
      tickArrayLower: getNextAccount(),
      tickArrayUpper: getNextAccount()
    },
    data: getUpdateFeesAndRewardsInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/gpa/adaptiveFeeTier.ts
import {
  getAddressEncoder as getAddressEncoder15,
  getBase58Decoder,
  getU16Encoder as getU16Encoder20,
  getU32Encoder as getU32Encoder6
} from "@solana/kit";

// src/gpa/utils.ts
import { getBase64Encoder } from "@solana/kit";
async function fetchDecodedProgramAccounts(rpc, programAddress, filters, decoder) {
  const accountInfos = await rpc.getProgramAccounts(programAddress, {
    encoding: "base64",
    filters
  }).send();
  const encoder = getBase64Encoder();
  const datas = accountInfos.map((x) => encoder.encode(x.account.data[0]));
  const decoded = datas.map((x) => decoder.decode(x));
  return decoded.map((data, i) => ({
    ...accountInfos[i].account,
    address: accountInfos[i].pubkey,
    programAddress,
    data
  }));
}

// src/gpa/adaptiveFeeTier.ts
function adaptiveFeeTierWhirlpoolsConfigFilter(address) {
  return {
    memcmp: {
      offset: 8n,
      bytes: getBase58Decoder().decode(getAddressEncoder15().encode(address)),
      encoding: "base58"
    }
  };
}
function adaptiveFeeTierFeeTierIndexFilter(feeTierIndex) {
  return {
    memcmp: {
      offset: 40n,
      bytes: getBase58Decoder().decode(getU16Encoder20().encode(feeTierIndex)),
      encoding: "base58"
    }
  };
}
function adaptiveFeeTierTickSpacingFilter(tickSpacing) {
  return {
    memcmp: {
      offset: 42n,
      bytes: getBase58Decoder().decode(getU16Encoder20().encode(tickSpacing)),
      encoding: "base58"
    }
  };
}
function adaptiveFeeTierInitializePoolAuthorityFilter(address) {
  return {
    memcmp: {
      offset: 44n,
      bytes: getBase58Decoder().decode(getAddressEncoder15().encode(address)),
      encoding: "base58"
    }
  };
}
function adaptiveFeeTierDelegatedFeeAuthorityFilter(address) {
  return {
    memcmp: {
      offset: 76n,
      bytes: getBase58Decoder().decode(getAddressEncoder15().encode(address)),
      encoding: "base58"
    }
  };
}
function adaptiveFeeTierDefaultBaseFeeRateFilter(feeRate) {
  return {
    memcmp: {
      offset: 108n,
      bytes: getBase58Decoder().decode(getU16Encoder20().encode(feeRate)),
      encoding: "base58"
    }
  };
}
function adaptiveFeeTierFilterPeriodFilter(filterPeriod) {
  return {
    memcmp: {
      offset: 110n,
      bytes: getBase58Decoder().decode(getU16Encoder20().encode(filterPeriod)),
      encoding: "base58"
    }
  };
}
function adaptiveFeeTierDecayPeriodFilter(decayPeriod) {
  return {
    memcmp: {
      offset: 112n,
      bytes: getBase58Decoder().decode(getU16Encoder20().encode(decayPeriod)),
      encoding: "base58"
    }
  };
}
function adaptiveFeeTierReductionFactorFilter(reductionFactor) {
  return {
    memcmp: {
      offset: 114n,
      bytes: getBase58Decoder().decode(getU16Encoder20().encode(reductionFactor)),
      encoding: "base58"
    }
  };
}
function adaptiveFeeTierAdaptiveFeeControlFactorFilter(adaptiveFeeControlFactor) {
  return {
    memcmp: {
      offset: 116n,
      bytes: getBase58Decoder().decode(
        getU32Encoder6().encode(adaptiveFeeControlFactor)
      ),
      encoding: "base58"
    }
  };
}
function adaptiveFeeTierMaxVolatilityFilter(maxVolatility) {
  return {
    memcmp: {
      offset: 120n,
      bytes: getBase58Decoder().decode(getU32Encoder6().encode(maxVolatility)),
      encoding: "base58"
    }
  };
}
function adaptiveFeeTierTickGroupSizeFilter(tickGroupSize) {
  return {
    memcmp: {
      offset: 124n,
      bytes: getBase58Decoder().decode(getU16Encoder20().encode(tickGroupSize)),
      encoding: "base58"
    }
  };
}
function adaptiveFeeTierMajorSwapThresholdTicksFilter(majorSwapThresholdTicks) {
  return {
    memcmp: {
      offset: 126n,
      bytes: getBase58Decoder().decode(
        getU16Encoder20().encode(majorSwapThresholdTicks)
      ),
      encoding: "base58"
    }
  };
}
async function fetchAllAdaptiveFeeTierWithFilter(rpc, ...filters) {
  const discriminator = getBase58Decoder().decode(
    ADAPTIVE_FEE_TIER_DISCRIMINATOR
  );
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getAdaptiveFeeTierDecoder()
  );
}

// src/gpa/feeTier.ts
import {
  getAddressEncoder as getAddressEncoder16,
  getBase58Decoder as getBase58Decoder2,
  getU16Encoder as getU16Encoder21
} from "@solana/kit";
function feeTierWhirlpoolsConfigFilter(address) {
  return {
    memcmp: {
      offset: 8n,
      bytes: getBase58Decoder2().decode(getAddressEncoder16().encode(address)),
      encoding: "base58"
    }
  };
}
function feeTierTickSpacingFilter(tickSpacing) {
  return {
    memcmp: {
      offset: 40n,
      bytes: getBase58Decoder2().decode(getU16Encoder21().encode(tickSpacing)),
      encoding: "base58"
    }
  };
}
function feeTierFeeRateFilter(defaultFeeRate) {
  return {
    memcmp: {
      offset: 42n,
      bytes: getBase58Decoder2().decode(getU16Encoder21().encode(defaultFeeRate)),
      encoding: "base58"
    }
  };
}
async function fetchAllFeeTierWithFilter(rpc, ...filters) {
  const discriminator = getBase58Decoder2().decode(FEE_TIER_DISCRIMINATOR);
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getFeeTierDecoder()
  );
}

// src/gpa/oracle.ts
import {
  getAddressEncoder as getAddressEncoder17,
  getBase58Decoder as getBase58Decoder3,
  getU16Encoder as getU16Encoder22,
  getU32Encoder as getU32Encoder7,
  getU64Encoder as getU64Encoder16
} from "@solana/kit";
function oracleWhirlpoolFilter(address) {
  return {
    memcmp: {
      offset: 8n,
      bytes: getBase58Decoder3().decode(getAddressEncoder17().encode(address)),
      encoding: "base58"
    }
  };
}
function oracleTradeEnableTimestampFilter(timestamp) {
  return {
    memcmp: {
      offset: 40n,
      bytes: getBase58Decoder3().decode(getU64Encoder16().encode(timestamp)),
      encoding: "base58"
    }
  };
}
function oracleFilterPeriodFilter(filterPeriod) {
  return {
    memcmp: {
      offset: 48n,
      bytes: getBase58Decoder3().decode(getU16Encoder22().encode(filterPeriod)),
      encoding: "base58"
    }
  };
}
function oracleDecayPeriodFilter(decayPeriod) {
  return {
    memcmp: {
      offset: 50n,
      bytes: getBase58Decoder3().decode(getU16Encoder22().encode(decayPeriod)),
      encoding: "base58"
    }
  };
}
function oracleReductionFactorFilter(reductionFactor) {
  return {
    memcmp: {
      offset: 52n,
      bytes: getBase58Decoder3().decode(getU16Encoder22().encode(reductionFactor)),
      encoding: "base58"
    }
  };
}
function oracleAdaptiveFeeControlFactorFilter(adaptiveFeeControlFactor) {
  return {
    memcmp: {
      offset: 54n,
      bytes: getBase58Decoder3().decode(
        getU32Encoder7().encode(adaptiveFeeControlFactor)
      ),
      encoding: "base58"
    }
  };
}
function oracleMaxVolatilityFilter(maxVolatility) {
  return {
    memcmp: {
      offset: 58n,
      bytes: getBase58Decoder3().decode(getU32Encoder7().encode(maxVolatility)),
      encoding: "base58"
    }
  };
}
function oracleTickGroupSizeFilter(tickGroupSize) {
  return {
    memcmp: {
      offset: 62n,
      bytes: getBase58Decoder3().decode(getU16Encoder22().encode(tickGroupSize)),
      encoding: "base58"
    }
  };
}
function oracleMajorSwapThresholdTicksFilter(majorSwapThresholdTicks) {
  return {
    memcmp: {
      offset: 64n,
      bytes: getBase58Decoder3().decode(
        getU16Encoder22().encode(majorSwapThresholdTicks)
      ),
      encoding: "base58"
    }
  };
}
async function fetchAllOracleWithFilter(rpc, ...filters) {
  const discriminator = getBase58Decoder3().decode(ORACLE_DISCRIMINATOR);
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getOracleDecoder()
  );
}

// src/gpa/position.ts
import {
  getBase58Decoder as getBase58Decoder4,
  getAddressEncoder as getAddressEncoder18,
  getI32Encoder as getI32Encoder11
} from "@solana/kit";
function positionWhirlpoolFilter(address) {
  return {
    memcmp: {
      offset: 8n,
      bytes: getBase58Decoder4().decode(getAddressEncoder18().encode(address)),
      encoding: "base58"
    }
  };
}
function positionMintFilter(address) {
  return {
    memcmp: {
      offset: 40n,
      bytes: getBase58Decoder4().decode(getAddressEncoder18().encode(address)),
      encoding: "base58"
    }
  };
}
function positionTickLowerIndexFilter(tickLowerIndex) {
  return {
    memcmp: {
      offset: 88n,
      bytes: getBase58Decoder4().decode(getI32Encoder11().encode(tickLowerIndex)),
      encoding: "base58"
    }
  };
}
function positionTickUpperIndexFilter(tickUpperIndex) {
  return {
    memcmp: {
      offset: 92n,
      bytes: getBase58Decoder4().decode(getI32Encoder11().encode(tickUpperIndex)),
      encoding: "base58"
    }
  };
}
async function fetchAllPositionWithFilter(rpc, ...filters) {
  const discriminator = getBase58Decoder4().decode(POSITION_DISCRIMINATOR);
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getPositionDecoder()
  );
}

// src/gpa/positionBundle.ts
import { getAddressEncoder as getAddressEncoder19, getBase58Decoder as getBase58Decoder5 } from "@solana/kit";
function positionBundleMintFilter(address) {
  return {
    memcmp: {
      offset: 8n,
      bytes: getBase58Decoder5().decode(getAddressEncoder19().encode(address)),
      encoding: "base58"
    }
  };
}
async function fetchAllPositionBundleWithFilter(rpc, ...filters) {
  const discriminator = getBase58Decoder5().decode(
    POSITION_BUNDLE_DISCRIMINATOR
  );
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getPositionBundleDecoder()
  );
}

// src/gpa/tickArray.ts
import {
  getAddressEncoder as getAddressEncoder20,
  getBase58Decoder as getBase58Decoder6,
  getI32Encoder as getI32Encoder12
} from "@solana/kit";
function tickArrayStartTickIndexFilter(startTickIndex) {
  return {
    memcmp: {
      offset: 8n,
      bytes: getBase58Decoder6().decode(getI32Encoder12().encode(startTickIndex)),
      encoding: "base58"
    }
  };
}
function tickArrayWhirlpoolFilter(address) {
  return {
    memcmp: {
      offset: 9956n,
      bytes: getBase58Decoder6().decode(getAddressEncoder20().encode(address)),
      encoding: "base58"
    }
  };
}
async function fetchAllTickArrayWithFilter(rpc, ...filters) {
  const discriminator = getBase58Decoder6().decode(TICK_ARRAY_DISCRIMINATOR);
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getTickArrayDecoder()
  );
}

// src/gpa/tokenBadge.ts
import { getBase58Decoder as getBase58Decoder7, getAddressEncoder as getAddressEncoder21 } from "@solana/kit";
function tokenBadgeWhirlpoolsConfigFilter(address) {
  return {
    memcmp: {
      offset: 8n,
      bytes: getBase58Decoder7().decode(getAddressEncoder21().encode(address)),
      encoding: "base58"
    }
  };
}
function tokenBadgeTokenMintFilter(address) {
  return {
    memcmp: {
      offset: 40n,
      bytes: getBase58Decoder7().decode(getAddressEncoder21().encode(address)),
      encoding: "base58"
    }
  };
}
async function fetchAllTokenBadgeWithFilter(rpc, ...filters) {
  const discriminator = getBase58Decoder7().decode(TOKEN_BADGE_DISCRIMINATOR);
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getTokenBadgeDecoder()
  );
}

// src/gpa/whirlpool.ts
import {
  getAddressEncoder as getAddressEncoder22,
  getBase58Decoder as getBase58Decoder8,
  getU16Encoder as getU16Encoder23
} from "@solana/kit";
function whirlpoolWhirlpoolConfigFilter(address) {
  return {
    memcmp: {
      offset: 8n,
      bytes: getBase58Decoder8().decode(getAddressEncoder22().encode(address)),
      encoding: "base58"
    }
  };
}
function whirlpoolTickSpacingFilter(tickSpacing) {
  return {
    memcmp: {
      offset: 41n,
      bytes: getBase58Decoder8().decode(getU16Encoder23().encode(tickSpacing)),
      encoding: "base58"
    }
  };
}
function whirlpoolFeeRateFilter(defaultFeeRate) {
  return {
    memcmp: {
      offset: 45n,
      bytes: getBase58Decoder8().decode(getU16Encoder23().encode(defaultFeeRate)),
      encoding: "base58"
    }
  };
}
function whirlpoolProtocolFeeRateFilter(protocolFeeRate) {
  return {
    memcmp: {
      offset: 47n,
      bytes: getBase58Decoder8().decode(getU16Encoder23().encode(protocolFeeRate)),
      encoding: "base58"
    }
  };
}
function whirlpoolTokenMintAFilter(tokenMintA) {
  return {
    memcmp: {
      offset: 101n,
      bytes: getBase58Decoder8().decode(getAddressEncoder22().encode(tokenMintA)),
      encoding: "base58"
    }
  };
}
function whirlpoolTokenVaultAFilter(tokenVaultA) {
  return {
    memcmp: {
      offset: 133n,
      bytes: getBase58Decoder8().decode(getAddressEncoder22().encode(tokenVaultA)),
      encoding: "base58"
    }
  };
}
function whirlpoolTokenMintBFilter(tokenMintB) {
  return {
    memcmp: {
      offset: 181n,
      bytes: getBase58Decoder8().decode(getAddressEncoder22().encode(tokenMintB)),
      encoding: "base58"
    }
  };
}
function whirlpoolTokenVaultBFilter(tokenVaultB) {
  return {
    memcmp: {
      offset: 213n,
      bytes: getBase58Decoder8().decode(getAddressEncoder22().encode(tokenVaultB)),
      encoding: "base58"
    }
  };
}
function whirlpoolRewardMint1Filter(rewardMint1) {
  return {
    memcmp: {
      offset: 269n,
      bytes: getBase58Decoder8().decode(getAddressEncoder22().encode(rewardMint1)),
      encoding: "base58"
    }
  };
}
function whirlpoolRewardVault1Filter(rewardVault1) {
  return {
    memcmp: {
      offset: 301n,
      bytes: getBase58Decoder8().decode(
        getAddressEncoder22().encode(rewardVault1)
      ),
      encoding: "base58"
    }
  };
}
function whirlpoolRewardMint2Filter(rewardMint2) {
  return {
    memcmp: {
      offset: 397n,
      bytes: getBase58Decoder8().decode(getAddressEncoder22().encode(rewardMint2)),
      encoding: "base58"
    }
  };
}
function whirlpoolRewardVault2Filter(rewardVault2) {
  return {
    memcmp: {
      offset: 429n,
      bytes: getBase58Decoder8().decode(
        getAddressEncoder22().encode(rewardVault2)
      ),
      encoding: "base58"
    }
  };
}
function whirlpoolRewardMint3Filter(rewardMint3) {
  return {
    memcmp: {
      offset: 525n,
      bytes: getBase58Decoder8().decode(getAddressEncoder22().encode(rewardMint3)),
      encoding: "base58"
    }
  };
}
function whirlpoolRewardVault3Filter(rewardVault3) {
  return {
    memcmp: {
      offset: 557n,
      bytes: getBase58Decoder8().decode(
        getAddressEncoder22().encode(rewardVault3)
      ),
      encoding: "base58"
    }
  };
}
async function fetchAllWhirlpoolWithFilter(rpc, ...filters) {
  const discriminator = getBase58Decoder8().decode(WHIRLPOOL_DISCRIMINATOR);
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getWhirlpoolDecoder()
  );
}

// src/gpa/whirlpoolsConfig.ts
import {
  getBase58Decoder as getBase58Decoder9,
  getAddressEncoder as getAddressEncoder23,
  getU16Encoder as getU16Encoder24
} from "@solana/kit";
function whirlpoolsConfigFeeAuthorityFilter(feeAuthority) {
  return {
    memcmp: {
      offset: 8n,
      bytes: getBase58Decoder9().decode(
        getAddressEncoder23().encode(feeAuthority)
      ),
      encoding: "base58"
    }
  };
}
function whirlpoolsConfigCollectProtocolFeesAuthorityFilter(collectProtocolFeesAuthority) {
  return {
    memcmp: {
      offset: 40n,
      bytes: getBase58Decoder9().decode(
        getAddressEncoder23().encode(collectProtocolFeesAuthority)
      ),
      encoding: "base58"
    }
  };
}
function whirlpoolsConfigRewardEmissionsSuperAuthorityFilter(rewardEmissionsSuperAuthority) {
  return {
    memcmp: {
      offset: 72n,
      bytes: getBase58Decoder9().decode(
        getAddressEncoder23().encode(rewardEmissionsSuperAuthority)
      ),
      encoding: "base58"
    }
  };
}
function whirlpoolsConfigDefaultProtocolFeeRateFilter(defaultFeeRate) {
  return {
    memcmp: {
      offset: 104n,
      bytes: getBase58Decoder9().decode(getU16Encoder24().encode(defaultFeeRate)),
      encoding: "base58"
    }
  };
}
async function fetchAllWhirlpoolsConfigWithFilter(rpc, ...filters) {
  const discriminator = getBase58Decoder9().decode(
    WHIRLPOOLS_CONFIG_DISCRIMINATOR
  );
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getWhirlpoolsConfigDecoder()
  );
}

// src/gpa/whirlpoolsConfigExtension.ts
import { getBase58Decoder as getBase58Decoder10, getAddressEncoder as getAddressEncoder24 } from "@solana/kit";
function whirlpoolsConfigExtensionWhirlpoolsConfigFilter(address) {
  return {
    memcmp: {
      offset: 8n,
      bytes: getBase58Decoder10().decode(getAddressEncoder24().encode(address)),
      encoding: "base58"
    }
  };
}
function whirlpoolsConfigExtensionConfigExtensionAuthorityFilter(configExtensionAuthority) {
  return {
    memcmp: {
      offset: 40n,
      bytes: getBase58Decoder10().decode(
        getAddressEncoder24().encode(configExtensionAuthority)
      ),
      encoding: "base58"
    }
  };
}
function whirlpoolsConfigExtensionConfigTokenBadgeAuthorityFilter(configTokenBadgeAuthority) {
  return {
    memcmp: {
      offset: 72n,
      bytes: getBase58Decoder10().decode(
        getAddressEncoder24().encode(configTokenBadgeAuthority)
      ),
      encoding: "base58"
    }
  };
}
async function fetchAllWhirlpoolsConfigExtensionWithFilter(rpc, ...filters) {
  const discriminator = getBase58Decoder10().decode(
    WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR
  );
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getWhirlpoolsConfigExtensionDecoder()
  );
}

// src/pda/feeTier.ts
import {
  getAddressEncoder as getAddressEncoder25,
  getProgramDerivedAddress,
  getU16Encoder as getU16Encoder25
} from "@solana/kit";
async function getFeeTierAddress(whirlpoolsConfig, feeTierIndex) {
  return await getProgramDerivedAddress({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: [
      "fee_tier",
      getAddressEncoder25().encode(whirlpoolsConfig),
      getU16Encoder25().encode(feeTierIndex)
    ]
  });
}

// src/pda/oracle.ts
import { getAddressEncoder as getAddressEncoder26, getProgramDerivedAddress as getProgramDerivedAddress2 } from "@solana/kit";
async function getOracleAddress(whirlpool) {
  return await getProgramDerivedAddress2({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: ["oracle", getAddressEncoder26().encode(whirlpool)]
  });
}

// src/pda/position.ts
import { getAddressEncoder as getAddressEncoder27, getProgramDerivedAddress as getProgramDerivedAddress3 } from "@solana/kit";
async function getPositionAddress(positionMint) {
  return await getProgramDerivedAddress3({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: ["position", getAddressEncoder27().encode(positionMint)]
  });
}

// src/pda/positionBundle.ts
import { getAddressEncoder as getAddressEncoder28, getProgramDerivedAddress as getProgramDerivedAddress4 } from "@solana/kit";
async function getPositionBundleAddress(positionBundleMint) {
  return await getProgramDerivedAddress4({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: ["position_bundle", getAddressEncoder28().encode(positionBundleMint)]
  });
}
async function getBundledPositionAddress(positionBundleAddress, bundleIndex) {
  return await getProgramDerivedAddress4({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: [
      "bundled_position",
      getAddressEncoder28().encode(positionBundleAddress),
      Buffer.from(bundleIndex.toString())
    ]
  });
}

// src/pda/tickArray.ts
import { getAddressEncoder as getAddressEncoder29, getProgramDerivedAddress as getProgramDerivedAddress5 } from "@solana/kit";
async function getTickArrayAddress(whirlpool, startTickIndex) {
  return await getProgramDerivedAddress5({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: [
      "tick_array",
      getAddressEncoder29().encode(whirlpool),
      `${startTickIndex}`
    ]
  });
}

// src/pda/tokenBadge.ts
import { getAddressEncoder as getAddressEncoder30, getProgramDerivedAddress as getProgramDerivedAddress6 } from "@solana/kit";
async function getTokenBadgeAddress(whirlpoolsConfig, tokenMint) {
  return await getProgramDerivedAddress6({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: [
      "token_badge",
      getAddressEncoder30().encode(whirlpoolsConfig),
      getAddressEncoder30().encode(tokenMint)
    ]
  });
}

// src/pda/whirlpool.ts
import {
  getAddressEncoder as getAddressEncoder31,
  getProgramDerivedAddress as getProgramDerivedAddress7,
  getU16Encoder as getU16Encoder26
} from "@solana/kit";
async function getWhirlpoolAddress(whirlpoolsConfig, tokenMintA, tokenMintB, feeTierIndex) {
  return await getProgramDerivedAddress7({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: [
      "whirlpool",
      getAddressEncoder31().encode(whirlpoolsConfig),
      getAddressEncoder31().encode(tokenMintA),
      getAddressEncoder31().encode(tokenMintB),
      getU16Encoder26().encode(feeTierIndex)
    ]
  });
}

// src/pda/whirlpoolsConfigExtension.ts
import { getAddressEncoder as getAddressEncoder32, getProgramDerivedAddress as getProgramDerivedAddress8 } from "@solana/kit";
async function getWhirlpoolsConfigExtensionAddress(configAddress) {
  return await getProgramDerivedAddress8({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: ["config_extension", getAddressEncoder32().encode(configAddress)]
  });
}
export {
  ADAPTIVE_FEE_TIER_DISCRIMINATOR,
  AccountsType,
  CLOSE_BUNDLED_POSITION_DISCRIMINATOR,
  CLOSE_POSITION_DISCRIMINATOR,
  CLOSE_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR,
  COLLECT_FEES_DISCRIMINATOR,
  COLLECT_FEES_V2_DISCRIMINATOR,
  COLLECT_PROTOCOL_FEES_DISCRIMINATOR,
  COLLECT_PROTOCOL_FEES_V2_DISCRIMINATOR,
  COLLECT_REWARD_DISCRIMINATOR,
  COLLECT_REWARD_V2_DISCRIMINATOR,
  DECREASE_LIQUIDITY_DISCRIMINATOR,
  DECREASE_LIQUIDITY_V2_DISCRIMINATOR,
  DELETE_POSITION_BUNDLE_DISCRIMINATOR,
  DELETE_TOKEN_BADGE_DISCRIMINATOR,
  FEE_TIER_DISCRIMINATOR,
  INCREASE_LIQUIDITY_DISCRIMINATOR,
  INCREASE_LIQUIDITY_V2_DISCRIMINATOR,
  INITIALIZE_ADAPTIVE_FEE_TIER_DISCRIMINATOR,
  INITIALIZE_CONFIG_DISCRIMINATOR,
  INITIALIZE_CONFIG_EXTENSION_DISCRIMINATOR,
  INITIALIZE_FEE_TIER_DISCRIMINATOR,
  INITIALIZE_POOL_DISCRIMINATOR,
  INITIALIZE_POOL_V2_DISCRIMINATOR,
  INITIALIZE_POOL_WITH_ADAPTIVE_FEE_DISCRIMINATOR,
  INITIALIZE_POSITION_BUNDLE_DISCRIMINATOR,
  INITIALIZE_POSITION_BUNDLE_WITH_METADATA_DISCRIMINATOR,
  INITIALIZE_REWARD_DISCRIMINATOR,
  INITIALIZE_REWARD_V2_DISCRIMINATOR,
  INITIALIZE_TICK_ARRAY_DISCRIMINATOR,
  INITIALIZE_TOKEN_BADGE_DISCRIMINATOR,
  LOCK_CONFIG_DISCRIMINATOR,
  LOCK_POSITION_DISCRIMINATOR,
  LockType,
  LockTypeLabel,
  OPEN_BUNDLED_POSITION_DISCRIMINATOR,
  OPEN_POSITION_DISCRIMINATOR,
  OPEN_POSITION_WITH_METADATA_DISCRIMINATOR,
  OPEN_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR,
  ORACLE_DISCRIMINATOR,
  POSITION_BUNDLE_DISCRIMINATOR,
  POSITION_DISCRIMINATOR,
  RESET_POSITION_RANGE_DISCRIMINATOR,
  SET_COLLECT_PROTOCOL_FEES_AUTHORITY_DISCRIMINATOR,
  SET_CONFIG_EXTENSION_AUTHORITY_DISCRIMINATOR,
  SET_DEFAULT_BASE_FEE_RATE_DISCRIMINATOR,
  SET_DEFAULT_FEE_RATE_DISCRIMINATOR,
  SET_DEFAULT_PROTOCOL_FEE_RATE_DISCRIMINATOR,
  SET_DELEGATED_FEE_AUTHORITY_DISCRIMINATOR,
  SET_FEE_AUTHORITY_DISCRIMINATOR,
  SET_FEE_RATE_BY_DELEGATED_FEE_AUTHORITY_DISCRIMINATOR,
  SET_FEE_RATE_DISCRIMINATOR,
  SET_INITIALIZE_POOL_AUTHORITY_DISCRIMINATOR,
  SET_PRESET_ADAPTIVE_FEE_CONSTANTS_DISCRIMINATOR,
  SET_PROTOCOL_FEE_RATE_DISCRIMINATOR,
  SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_DISCRIMINATOR,
  SET_REWARD_AUTHORITY_DISCRIMINATOR,
  SET_REWARD_EMISSIONS_DISCRIMINATOR,
  SET_REWARD_EMISSIONS_SUPER_AUTHORITY_DISCRIMINATOR,
  SET_REWARD_EMISSIONS_V2_DISCRIMINATOR,
  SET_TOKEN_BADGE_AUTHORITY_DISCRIMINATOR,
  SWAP_DISCRIMINATOR,
  SWAP_V2_DISCRIMINATOR,
  TICK_ARRAY_DISCRIMINATOR,
  TOKEN_BADGE_DISCRIMINATOR,
  TRANSFER_LOCKED_POSITION_DISCRIMINATOR,
  TWO_HOP_SWAP_DISCRIMINATOR,
  TWO_HOP_SWAP_V2_DISCRIMINATOR,
  UPDATE_FEES_AND_REWARDS_DISCRIMINATOR,
  WHIRLPOOLS_CONFIG_DISCRIMINATOR,
  WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR,
  WHIRLPOOL_DISCRIMINATOR,
  WHIRLPOOL_ERROR__AMOUNT_CALC_OVERFLOW,
  WHIRLPOOL_ERROR__AMOUNT_IN_ABOVE_MAXIMUM,
  WHIRLPOOL_ERROR__AMOUNT_OUT_BELOW_MINIMUM,
  WHIRLPOOL_ERROR__AMOUNT_REMAINING_OVERFLOW,
  WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_CLOSED,
  WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_OPENED,
  WHIRLPOOL_ERROR__CLOSE_POSITION_NOT_EMPTY,
  WHIRLPOOL_ERROR__DIFFERENT_WHIRLPOOL_TICK_ARRAY_ACCOUNT,
  WHIRLPOOL_ERROR__DIVIDE_BY_ZERO,
  WHIRLPOOL_ERROR__DUPLICATE_TWO_HOP_POOL,
  WHIRLPOOL_ERROR__FEE_RATE_MAX_EXCEEDED,
  WHIRLPOOL_ERROR__FULL_RANGE_ONLY_POOL,
  WHIRLPOOL_ERROR__INTERMEDIATE_TOKEN_AMOUNT_MISMATCH,
  WHIRLPOOL_ERROR__INVALID_ADAPTIVE_FEE_CONSTANTS,
  WHIRLPOOL_ERROR__INVALID_BUNDLE_INDEX,
  WHIRLPOOL_ERROR__INVALID_ENUM,
  WHIRLPOOL_ERROR__INVALID_FEE_TIER_INDEX,
  WHIRLPOOL_ERROR__INVALID_INTERMEDIARY_MINT,
  WHIRLPOOL_ERROR__INVALID_POSITION_TOKEN_AMOUNT,
  WHIRLPOOL_ERROR__INVALID_REWARD_INDEX,
  WHIRLPOOL_ERROR__INVALID_SQRT_PRICE_LIMIT_DIRECTION,
  WHIRLPOOL_ERROR__INVALID_START_TICK,
  WHIRLPOOL_ERROR__INVALID_TICK_ARRAY_SEQUENCE,
  WHIRLPOOL_ERROR__INVALID_TICK_INDEX,
  WHIRLPOOL_ERROR__INVALID_TICK_SPACING,
  WHIRLPOOL_ERROR__INVALID_TIMESTAMP,
  WHIRLPOOL_ERROR__INVALID_TIMESTAMP_CONVERSION,
  WHIRLPOOL_ERROR__INVALID_TOKEN_MINT_ORDER,
  WHIRLPOOL_ERROR__INVALID_TRADE_ENABLE_TIMESTAMP,
  WHIRLPOOL_ERROR__LIQUIDITY_NET_ERROR,
  WHIRLPOOL_ERROR__LIQUIDITY_OVERFLOW,
  WHIRLPOOL_ERROR__LIQUIDITY_TOO_HIGH,
  WHIRLPOOL_ERROR__LIQUIDITY_UNDERFLOW,
  WHIRLPOOL_ERROR__LIQUIDITY_ZERO,
  WHIRLPOOL_ERROR__MISSING_OR_INVALID_DELEGATE,
  WHIRLPOOL_ERROR__MULTIPLICATION_OVERFLOW,
  WHIRLPOOL_ERROR__MULTIPLICATION_SHIFT_RIGHT_OVERFLOW,
  WHIRLPOOL_ERROR__MUL_DIV_INVALID_INPUT,
  WHIRLPOOL_ERROR__MUL_DIV_OVERFLOW,
  WHIRLPOOL_ERROR__NO_EXTRA_ACCOUNTS_FOR_TRANSFER_HOOK,
  WHIRLPOOL_ERROR__NUMBER_CAST_ERROR,
  WHIRLPOOL_ERROR__NUMBER_DOWN_CAST_ERROR,
  WHIRLPOOL_ERROR__OPERATION_NOT_ALLOWED_ON_LOCKED_POSITION,
  WHIRLPOOL_ERROR__PARTIAL_FILL_ERROR,
  WHIRLPOOL_ERROR__POSITION_BUNDLE_NOT_DELETABLE,
  WHIRLPOOL_ERROR__POSITION_NOT_LOCKABLE,
  WHIRLPOOL_ERROR__PROTOCOL_FEE_RATE_MAX_EXCEEDED,
  WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_DUPLICATED_ACCOUNTS_TYPE,
  WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INSUFFICIENT,
  WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INVALID_SLICE,
  WHIRLPOOL_ERROR__REWARD_NOT_INITIALIZED,
  WHIRLPOOL_ERROR__REWARD_VAULT_AMOUNT_INSUFFICIENT,
  WHIRLPOOL_ERROR__SAME_TICK_RANGE_NOT_ALLOWED,
  WHIRLPOOL_ERROR__SQRT_PRICE_OUT_OF_BOUNDS,
  WHIRLPOOL_ERROR__TICK_ARRAY_EXIST_IN_POOL,
  WHIRLPOOL_ERROR__TICK_ARRAY_INDEX_OUTOF_BOUNDS,
  WHIRLPOOL_ERROR__TICK_ARRAY_SEQUENCE_INVALID_INDEX,
  WHIRLPOOL_ERROR__TICK_NOT_FOUND,
  WHIRLPOOL_ERROR__TOKEN_MAX_EXCEEDED,
  WHIRLPOOL_ERROR__TOKEN_MIN_SUBCEEDED,
  WHIRLPOOL_ERROR__TOO_MANY_SUPPLEMENTAL_TICK_ARRAYS,
  WHIRLPOOL_ERROR__TRADE_IS_NOT_ENABLED,
  WHIRLPOOL_ERROR__TRANSFER_FEE_CALCULATION_ERROR,
  WHIRLPOOL_ERROR__UNSUPPORTED_TOKEN_MINT,
  WHIRLPOOL_ERROR__ZERO_TRADABLE_AMOUNT,
  WHIRLPOOL_PROGRAM_ADDRESS,
  WhirlpoolAccount,
  WhirlpoolInstruction,
  adaptiveFeeTierAdaptiveFeeControlFactorFilter,
  adaptiveFeeTierDecayPeriodFilter,
  adaptiveFeeTierDefaultBaseFeeRateFilter,
  adaptiveFeeTierDelegatedFeeAuthorityFilter,
  adaptiveFeeTierFeeTierIndexFilter,
  adaptiveFeeTierFilterPeriodFilter,
  adaptiveFeeTierInitializePoolAuthorityFilter,
  adaptiveFeeTierMajorSwapThresholdTicksFilter,
  adaptiveFeeTierMaxVolatilityFilter,
  adaptiveFeeTierReductionFactorFilter,
  adaptiveFeeTierTickGroupSizeFilter,
  adaptiveFeeTierTickSpacingFilter,
  adaptiveFeeTierWhirlpoolsConfigFilter,
  decodeAdaptiveFeeTier,
  decodeFeeTier,
  decodeLockConfig,
  decodeOracle,
  decodePosition,
  decodePositionBundle,
  decodeTickArray,
  decodeTokenBadge,
  decodeWhirlpool,
  decodeWhirlpoolsConfig,
  decodeWhirlpoolsConfigExtension,
  feeTierFeeRateFilter,
  feeTierTickSpacingFilter,
  feeTierWhirlpoolsConfigFilter,
  fetchAdaptiveFeeTier,
  fetchAllAdaptiveFeeTier,
  fetchAllAdaptiveFeeTierWithFilter,
  fetchAllFeeTier,
  fetchAllFeeTierWithFilter,
  fetchAllLockConfig,
  fetchAllMaybeAdaptiveFeeTier,
  fetchAllMaybeFeeTier,
  fetchAllMaybeLockConfig,
  fetchAllMaybeOracle,
  fetchAllMaybePosition,
  fetchAllMaybePositionBundle,
  fetchAllMaybeTickArray,
  fetchAllMaybeTokenBadge,
  fetchAllMaybeWhirlpool,
  fetchAllMaybeWhirlpoolsConfig,
  fetchAllMaybeWhirlpoolsConfigExtension,
  fetchAllOracle,
  fetchAllOracleWithFilter,
  fetchAllPosition,
  fetchAllPositionBundle,
  fetchAllPositionBundleWithFilter,
  fetchAllPositionWithFilter,
  fetchAllTickArray,
  fetchAllTickArrayWithFilter,
  fetchAllTokenBadge,
  fetchAllTokenBadgeWithFilter,
  fetchAllWhirlpool,
  fetchAllWhirlpoolWithFilter,
  fetchAllWhirlpoolsConfig,
  fetchAllWhirlpoolsConfigExtension,
  fetchAllWhirlpoolsConfigExtensionWithFilter,
  fetchAllWhirlpoolsConfigWithFilter,
  fetchFeeTier,
  fetchLockConfig,
  fetchMaybeAdaptiveFeeTier,
  fetchMaybeFeeTier,
  fetchMaybeLockConfig,
  fetchMaybeOracle,
  fetchMaybePosition,
  fetchMaybePositionBundle,
  fetchMaybeTickArray,
  fetchMaybeTokenBadge,
  fetchMaybeWhirlpool,
  fetchMaybeWhirlpoolsConfig,
  fetchMaybeWhirlpoolsConfigExtension,
  fetchOracle,
  fetchPosition,
  fetchPositionBundle,
  fetchTickArray,
  fetchTokenBadge,
  fetchWhirlpool,
  fetchWhirlpoolsConfig,
  fetchWhirlpoolsConfigExtension,
  getAccountsTypeCodec,
  getAccountsTypeDecoder,
  getAccountsTypeEncoder,
  getAdaptiveFeeConstantsCodec,
  getAdaptiveFeeConstantsDecoder,
  getAdaptiveFeeConstantsEncoder,
  getAdaptiveFeeTierCodec,
  getAdaptiveFeeTierDecoder,
  getAdaptiveFeeTierDiscriminatorBytes,
  getAdaptiveFeeTierEncoder,
  getAdaptiveFeeTierSize,
  getAdaptiveFeeVariablesCodec,
  getAdaptiveFeeVariablesDecoder,
  getAdaptiveFeeVariablesEncoder,
  getBundledPositionAddress,
  getCloseBundledPositionDiscriminatorBytes,
  getCloseBundledPositionInstruction,
  getCloseBundledPositionInstructionDataCodec,
  getCloseBundledPositionInstructionDataDecoder,
  getCloseBundledPositionInstructionDataEncoder,
  getClosePositionDiscriminatorBytes,
  getClosePositionInstruction,
  getClosePositionInstructionDataCodec,
  getClosePositionInstructionDataDecoder,
  getClosePositionInstructionDataEncoder,
  getClosePositionWithTokenExtensionsDiscriminatorBytes,
  getClosePositionWithTokenExtensionsInstruction,
  getClosePositionWithTokenExtensionsInstructionDataCodec,
  getClosePositionWithTokenExtensionsInstructionDataDecoder,
  getClosePositionWithTokenExtensionsInstructionDataEncoder,
  getCollectFeesDiscriminatorBytes,
  getCollectFeesInstruction,
  getCollectFeesInstructionDataCodec,
  getCollectFeesInstructionDataDecoder,
  getCollectFeesInstructionDataEncoder,
  getCollectFeesV2DiscriminatorBytes,
  getCollectFeesV2Instruction,
  getCollectFeesV2InstructionDataCodec,
  getCollectFeesV2InstructionDataDecoder,
  getCollectFeesV2InstructionDataEncoder,
  getCollectProtocolFeesDiscriminatorBytes,
  getCollectProtocolFeesInstruction,
  getCollectProtocolFeesInstructionDataCodec,
  getCollectProtocolFeesInstructionDataDecoder,
  getCollectProtocolFeesInstructionDataEncoder,
  getCollectProtocolFeesV2DiscriminatorBytes,
  getCollectProtocolFeesV2Instruction,
  getCollectProtocolFeesV2InstructionDataCodec,
  getCollectProtocolFeesV2InstructionDataDecoder,
  getCollectProtocolFeesV2InstructionDataEncoder,
  getCollectRewardDiscriminatorBytes,
  getCollectRewardInstruction,
  getCollectRewardInstructionDataCodec,
  getCollectRewardInstructionDataDecoder,
  getCollectRewardInstructionDataEncoder,
  getCollectRewardV2DiscriminatorBytes,
  getCollectRewardV2Instruction,
  getCollectRewardV2InstructionDataCodec,
  getCollectRewardV2InstructionDataDecoder,
  getCollectRewardV2InstructionDataEncoder,
  getDecreaseLiquidityDiscriminatorBytes,
  getDecreaseLiquidityInstruction,
  getDecreaseLiquidityInstructionDataCodec,
  getDecreaseLiquidityInstructionDataDecoder,
  getDecreaseLiquidityInstructionDataEncoder,
  getDecreaseLiquidityV2DiscriminatorBytes,
  getDecreaseLiquidityV2Instruction,
  getDecreaseLiquidityV2InstructionDataCodec,
  getDecreaseLiquidityV2InstructionDataDecoder,
  getDecreaseLiquidityV2InstructionDataEncoder,
  getDeletePositionBundleDiscriminatorBytes,
  getDeletePositionBundleInstruction,
  getDeletePositionBundleInstructionDataCodec,
  getDeletePositionBundleInstructionDataDecoder,
  getDeletePositionBundleInstructionDataEncoder,
  getDeleteTokenBadgeDiscriminatorBytes,
  getDeleteTokenBadgeInstruction,
  getDeleteTokenBadgeInstructionDataCodec,
  getDeleteTokenBadgeInstructionDataDecoder,
  getDeleteTokenBadgeInstructionDataEncoder,
  getFeeTierAddress,
  getFeeTierCodec,
  getFeeTierDecoder,
  getFeeTierDiscriminatorBytes,
  getFeeTierEncoder,
  getFeeTierSize,
  getIncreaseLiquidityDiscriminatorBytes,
  getIncreaseLiquidityInstruction,
  getIncreaseLiquidityInstructionDataCodec,
  getIncreaseLiquidityInstructionDataDecoder,
  getIncreaseLiquidityInstructionDataEncoder,
  getIncreaseLiquidityV2DiscriminatorBytes,
  getIncreaseLiquidityV2Instruction,
  getIncreaseLiquidityV2InstructionDataCodec,
  getIncreaseLiquidityV2InstructionDataDecoder,
  getIncreaseLiquidityV2InstructionDataEncoder,
  getInitializeAdaptiveFeeTierDiscriminatorBytes,
  getInitializeAdaptiveFeeTierInstruction,
  getInitializeAdaptiveFeeTierInstructionDataCodec,
  getInitializeAdaptiveFeeTierInstructionDataDecoder,
  getInitializeAdaptiveFeeTierInstructionDataEncoder,
  getInitializeConfigDiscriminatorBytes,
  getInitializeConfigExtensionDiscriminatorBytes,
  getInitializeConfigExtensionInstruction,
  getInitializeConfigExtensionInstructionDataCodec,
  getInitializeConfigExtensionInstructionDataDecoder,
  getInitializeConfigExtensionInstructionDataEncoder,
  getInitializeConfigInstruction,
  getInitializeConfigInstructionDataCodec,
  getInitializeConfigInstructionDataDecoder,
  getInitializeConfigInstructionDataEncoder,
  getInitializeFeeTierDiscriminatorBytes,
  getInitializeFeeTierInstruction,
  getInitializeFeeTierInstructionDataCodec,
  getInitializeFeeTierInstructionDataDecoder,
  getInitializeFeeTierInstructionDataEncoder,
  getInitializePoolDiscriminatorBytes,
  getInitializePoolInstruction,
  getInitializePoolInstructionDataCodec,
  getInitializePoolInstructionDataDecoder,
  getInitializePoolInstructionDataEncoder,
  getInitializePoolV2DiscriminatorBytes,
  getInitializePoolV2Instruction,
  getInitializePoolV2InstructionDataCodec,
  getInitializePoolV2InstructionDataDecoder,
  getInitializePoolV2InstructionDataEncoder,
  getInitializePoolWithAdaptiveFeeDiscriminatorBytes,
  getInitializePoolWithAdaptiveFeeInstruction,
  getInitializePoolWithAdaptiveFeeInstructionDataCodec,
  getInitializePoolWithAdaptiveFeeInstructionDataDecoder,
  getInitializePoolWithAdaptiveFeeInstructionDataEncoder,
  getInitializePositionBundleDiscriminatorBytes,
  getInitializePositionBundleInstruction,
  getInitializePositionBundleInstructionDataCodec,
  getInitializePositionBundleInstructionDataDecoder,
  getInitializePositionBundleInstructionDataEncoder,
  getInitializePositionBundleWithMetadataDiscriminatorBytes,
  getInitializePositionBundleWithMetadataInstruction,
  getInitializePositionBundleWithMetadataInstructionDataCodec,
  getInitializePositionBundleWithMetadataInstructionDataDecoder,
  getInitializePositionBundleWithMetadataInstructionDataEncoder,
  getInitializeRewardDiscriminatorBytes,
  getInitializeRewardInstruction,
  getInitializeRewardInstructionDataCodec,
  getInitializeRewardInstructionDataDecoder,
  getInitializeRewardInstructionDataEncoder,
  getInitializeRewardV2DiscriminatorBytes,
  getInitializeRewardV2Instruction,
  getInitializeRewardV2InstructionDataCodec,
  getInitializeRewardV2InstructionDataDecoder,
  getInitializeRewardV2InstructionDataEncoder,
  getInitializeTickArrayDiscriminatorBytes,
  getInitializeTickArrayInstruction,
  getInitializeTickArrayInstructionDataCodec,
  getInitializeTickArrayInstructionDataDecoder,
  getInitializeTickArrayInstructionDataEncoder,
  getInitializeTokenBadgeDiscriminatorBytes,
  getInitializeTokenBadgeInstruction,
  getInitializeTokenBadgeInstructionDataCodec,
  getInitializeTokenBadgeInstructionDataDecoder,
  getInitializeTokenBadgeInstructionDataEncoder,
  getLockConfigCodec,
  getLockConfigDecoder,
  getLockConfigDiscriminatorBytes,
  getLockConfigEncoder,
  getLockConfigSize,
  getLockPositionDiscriminatorBytes,
  getLockPositionInstruction,
  getLockPositionInstructionDataCodec,
  getLockPositionInstructionDataDecoder,
  getLockPositionInstructionDataEncoder,
  getLockTypeCodec,
  getLockTypeDecoder,
  getLockTypeEncoder,
  getLockTypeLabelCodec,
  getLockTypeLabelDecoder,
  getLockTypeLabelEncoder,
  getOpenBundledPositionDiscriminatorBytes,
  getOpenBundledPositionInstruction,
  getOpenBundledPositionInstructionDataCodec,
  getOpenBundledPositionInstructionDataDecoder,
  getOpenBundledPositionInstructionDataEncoder,
  getOpenPositionDiscriminatorBytes,
  getOpenPositionInstruction,
  getOpenPositionInstructionDataCodec,
  getOpenPositionInstructionDataDecoder,
  getOpenPositionInstructionDataEncoder,
  getOpenPositionWithMetadataDiscriminatorBytes,
  getOpenPositionWithMetadataInstruction,
  getOpenPositionWithMetadataInstructionDataCodec,
  getOpenPositionWithMetadataInstructionDataDecoder,
  getOpenPositionWithMetadataInstructionDataEncoder,
  getOpenPositionWithTokenExtensionsDiscriminatorBytes,
  getOpenPositionWithTokenExtensionsInstruction,
  getOpenPositionWithTokenExtensionsInstructionDataCodec,
  getOpenPositionWithTokenExtensionsInstructionDataDecoder,
  getOpenPositionWithTokenExtensionsInstructionDataEncoder,
  getOracleAddress,
  getOracleCodec,
  getOracleDecoder,
  getOracleDiscriminatorBytes,
  getOracleEncoder,
  getOracleSize,
  getPositionAddress,
  getPositionBundleAddress,
  getPositionBundleCodec,
  getPositionBundleDecoder,
  getPositionBundleDiscriminatorBytes,
  getPositionBundleEncoder,
  getPositionBundleSize,
  getPositionCodec,
  getPositionDecoder,
  getPositionDiscriminatorBytes,
  getPositionEncoder,
  getPositionRewardInfoCodec,
  getPositionRewardInfoDecoder,
  getPositionRewardInfoEncoder,
  getPositionSize,
  getRemainingAccountsInfoCodec,
  getRemainingAccountsInfoDecoder,
  getRemainingAccountsInfoEncoder,
  getRemainingAccountsSliceCodec,
  getRemainingAccountsSliceDecoder,
  getRemainingAccountsSliceEncoder,
  getResetPositionRangeDiscriminatorBytes,
  getResetPositionRangeInstruction,
  getResetPositionRangeInstructionDataCodec,
  getResetPositionRangeInstructionDataDecoder,
  getResetPositionRangeInstructionDataEncoder,
  getSetCollectProtocolFeesAuthorityDiscriminatorBytes,
  getSetCollectProtocolFeesAuthorityInstruction,
  getSetCollectProtocolFeesAuthorityInstructionDataCodec,
  getSetCollectProtocolFeesAuthorityInstructionDataDecoder,
  getSetCollectProtocolFeesAuthorityInstructionDataEncoder,
  getSetConfigExtensionAuthorityDiscriminatorBytes,
  getSetConfigExtensionAuthorityInstruction,
  getSetConfigExtensionAuthorityInstructionDataCodec,
  getSetConfigExtensionAuthorityInstructionDataDecoder,
  getSetConfigExtensionAuthorityInstructionDataEncoder,
  getSetDefaultBaseFeeRateDiscriminatorBytes,
  getSetDefaultBaseFeeRateInstruction,
  getSetDefaultBaseFeeRateInstructionDataCodec,
  getSetDefaultBaseFeeRateInstructionDataDecoder,
  getSetDefaultBaseFeeRateInstructionDataEncoder,
  getSetDefaultFeeRateDiscriminatorBytes,
  getSetDefaultFeeRateInstruction,
  getSetDefaultFeeRateInstructionDataCodec,
  getSetDefaultFeeRateInstructionDataDecoder,
  getSetDefaultFeeRateInstructionDataEncoder,
  getSetDefaultProtocolFeeRateDiscriminatorBytes,
  getSetDefaultProtocolFeeRateInstruction,
  getSetDefaultProtocolFeeRateInstructionDataCodec,
  getSetDefaultProtocolFeeRateInstructionDataDecoder,
  getSetDefaultProtocolFeeRateInstructionDataEncoder,
  getSetDelegatedFeeAuthorityDiscriminatorBytes,
  getSetDelegatedFeeAuthorityInstruction,
  getSetDelegatedFeeAuthorityInstructionDataCodec,
  getSetDelegatedFeeAuthorityInstructionDataDecoder,
  getSetDelegatedFeeAuthorityInstructionDataEncoder,
  getSetFeeAuthorityDiscriminatorBytes,
  getSetFeeAuthorityInstruction,
  getSetFeeAuthorityInstructionDataCodec,
  getSetFeeAuthorityInstructionDataDecoder,
  getSetFeeAuthorityInstructionDataEncoder,
  getSetFeeRateByDelegatedFeeAuthorityDiscriminatorBytes,
  getSetFeeRateByDelegatedFeeAuthorityInstruction,
  getSetFeeRateByDelegatedFeeAuthorityInstructionDataCodec,
  getSetFeeRateByDelegatedFeeAuthorityInstructionDataDecoder,
  getSetFeeRateByDelegatedFeeAuthorityInstructionDataEncoder,
  getSetFeeRateDiscriminatorBytes,
  getSetFeeRateInstruction,
  getSetFeeRateInstructionDataCodec,
  getSetFeeRateInstructionDataDecoder,
  getSetFeeRateInstructionDataEncoder,
  getSetInitializePoolAuthorityDiscriminatorBytes,
  getSetInitializePoolAuthorityInstruction,
  getSetInitializePoolAuthorityInstructionDataCodec,
  getSetInitializePoolAuthorityInstructionDataDecoder,
  getSetInitializePoolAuthorityInstructionDataEncoder,
  getSetPresetAdaptiveFeeConstantsDiscriminatorBytes,
  getSetPresetAdaptiveFeeConstantsInstruction,
  getSetPresetAdaptiveFeeConstantsInstructionDataCodec,
  getSetPresetAdaptiveFeeConstantsInstructionDataDecoder,
  getSetPresetAdaptiveFeeConstantsInstructionDataEncoder,
  getSetProtocolFeeRateDiscriminatorBytes,
  getSetProtocolFeeRateInstruction,
  getSetProtocolFeeRateInstructionDataCodec,
  getSetProtocolFeeRateInstructionDataDecoder,
  getSetProtocolFeeRateInstructionDataEncoder,
  getSetRewardAuthorityBySuperAuthorityDiscriminatorBytes,
  getSetRewardAuthorityBySuperAuthorityInstruction,
  getSetRewardAuthorityBySuperAuthorityInstructionDataCodec,
  getSetRewardAuthorityBySuperAuthorityInstructionDataDecoder,
  getSetRewardAuthorityBySuperAuthorityInstructionDataEncoder,
  getSetRewardAuthorityDiscriminatorBytes,
  getSetRewardAuthorityInstruction,
  getSetRewardAuthorityInstructionDataCodec,
  getSetRewardAuthorityInstructionDataDecoder,
  getSetRewardAuthorityInstructionDataEncoder,
  getSetRewardEmissionsDiscriminatorBytes,
  getSetRewardEmissionsInstruction,
  getSetRewardEmissionsInstructionDataCodec,
  getSetRewardEmissionsInstructionDataDecoder,
  getSetRewardEmissionsInstructionDataEncoder,
  getSetRewardEmissionsSuperAuthorityDiscriminatorBytes,
  getSetRewardEmissionsSuperAuthorityInstruction,
  getSetRewardEmissionsSuperAuthorityInstructionDataCodec,
  getSetRewardEmissionsSuperAuthorityInstructionDataDecoder,
  getSetRewardEmissionsSuperAuthorityInstructionDataEncoder,
  getSetRewardEmissionsV2DiscriminatorBytes,
  getSetRewardEmissionsV2Instruction,
  getSetRewardEmissionsV2InstructionDataCodec,
  getSetRewardEmissionsV2InstructionDataDecoder,
  getSetRewardEmissionsV2InstructionDataEncoder,
  getSetTokenBadgeAuthorityDiscriminatorBytes,
  getSetTokenBadgeAuthorityInstruction,
  getSetTokenBadgeAuthorityInstructionDataCodec,
  getSetTokenBadgeAuthorityInstructionDataDecoder,
  getSetTokenBadgeAuthorityInstructionDataEncoder,
  getSwapDiscriminatorBytes,
  getSwapInstruction,
  getSwapInstructionDataCodec,
  getSwapInstructionDataDecoder,
  getSwapInstructionDataEncoder,
  getSwapV2DiscriminatorBytes,
  getSwapV2Instruction,
  getSwapV2InstructionDataCodec,
  getSwapV2InstructionDataDecoder,
  getSwapV2InstructionDataEncoder,
  getTickArrayAddress,
  getTickArrayCodec,
  getTickArrayDecoder,
  getTickArrayDiscriminatorBytes,
  getTickArrayEncoder,
  getTickArraySize,
  getTickCodec,
  getTickDecoder,
  getTickEncoder,
  getTokenBadgeAddress,
  getTokenBadgeCodec,
  getTokenBadgeDecoder,
  getTokenBadgeDiscriminatorBytes,
  getTokenBadgeEncoder,
  getTokenBadgeSize,
  getTransferLockedPositionDiscriminatorBytes,
  getTransferLockedPositionInstruction,
  getTransferLockedPositionInstructionDataCodec,
  getTransferLockedPositionInstructionDataDecoder,
  getTransferLockedPositionInstructionDataEncoder,
  getTwoHopSwapDiscriminatorBytes,
  getTwoHopSwapInstruction,
  getTwoHopSwapInstructionDataCodec,
  getTwoHopSwapInstructionDataDecoder,
  getTwoHopSwapInstructionDataEncoder,
  getTwoHopSwapV2DiscriminatorBytes,
  getTwoHopSwapV2Instruction,
  getTwoHopSwapV2InstructionDataCodec,
  getTwoHopSwapV2InstructionDataDecoder,
  getTwoHopSwapV2InstructionDataEncoder,
  getUpdateFeesAndRewardsDiscriminatorBytes,
  getUpdateFeesAndRewardsInstruction,
  getUpdateFeesAndRewardsInstructionDataCodec,
  getUpdateFeesAndRewardsInstructionDataDecoder,
  getUpdateFeesAndRewardsInstructionDataEncoder,
  getWhirlpoolAddress,
  getWhirlpoolCodec,
  getWhirlpoolDecoder,
  getWhirlpoolDiscriminatorBytes,
  getWhirlpoolEncoder,
  getWhirlpoolErrorMessage,
  getWhirlpoolRewardInfoCodec,
  getWhirlpoolRewardInfoDecoder,
  getWhirlpoolRewardInfoEncoder,
  getWhirlpoolSize,
  getWhirlpoolsConfigCodec,
  getWhirlpoolsConfigDecoder,
  getWhirlpoolsConfigDiscriminatorBytes,
  getWhirlpoolsConfigEncoder,
  getWhirlpoolsConfigExtensionAddress,
  getWhirlpoolsConfigExtensionCodec,
  getWhirlpoolsConfigExtensionDecoder,
  getWhirlpoolsConfigExtensionDiscriminatorBytes,
  getWhirlpoolsConfigExtensionEncoder,
  getWhirlpoolsConfigExtensionSize,
  getWhirlpoolsConfigSize,
  identifyWhirlpoolAccount,
  identifyWhirlpoolInstruction,
  isWhirlpoolError,
  oracleAdaptiveFeeControlFactorFilter,
  oracleDecayPeriodFilter,
  oracleFilterPeriodFilter,
  oracleMajorSwapThresholdTicksFilter,
  oracleMaxVolatilityFilter,
  oracleReductionFactorFilter,
  oracleTickGroupSizeFilter,
  oracleTradeEnableTimestampFilter,
  oracleWhirlpoolFilter,
  parseCloseBundledPositionInstruction,
  parseClosePositionInstruction,
  parseClosePositionWithTokenExtensionsInstruction,
  parseCollectFeesInstruction,
  parseCollectFeesV2Instruction,
  parseCollectProtocolFeesInstruction,
  parseCollectProtocolFeesV2Instruction,
  parseCollectRewardInstruction,
  parseCollectRewardV2Instruction,
  parseDecreaseLiquidityInstruction,
  parseDecreaseLiquidityV2Instruction,
  parseDeletePositionBundleInstruction,
  parseDeleteTokenBadgeInstruction,
  parseIncreaseLiquidityInstruction,
  parseIncreaseLiquidityV2Instruction,
  parseInitializeAdaptiveFeeTierInstruction,
  parseInitializeConfigExtensionInstruction,
  parseInitializeConfigInstruction,
  parseInitializeFeeTierInstruction,
  parseInitializePoolInstruction,
  parseInitializePoolV2Instruction,
  parseInitializePoolWithAdaptiveFeeInstruction,
  parseInitializePositionBundleInstruction,
  parseInitializePositionBundleWithMetadataInstruction,
  parseInitializeRewardInstruction,
  parseInitializeRewardV2Instruction,
  parseInitializeTickArrayInstruction,
  parseInitializeTokenBadgeInstruction,
  parseLockPositionInstruction,
  parseOpenBundledPositionInstruction,
  parseOpenPositionInstruction,
  parseOpenPositionWithMetadataInstruction,
  parseOpenPositionWithTokenExtensionsInstruction,
  parseResetPositionRangeInstruction,
  parseSetCollectProtocolFeesAuthorityInstruction,
  parseSetConfigExtensionAuthorityInstruction,
  parseSetDefaultBaseFeeRateInstruction,
  parseSetDefaultFeeRateInstruction,
  parseSetDefaultProtocolFeeRateInstruction,
  parseSetDelegatedFeeAuthorityInstruction,
  parseSetFeeAuthorityInstruction,
  parseSetFeeRateByDelegatedFeeAuthorityInstruction,
  parseSetFeeRateInstruction,
  parseSetInitializePoolAuthorityInstruction,
  parseSetPresetAdaptiveFeeConstantsInstruction,
  parseSetProtocolFeeRateInstruction,
  parseSetRewardAuthorityBySuperAuthorityInstruction,
  parseSetRewardAuthorityInstruction,
  parseSetRewardEmissionsInstruction,
  parseSetRewardEmissionsSuperAuthorityInstruction,
  parseSetRewardEmissionsV2Instruction,
  parseSetTokenBadgeAuthorityInstruction,
  parseSwapInstruction,
  parseSwapV2Instruction,
  parseTransferLockedPositionInstruction,
  parseTwoHopSwapInstruction,
  parseTwoHopSwapV2Instruction,
  parseUpdateFeesAndRewardsInstruction,
  positionBundleMintFilter,
  positionMintFilter,
  positionTickLowerIndexFilter,
  positionTickUpperIndexFilter,
  positionWhirlpoolFilter,
  tickArrayStartTickIndexFilter,
  tickArrayWhirlpoolFilter,
  tokenBadgeTokenMintFilter,
  tokenBadgeWhirlpoolsConfigFilter,
  whirlpoolFeeRateFilter,
  whirlpoolProtocolFeeRateFilter,
  whirlpoolRewardMint1Filter,
  whirlpoolRewardMint2Filter,
  whirlpoolRewardMint3Filter,
  whirlpoolRewardVault1Filter,
  whirlpoolRewardVault2Filter,
  whirlpoolRewardVault3Filter,
  whirlpoolTickSpacingFilter,
  whirlpoolTokenMintAFilter,
  whirlpoolTokenMintBFilter,
  whirlpoolTokenVaultAFilter,
  whirlpoolTokenVaultBFilter,
  whirlpoolWhirlpoolConfigFilter,
  whirlpoolsConfigCollectProtocolFeesAuthorityFilter,
  whirlpoolsConfigDefaultProtocolFeeRateFilter,
  whirlpoolsConfigExtensionConfigExtensionAuthorityFilter,
  whirlpoolsConfigExtensionConfigTokenBadgeAuthorityFilter,
  whirlpoolsConfigExtensionWhirlpoolsConfigFilter,
  whirlpoolsConfigFeeAuthorityFilter,
  whirlpoolsConfigRewardEmissionsSuperAuthorityFilter
};
//# sourceMappingURL=index.js.map
"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  ADAPTIVE_FEE_TIER_DISCRIMINATOR: () => ADAPTIVE_FEE_TIER_DISCRIMINATOR,
  AccountsType: () => AccountsType,
  CLOSE_BUNDLED_POSITION_DISCRIMINATOR: () => CLOSE_BUNDLED_POSITION_DISCRIMINATOR,
  CLOSE_POSITION_DISCRIMINATOR: () => CLOSE_POSITION_DISCRIMINATOR,
  CLOSE_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR: () => CLOSE_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR,
  COLLECT_FEES_DISCRIMINATOR: () => COLLECT_FEES_DISCRIMINATOR,
  COLLECT_FEES_V2_DISCRIMINATOR: () => COLLECT_FEES_V2_DISCRIMINATOR,
  COLLECT_PROTOCOL_FEES_DISCRIMINATOR: () => COLLECT_PROTOCOL_FEES_DISCRIMINATOR,
  COLLECT_PROTOCOL_FEES_V2_DISCRIMINATOR: () => COLLECT_PROTOCOL_FEES_V2_DISCRIMINATOR,
  COLLECT_REWARD_DISCRIMINATOR: () => COLLECT_REWARD_DISCRIMINATOR,
  COLLECT_REWARD_V2_DISCRIMINATOR: () => COLLECT_REWARD_V2_DISCRIMINATOR,
  DECREASE_LIQUIDITY_DISCRIMINATOR: () => DECREASE_LIQUIDITY_DISCRIMINATOR,
  DECREASE_LIQUIDITY_V2_DISCRIMINATOR: () => DECREASE_LIQUIDITY_V2_DISCRIMINATOR,
  DELETE_POSITION_BUNDLE_DISCRIMINATOR: () => DELETE_POSITION_BUNDLE_DISCRIMINATOR,
  DELETE_TOKEN_BADGE_DISCRIMINATOR: () => DELETE_TOKEN_BADGE_DISCRIMINATOR,
  FEE_TIER_DISCRIMINATOR: () => FEE_TIER_DISCRIMINATOR,
  INCREASE_LIQUIDITY_DISCRIMINATOR: () => INCREASE_LIQUIDITY_DISCRIMINATOR,
  INCREASE_LIQUIDITY_V2_DISCRIMINATOR: () => INCREASE_LIQUIDITY_V2_DISCRIMINATOR,
  INITIALIZE_ADAPTIVE_FEE_TIER_DISCRIMINATOR: () => INITIALIZE_ADAPTIVE_FEE_TIER_DISCRIMINATOR,
  INITIALIZE_CONFIG_DISCRIMINATOR: () => INITIALIZE_CONFIG_DISCRIMINATOR,
  INITIALIZE_CONFIG_EXTENSION_DISCRIMINATOR: () => INITIALIZE_CONFIG_EXTENSION_DISCRIMINATOR,
  INITIALIZE_FEE_TIER_DISCRIMINATOR: () => INITIALIZE_FEE_TIER_DISCRIMINATOR,
  INITIALIZE_POOL_DISCRIMINATOR: () => INITIALIZE_POOL_DISCRIMINATOR,
  INITIALIZE_POOL_V2_DISCRIMINATOR: () => INITIALIZE_POOL_V2_DISCRIMINATOR,
  INITIALIZE_POOL_WITH_ADAPTIVE_FEE_DISCRIMINATOR: () => INITIALIZE_POOL_WITH_ADAPTIVE_FEE_DISCRIMINATOR,
  INITIALIZE_POSITION_BUNDLE_DISCRIMINATOR: () => INITIALIZE_POSITION_BUNDLE_DISCRIMINATOR,
  INITIALIZE_POSITION_BUNDLE_WITH_METADATA_DISCRIMINATOR: () => INITIALIZE_POSITION_BUNDLE_WITH_METADATA_DISCRIMINATOR,
  INITIALIZE_REWARD_DISCRIMINATOR: () => INITIALIZE_REWARD_DISCRIMINATOR,
  INITIALIZE_REWARD_V2_DISCRIMINATOR: () => INITIALIZE_REWARD_V2_DISCRIMINATOR,
  INITIALIZE_TICK_ARRAY_DISCRIMINATOR: () => INITIALIZE_TICK_ARRAY_DISCRIMINATOR,
  INITIALIZE_TOKEN_BADGE_DISCRIMINATOR: () => INITIALIZE_TOKEN_BADGE_DISCRIMINATOR,
  LOCK_CONFIG_DISCRIMINATOR: () => LOCK_CONFIG_DISCRIMINATOR,
  LOCK_POSITION_DISCRIMINATOR: () => LOCK_POSITION_DISCRIMINATOR,
  LockType: () => LockType,
  LockTypeLabel: () => LockTypeLabel,
  OPEN_BUNDLED_POSITION_DISCRIMINATOR: () => OPEN_BUNDLED_POSITION_DISCRIMINATOR,
  OPEN_POSITION_DISCRIMINATOR: () => OPEN_POSITION_DISCRIMINATOR,
  OPEN_POSITION_WITH_METADATA_DISCRIMINATOR: () => OPEN_POSITION_WITH_METADATA_DISCRIMINATOR,
  OPEN_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR: () => OPEN_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR,
  ORACLE_DISCRIMINATOR: () => ORACLE_DISCRIMINATOR,
  POSITION_BUNDLE_DISCRIMINATOR: () => POSITION_BUNDLE_DISCRIMINATOR,
  POSITION_DISCRIMINATOR: () => POSITION_DISCRIMINATOR,
  RESET_POSITION_RANGE_DISCRIMINATOR: () => RESET_POSITION_RANGE_DISCRIMINATOR,
  SET_COLLECT_PROTOCOL_FEES_AUTHORITY_DISCRIMINATOR: () => SET_COLLECT_PROTOCOL_FEES_AUTHORITY_DISCRIMINATOR,
  SET_CONFIG_EXTENSION_AUTHORITY_DISCRIMINATOR: () => SET_CONFIG_EXTENSION_AUTHORITY_DISCRIMINATOR,
  SET_DEFAULT_BASE_FEE_RATE_DISCRIMINATOR: () => SET_DEFAULT_BASE_FEE_RATE_DISCRIMINATOR,
  SET_DEFAULT_FEE_RATE_DISCRIMINATOR: () => SET_DEFAULT_FEE_RATE_DISCRIMINATOR,
  SET_DEFAULT_PROTOCOL_FEE_RATE_DISCRIMINATOR: () => SET_DEFAULT_PROTOCOL_FEE_RATE_DISCRIMINATOR,
  SET_DELEGATED_FEE_AUTHORITY_DISCRIMINATOR: () => SET_DELEGATED_FEE_AUTHORITY_DISCRIMINATOR,
  SET_FEE_AUTHORITY_DISCRIMINATOR: () => SET_FEE_AUTHORITY_DISCRIMINATOR,
  SET_FEE_RATE_BY_DELEGATED_FEE_AUTHORITY_DISCRIMINATOR: () => SET_FEE_RATE_BY_DELEGATED_FEE_AUTHORITY_DISCRIMINATOR,
  SET_FEE_RATE_DISCRIMINATOR: () => SET_FEE_RATE_DISCRIMINATOR,
  SET_INITIALIZE_POOL_AUTHORITY_DISCRIMINATOR: () => SET_INITIALIZE_POOL_AUTHORITY_DISCRIMINATOR,
  SET_PRESET_ADAPTIVE_FEE_CONSTANTS_DISCRIMINATOR: () => SET_PRESET_ADAPTIVE_FEE_CONSTANTS_DISCRIMINATOR,
  SET_PROTOCOL_FEE_RATE_DISCRIMINATOR: () => SET_PROTOCOL_FEE_RATE_DISCRIMINATOR,
  SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_DISCRIMINATOR: () => SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_DISCRIMINATOR,
  SET_REWARD_AUTHORITY_DISCRIMINATOR: () => SET_REWARD_AUTHORITY_DISCRIMINATOR,
  SET_REWARD_EMISSIONS_DISCRIMINATOR: () => SET_REWARD_EMISSIONS_DISCRIMINATOR,
  SET_REWARD_EMISSIONS_SUPER_AUTHORITY_DISCRIMINATOR: () => SET_REWARD_EMISSIONS_SUPER_AUTHORITY_DISCRIMINATOR,
  SET_REWARD_EMISSIONS_V2_DISCRIMINATOR: () => SET_REWARD_EMISSIONS_V2_DISCRIMINATOR,
  SET_TOKEN_BADGE_AUTHORITY_DISCRIMINATOR: () => SET_TOKEN_BADGE_AUTHORITY_DISCRIMINATOR,
  SWAP_DISCRIMINATOR: () => SWAP_DISCRIMINATOR,
  SWAP_V2_DISCRIMINATOR: () => SWAP_V2_DISCRIMINATOR,
  TICK_ARRAY_DISCRIMINATOR: () => TICK_ARRAY_DISCRIMINATOR,
  TOKEN_BADGE_DISCRIMINATOR: () => TOKEN_BADGE_DISCRIMINATOR,
  TRANSFER_LOCKED_POSITION_DISCRIMINATOR: () => TRANSFER_LOCKED_POSITION_DISCRIMINATOR,
  TWO_HOP_SWAP_DISCRIMINATOR: () => TWO_HOP_SWAP_DISCRIMINATOR,
  TWO_HOP_SWAP_V2_DISCRIMINATOR: () => TWO_HOP_SWAP_V2_DISCRIMINATOR,
  UPDATE_FEES_AND_REWARDS_DISCRIMINATOR: () => UPDATE_FEES_AND_REWARDS_DISCRIMINATOR,
  WHIRLPOOLS_CONFIG_DISCRIMINATOR: () => WHIRLPOOLS_CONFIG_DISCRIMINATOR,
  WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR: () => WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR,
  WHIRLPOOL_DISCRIMINATOR: () => WHIRLPOOL_DISCRIMINATOR,
  WHIRLPOOL_ERROR__AMOUNT_CALC_OVERFLOW: () => WHIRLPOOL_ERROR__AMOUNT_CALC_OVERFLOW,
  WHIRLPOOL_ERROR__AMOUNT_IN_ABOVE_MAXIMUM: () => WHIRLPOOL_ERROR__AMOUNT_IN_ABOVE_MAXIMUM,
  WHIRLPOOL_ERROR__AMOUNT_OUT_BELOW_MINIMUM: () => WHIRLPOOL_ERROR__AMOUNT_OUT_BELOW_MINIMUM,
  WHIRLPOOL_ERROR__AMOUNT_REMAINING_OVERFLOW: () => WHIRLPOOL_ERROR__AMOUNT_REMAINING_OVERFLOW,
  WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_CLOSED: () => WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_CLOSED,
  WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_OPENED: () => WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_OPENED,
  WHIRLPOOL_ERROR__CLOSE_POSITION_NOT_EMPTY: () => WHIRLPOOL_ERROR__CLOSE_POSITION_NOT_EMPTY,
  WHIRLPOOL_ERROR__DIFFERENT_WHIRLPOOL_TICK_ARRAY_ACCOUNT: () => WHIRLPOOL_ERROR__DIFFERENT_WHIRLPOOL_TICK_ARRAY_ACCOUNT,
  WHIRLPOOL_ERROR__DIVIDE_BY_ZERO: () => WHIRLPOOL_ERROR__DIVIDE_BY_ZERO,
  WHIRLPOOL_ERROR__DUPLICATE_TWO_HOP_POOL: () => WHIRLPOOL_ERROR__DUPLICATE_TWO_HOP_POOL,
  WHIRLPOOL_ERROR__FEE_RATE_MAX_EXCEEDED: () => WHIRLPOOL_ERROR__FEE_RATE_MAX_EXCEEDED,
  WHIRLPOOL_ERROR__FULL_RANGE_ONLY_POOL: () => WHIRLPOOL_ERROR__FULL_RANGE_ONLY_POOL,
  WHIRLPOOL_ERROR__INTERMEDIATE_TOKEN_AMOUNT_MISMATCH: () => WHIRLPOOL_ERROR__INTERMEDIATE_TOKEN_AMOUNT_MISMATCH,
  WHIRLPOOL_ERROR__INVALID_ADAPTIVE_FEE_CONSTANTS: () => WHIRLPOOL_ERROR__INVALID_ADAPTIVE_FEE_CONSTANTS,
  WHIRLPOOL_ERROR__INVALID_BUNDLE_INDEX: () => WHIRLPOOL_ERROR__INVALID_BUNDLE_INDEX,
  WHIRLPOOL_ERROR__INVALID_ENUM: () => WHIRLPOOL_ERROR__INVALID_ENUM,
  WHIRLPOOL_ERROR__INVALID_FEE_TIER_INDEX: () => WHIRLPOOL_ERROR__INVALID_FEE_TIER_INDEX,
  WHIRLPOOL_ERROR__INVALID_INTERMEDIARY_MINT: () => WHIRLPOOL_ERROR__INVALID_INTERMEDIARY_MINT,
  WHIRLPOOL_ERROR__INVALID_POSITION_TOKEN_AMOUNT: () => WHIRLPOOL_ERROR__INVALID_POSITION_TOKEN_AMOUNT,
  WHIRLPOOL_ERROR__INVALID_REWARD_INDEX: () => WHIRLPOOL_ERROR__INVALID_REWARD_INDEX,
  WHIRLPOOL_ERROR__INVALID_SQRT_PRICE_LIMIT_DIRECTION: () => WHIRLPOOL_ERROR__INVALID_SQRT_PRICE_LIMIT_DIRECTION,
  WHIRLPOOL_ERROR__INVALID_START_TICK: () => WHIRLPOOL_ERROR__INVALID_START_TICK,
  WHIRLPOOL_ERROR__INVALID_TICK_ARRAY_SEQUENCE: () => WHIRLPOOL_ERROR__INVALID_TICK_ARRAY_SEQUENCE,
  WHIRLPOOL_ERROR__INVALID_TICK_INDEX: () => WHIRLPOOL_ERROR__INVALID_TICK_INDEX,
  WHIRLPOOL_ERROR__INVALID_TICK_SPACING: () => WHIRLPOOL_ERROR__INVALID_TICK_SPACING,
  WHIRLPOOL_ERROR__INVALID_TIMESTAMP: () => WHIRLPOOL_ERROR__INVALID_TIMESTAMP,
  WHIRLPOOL_ERROR__INVALID_TIMESTAMP_CONVERSION: () => WHIRLPOOL_ERROR__INVALID_TIMESTAMP_CONVERSION,
  WHIRLPOOL_ERROR__INVALID_TOKEN_MINT_ORDER: () => WHIRLPOOL_ERROR__INVALID_TOKEN_MINT_ORDER,
  WHIRLPOOL_ERROR__INVALID_TRADE_ENABLE_TIMESTAMP: () => WHIRLPOOL_ERROR__INVALID_TRADE_ENABLE_TIMESTAMP,
  WHIRLPOOL_ERROR__LIQUIDITY_NET_ERROR: () => WHIRLPOOL_ERROR__LIQUIDITY_NET_ERROR,
  WHIRLPOOL_ERROR__LIQUIDITY_OVERFLOW: () => WHIRLPOOL_ERROR__LIQUIDITY_OVERFLOW,
  WHIRLPOOL_ERROR__LIQUIDITY_TOO_HIGH: () => WHIRLPOOL_ERROR__LIQUIDITY_TOO_HIGH,
  WHIRLPOOL_ERROR__LIQUIDITY_UNDERFLOW: () => WHIRLPOOL_ERROR__LIQUIDITY_UNDERFLOW,
  WHIRLPOOL_ERROR__LIQUIDITY_ZERO: () => WHIRLPOOL_ERROR__LIQUIDITY_ZERO,
  WHIRLPOOL_ERROR__MISSING_OR_INVALID_DELEGATE: () => WHIRLPOOL_ERROR__MISSING_OR_INVALID_DELEGATE,
  WHIRLPOOL_ERROR__MULTIPLICATION_OVERFLOW: () => WHIRLPOOL_ERROR__MULTIPLICATION_OVERFLOW,
  WHIRLPOOL_ERROR__MULTIPLICATION_SHIFT_RIGHT_OVERFLOW: () => WHIRLPOOL_ERROR__MULTIPLICATION_SHIFT_RIGHT_OVERFLOW,
  WHIRLPOOL_ERROR__MUL_DIV_INVALID_INPUT: () => WHIRLPOOL_ERROR__MUL_DIV_INVALID_INPUT,
  WHIRLPOOL_ERROR__MUL_DIV_OVERFLOW: () => WHIRLPOOL_ERROR__MUL_DIV_OVERFLOW,
  WHIRLPOOL_ERROR__NO_EXTRA_ACCOUNTS_FOR_TRANSFER_HOOK: () => WHIRLPOOL_ERROR__NO_EXTRA_ACCOUNTS_FOR_TRANSFER_HOOK,
  WHIRLPOOL_ERROR__NUMBER_CAST_ERROR: () => WHIRLPOOL_ERROR__NUMBER_CAST_ERROR,
  WHIRLPOOL_ERROR__NUMBER_DOWN_CAST_ERROR: () => WHIRLPOOL_ERROR__NUMBER_DOWN_CAST_ERROR,
  WHIRLPOOL_ERROR__OPERATION_NOT_ALLOWED_ON_LOCKED_POSITION: () => WHIRLPOOL_ERROR__OPERATION_NOT_ALLOWED_ON_LOCKED_POSITION,
  WHIRLPOOL_ERROR__PARTIAL_FILL_ERROR: () => WHIRLPOOL_ERROR__PARTIAL_FILL_ERROR,
  WHIRLPOOL_ERROR__POSITION_BUNDLE_NOT_DELETABLE: () => WHIRLPOOL_ERROR__POSITION_BUNDLE_NOT_DELETABLE,
  WHIRLPOOL_ERROR__POSITION_NOT_LOCKABLE: () => WHIRLPOOL_ERROR__POSITION_NOT_LOCKABLE,
  WHIRLPOOL_ERROR__PROTOCOL_FEE_RATE_MAX_EXCEEDED: () => WHIRLPOOL_ERROR__PROTOCOL_FEE_RATE_MAX_EXCEEDED,
  WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_DUPLICATED_ACCOUNTS_TYPE: () => WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_DUPLICATED_ACCOUNTS_TYPE,
  WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INSUFFICIENT: () => WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INSUFFICIENT,
  WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INVALID_SLICE: () => WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INVALID_SLICE,
  WHIRLPOOL_ERROR__REWARD_NOT_INITIALIZED: () => WHIRLPOOL_ERROR__REWARD_NOT_INITIALIZED,
  WHIRLPOOL_ERROR__REWARD_VAULT_AMOUNT_INSUFFICIENT: () => WHIRLPOOL_ERROR__REWARD_VAULT_AMOUNT_INSUFFICIENT,
  WHIRLPOOL_ERROR__SAME_TICK_RANGE_NOT_ALLOWED: () => WHIRLPOOL_ERROR__SAME_TICK_RANGE_NOT_ALLOWED,
  WHIRLPOOL_ERROR__SQRT_PRICE_OUT_OF_BOUNDS: () => WHIRLPOOL_ERROR__SQRT_PRICE_OUT_OF_BOUNDS,
  WHIRLPOOL_ERROR__TICK_ARRAY_EXIST_IN_POOL: () => WHIRLPOOL_ERROR__TICK_ARRAY_EXIST_IN_POOL,
  WHIRLPOOL_ERROR__TICK_ARRAY_INDEX_OUTOF_BOUNDS: () => WHIRLPOOL_ERROR__TICK_ARRAY_INDEX_OUTOF_BOUNDS,
  WHIRLPOOL_ERROR__TICK_ARRAY_SEQUENCE_INVALID_INDEX: () => WHIRLPOOL_ERROR__TICK_ARRAY_SEQUENCE_INVALID_INDEX,
  WHIRLPOOL_ERROR__TICK_NOT_FOUND: () => WHIRLPOOL_ERROR__TICK_NOT_FOUND,
  WHIRLPOOL_ERROR__TOKEN_MAX_EXCEEDED: () => WHIRLPOOL_ERROR__TOKEN_MAX_EXCEEDED,
  WHIRLPOOL_ERROR__TOKEN_MIN_SUBCEEDED: () => WHIRLPOOL_ERROR__TOKEN_MIN_SUBCEEDED,
  WHIRLPOOL_ERROR__TOO_MANY_SUPPLEMENTAL_TICK_ARRAYS: () => WHIRLPOOL_ERROR__TOO_MANY_SUPPLEMENTAL_TICK_ARRAYS,
  WHIRLPOOL_ERROR__TRADE_IS_NOT_ENABLED: () => WHIRLPOOL_ERROR__TRADE_IS_NOT_ENABLED,
  WHIRLPOOL_ERROR__TRANSFER_FEE_CALCULATION_ERROR: () => WHIRLPOOL_ERROR__TRANSFER_FEE_CALCULATION_ERROR,
  WHIRLPOOL_ERROR__UNSUPPORTED_TOKEN_MINT: () => WHIRLPOOL_ERROR__UNSUPPORTED_TOKEN_MINT,
  WHIRLPOOL_ERROR__ZERO_TRADABLE_AMOUNT: () => WHIRLPOOL_ERROR__ZERO_TRADABLE_AMOUNT,
  WHIRLPOOL_PROGRAM_ADDRESS: () => WHIRLPOOL_PROGRAM_ADDRESS,
  WhirlpoolAccount: () => WhirlpoolAccount,
  WhirlpoolInstruction: () => WhirlpoolInstruction,
  adaptiveFeeTierAdaptiveFeeControlFactorFilter: () => adaptiveFeeTierAdaptiveFeeControlFactorFilter,
  adaptiveFeeTierDecayPeriodFilter: () => adaptiveFeeTierDecayPeriodFilter,
  adaptiveFeeTierDefaultBaseFeeRateFilter: () => adaptiveFeeTierDefaultBaseFeeRateFilter,
  adaptiveFeeTierDelegatedFeeAuthorityFilter: () => adaptiveFeeTierDelegatedFeeAuthorityFilter,
  adaptiveFeeTierFeeTierIndexFilter: () => adaptiveFeeTierFeeTierIndexFilter,
  adaptiveFeeTierFilterPeriodFilter: () => adaptiveFeeTierFilterPeriodFilter,
  adaptiveFeeTierInitializePoolAuthorityFilter: () => adaptiveFeeTierInitializePoolAuthorityFilter,
  adaptiveFeeTierMajorSwapThresholdTicksFilter: () => adaptiveFeeTierMajorSwapThresholdTicksFilter,
  adaptiveFeeTierMaxVolatilityFilter: () => adaptiveFeeTierMaxVolatilityFilter,
  adaptiveFeeTierReductionFactorFilter: () => adaptiveFeeTierReductionFactorFilter,
  adaptiveFeeTierTickGroupSizeFilter: () => adaptiveFeeTierTickGroupSizeFilter,
  adaptiveFeeTierTickSpacingFilter: () => adaptiveFeeTierTickSpacingFilter,
  adaptiveFeeTierWhirlpoolsConfigFilter: () => adaptiveFeeTierWhirlpoolsConfigFilter,
  decodeAdaptiveFeeTier: () => decodeAdaptiveFeeTier,
  decodeFeeTier: () => decodeFeeTier,
  decodeLockConfig: () => decodeLockConfig,
  decodeOracle: () => decodeOracle,
  decodePosition: () => decodePosition,
  decodePositionBundle: () => decodePositionBundle,
  decodeTickArray: () => decodeTickArray,
  decodeTokenBadge: () => decodeTokenBadge,
  decodeWhirlpool: () => decodeWhirlpool,
  decodeWhirlpoolsConfig: () => decodeWhirlpoolsConfig,
  decodeWhirlpoolsConfigExtension: () => decodeWhirlpoolsConfigExtension,
  feeTierFeeRateFilter: () => feeTierFeeRateFilter,
  feeTierTickSpacingFilter: () => feeTierTickSpacingFilter,
  feeTierWhirlpoolsConfigFilter: () => feeTierWhirlpoolsConfigFilter,
  fetchAdaptiveFeeTier: () => fetchAdaptiveFeeTier,
  fetchAllAdaptiveFeeTier: () => fetchAllAdaptiveFeeTier,
  fetchAllAdaptiveFeeTierWithFilter: () => fetchAllAdaptiveFeeTierWithFilter,
  fetchAllFeeTier: () => fetchAllFeeTier,
  fetchAllFeeTierWithFilter: () => fetchAllFeeTierWithFilter,
  fetchAllLockConfig: () => fetchAllLockConfig,
  fetchAllMaybeAdaptiveFeeTier: () => fetchAllMaybeAdaptiveFeeTier,
  fetchAllMaybeFeeTier: () => fetchAllMaybeFeeTier,
  fetchAllMaybeLockConfig: () => fetchAllMaybeLockConfig,
  fetchAllMaybeOracle: () => fetchAllMaybeOracle,
  fetchAllMaybePosition: () => fetchAllMaybePosition,
  fetchAllMaybePositionBundle: () => fetchAllMaybePositionBundle,
  fetchAllMaybeTickArray: () => fetchAllMaybeTickArray,
  fetchAllMaybeTokenBadge: () => fetchAllMaybeTokenBadge,
  fetchAllMaybeWhirlpool: () => fetchAllMaybeWhirlpool,
  fetchAllMaybeWhirlpoolsConfig: () => fetchAllMaybeWhirlpoolsConfig,
  fetchAllMaybeWhirlpoolsConfigExtension: () => fetchAllMaybeWhirlpoolsConfigExtension,
  fetchAllOracle: () => fetchAllOracle,
  fetchAllOracleWithFilter: () => fetchAllOracleWithFilter,
  fetchAllPosition: () => fetchAllPosition,
  fetchAllPositionBundle: () => fetchAllPositionBundle,
  fetchAllPositionBundleWithFilter: () => fetchAllPositionBundleWithFilter,
  fetchAllPositionWithFilter: () => fetchAllPositionWithFilter,
  fetchAllTickArray: () => fetchAllTickArray,
  fetchAllTickArrayWithFilter: () => fetchAllTickArrayWithFilter,
  fetchAllTokenBadge: () => fetchAllTokenBadge,
  fetchAllTokenBadgeWithFilter: () => fetchAllTokenBadgeWithFilter,
  fetchAllWhirlpool: () => fetchAllWhirlpool,
  fetchAllWhirlpoolWithFilter: () => fetchAllWhirlpoolWithFilter,
  fetchAllWhirlpoolsConfig: () => fetchAllWhirlpoolsConfig,
  fetchAllWhirlpoolsConfigExtension: () => fetchAllWhirlpoolsConfigExtension,
  fetchAllWhirlpoolsConfigExtensionWithFilter: () => fetchAllWhirlpoolsConfigExtensionWithFilter,
  fetchAllWhirlpoolsConfigWithFilter: () => fetchAllWhirlpoolsConfigWithFilter,
  fetchFeeTier: () => fetchFeeTier,
  fetchLockConfig: () => fetchLockConfig,
  fetchMaybeAdaptiveFeeTier: () => fetchMaybeAdaptiveFeeTier,
  fetchMaybeFeeTier: () => fetchMaybeFeeTier,
  fetchMaybeLockConfig: () => fetchMaybeLockConfig,
  fetchMaybeOracle: () => fetchMaybeOracle,
  fetchMaybePosition: () => fetchMaybePosition,
  fetchMaybePositionBundle: () => fetchMaybePositionBundle,
  fetchMaybeTickArray: () => fetchMaybeTickArray,
  fetchMaybeTokenBadge: () => fetchMaybeTokenBadge,
  fetchMaybeWhirlpool: () => fetchMaybeWhirlpool,
  fetchMaybeWhirlpoolsConfig: () => fetchMaybeWhirlpoolsConfig,
  fetchMaybeWhirlpoolsConfigExtension: () => fetchMaybeWhirlpoolsConfigExtension,
  fetchOracle: () => fetchOracle,
  fetchPosition: () => fetchPosition,
  fetchPositionBundle: () => fetchPositionBundle,
  fetchTickArray: () => fetchTickArray,
  fetchTokenBadge: () => fetchTokenBadge,
  fetchWhirlpool: () => fetchWhirlpool,
  fetchWhirlpoolsConfig: () => fetchWhirlpoolsConfig,
  fetchWhirlpoolsConfigExtension: () => fetchWhirlpoolsConfigExtension,
  getAccountsTypeCodec: () => getAccountsTypeCodec,
  getAccountsTypeDecoder: () => getAccountsTypeDecoder,
  getAccountsTypeEncoder: () => getAccountsTypeEncoder,
  getAdaptiveFeeConstantsCodec: () => getAdaptiveFeeConstantsCodec,
  getAdaptiveFeeConstantsDecoder: () => getAdaptiveFeeConstantsDecoder,
  getAdaptiveFeeConstantsEncoder: () => getAdaptiveFeeConstantsEncoder,
  getAdaptiveFeeTierCodec: () => getAdaptiveFeeTierCodec,
  getAdaptiveFeeTierDecoder: () => getAdaptiveFeeTierDecoder,
  getAdaptiveFeeTierDiscriminatorBytes: () => getAdaptiveFeeTierDiscriminatorBytes,
  getAdaptiveFeeTierEncoder: () => getAdaptiveFeeTierEncoder,
  getAdaptiveFeeTierSize: () => getAdaptiveFeeTierSize,
  getAdaptiveFeeVariablesCodec: () => getAdaptiveFeeVariablesCodec,
  getAdaptiveFeeVariablesDecoder: () => getAdaptiveFeeVariablesDecoder,
  getAdaptiveFeeVariablesEncoder: () => getAdaptiveFeeVariablesEncoder,
  getBundledPositionAddress: () => getBundledPositionAddress,
  getCloseBundledPositionDiscriminatorBytes: () => getCloseBundledPositionDiscriminatorBytes,
  getCloseBundledPositionInstruction: () => getCloseBundledPositionInstruction,
  getCloseBundledPositionInstructionDataCodec: () => getCloseBundledPositionInstructionDataCodec,
  getCloseBundledPositionInstructionDataDecoder: () => getCloseBundledPositionInstructionDataDecoder,
  getCloseBundledPositionInstructionDataEncoder: () => getCloseBundledPositionInstructionDataEncoder,
  getClosePositionDiscriminatorBytes: () => getClosePositionDiscriminatorBytes,
  getClosePositionInstruction: () => getClosePositionInstruction,
  getClosePositionInstructionDataCodec: () => getClosePositionInstructionDataCodec,
  getClosePositionInstructionDataDecoder: () => getClosePositionInstructionDataDecoder,
  getClosePositionInstructionDataEncoder: () => getClosePositionInstructionDataEncoder,
  getClosePositionWithTokenExtensionsDiscriminatorBytes: () => getClosePositionWithTokenExtensionsDiscriminatorBytes,
  getClosePositionWithTokenExtensionsInstruction: () => getClosePositionWithTokenExtensionsInstruction,
  getClosePositionWithTokenExtensionsInstructionDataCodec: () => getClosePositionWithTokenExtensionsInstructionDataCodec,
  getClosePositionWithTokenExtensionsInstructionDataDecoder: () => getClosePositionWithTokenExtensionsInstructionDataDecoder,
  getClosePositionWithTokenExtensionsInstructionDataEncoder: () => getClosePositionWithTokenExtensionsInstructionDataEncoder,
  getCollectFeesDiscriminatorBytes: () => getCollectFeesDiscriminatorBytes,
  getCollectFeesInstruction: () => getCollectFeesInstruction,
  getCollectFeesInstructionDataCodec: () => getCollectFeesInstructionDataCodec,
  getCollectFeesInstructionDataDecoder: () => getCollectFeesInstructionDataDecoder,
  getCollectFeesInstructionDataEncoder: () => getCollectFeesInstructionDataEncoder,
  getCollectFeesV2DiscriminatorBytes: () => getCollectFeesV2DiscriminatorBytes,
  getCollectFeesV2Instruction: () => getCollectFeesV2Instruction,
  getCollectFeesV2InstructionDataCodec: () => getCollectFeesV2InstructionDataCodec,
  getCollectFeesV2InstructionDataDecoder: () => getCollectFeesV2InstructionDataDecoder,
  getCollectFeesV2InstructionDataEncoder: () => getCollectFeesV2InstructionDataEncoder,
  getCollectProtocolFeesDiscriminatorBytes: () => getCollectProtocolFeesDiscriminatorBytes,
  getCollectProtocolFeesInstruction: () => getCollectProtocolFeesInstruction,
  getCollectProtocolFeesInstructionDataCodec: () => getCollectProtocolFeesInstructionDataCodec,
  getCollectProtocolFeesInstructionDataDecoder: () => getCollectProtocolFeesInstructionDataDecoder,
  getCollectProtocolFeesInstructionDataEncoder: () => getCollectProtocolFeesInstructionDataEncoder,
  getCollectProtocolFeesV2DiscriminatorBytes: () => getCollectProtocolFeesV2DiscriminatorBytes,
  getCollectProtocolFeesV2Instruction: () => getCollectProtocolFeesV2Instruction,
  getCollectProtocolFeesV2InstructionDataCodec: () => getCollectProtocolFeesV2InstructionDataCodec,
  getCollectProtocolFeesV2InstructionDataDecoder: () => getCollectProtocolFeesV2InstructionDataDecoder,
  getCollectProtocolFeesV2InstructionDataEncoder: () => getCollectProtocolFeesV2InstructionDataEncoder,
  getCollectRewardDiscriminatorBytes: () => getCollectRewardDiscriminatorBytes,
  getCollectRewardInstruction: () => getCollectRewardInstruction,
  getCollectRewardInstructionDataCodec: () => getCollectRewardInstructionDataCodec,
  getCollectRewardInstructionDataDecoder: () => getCollectRewardInstructionDataDecoder,
  getCollectRewardInstructionDataEncoder: () => getCollectRewardInstructionDataEncoder,
  getCollectRewardV2DiscriminatorBytes: () => getCollectRewardV2DiscriminatorBytes,
  getCollectRewardV2Instruction: () => getCollectRewardV2Instruction,
  getCollectRewardV2InstructionDataCodec: () => getCollectRewardV2InstructionDataCodec,
  getCollectRewardV2InstructionDataDecoder: () => getCollectRewardV2InstructionDataDecoder,
  getCollectRewardV2InstructionDataEncoder: () => getCollectRewardV2InstructionDataEncoder,
  getDecreaseLiquidityDiscriminatorBytes: () => getDecreaseLiquidityDiscriminatorBytes,
  getDecreaseLiquidityInstruction: () => getDecreaseLiquidityInstruction,
  getDecreaseLiquidityInstructionDataCodec: () => getDecreaseLiquidityInstructionDataCodec,
  getDecreaseLiquidityInstructionDataDecoder: () => getDecreaseLiquidityInstructionDataDecoder,
  getDecreaseLiquidityInstructionDataEncoder: () => getDecreaseLiquidityInstructionDataEncoder,
  getDecreaseLiquidityV2DiscriminatorBytes: () => getDecreaseLiquidityV2DiscriminatorBytes,
  getDecreaseLiquidityV2Instruction: () => getDecreaseLiquidityV2Instruction,
  getDecreaseLiquidityV2InstructionDataCodec: () => getDecreaseLiquidityV2InstructionDataCodec,
  getDecreaseLiquidityV2InstructionDataDecoder: () => getDecreaseLiquidityV2InstructionDataDecoder,
  getDecreaseLiquidityV2InstructionDataEncoder: () => getDecreaseLiquidityV2InstructionDataEncoder,
  getDeletePositionBundleDiscriminatorBytes: () => getDeletePositionBundleDiscriminatorBytes,
  getDeletePositionBundleInstruction: () => getDeletePositionBundleInstruction,
  getDeletePositionBundleInstructionDataCodec: () => getDeletePositionBundleInstructionDataCodec,
  getDeletePositionBundleInstructionDataDecoder: () => getDeletePositionBundleInstructionDataDecoder,
  getDeletePositionBundleInstructionDataEncoder: () => getDeletePositionBundleInstructionDataEncoder,
  getDeleteTokenBadgeDiscriminatorBytes: () => getDeleteTokenBadgeDiscriminatorBytes,
  getDeleteTokenBadgeInstruction: () => getDeleteTokenBadgeInstruction,
  getDeleteTokenBadgeInstructionDataCodec: () => getDeleteTokenBadgeInstructionDataCodec,
  getDeleteTokenBadgeInstructionDataDecoder: () => getDeleteTokenBadgeInstructionDataDecoder,
  getDeleteTokenBadgeInstructionDataEncoder: () => getDeleteTokenBadgeInstructionDataEncoder,
  getFeeTierAddress: () => getFeeTierAddress,
  getFeeTierCodec: () => getFeeTierCodec,
  getFeeTierDecoder: () => getFeeTierDecoder,
  getFeeTierDiscriminatorBytes: () => getFeeTierDiscriminatorBytes,
  getFeeTierEncoder: () => getFeeTierEncoder,
  getFeeTierSize: () => getFeeTierSize,
  getIncreaseLiquidityDiscriminatorBytes: () => getIncreaseLiquidityDiscriminatorBytes,
  getIncreaseLiquidityInstruction: () => getIncreaseLiquidityInstruction,
  getIncreaseLiquidityInstructionDataCodec: () => getIncreaseLiquidityInstructionDataCodec,
  getIncreaseLiquidityInstructionDataDecoder: () => getIncreaseLiquidityInstructionDataDecoder,
  getIncreaseLiquidityInstructionDataEncoder: () => getIncreaseLiquidityInstructionDataEncoder,
  getIncreaseLiquidityV2DiscriminatorBytes: () => getIncreaseLiquidityV2DiscriminatorBytes,
  getIncreaseLiquidityV2Instruction: () => getIncreaseLiquidityV2Instruction,
  getIncreaseLiquidityV2InstructionDataCodec: () => getIncreaseLiquidityV2InstructionDataCodec,
  getIncreaseLiquidityV2InstructionDataDecoder: () => getIncreaseLiquidityV2InstructionDataDecoder,
  getIncreaseLiquidityV2InstructionDataEncoder: () => getIncreaseLiquidityV2InstructionDataEncoder,
  getInitializeAdaptiveFeeTierDiscriminatorBytes: () => getInitializeAdaptiveFeeTierDiscriminatorBytes,
  getInitializeAdaptiveFeeTierInstruction: () => getInitializeAdaptiveFeeTierInstruction,
  getInitializeAdaptiveFeeTierInstructionDataCodec: () => getInitializeAdaptiveFeeTierInstructionDataCodec,
  getInitializeAdaptiveFeeTierInstructionDataDecoder: () => getInitializeAdaptiveFeeTierInstructionDataDecoder,
  getInitializeAdaptiveFeeTierInstructionDataEncoder: () => getInitializeAdaptiveFeeTierInstructionDataEncoder,
  getInitializeConfigDiscriminatorBytes: () => getInitializeConfigDiscriminatorBytes,
  getInitializeConfigExtensionDiscriminatorBytes: () => getInitializeConfigExtensionDiscriminatorBytes,
  getInitializeConfigExtensionInstruction: () => getInitializeConfigExtensionInstruction,
  getInitializeConfigExtensionInstructionDataCodec: () => getInitializeConfigExtensionInstructionDataCodec,
  getInitializeConfigExtensionInstructionDataDecoder: () => getInitializeConfigExtensionInstructionDataDecoder,
  getInitializeConfigExtensionInstructionDataEncoder: () => getInitializeConfigExtensionInstructionDataEncoder,
  getInitializeConfigInstruction: () => getInitializeConfigInstruction,
  getInitializeConfigInstructionDataCodec: () => getInitializeConfigInstructionDataCodec,
  getInitializeConfigInstructionDataDecoder: () => getInitializeConfigInstructionDataDecoder,
  getInitializeConfigInstructionDataEncoder: () => getInitializeConfigInstructionDataEncoder,
  getInitializeFeeTierDiscriminatorBytes: () => getInitializeFeeTierDiscriminatorBytes,
  getInitializeFeeTierInstruction: () => getInitializeFeeTierInstruction,
  getInitializeFeeTierInstructionDataCodec: () => getInitializeFeeTierInstructionDataCodec,
  getInitializeFeeTierInstructionDataDecoder: () => getInitializeFeeTierInstructionDataDecoder,
  getInitializeFeeTierInstructionDataEncoder: () => getInitializeFeeTierInstructionDataEncoder,
  getInitializePoolDiscriminatorBytes: () => getInitializePoolDiscriminatorBytes,
  getInitializePoolInstruction: () => getInitializePoolInstruction,
  getInitializePoolInstructionDataCodec: () => getInitializePoolInstructionDataCodec,
  getInitializePoolInstructionDataDecoder: () => getInitializePoolInstructionDataDecoder,
  getInitializePoolInstructionDataEncoder: () => getInitializePoolInstructionDataEncoder,
  getInitializePoolV2DiscriminatorBytes: () => getInitializePoolV2DiscriminatorBytes,
  getInitializePoolV2Instruction: () => getInitializePoolV2Instruction,
  getInitializePoolV2InstructionDataCodec: () => getInitializePoolV2InstructionDataCodec,
  getInitializePoolV2InstructionDataDecoder: () => getInitializePoolV2InstructionDataDecoder,
  getInitializePoolV2InstructionDataEncoder: () => getInitializePoolV2InstructionDataEncoder,
  getInitializePoolWithAdaptiveFeeDiscriminatorBytes: () => getInitializePoolWithAdaptiveFeeDiscriminatorBytes,
  getInitializePoolWithAdaptiveFeeInstruction: () => getInitializePoolWithAdaptiveFeeInstruction,
  getInitializePoolWithAdaptiveFeeInstructionDataCodec: () => getInitializePoolWithAdaptiveFeeInstructionDataCodec,
  getInitializePoolWithAdaptiveFeeInstructionDataDecoder: () => getInitializePoolWithAdaptiveFeeInstructionDataDecoder,
  getInitializePoolWithAdaptiveFeeInstructionDataEncoder: () => getInitializePoolWithAdaptiveFeeInstructionDataEncoder,
  getInitializePositionBundleDiscriminatorBytes: () => getInitializePositionBundleDiscriminatorBytes,
  getInitializePositionBundleInstruction: () => getInitializePositionBundleInstruction,
  getInitializePositionBundleInstructionDataCodec: () => getInitializePositionBundleInstructionDataCodec,
  getInitializePositionBundleInstructionDataDecoder: () => getInitializePositionBundleInstructionDataDecoder,
  getInitializePositionBundleInstructionDataEncoder: () => getInitializePositionBundleInstructionDataEncoder,
  getInitializePositionBundleWithMetadataDiscriminatorBytes: () => getInitializePositionBundleWithMetadataDiscriminatorBytes,
  getInitializePositionBundleWithMetadataInstruction: () => getInitializePositionBundleWithMetadataInstruction,
  getInitializePositionBundleWithMetadataInstructionDataCodec: () => getInitializePositionBundleWithMetadataInstructionDataCodec,
  getInitializePositionBundleWithMetadataInstructionDataDecoder: () => getInitializePositionBundleWithMetadataInstructionDataDecoder,
  getInitializePositionBundleWithMetadataInstructionDataEncoder: () => getInitializePositionBundleWithMetadataInstructionDataEncoder,
  getInitializeRewardDiscriminatorBytes: () => getInitializeRewardDiscriminatorBytes,
  getInitializeRewardInstruction: () => getInitializeRewardInstruction,
  getInitializeRewardInstructionDataCodec: () => getInitializeRewardInstructionDataCodec,
  getInitializeRewardInstructionDataDecoder: () => getInitializeRewardInstructionDataDecoder,
  getInitializeRewardInstructionDataEncoder: () => getInitializeRewardInstructionDataEncoder,
  getInitializeRewardV2DiscriminatorBytes: () => getInitializeRewardV2DiscriminatorBytes,
  getInitializeRewardV2Instruction: () => getInitializeRewardV2Instruction,
  getInitializeRewardV2InstructionDataCodec: () => getInitializeRewardV2InstructionDataCodec,
  getInitializeRewardV2InstructionDataDecoder: () => getInitializeRewardV2InstructionDataDecoder,
  getInitializeRewardV2InstructionDataEncoder: () => getInitializeRewardV2InstructionDataEncoder,
  getInitializeTickArrayDiscriminatorBytes: () => getInitializeTickArrayDiscriminatorBytes,
  getInitializeTickArrayInstruction: () => getInitializeTickArrayInstruction,
  getInitializeTickArrayInstructionDataCodec: () => getInitializeTickArrayInstructionDataCodec,
  getInitializeTickArrayInstructionDataDecoder: () => getInitializeTickArrayInstructionDataDecoder,
  getInitializeTickArrayInstructionDataEncoder: () => getInitializeTickArrayInstructionDataEncoder,
  getInitializeTokenBadgeDiscriminatorBytes: () => getInitializeTokenBadgeDiscriminatorBytes,
  getInitializeTokenBadgeInstruction: () => getInitializeTokenBadgeInstruction,
  getInitializeTokenBadgeInstructionDataCodec: () => getInitializeTokenBadgeInstructionDataCodec,
  getInitializeTokenBadgeInstructionDataDecoder: () => getInitializeTokenBadgeInstructionDataDecoder,
  getInitializeTokenBadgeInstructionDataEncoder: () => getInitializeTokenBadgeInstructionDataEncoder,
  getLockConfigCodec: () => getLockConfigCodec,
  getLockConfigDecoder: () => getLockConfigDecoder,
  getLockConfigDiscriminatorBytes: () => getLockConfigDiscriminatorBytes,
  getLockConfigEncoder: () => getLockConfigEncoder,
  getLockConfigSize: () => getLockConfigSize,
  getLockPositionDiscriminatorBytes: () => getLockPositionDiscriminatorBytes,
  getLockPositionInstruction: () => getLockPositionInstruction,
  getLockPositionInstructionDataCodec: () => getLockPositionInstructionDataCodec,
  getLockPositionInstructionDataDecoder: () => getLockPositionInstructionDataDecoder,
  getLockPositionInstructionDataEncoder: () => getLockPositionInstructionDataEncoder,
  getLockTypeCodec: () => getLockTypeCodec,
  getLockTypeDecoder: () => getLockTypeDecoder,
  getLockTypeEncoder: () => getLockTypeEncoder,
  getLockTypeLabelCodec: () => getLockTypeLabelCodec,
  getLockTypeLabelDecoder: () => getLockTypeLabelDecoder,
  getLockTypeLabelEncoder: () => getLockTypeLabelEncoder,
  getOpenBundledPositionDiscriminatorBytes: () => getOpenBundledPositionDiscriminatorBytes,
  getOpenBundledPositionInstruction: () => getOpenBundledPositionInstruction,
  getOpenBundledPositionInstructionDataCodec: () => getOpenBundledPositionInstructionDataCodec,
  getOpenBundledPositionInstructionDataDecoder: () => getOpenBundledPositionInstructionDataDecoder,
  getOpenBundledPositionInstructionDataEncoder: () => getOpenBundledPositionInstructionDataEncoder,
  getOpenPositionDiscriminatorBytes: () => getOpenPositionDiscriminatorBytes,
  getOpenPositionInstruction: () => getOpenPositionInstruction,
  getOpenPositionInstructionDataCodec: () => getOpenPositionInstructionDataCodec,
  getOpenPositionInstructionDataDecoder: () => getOpenPositionInstructionDataDecoder,
  getOpenPositionInstructionDataEncoder: () => getOpenPositionInstructionDataEncoder,
  getOpenPositionWithMetadataDiscriminatorBytes: () => getOpenPositionWithMetadataDiscriminatorBytes,
  getOpenPositionWithMetadataInstruction: () => getOpenPositionWithMetadataInstruction,
  getOpenPositionWithMetadataInstructionDataCodec: () => getOpenPositionWithMetadataInstructionDataCodec,
  getOpenPositionWithMetadataInstructionDataDecoder: () => getOpenPositionWithMetadataInstructionDataDecoder,
  getOpenPositionWithMetadataInstructionDataEncoder: () => getOpenPositionWithMetadataInstructionDataEncoder,
  getOpenPositionWithTokenExtensionsDiscriminatorBytes: () => getOpenPositionWithTokenExtensionsDiscriminatorBytes,
  getOpenPositionWithTokenExtensionsInstruction: () => getOpenPositionWithTokenExtensionsInstruction,
  getOpenPositionWithTokenExtensionsInstructionDataCodec: () => getOpenPositionWithTokenExtensionsInstructionDataCodec,
  getOpenPositionWithTokenExtensionsInstructionDataDecoder: () => getOpenPositionWithTokenExtensionsInstructionDataDecoder,
  getOpenPositionWithTokenExtensionsInstructionDataEncoder: () => getOpenPositionWithTokenExtensionsInstructionDataEncoder,
  getOracleAddress: () => getOracleAddress,
  getOracleCodec: () => getOracleCodec,
  getOracleDecoder: () => getOracleDecoder,
  getOracleDiscriminatorBytes: () => getOracleDiscriminatorBytes,
  getOracleEncoder: () => getOracleEncoder,
  getOracleSize: () => getOracleSize,
  getPositionAddress: () => getPositionAddress,
  getPositionBundleAddress: () => getPositionBundleAddress,
  getPositionBundleCodec: () => getPositionBundleCodec,
  getPositionBundleDecoder: () => getPositionBundleDecoder,
  getPositionBundleDiscriminatorBytes: () => getPositionBundleDiscriminatorBytes,
  getPositionBundleEncoder: () => getPositionBundleEncoder,
  getPositionBundleSize: () => getPositionBundleSize,
  getPositionCodec: () => getPositionCodec,
  getPositionDecoder: () => getPositionDecoder,
  getPositionDiscriminatorBytes: () => getPositionDiscriminatorBytes,
  getPositionEncoder: () => getPositionEncoder,
  getPositionRewardInfoCodec: () => getPositionRewardInfoCodec,
  getPositionRewardInfoDecoder: () => getPositionRewardInfoDecoder,
  getPositionRewardInfoEncoder: () => getPositionRewardInfoEncoder,
  getPositionSize: () => getPositionSize,
  getRemainingAccountsInfoCodec: () => getRemainingAccountsInfoCodec,
  getRemainingAccountsInfoDecoder: () => getRemainingAccountsInfoDecoder,
  getRemainingAccountsInfoEncoder: () => getRemainingAccountsInfoEncoder,
  getRemainingAccountsSliceCodec: () => getRemainingAccountsSliceCodec,
  getRemainingAccountsSliceDecoder: () => getRemainingAccountsSliceDecoder,
  getRemainingAccountsSliceEncoder: () => getRemainingAccountsSliceEncoder,
  getResetPositionRangeDiscriminatorBytes: () => getResetPositionRangeDiscriminatorBytes,
  getResetPositionRangeInstruction: () => getResetPositionRangeInstruction,
  getResetPositionRangeInstructionDataCodec: () => getResetPositionRangeInstructionDataCodec,
  getResetPositionRangeInstructionDataDecoder: () => getResetPositionRangeInstructionDataDecoder,
  getResetPositionRangeInstructionDataEncoder: () => getResetPositionRangeInstructionDataEncoder,
  getSetCollectProtocolFeesAuthorityDiscriminatorBytes: () => getSetCollectProtocolFeesAuthorityDiscriminatorBytes,
  getSetCollectProtocolFeesAuthorityInstruction: () => getSetCollectProtocolFeesAuthorityInstruction,
  getSetCollectProtocolFeesAuthorityInstructionDataCodec: () => getSetCollectProtocolFeesAuthorityInstructionDataCodec,
  getSetCollectProtocolFeesAuthorityInstructionDataDecoder: () => getSetCollectProtocolFeesAuthorityInstructionDataDecoder,
  getSetCollectProtocolFeesAuthorityInstructionDataEncoder: () => getSetCollectProtocolFeesAuthorityInstructionDataEncoder,
  getSetConfigExtensionAuthorityDiscriminatorBytes: () => getSetConfigExtensionAuthorityDiscriminatorBytes,
  getSetConfigExtensionAuthorityInstruction: () => getSetConfigExtensionAuthorityInstruction,
  getSetConfigExtensionAuthorityInstructionDataCodec: () => getSetConfigExtensionAuthorityInstructionDataCodec,
  getSetConfigExtensionAuthorityInstructionDataDecoder: () => getSetConfigExtensionAuthorityInstructionDataDecoder,
  getSetConfigExtensionAuthorityInstructionDataEncoder: () => getSetConfigExtensionAuthorityInstructionDataEncoder,
  getSetDefaultBaseFeeRateDiscriminatorBytes: () => getSetDefaultBaseFeeRateDiscriminatorBytes,
  getSetDefaultBaseFeeRateInstruction: () => getSetDefaultBaseFeeRateInstruction,
  getSetDefaultBaseFeeRateInstructionDataCodec: () => getSetDefaultBaseFeeRateInstructionDataCodec,
  getSetDefaultBaseFeeRateInstructionDataDecoder: () => getSetDefaultBaseFeeRateInstructionDataDecoder,
  getSetDefaultBaseFeeRateInstructionDataEncoder: () => getSetDefaultBaseFeeRateInstructionDataEncoder,
  getSetDefaultFeeRateDiscriminatorBytes: () => getSetDefaultFeeRateDiscriminatorBytes,
  getSetDefaultFeeRateInstruction: () => getSetDefaultFeeRateInstruction,
  getSetDefaultFeeRateInstructionDataCodec: () => getSetDefaultFeeRateInstructionDataCodec,
  getSetDefaultFeeRateInstructionDataDecoder: () => getSetDefaultFeeRateInstructionDataDecoder,
  getSetDefaultFeeRateInstructionDataEncoder: () => getSetDefaultFeeRateInstructionDataEncoder,
  getSetDefaultProtocolFeeRateDiscriminatorBytes: () => getSetDefaultProtocolFeeRateDiscriminatorBytes,
  getSetDefaultProtocolFeeRateInstruction: () => getSetDefaultProtocolFeeRateInstruction,
  getSetDefaultProtocolFeeRateInstructionDataCodec: () => getSetDefaultProtocolFeeRateInstructionDataCodec,
  getSetDefaultProtocolFeeRateInstructionDataDecoder: () => getSetDefaultProtocolFeeRateInstructionDataDecoder,
  getSetDefaultProtocolFeeRateInstructionDataEncoder: () => getSetDefaultProtocolFeeRateInstructionDataEncoder,
  getSetDelegatedFeeAuthorityDiscriminatorBytes: () => getSetDelegatedFeeAuthorityDiscriminatorBytes,
  getSetDelegatedFeeAuthorityInstruction: () => getSetDelegatedFeeAuthorityInstruction,
  getSetDelegatedFeeAuthorityInstructionDataCodec: () => getSetDelegatedFeeAuthorityInstructionDataCodec,
  getSetDelegatedFeeAuthorityInstructionDataDecoder: () => getSetDelegatedFeeAuthorityInstructionDataDecoder,
  getSetDelegatedFeeAuthorityInstructionDataEncoder: () => getSetDelegatedFeeAuthorityInstructionDataEncoder,
  getSetFeeAuthorityDiscriminatorBytes: () => getSetFeeAuthorityDiscriminatorBytes,
  getSetFeeAuthorityInstruction: () => getSetFeeAuthorityInstruction,
  getSetFeeAuthorityInstructionDataCodec: () => getSetFeeAuthorityInstructionDataCodec,
  getSetFeeAuthorityInstructionDataDecoder: () => getSetFeeAuthorityInstructionDataDecoder,
  getSetFeeAuthorityInstructionDataEncoder: () => getSetFeeAuthorityInstructionDataEncoder,
  getSetFeeRateByDelegatedFeeAuthorityDiscriminatorBytes: () => getSetFeeRateByDelegatedFeeAuthorityDiscriminatorBytes,
  getSetFeeRateByDelegatedFeeAuthorityInstruction: () => getSetFeeRateByDelegatedFeeAuthorityInstruction,
  getSetFeeRateByDelegatedFeeAuthorityInstructionDataCodec: () => getSetFeeRateByDelegatedFeeAuthorityInstructionDataCodec,
  getSetFeeRateByDelegatedFeeAuthorityInstructionDataDecoder: () => getSetFeeRateByDelegatedFeeAuthorityInstructionDataDecoder,
  getSetFeeRateByDelegatedFeeAuthorityInstructionDataEncoder: () => getSetFeeRateByDelegatedFeeAuthorityInstructionDataEncoder,
  getSetFeeRateDiscriminatorBytes: () => getSetFeeRateDiscriminatorBytes,
  getSetFeeRateInstruction: () => getSetFeeRateInstruction,
  getSetFeeRateInstructionDataCodec: () => getSetFeeRateInstructionDataCodec,
  getSetFeeRateInstructionDataDecoder: () => getSetFeeRateInstructionDataDecoder,
  getSetFeeRateInstructionDataEncoder: () => getSetFeeRateInstructionDataEncoder,
  getSetInitializePoolAuthorityDiscriminatorBytes: () => getSetInitializePoolAuthorityDiscriminatorBytes,
  getSetInitializePoolAuthorityInstruction: () => getSetInitializePoolAuthorityInstruction,
  getSetInitializePoolAuthorityInstructionDataCodec: () => getSetInitializePoolAuthorityInstructionDataCodec,
  getSetInitializePoolAuthorityInstructionDataDecoder: () => getSetInitializePoolAuthorityInstructionDataDecoder,
  getSetInitializePoolAuthorityInstructionDataEncoder: () => getSetInitializePoolAuthorityInstructionDataEncoder,
  getSetPresetAdaptiveFeeConstantsDiscriminatorBytes: () => getSetPresetAdaptiveFeeConstantsDiscriminatorBytes,
  getSetPresetAdaptiveFeeConstantsInstruction: () => getSetPresetAdaptiveFeeConstantsInstruction,
  getSetPresetAdaptiveFeeConstantsInstructionDataCodec: () => getSetPresetAdaptiveFeeConstantsInstructionDataCodec,
  getSetPresetAdaptiveFeeConstantsInstructionDataDecoder: () => getSetPresetAdaptiveFeeConstantsInstructionDataDecoder,
  getSetPresetAdaptiveFeeConstantsInstructionDataEncoder: () => getSetPresetAdaptiveFeeConstantsInstructionDataEncoder,
  getSetProtocolFeeRateDiscriminatorBytes: () => getSetProtocolFeeRateDiscriminatorBytes,
  getSetProtocolFeeRateInstruction: () => getSetProtocolFeeRateInstruction,
  getSetProtocolFeeRateInstructionDataCodec: () => getSetProtocolFeeRateInstructionDataCodec,
  getSetProtocolFeeRateInstructionDataDecoder: () => getSetProtocolFeeRateInstructionDataDecoder,
  getSetProtocolFeeRateInstructionDataEncoder: () => getSetProtocolFeeRateInstructionDataEncoder,
  getSetRewardAuthorityBySuperAuthorityDiscriminatorBytes: () => getSetRewardAuthorityBySuperAuthorityDiscriminatorBytes,
  getSetRewardAuthorityBySuperAuthorityInstruction: () => getSetRewardAuthorityBySuperAuthorityInstruction,
  getSetRewardAuthorityBySuperAuthorityInstructionDataCodec: () => getSetRewardAuthorityBySuperAuthorityInstructionDataCodec,
  getSetRewardAuthorityBySuperAuthorityInstructionDataDecoder: () => getSetRewardAuthorityBySuperAuthorityInstructionDataDecoder,
  getSetRewardAuthorityBySuperAuthorityInstructionDataEncoder: () => getSetRewardAuthorityBySuperAuthorityInstructionDataEncoder,
  getSetRewardAuthorityDiscriminatorBytes: () => getSetRewardAuthorityDiscriminatorBytes,
  getSetRewardAuthorityInstruction: () => getSetRewardAuthorityInstruction,
  getSetRewardAuthorityInstructionDataCodec: () => getSetRewardAuthorityInstructionDataCodec,
  getSetRewardAuthorityInstructionDataDecoder: () => getSetRewardAuthorityInstructionDataDecoder,
  getSetRewardAuthorityInstructionDataEncoder: () => getSetRewardAuthorityInstructionDataEncoder,
  getSetRewardEmissionsDiscriminatorBytes: () => getSetRewardEmissionsDiscriminatorBytes,
  getSetRewardEmissionsInstruction: () => getSetRewardEmissionsInstruction,
  getSetRewardEmissionsInstructionDataCodec: () => getSetRewardEmissionsInstructionDataCodec,
  getSetRewardEmissionsInstructionDataDecoder: () => getSetRewardEmissionsInstructionDataDecoder,
  getSetRewardEmissionsInstructionDataEncoder: () => getSetRewardEmissionsInstructionDataEncoder,
  getSetRewardEmissionsSuperAuthorityDiscriminatorBytes: () => getSetRewardEmissionsSuperAuthorityDiscriminatorBytes,
  getSetRewardEmissionsSuperAuthorityInstruction: () => getSetRewardEmissionsSuperAuthorityInstruction,
  getSetRewardEmissionsSuperAuthorityInstructionDataCodec: () => getSetRewardEmissionsSuperAuthorityInstructionDataCodec,
  getSetRewardEmissionsSuperAuthorityInstructionDataDecoder: () => getSetRewardEmissionsSuperAuthorityInstructionDataDecoder,
  getSetRewardEmissionsSuperAuthorityInstructionDataEncoder: () => getSetRewardEmissionsSuperAuthorityInstructionDataEncoder,
  getSetRewardEmissionsV2DiscriminatorBytes: () => getSetRewardEmissionsV2DiscriminatorBytes,
  getSetRewardEmissionsV2Instruction: () => getSetRewardEmissionsV2Instruction,
  getSetRewardEmissionsV2InstructionDataCodec: () => getSetRewardEmissionsV2InstructionDataCodec,
  getSetRewardEmissionsV2InstructionDataDecoder: () => getSetRewardEmissionsV2InstructionDataDecoder,
  getSetRewardEmissionsV2InstructionDataEncoder: () => getSetRewardEmissionsV2InstructionDataEncoder,
  getSetTokenBadgeAuthorityDiscriminatorBytes: () => getSetTokenBadgeAuthorityDiscriminatorBytes,
  getSetTokenBadgeAuthorityInstruction: () => getSetTokenBadgeAuthorityInstruction,
  getSetTokenBadgeAuthorityInstructionDataCodec: () => getSetTokenBadgeAuthorityInstructionDataCodec,
  getSetTokenBadgeAuthorityInstructionDataDecoder: () => getSetTokenBadgeAuthorityInstructionDataDecoder,
  getSetTokenBadgeAuthorityInstructionDataEncoder: () => getSetTokenBadgeAuthorityInstructionDataEncoder,
  getSwapDiscriminatorBytes: () => getSwapDiscriminatorBytes,
  getSwapInstruction: () => getSwapInstruction,
  getSwapInstructionDataCodec: () => getSwapInstructionDataCodec,
  getSwapInstructionDataDecoder: () => getSwapInstructionDataDecoder,
  getSwapInstructionDataEncoder: () => getSwapInstructionDataEncoder,
  getSwapV2DiscriminatorBytes: () => getSwapV2DiscriminatorBytes,
  getSwapV2Instruction: () => getSwapV2Instruction,
  getSwapV2InstructionDataCodec: () => getSwapV2InstructionDataCodec,
  getSwapV2InstructionDataDecoder: () => getSwapV2InstructionDataDecoder,
  getSwapV2InstructionDataEncoder: () => getSwapV2InstructionDataEncoder,
  getTickArrayAddress: () => getTickArrayAddress,
  getTickArrayCodec: () => getTickArrayCodec,
  getTickArrayDecoder: () => getTickArrayDecoder,
  getTickArrayDiscriminatorBytes: () => getTickArrayDiscriminatorBytes,
  getTickArrayEncoder: () => getTickArrayEncoder,
  getTickArraySize: () => getTickArraySize,
  getTickCodec: () => getTickCodec,
  getTickDecoder: () => getTickDecoder,
  getTickEncoder: () => getTickEncoder,
  getTokenBadgeAddress: () => getTokenBadgeAddress,
  getTokenBadgeCodec: () => getTokenBadgeCodec,
  getTokenBadgeDecoder: () => getTokenBadgeDecoder,
  getTokenBadgeDiscriminatorBytes: () => getTokenBadgeDiscriminatorBytes,
  getTokenBadgeEncoder: () => getTokenBadgeEncoder,
  getTokenBadgeSize: () => getTokenBadgeSize,
  getTransferLockedPositionDiscriminatorBytes: () => getTransferLockedPositionDiscriminatorBytes,
  getTransferLockedPositionInstruction: () => getTransferLockedPositionInstruction,
  getTransferLockedPositionInstructionDataCodec: () => getTransferLockedPositionInstructionDataCodec,
  getTransferLockedPositionInstructionDataDecoder: () => getTransferLockedPositionInstructionDataDecoder,
  getTransferLockedPositionInstructionDataEncoder: () => getTransferLockedPositionInstructionDataEncoder,
  getTwoHopSwapDiscriminatorBytes: () => getTwoHopSwapDiscriminatorBytes,
  getTwoHopSwapInstruction: () => getTwoHopSwapInstruction,
  getTwoHopSwapInstructionDataCodec: () => getTwoHopSwapInstructionDataCodec,
  getTwoHopSwapInstructionDataDecoder: () => getTwoHopSwapInstructionDataDecoder,
  getTwoHopSwapInstructionDataEncoder: () => getTwoHopSwapInstructionDataEncoder,
  getTwoHopSwapV2DiscriminatorBytes: () => getTwoHopSwapV2DiscriminatorBytes,
  getTwoHopSwapV2Instruction: () => getTwoHopSwapV2Instruction,
  getTwoHopSwapV2InstructionDataCodec: () => getTwoHopSwapV2InstructionDataCodec,
  getTwoHopSwapV2InstructionDataDecoder: () => getTwoHopSwapV2InstructionDataDecoder,
  getTwoHopSwapV2InstructionDataEncoder: () => getTwoHopSwapV2InstructionDataEncoder,
  getUpdateFeesAndRewardsDiscriminatorBytes: () => getUpdateFeesAndRewardsDiscriminatorBytes,
  getUpdateFeesAndRewardsInstruction: () => getUpdateFeesAndRewardsInstruction,
  getUpdateFeesAndRewardsInstructionDataCodec: () => getUpdateFeesAndRewardsInstructionDataCodec,
  getUpdateFeesAndRewardsInstructionDataDecoder: () => getUpdateFeesAndRewardsInstructionDataDecoder,
  getUpdateFeesAndRewardsInstructionDataEncoder: () => getUpdateFeesAndRewardsInstructionDataEncoder,
  getWhirlpoolAddress: () => getWhirlpoolAddress,
  getWhirlpoolCodec: () => getWhirlpoolCodec,
  getWhirlpoolDecoder: () => getWhirlpoolDecoder,
  getWhirlpoolDiscriminatorBytes: () => getWhirlpoolDiscriminatorBytes,
  getWhirlpoolEncoder: () => getWhirlpoolEncoder,
  getWhirlpoolErrorMessage: () => getWhirlpoolErrorMessage,
  getWhirlpoolRewardInfoCodec: () => getWhirlpoolRewardInfoCodec,
  getWhirlpoolRewardInfoDecoder: () => getWhirlpoolRewardInfoDecoder,
  getWhirlpoolRewardInfoEncoder: () => getWhirlpoolRewardInfoEncoder,
  getWhirlpoolSize: () => getWhirlpoolSize,
  getWhirlpoolsConfigCodec: () => getWhirlpoolsConfigCodec,
  getWhirlpoolsConfigDecoder: () => getWhirlpoolsConfigDecoder,
  getWhirlpoolsConfigDiscriminatorBytes: () => getWhirlpoolsConfigDiscriminatorBytes,
  getWhirlpoolsConfigEncoder: () => getWhirlpoolsConfigEncoder,
  getWhirlpoolsConfigExtensionAddress: () => getWhirlpoolsConfigExtensionAddress,
  getWhirlpoolsConfigExtensionCodec: () => getWhirlpoolsConfigExtensionCodec,
  getWhirlpoolsConfigExtensionDecoder: () => getWhirlpoolsConfigExtensionDecoder,
  getWhirlpoolsConfigExtensionDiscriminatorBytes: () => getWhirlpoolsConfigExtensionDiscriminatorBytes,
  getWhirlpoolsConfigExtensionEncoder: () => getWhirlpoolsConfigExtensionEncoder,
  getWhirlpoolsConfigExtensionSize: () => getWhirlpoolsConfigExtensionSize,
  getWhirlpoolsConfigSize: () => getWhirlpoolsConfigSize,
  identifyWhirlpoolAccount: () => identifyWhirlpoolAccount,
  identifyWhirlpoolInstruction: () => identifyWhirlpoolInstruction,
  isWhirlpoolError: () => isWhirlpoolError,
  oracleAdaptiveFeeControlFactorFilter: () => oracleAdaptiveFeeControlFactorFilter,
  oracleDecayPeriodFilter: () => oracleDecayPeriodFilter,
  oracleFilterPeriodFilter: () => oracleFilterPeriodFilter,
  oracleMajorSwapThresholdTicksFilter: () => oracleMajorSwapThresholdTicksFilter,
  oracleMaxVolatilityFilter: () => oracleMaxVolatilityFilter,
  oracleReductionFactorFilter: () => oracleReductionFactorFilter,
  oracleTickGroupSizeFilter: () => oracleTickGroupSizeFilter,
  oracleTradeEnableTimestampFilter: () => oracleTradeEnableTimestampFilter,
  oracleWhirlpoolFilter: () => oracleWhirlpoolFilter,
  parseCloseBundledPositionInstruction: () => parseCloseBundledPositionInstruction,
  parseClosePositionInstruction: () => parseClosePositionInstruction,
  parseClosePositionWithTokenExtensionsInstruction: () => parseClosePositionWithTokenExtensionsInstruction,
  parseCollectFeesInstruction: () => parseCollectFeesInstruction,
  parseCollectFeesV2Instruction: () => parseCollectFeesV2Instruction,
  parseCollectProtocolFeesInstruction: () => parseCollectProtocolFeesInstruction,
  parseCollectProtocolFeesV2Instruction: () => parseCollectProtocolFeesV2Instruction,
  parseCollectRewardInstruction: () => parseCollectRewardInstruction,
  parseCollectRewardV2Instruction: () => parseCollectRewardV2Instruction,
  parseDecreaseLiquidityInstruction: () => parseDecreaseLiquidityInstruction,
  parseDecreaseLiquidityV2Instruction: () => parseDecreaseLiquidityV2Instruction,
  parseDeletePositionBundleInstruction: () => parseDeletePositionBundleInstruction,
  parseDeleteTokenBadgeInstruction: () => parseDeleteTokenBadgeInstruction,
  parseIncreaseLiquidityInstruction: () => parseIncreaseLiquidityInstruction,
  parseIncreaseLiquidityV2Instruction: () => parseIncreaseLiquidityV2Instruction,
  parseInitializeAdaptiveFeeTierInstruction: () => parseInitializeAdaptiveFeeTierInstruction,
  parseInitializeConfigExtensionInstruction: () => parseInitializeConfigExtensionInstruction,
  parseInitializeConfigInstruction: () => parseInitializeConfigInstruction,
  parseInitializeFeeTierInstruction: () => parseInitializeFeeTierInstruction,
  parseInitializePoolInstruction: () => parseInitializePoolInstruction,
  parseInitializePoolV2Instruction: () => parseInitializePoolV2Instruction,
  parseInitializePoolWithAdaptiveFeeInstruction: () => parseInitializePoolWithAdaptiveFeeInstruction,
  parseInitializePositionBundleInstruction: () => parseInitializePositionBundleInstruction,
  parseInitializePositionBundleWithMetadataInstruction: () => parseInitializePositionBundleWithMetadataInstruction,
  parseInitializeRewardInstruction: () => parseInitializeRewardInstruction,
  parseInitializeRewardV2Instruction: () => parseInitializeRewardV2Instruction,
  parseInitializeTickArrayInstruction: () => parseInitializeTickArrayInstruction,
  parseInitializeTokenBadgeInstruction: () => parseInitializeTokenBadgeInstruction,
  parseLockPositionInstruction: () => parseLockPositionInstruction,
  parseOpenBundledPositionInstruction: () => parseOpenBundledPositionInstruction,
  parseOpenPositionInstruction: () => parseOpenPositionInstruction,
  parseOpenPositionWithMetadataInstruction: () => parseOpenPositionWithMetadataInstruction,
  parseOpenPositionWithTokenExtensionsInstruction: () => parseOpenPositionWithTokenExtensionsInstruction,
  parseResetPositionRangeInstruction: () => parseResetPositionRangeInstruction,
  parseSetCollectProtocolFeesAuthorityInstruction: () => parseSetCollectProtocolFeesAuthorityInstruction,
  parseSetConfigExtensionAuthorityInstruction: () => parseSetConfigExtensionAuthorityInstruction,
  parseSetDefaultBaseFeeRateInstruction: () => parseSetDefaultBaseFeeRateInstruction,
  parseSetDefaultFeeRateInstruction: () => parseSetDefaultFeeRateInstruction,
  parseSetDefaultProtocolFeeRateInstruction: () => parseSetDefaultProtocolFeeRateInstruction,
  parseSetDelegatedFeeAuthorityInstruction: () => parseSetDelegatedFeeAuthorityInstruction,
  parseSetFeeAuthorityInstruction: () => parseSetFeeAuthorityInstruction,
  parseSetFeeRateByDelegatedFeeAuthorityInstruction: () => parseSetFeeRateByDelegatedFeeAuthorityInstruction,
  parseSetFeeRateInstruction: () => parseSetFeeRateInstruction,
  parseSetInitializePoolAuthorityInstruction: () => parseSetInitializePoolAuthorityInstruction,
  parseSetPresetAdaptiveFeeConstantsInstruction: () => parseSetPresetAdaptiveFeeConstantsInstruction,
  parseSetProtocolFeeRateInstruction: () => parseSetProtocolFeeRateInstruction,
  parseSetRewardAuthorityBySuperAuthorityInstruction: () => parseSetRewardAuthorityBySuperAuthorityInstruction,
  parseSetRewardAuthorityInstruction: () => parseSetRewardAuthorityInstruction,
  parseSetRewardEmissionsInstruction: () => parseSetRewardEmissionsInstruction,
  parseSetRewardEmissionsSuperAuthorityInstruction: () => parseSetRewardEmissionsSuperAuthorityInstruction,
  parseSetRewardEmissionsV2Instruction: () => parseSetRewardEmissionsV2Instruction,
  parseSetTokenBadgeAuthorityInstruction: () => parseSetTokenBadgeAuthorityInstruction,
  parseSwapInstruction: () => parseSwapInstruction,
  parseSwapV2Instruction: () => parseSwapV2Instruction,
  parseTransferLockedPositionInstruction: () => parseTransferLockedPositionInstruction,
  parseTwoHopSwapInstruction: () => parseTwoHopSwapInstruction,
  parseTwoHopSwapV2Instruction: () => parseTwoHopSwapV2Instruction,
  parseUpdateFeesAndRewardsInstruction: () => parseUpdateFeesAndRewardsInstruction,
  positionBundleMintFilter: () => positionBundleMintFilter,
  positionMintFilter: () => positionMintFilter,
  positionTickLowerIndexFilter: () => positionTickLowerIndexFilter,
  positionTickUpperIndexFilter: () => positionTickUpperIndexFilter,
  positionWhirlpoolFilter: () => positionWhirlpoolFilter,
  tickArrayStartTickIndexFilter: () => tickArrayStartTickIndexFilter,
  tickArrayWhirlpoolFilter: () => tickArrayWhirlpoolFilter,
  tokenBadgeTokenMintFilter: () => tokenBadgeTokenMintFilter,
  tokenBadgeWhirlpoolsConfigFilter: () => tokenBadgeWhirlpoolsConfigFilter,
  whirlpoolFeeRateFilter: () => whirlpoolFeeRateFilter,
  whirlpoolProtocolFeeRateFilter: () => whirlpoolProtocolFeeRateFilter,
  whirlpoolRewardMint1Filter: () => whirlpoolRewardMint1Filter,
  whirlpoolRewardMint2Filter: () => whirlpoolRewardMint2Filter,
  whirlpoolRewardMint3Filter: () => whirlpoolRewardMint3Filter,
  whirlpoolRewardVault1Filter: () => whirlpoolRewardVault1Filter,
  whirlpoolRewardVault2Filter: () => whirlpoolRewardVault2Filter,
  whirlpoolRewardVault3Filter: () => whirlpoolRewardVault3Filter,
  whirlpoolTickSpacingFilter: () => whirlpoolTickSpacingFilter,
  whirlpoolTokenMintAFilter: () => whirlpoolTokenMintAFilter,
  whirlpoolTokenMintBFilter: () => whirlpoolTokenMintBFilter,
  whirlpoolTokenVaultAFilter: () => whirlpoolTokenVaultAFilter,
  whirlpoolTokenVaultBFilter: () => whirlpoolTokenVaultBFilter,
  whirlpoolWhirlpoolConfigFilter: () => whirlpoolWhirlpoolConfigFilter,
  whirlpoolsConfigCollectProtocolFeesAuthorityFilter: () => whirlpoolsConfigCollectProtocolFeesAuthorityFilter,
  whirlpoolsConfigDefaultProtocolFeeRateFilter: () => whirlpoolsConfigDefaultProtocolFeeRateFilter,
  whirlpoolsConfigExtensionConfigExtensionAuthorityFilter: () => whirlpoolsConfigExtensionConfigExtensionAuthorityFilter,
  whirlpoolsConfigExtensionConfigTokenBadgeAuthorityFilter: () => whirlpoolsConfigExtensionConfigTokenBadgeAuthorityFilter,
  whirlpoolsConfigExtensionWhirlpoolsConfigFilter: () => whirlpoolsConfigExtensionWhirlpoolsConfigFilter,
  whirlpoolsConfigFeeAuthorityFilter: () => whirlpoolsConfigFeeAuthorityFilter,
  whirlpoolsConfigRewardEmissionsSuperAuthorityFilter: () => whirlpoolsConfigRewardEmissionsSuperAuthorityFilter
});
module.exports = __toCommonJS(index_exports);

// src/generated/accounts/adaptiveFeeTier.ts
var import_kit = require("@solana/kit");
var ADAPTIVE_FEE_TIER_DISCRIMINATOR = new Uint8Array([
  147,
  16,
  144,
  116,
  47,
  146,
  149,
  46
]);
function getAdaptiveFeeTierDiscriminatorBytes() {
  return (0, import_kit.fixEncoderSize)((0, import_kit.getBytesEncoder)(), 8).encode(
    ADAPTIVE_FEE_TIER_DISCRIMINATOR
  );
}
function getAdaptiveFeeTierEncoder() {
  return (0, import_kit.transformEncoder)(
    (0, import_kit.getStructEncoder)([
      ["discriminator", (0, import_kit.fixEncoderSize)((0, import_kit.getBytesEncoder)(), 8)],
      ["whirlpoolsConfig", (0, import_kit.getAddressEncoder)()],
      ["feeTierIndex", (0, import_kit.getU16Encoder)()],
      ["tickSpacing", (0, import_kit.getU16Encoder)()],
      ["initializePoolAuthority", (0, import_kit.getAddressEncoder)()],
      ["delegatedFeeAuthority", (0, import_kit.getAddressEncoder)()],
      ["defaultBaseFeeRate", (0, import_kit.getU16Encoder)()],
      ["filterPeriod", (0, import_kit.getU16Encoder)()],
      ["decayPeriod", (0, import_kit.getU16Encoder)()],
      ["reductionFactor", (0, import_kit.getU16Encoder)()],
      ["adaptiveFeeControlFactor", (0, import_kit.getU32Encoder)()],
      ["maxVolatilityAccumulator", (0, import_kit.getU32Encoder)()],
      ["tickGroupSize", (0, import_kit.getU16Encoder)()],
      ["majorSwapThresholdTicks", (0, import_kit.getU16Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: ADAPTIVE_FEE_TIER_DISCRIMINATOR })
  );
}
function getAdaptiveFeeTierDecoder() {
  return (0, import_kit.getStructDecoder)([
    ["discriminator", (0, import_kit.fixDecoderSize)((0, import_kit.getBytesDecoder)(), 8)],
    ["whirlpoolsConfig", (0, import_kit.getAddressDecoder)()],
    ["feeTierIndex", (0, import_kit.getU16Decoder)()],
    ["tickSpacing", (0, import_kit.getU16Decoder)()],
    ["initializePoolAuthority", (0, import_kit.getAddressDecoder)()],
    ["delegatedFeeAuthority", (0, import_kit.getAddressDecoder)()],
    ["defaultBaseFeeRate", (0, import_kit.getU16Decoder)()],
    ["filterPeriod", (0, import_kit.getU16Decoder)()],
    ["decayPeriod", (0, import_kit.getU16Decoder)()],
    ["reductionFactor", (0, import_kit.getU16Decoder)()],
    ["adaptiveFeeControlFactor", (0, import_kit.getU32Decoder)()],
    ["maxVolatilityAccumulator", (0, import_kit.getU32Decoder)()],
    ["tickGroupSize", (0, import_kit.getU16Decoder)()],
    ["majorSwapThresholdTicks", (0, import_kit.getU16Decoder)()]
  ]);
}
function getAdaptiveFeeTierCodec() {
  return (0, import_kit.combineCodec)(getAdaptiveFeeTierEncoder(), getAdaptiveFeeTierDecoder());
}
function decodeAdaptiveFeeTier(encodedAccount) {
  return (0, import_kit.decodeAccount)(
    encodedAccount,
    getAdaptiveFeeTierDecoder()
  );
}
async function fetchAdaptiveFeeTier(rpc, address, config) {
  const maybeAccount = await fetchMaybeAdaptiveFeeTier(rpc, address, config);
  (0, import_kit.assertAccountExists)(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeAdaptiveFeeTier(rpc, address, config) {
  const maybeAccount = await (0, import_kit.fetchEncodedAccount)(rpc, address, config);
  return decodeAdaptiveFeeTier(maybeAccount);
}
async function fetchAllAdaptiveFeeTier(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeAdaptiveFeeTier(
    rpc,
    addresses,
    config
  );
  (0, import_kit.assertAccountsExist)(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeAdaptiveFeeTier(rpc, addresses, config) {
  const maybeAccounts = await (0, import_kit.fetchEncodedAccounts)(rpc, addresses, config);
  return maybeAccounts.map(
    (maybeAccount) => decodeAdaptiveFeeTier(maybeAccount)
  );
}
function getAdaptiveFeeTierSize() {
  return 128;
}

// src/generated/accounts/feeTier.ts
var import_kit2 = require("@solana/kit");
var FEE_TIER_DISCRIMINATOR = new Uint8Array([
  56,
  75,
  159,
  76,
  142,
  68,
  190,
  105
]);
function getFeeTierDiscriminatorBytes() {
  return (0, import_kit2.fixEncoderSize)((0, import_kit2.getBytesEncoder)(), 8).encode(FEE_TIER_DISCRIMINATOR);
}
function getFeeTierEncoder() {
  return (0, import_kit2.transformEncoder)(
    (0, import_kit2.getStructEncoder)([
      ["discriminator", (0, import_kit2.fixEncoderSize)((0, import_kit2.getBytesEncoder)(), 8)],
      ["whirlpoolsConfig", (0, import_kit2.getAddressEncoder)()],
      ["tickSpacing", (0, import_kit2.getU16Encoder)()],
      ["defaultFeeRate", (0, import_kit2.getU16Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: FEE_TIER_DISCRIMINATOR })
  );
}
function getFeeTierDecoder() {
  return (0, import_kit2.getStructDecoder)([
    ["discriminator", (0, import_kit2.fixDecoderSize)((0, import_kit2.getBytesDecoder)(), 8)],
    ["whirlpoolsConfig", (0, import_kit2.getAddressDecoder)()],
    ["tickSpacing", (0, import_kit2.getU16Decoder)()],
    ["defaultFeeRate", (0, import_kit2.getU16Decoder)()]
  ]);
}
function getFeeTierCodec() {
  return (0, import_kit2.combineCodec)(getFeeTierEncoder(), getFeeTierDecoder());
}
function decodeFeeTier(encodedAccount) {
  return (0, import_kit2.decodeAccount)(
    encodedAccount,
    getFeeTierDecoder()
  );
}
async function fetchFeeTier(rpc, address, config) {
  const maybeAccount = await fetchMaybeFeeTier(rpc, address, config);
  (0, import_kit2.assertAccountExists)(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeFeeTier(rpc, address, config) {
  const maybeAccount = await (0, import_kit2.fetchEncodedAccount)(rpc, address, config);
  return decodeFeeTier(maybeAccount);
}
async function fetchAllFeeTier(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeFeeTier(rpc, addresses, config);
  (0, import_kit2.assertAccountsExist)(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeFeeTier(rpc, addresses, config) {
  const maybeAccounts = await (0, import_kit2.fetchEncodedAccounts)(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeFeeTier(maybeAccount));
}
function getFeeTierSize() {
  return 44;
}

// src/generated/accounts/lockConfig.ts
var import_kit13 = require("@solana/kit");

// src/generated/types/accountsType.ts
var import_kit3 = require("@solana/kit");
var AccountsType = /* @__PURE__ */ ((AccountsType2) => {
  AccountsType2[AccountsType2["TransferHookA"] = 0] = "TransferHookA";
  AccountsType2[AccountsType2["TransferHookB"] = 1] = "TransferHookB";
  AccountsType2[AccountsType2["TransferHookReward"] = 2] = "TransferHookReward";
  AccountsType2[AccountsType2["TransferHookInput"] = 3] = "TransferHookInput";
  AccountsType2[AccountsType2["TransferHookIntermediate"] = 4] = "TransferHookIntermediate";
  AccountsType2[AccountsType2["TransferHookOutput"] = 5] = "TransferHookOutput";
  AccountsType2[AccountsType2["SupplementalTickArrays"] = 6] = "SupplementalTickArrays";
  AccountsType2[AccountsType2["SupplementalTickArraysOne"] = 7] = "SupplementalTickArraysOne";
  AccountsType2[AccountsType2["SupplementalTickArraysTwo"] = 8] = "SupplementalTickArraysTwo";
  return AccountsType2;
})(AccountsType || {});
function getAccountsTypeEncoder() {
  return (0, import_kit3.getEnumEncoder)(AccountsType);
}
function getAccountsTypeDecoder() {
  return (0, import_kit3.getEnumDecoder)(AccountsType);
}
function getAccountsTypeCodec() {
  return (0, import_kit3.combineCodec)(getAccountsTypeEncoder(), getAccountsTypeDecoder());
}

// src/generated/types/adaptiveFeeConstants.ts
var import_kit4 = require("@solana/kit");
function getAdaptiveFeeConstantsEncoder() {
  return (0, import_kit4.getStructEncoder)([
    ["filterPeriod", (0, import_kit4.getU16Encoder)()],
    ["decayPeriod", (0, import_kit4.getU16Encoder)()],
    ["reductionFactor", (0, import_kit4.getU16Encoder)()],
    ["adaptiveFeeControlFactor", (0, import_kit4.getU32Encoder)()],
    ["maxVolatilityAccumulator", (0, import_kit4.getU32Encoder)()],
    ["tickGroupSize", (0, import_kit4.getU16Encoder)()],
    ["majorSwapThresholdTicks", (0, import_kit4.getU16Encoder)()],
    ["reserved", (0, import_kit4.fixEncoderSize)((0, import_kit4.getBytesEncoder)(), 16)]
  ]);
}
function getAdaptiveFeeConstantsDecoder() {
  return (0, import_kit4.getStructDecoder)([
    ["filterPeriod", (0, import_kit4.getU16Decoder)()],
    ["decayPeriod", (0, import_kit4.getU16Decoder)()],
    ["reductionFactor", (0, import_kit4.getU16Decoder)()],
    ["adaptiveFeeControlFactor", (0, import_kit4.getU32Decoder)()],
    ["maxVolatilityAccumulator", (0, import_kit4.getU32Decoder)()],
    ["tickGroupSize", (0, import_kit4.getU16Decoder)()],
    ["majorSwapThresholdTicks", (0, import_kit4.getU16Decoder)()],
    ["reserved", (0, import_kit4.fixDecoderSize)((0, import_kit4.getBytesDecoder)(), 16)]
  ]);
}
function getAdaptiveFeeConstantsCodec() {
  return (0, import_kit4.combineCodec)(
    getAdaptiveFeeConstantsEncoder(),
    getAdaptiveFeeConstantsDecoder()
  );
}

// src/generated/types/adaptiveFeeVariables.ts
var import_kit5 = require("@solana/kit");
function getAdaptiveFeeVariablesEncoder() {
  return (0, import_kit5.getStructEncoder)([
    ["lastReferenceUpdateTimestamp", (0, import_kit5.getU64Encoder)()],
    ["lastMajorSwapTimestamp", (0, import_kit5.getU64Encoder)()],
    ["volatilityReference", (0, import_kit5.getU32Encoder)()],
    ["tickGroupIndexReference", (0, import_kit5.getI32Encoder)()],
    ["volatilityAccumulator", (0, import_kit5.getU32Encoder)()],
    ["reserved", (0, import_kit5.fixEncoderSize)((0, import_kit5.getBytesEncoder)(), 16)]
  ]);
}
function getAdaptiveFeeVariablesDecoder() {
  return (0, import_kit5.getStructDecoder)([
    ["lastReferenceUpdateTimestamp", (0, import_kit5.getU64Decoder)()],
    ["lastMajorSwapTimestamp", (0, import_kit5.getU64Decoder)()],
    ["volatilityReference", (0, import_kit5.getU32Decoder)()],
    ["tickGroupIndexReference", (0, import_kit5.getI32Decoder)()],
    ["volatilityAccumulator", (0, import_kit5.getU32Decoder)()],
    ["reserved", (0, import_kit5.fixDecoderSize)((0, import_kit5.getBytesDecoder)(), 16)]
  ]);
}
function getAdaptiveFeeVariablesCodec() {
  return (0, import_kit5.combineCodec)(
    getAdaptiveFeeVariablesEncoder(),
    getAdaptiveFeeVariablesDecoder()
  );
}

// src/generated/types/lockType.ts
var import_kit6 = require("@solana/kit");
var LockType = /* @__PURE__ */ ((LockType2) => {
  LockType2[LockType2["Permanent"] = 0] = "Permanent";
  return LockType2;
})(LockType || {});
function getLockTypeEncoder() {
  return (0, import_kit6.getEnumEncoder)(LockType);
}
function getLockTypeDecoder() {
  return (0, import_kit6.getEnumDecoder)(LockType);
}
function getLockTypeCodec() {
  return (0, import_kit6.combineCodec)(getLockTypeEncoder(), getLockTypeDecoder());
}

// src/generated/types/lockTypeLabel.ts
var import_kit7 = require("@solana/kit");
var LockTypeLabel = /* @__PURE__ */ ((LockTypeLabel2) => {
  LockTypeLabel2[LockTypeLabel2["Permanent"] = 0] = "Permanent";
  return LockTypeLabel2;
})(LockTypeLabel || {});
function getLockTypeLabelEncoder() {
  return (0, import_kit7.getEnumEncoder)(LockTypeLabel);
}
function getLockTypeLabelDecoder() {
  return (0, import_kit7.getEnumDecoder)(LockTypeLabel);
}
function getLockTypeLabelCodec() {
  return (0, import_kit7.combineCodec)(getLockTypeLabelEncoder(), getLockTypeLabelDecoder());
}

// src/generated/types/positionRewardInfo.ts
var import_kit8 = require("@solana/kit");
function getPositionRewardInfoEncoder() {
  return (0, import_kit8.getStructEncoder)([
    ["growthInsideCheckpoint", (0, import_kit8.getU128Encoder)()],
    ["amountOwed", (0, import_kit8.getU64Encoder)()]
  ]);
}
function getPositionRewardInfoDecoder() {
  return (0, import_kit8.getStructDecoder)([
    ["growthInsideCheckpoint", (0, import_kit8.getU128Decoder)()],
    ["amountOwed", (0, import_kit8.getU64Decoder)()]
  ]);
}
function getPositionRewardInfoCodec() {
  return (0, import_kit8.combineCodec)(
    getPositionRewardInfoEncoder(),
    getPositionRewardInfoDecoder()
  );
}

// src/generated/types/remainingAccountsInfo.ts
var import_kit9 = require("@solana/kit");
function getRemainingAccountsInfoEncoder() {
  return (0, import_kit9.getStructEncoder)([
    ["slices", (0, import_kit9.getArrayEncoder)(getRemainingAccountsSliceEncoder())]
  ]);
}
function getRemainingAccountsInfoDecoder() {
  return (0, import_kit9.getStructDecoder)([
    ["slices", (0, import_kit9.getArrayDecoder)(getRemainingAccountsSliceDecoder())]
  ]);
}
function getRemainingAccountsInfoCodec() {
  return (0, import_kit9.combineCodec)(
    getRemainingAccountsInfoEncoder(),
    getRemainingAccountsInfoDecoder()
  );
}

// src/generated/types/remainingAccountsSlice.ts
var import_kit10 = require("@solana/kit");
function getRemainingAccountsSliceEncoder() {
  return (0, import_kit10.getStructEncoder)([
    ["accountsType", getAccountsTypeEncoder()],
    ["length", (0, import_kit10.getU8Encoder)()]
  ]);
}
function getRemainingAccountsSliceDecoder() {
  return (0, import_kit10.getStructDecoder)([
    ["accountsType", getAccountsTypeDecoder()],
    ["length", (0, import_kit10.getU8Decoder)()]
  ]);
}
function getRemainingAccountsSliceCodec() {
  return (0, import_kit10.combineCodec)(
    getRemainingAccountsSliceEncoder(),
    getRemainingAccountsSliceDecoder()
  );
}

// src/generated/types/tick.ts
var import_kit11 = require("@solana/kit");
function getTickEncoder() {
  return (0, import_kit11.getStructEncoder)([
    ["initialized", (0, import_kit11.getBooleanEncoder)()],
    ["liquidityNet", (0, import_kit11.getI128Encoder)()],
    ["liquidityGross", (0, import_kit11.getU128Encoder)()],
    ["feeGrowthOutsideA", (0, import_kit11.getU128Encoder)()],
    ["feeGrowthOutsideB", (0, import_kit11.getU128Encoder)()],
    ["rewardGrowthsOutside", (0, import_kit11.getArrayEncoder)((0, import_kit11.getU128Encoder)(), { size: 3 })]
  ]);
}
function getTickDecoder() {
  return (0, import_kit11.getStructDecoder)([
    ["initialized", (0, import_kit11.getBooleanDecoder)()],
    ["liquidityNet", (0, import_kit11.getI128Decoder)()],
    ["liquidityGross", (0, import_kit11.getU128Decoder)()],
    ["feeGrowthOutsideA", (0, import_kit11.getU128Decoder)()],
    ["feeGrowthOutsideB", (0, import_kit11.getU128Decoder)()],
    ["rewardGrowthsOutside", (0, import_kit11.getArrayDecoder)((0, import_kit11.getU128Decoder)(), { size: 3 })]
  ]);
}
function getTickCodec() {
  return (0, import_kit11.combineCodec)(getTickEncoder(), getTickDecoder());
}

// src/generated/types/whirlpoolRewardInfo.ts
var import_kit12 = require("@solana/kit");
function getWhirlpoolRewardInfoEncoder() {
  return (0, import_kit12.getStructEncoder)([
    ["mint", (0, import_kit12.getAddressEncoder)()],
    ["vault", (0, import_kit12.getAddressEncoder)()],
    ["authority", (0, import_kit12.getAddressEncoder)()],
    ["emissionsPerSecondX64", (0, import_kit12.getU128Encoder)()],
    ["growthGlobalX64", (0, import_kit12.getU128Encoder)()]
  ]);
}
function getWhirlpoolRewardInfoDecoder() {
  return (0, import_kit12.getStructDecoder)([
    ["mint", (0, import_kit12.getAddressDecoder)()],
    ["vault", (0, import_kit12.getAddressDecoder)()],
    ["authority", (0, import_kit12.getAddressDecoder)()],
    ["emissionsPerSecondX64", (0, import_kit12.getU128Decoder)()],
    ["growthGlobalX64", (0, import_kit12.getU128Decoder)()]
  ]);
}
function getWhirlpoolRewardInfoCodec() {
  return (0, import_kit12.combineCodec)(
    getWhirlpoolRewardInfoEncoder(),
    getWhirlpoolRewardInfoDecoder()
  );
}

// src/generated/accounts/lockConfig.ts
var LOCK_CONFIG_DISCRIMINATOR = new Uint8Array([
  106,
  47,
  238,
  159,
  124,
  12,
  160,
  192
]);
function getLockConfigDiscriminatorBytes() {
  return (0, import_kit13.fixEncoderSize)((0, import_kit13.getBytesEncoder)(), 8).encode(LOCK_CONFIG_DISCRIMINATOR);
}
function getLockConfigEncoder() {
  return (0, import_kit13.transformEncoder)(
    (0, import_kit13.getStructEncoder)([
      ["discriminator", (0, import_kit13.fixEncoderSize)((0, import_kit13.getBytesEncoder)(), 8)],
      ["position", (0, import_kit13.getAddressEncoder)()],
      ["positionOwner", (0, import_kit13.getAddressEncoder)()],
      ["whirlpool", (0, import_kit13.getAddressEncoder)()],
      ["lockedTimestamp", (0, import_kit13.getU64Encoder)()],
      ["lockType", getLockTypeLabelEncoder()]
    ]),
    (value) => ({ ...value, discriminator: LOCK_CONFIG_DISCRIMINATOR })
  );
}
function getLockConfigDecoder() {
  return (0, import_kit13.getStructDecoder)([
    ["discriminator", (0, import_kit13.fixDecoderSize)((0, import_kit13.getBytesDecoder)(), 8)],
    ["position", (0, import_kit13.getAddressDecoder)()],
    ["positionOwner", (0, import_kit13.getAddressDecoder)()],
    ["whirlpool", (0, import_kit13.getAddressDecoder)()],
    ["lockedTimestamp", (0, import_kit13.getU64Decoder)()],
    ["lockType", getLockTypeLabelDecoder()]
  ]);
}
function getLockConfigCodec() {
  return (0, import_kit13.combineCodec)(getLockConfigEncoder(), getLockConfigDecoder());
}
function decodeLockConfig(encodedAccount) {
  return (0, import_kit13.decodeAccount)(
    encodedAccount,
    getLockConfigDecoder()
  );
}
async function fetchLockConfig(rpc, address, config) {
  const maybeAccount = await fetchMaybeLockConfig(rpc, address, config);
  (0, import_kit13.assertAccountExists)(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeLockConfig(rpc, address, config) {
  const maybeAccount = await (0, import_kit13.fetchEncodedAccount)(rpc, address, config);
  return decodeLockConfig(maybeAccount);
}
async function fetchAllLockConfig(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeLockConfig(rpc, addresses, config);
  (0, import_kit13.assertAccountsExist)(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeLockConfig(rpc, addresses, config) {
  const maybeAccounts = await (0, import_kit13.fetchEncodedAccounts)(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeLockConfig(maybeAccount));
}
function getLockConfigSize() {
  return 113;
}

// src/generated/accounts/oracle.ts
var import_kit14 = require("@solana/kit");
var ORACLE_DISCRIMINATOR = new Uint8Array([
  139,
  194,
  131,
  179,
  140,
  179,
  229,
  244
]);
function getOracleDiscriminatorBytes() {
  return (0, import_kit14.fixEncoderSize)((0, import_kit14.getBytesEncoder)(), 8).encode(ORACLE_DISCRIMINATOR);
}
function getOracleEncoder() {
  return (0, import_kit14.transformEncoder)(
    (0, import_kit14.getStructEncoder)([
      ["discriminator", (0, import_kit14.fixEncoderSize)((0, import_kit14.getBytesEncoder)(), 8)],
      ["whirlpool", (0, import_kit14.getAddressEncoder)()],
      ["tradeEnableTimestamp", (0, import_kit14.getU64Encoder)()],
      ["adaptiveFeeConstants", getAdaptiveFeeConstantsEncoder()],
      ["adaptiveFeeVariables", getAdaptiveFeeVariablesEncoder()],
      ["reserved", (0, import_kit14.fixEncoderSize)((0, import_kit14.getBytesEncoder)(), 128)]
    ]),
    (value) => ({ ...value, discriminator: ORACLE_DISCRIMINATOR })
  );
}
function getOracleDecoder() {
  return (0, import_kit14.getStructDecoder)([
    ["discriminator", (0, import_kit14.fixDecoderSize)((0, import_kit14.getBytesDecoder)(), 8)],
    ["whirlpool", (0, import_kit14.getAddressDecoder)()],
    ["tradeEnableTimestamp", (0, import_kit14.getU64Decoder)()],
    ["adaptiveFeeConstants", getAdaptiveFeeConstantsDecoder()],
    ["adaptiveFeeVariables", getAdaptiveFeeVariablesDecoder()],
    ["reserved", (0, import_kit14.fixDecoderSize)((0, import_kit14.getBytesDecoder)(), 128)]
  ]);
}
function getOracleCodec() {
  return (0, import_kit14.combineCodec)(getOracleEncoder(), getOracleDecoder());
}
function decodeOracle(encodedAccount) {
  return (0, import_kit14.decodeAccount)(
    encodedAccount,
    getOracleDecoder()
  );
}
async function fetchOracle(rpc, address, config) {
  const maybeAccount = await fetchMaybeOracle(rpc, address, config);
  (0, import_kit14.assertAccountExists)(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeOracle(rpc, address, config) {
  const maybeAccount = await (0, import_kit14.fetchEncodedAccount)(rpc, address, config);
  return decodeOracle(maybeAccount);
}
async function fetchAllOracle(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeOracle(rpc, addresses, config);
  (0, import_kit14.assertAccountsExist)(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeOracle(rpc, addresses, config) {
  const maybeAccounts = await (0, import_kit14.fetchEncodedAccounts)(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeOracle(maybeAccount));
}
function getOracleSize() {
  return 254;
}

// src/generated/accounts/position.ts
var import_kit15 = require("@solana/kit");
var POSITION_DISCRIMINATOR = new Uint8Array([
  170,
  188,
  143,
  228,
  122,
  64,
  247,
  208
]);
function getPositionDiscriminatorBytes() {
  return (0, import_kit15.fixEncoderSize)((0, import_kit15.getBytesEncoder)(), 8).encode(POSITION_DISCRIMINATOR);
}
function getPositionEncoder() {
  return (0, import_kit15.transformEncoder)(
    (0, import_kit15.getStructEncoder)([
      ["discriminator", (0, import_kit15.fixEncoderSize)((0, import_kit15.getBytesEncoder)(), 8)],
      ["whirlpool", (0, import_kit15.getAddressEncoder)()],
      ["positionMint", (0, import_kit15.getAddressEncoder)()],
      ["liquidity", (0, import_kit15.getU128Encoder)()],
      ["tickLowerIndex", (0, import_kit15.getI32Encoder)()],
      ["tickUpperIndex", (0, import_kit15.getI32Encoder)()],
      ["feeGrowthCheckpointA", (0, import_kit15.getU128Encoder)()],
      ["feeOwedA", (0, import_kit15.getU64Encoder)()],
      ["feeGrowthCheckpointB", (0, import_kit15.getU128Encoder)()],
      ["feeOwedB", (0, import_kit15.getU64Encoder)()],
      [
        "rewardInfos",
        (0, import_kit15.getArrayEncoder)(getPositionRewardInfoEncoder(), { size: 3 })
      ]
    ]),
    (value) => ({ ...value, discriminator: POSITION_DISCRIMINATOR })
  );
}
function getPositionDecoder() {
  return (0, import_kit15.getStructDecoder)([
    ["discriminator", (0, import_kit15.fixDecoderSize)((0, import_kit15.getBytesDecoder)(), 8)],
    ["whirlpool", (0, import_kit15.getAddressDecoder)()],
    ["positionMint", (0, import_kit15.getAddressDecoder)()],
    ["liquidity", (0, import_kit15.getU128Decoder)()],
    ["tickLowerIndex", (0, import_kit15.getI32Decoder)()],
    ["tickUpperIndex", (0, import_kit15.getI32Decoder)()],
    ["feeGrowthCheckpointA", (0, import_kit15.getU128Decoder)()],
    ["feeOwedA", (0, import_kit15.getU64Decoder)()],
    ["feeGrowthCheckpointB", (0, import_kit15.getU128Decoder)()],
    ["feeOwedB", (0, import_kit15.getU64Decoder)()],
    [
      "rewardInfos",
      (0, import_kit15.getArrayDecoder)(getPositionRewardInfoDecoder(), { size: 3 })
    ]
  ]);
}
function getPositionCodec() {
  return (0, import_kit15.combineCodec)(getPositionEncoder(), getPositionDecoder());
}
function decodePosition(encodedAccount) {
  return (0, import_kit15.decodeAccount)(
    encodedAccount,
    getPositionDecoder()
  );
}
async function fetchPosition(rpc, address, config) {
  const maybeAccount = await fetchMaybePosition(rpc, address, config);
  (0, import_kit15.assertAccountExists)(maybeAccount);
  return maybeAccount;
}
async function fetchMaybePosition(rpc, address, config) {
  const maybeAccount = await (0, import_kit15.fetchEncodedAccount)(rpc, address, config);
  return decodePosition(maybeAccount);
}
async function fetchAllPosition(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybePosition(rpc, addresses, config);
  (0, import_kit15.assertAccountsExist)(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybePosition(rpc, addresses, config) {
  const maybeAccounts = await (0, import_kit15.fetchEncodedAccounts)(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodePosition(maybeAccount));
}
function getPositionSize() {
  return 216;
}

// src/generated/accounts/positionBundle.ts
var import_kit16 = require("@solana/kit");
var POSITION_BUNDLE_DISCRIMINATOR = new Uint8Array([
  129,
  169,
  175,
  65,
  185,
  95,
  32,
  100
]);
function getPositionBundleDiscriminatorBytes() {
  return (0, import_kit16.fixEncoderSize)((0, import_kit16.getBytesEncoder)(), 8).encode(
    POSITION_BUNDLE_DISCRIMINATOR
  );
}
function getPositionBundleEncoder() {
  return (0, import_kit16.transformEncoder)(
    (0, import_kit16.getStructEncoder)([
      ["discriminator", (0, import_kit16.fixEncoderSize)((0, import_kit16.getBytesEncoder)(), 8)],
      ["positionBundleMint", (0, import_kit16.getAddressEncoder)()],
      ["positionBitmap", (0, import_kit16.fixEncoderSize)((0, import_kit16.getBytesEncoder)(), 32)]
    ]),
    (value) => ({ ...value, discriminator: POSITION_BUNDLE_DISCRIMINATOR })
  );
}
function getPositionBundleDecoder() {
  return (0, import_kit16.getStructDecoder)([
    ["discriminator", (0, import_kit16.fixDecoderSize)((0, import_kit16.getBytesDecoder)(), 8)],
    ["positionBundleMint", (0, import_kit16.getAddressDecoder)()],
    ["positionBitmap", (0, import_kit16.fixDecoderSize)((0, import_kit16.getBytesDecoder)(), 32)]
  ]);
}
function getPositionBundleCodec() {
  return (0, import_kit16.combineCodec)(getPositionBundleEncoder(), getPositionBundleDecoder());
}
function decodePositionBundle(encodedAccount) {
  return (0, import_kit16.decodeAccount)(
    encodedAccount,
    getPositionBundleDecoder()
  );
}
async function fetchPositionBundle(rpc, address, config) {
  const maybeAccount = await fetchMaybePositionBundle(rpc, address, config);
  (0, import_kit16.assertAccountExists)(maybeAccount);
  return maybeAccount;
}
async function fetchMaybePositionBundle(rpc, address, config) {
  const maybeAccount = await (0, import_kit16.fetchEncodedAccount)(rpc, address, config);
  return decodePositionBundle(maybeAccount);
}
async function fetchAllPositionBundle(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybePositionBundle(
    rpc,
    addresses,
    config
  );
  (0, import_kit16.assertAccountsExist)(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybePositionBundle(rpc, addresses, config) {
  const maybeAccounts = await (0, import_kit16.fetchEncodedAccounts)(rpc, addresses, config);
  return maybeAccounts.map(
    (maybeAccount) => decodePositionBundle(maybeAccount)
  );
}
function getPositionBundleSize() {
  return 72;
}

// src/generated/accounts/tickArray.ts
var import_kit17 = require("@solana/kit");
var TICK_ARRAY_DISCRIMINATOR = new Uint8Array([
  69,
  97,
  189,
  190,
  110,
  7,
  66,
  187
]);
function getTickArrayDiscriminatorBytes() {
  return (0, import_kit17.fixEncoderSize)((0, import_kit17.getBytesEncoder)(), 8).encode(TICK_ARRAY_DISCRIMINATOR);
}
function getTickArrayEncoder() {
  return (0, import_kit17.transformEncoder)(
    (0, import_kit17.getStructEncoder)([
      ["discriminator", (0, import_kit17.fixEncoderSize)((0, import_kit17.getBytesEncoder)(), 8)],
      ["startTickIndex", (0, import_kit17.getI32Encoder)()],
      ["ticks", (0, import_kit17.getArrayEncoder)(getTickEncoder(), { size: 88 })],
      ["whirlpool", (0, import_kit17.getAddressEncoder)()]
    ]),
    (value) => ({ ...value, discriminator: TICK_ARRAY_DISCRIMINATOR })
  );
}
function getTickArrayDecoder() {
  return (0, import_kit17.getStructDecoder)([
    ["discriminator", (0, import_kit17.fixDecoderSize)((0, import_kit17.getBytesDecoder)(), 8)],
    ["startTickIndex", (0, import_kit17.getI32Decoder)()],
    ["ticks", (0, import_kit17.getArrayDecoder)(getTickDecoder(), { size: 88 })],
    ["whirlpool", (0, import_kit17.getAddressDecoder)()]
  ]);
}
function getTickArrayCodec() {
  return (0, import_kit17.combineCodec)(getTickArrayEncoder(), getTickArrayDecoder());
}
function decodeTickArray(encodedAccount) {
  return (0, import_kit17.decodeAccount)(
    encodedAccount,
    getTickArrayDecoder()
  );
}
async function fetchTickArray(rpc, address, config) {
  const maybeAccount = await fetchMaybeTickArray(rpc, address, config);
  (0, import_kit17.assertAccountExists)(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeTickArray(rpc, address, config) {
  const maybeAccount = await (0, import_kit17.fetchEncodedAccount)(rpc, address, config);
  return decodeTickArray(maybeAccount);
}
async function fetchAllTickArray(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeTickArray(rpc, addresses, config);
  (0, import_kit17.assertAccountsExist)(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeTickArray(rpc, addresses, config) {
  const maybeAccounts = await (0, import_kit17.fetchEncodedAccounts)(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeTickArray(maybeAccount));
}
function getTickArraySize() {
  return 9988;
}

// src/generated/accounts/tokenBadge.ts
var import_kit18 = require("@solana/kit");
var TOKEN_BADGE_DISCRIMINATOR = new Uint8Array([
  116,
  219,
  204,
  229,
  249,
  116,
  255,
  150
]);
function getTokenBadgeDiscriminatorBytes() {
  return (0, import_kit18.fixEncoderSize)((0, import_kit18.getBytesEncoder)(), 8).encode(TOKEN_BADGE_DISCRIMINATOR);
}
function getTokenBadgeEncoder() {
  return (0, import_kit18.transformEncoder)(
    (0, import_kit18.getStructEncoder)([
      ["discriminator", (0, import_kit18.fixEncoderSize)((0, import_kit18.getBytesEncoder)(), 8)],
      ["whirlpoolsConfig", (0, import_kit18.getAddressEncoder)()],
      ["tokenMint", (0, import_kit18.getAddressEncoder)()]
    ]),
    (value) => ({ ...value, discriminator: TOKEN_BADGE_DISCRIMINATOR })
  );
}
function getTokenBadgeDecoder() {
  return (0, import_kit18.getStructDecoder)([
    ["discriminator", (0, import_kit18.fixDecoderSize)((0, import_kit18.getBytesDecoder)(), 8)],
    ["whirlpoolsConfig", (0, import_kit18.getAddressDecoder)()],
    ["tokenMint", (0, import_kit18.getAddressDecoder)()]
  ]);
}
function getTokenBadgeCodec() {
  return (0, import_kit18.combineCodec)(getTokenBadgeEncoder(), getTokenBadgeDecoder());
}
function decodeTokenBadge(encodedAccount) {
  return (0, import_kit18.decodeAccount)(
    encodedAccount,
    getTokenBadgeDecoder()
  );
}
async function fetchTokenBadge(rpc, address, config) {
  const maybeAccount = await fetchMaybeTokenBadge(rpc, address, config);
  (0, import_kit18.assertAccountExists)(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeTokenBadge(rpc, address, config) {
  const maybeAccount = await (0, import_kit18.fetchEncodedAccount)(rpc, address, config);
  return decodeTokenBadge(maybeAccount);
}
async function fetchAllTokenBadge(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeTokenBadge(rpc, addresses, config);
  (0, import_kit18.assertAccountsExist)(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeTokenBadge(rpc, addresses, config) {
  const maybeAccounts = await (0, import_kit18.fetchEncodedAccounts)(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeTokenBadge(maybeAccount));
}
function getTokenBadgeSize() {
  return 72;
}

// src/generated/accounts/whirlpool.ts
var import_kit19 = require("@solana/kit");
var WHIRLPOOL_DISCRIMINATOR = new Uint8Array([
  63,
  149,
  209,
  12,
  225,
  128,
  99,
  9
]);
function getWhirlpoolDiscriminatorBytes() {
  return (0, import_kit19.fixEncoderSize)((0, import_kit19.getBytesEncoder)(), 8).encode(WHIRLPOOL_DISCRIMINATOR);
}
function getWhirlpoolEncoder() {
  return (0, import_kit19.transformEncoder)(
    (0, import_kit19.getStructEncoder)([
      ["discriminator", (0, import_kit19.fixEncoderSize)((0, import_kit19.getBytesEncoder)(), 8)],
      ["whirlpoolsConfig", (0, import_kit19.getAddressEncoder)()],
      ["whirlpoolBump", (0, import_kit19.fixEncoderSize)((0, import_kit19.getBytesEncoder)(), 1)],
      ["tickSpacing", (0, import_kit19.getU16Encoder)()],
      ["feeTierIndexSeed", (0, import_kit19.fixEncoderSize)((0, import_kit19.getBytesEncoder)(), 2)],
      ["feeRate", (0, import_kit19.getU16Encoder)()],
      ["protocolFeeRate", (0, import_kit19.getU16Encoder)()],
      ["liquidity", (0, import_kit19.getU128Encoder)()],
      ["sqrtPrice", (0, import_kit19.getU128Encoder)()],
      ["tickCurrentIndex", (0, import_kit19.getI32Encoder)()],
      ["protocolFeeOwedA", (0, import_kit19.getU64Encoder)()],
      ["protocolFeeOwedB", (0, import_kit19.getU64Encoder)()],
      ["tokenMintA", (0, import_kit19.getAddressEncoder)()],
      ["tokenVaultA", (0, import_kit19.getAddressEncoder)()],
      ["feeGrowthGlobalA", (0, import_kit19.getU128Encoder)()],
      ["tokenMintB", (0, import_kit19.getAddressEncoder)()],
      ["tokenVaultB", (0, import_kit19.getAddressEncoder)()],
      ["feeGrowthGlobalB", (0, import_kit19.getU128Encoder)()],
      ["rewardLastUpdatedTimestamp", (0, import_kit19.getU64Encoder)()],
      [
        "rewardInfos",
        (0, import_kit19.getArrayEncoder)(getWhirlpoolRewardInfoEncoder(), { size: 3 })
      ]
    ]),
    (value) => ({ ...value, discriminator: WHIRLPOOL_DISCRIMINATOR })
  );
}
function getWhirlpoolDecoder() {
  return (0, import_kit19.getStructDecoder)([
    ["discriminator", (0, import_kit19.fixDecoderSize)((0, import_kit19.getBytesDecoder)(), 8)],
    ["whirlpoolsConfig", (0, import_kit19.getAddressDecoder)()],
    ["whirlpoolBump", (0, import_kit19.fixDecoderSize)((0, import_kit19.getBytesDecoder)(), 1)],
    ["tickSpacing", (0, import_kit19.getU16Decoder)()],
    ["feeTierIndexSeed", (0, import_kit19.fixDecoderSize)((0, import_kit19.getBytesDecoder)(), 2)],
    ["feeRate", (0, import_kit19.getU16Decoder)()],
    ["protocolFeeRate", (0, import_kit19.getU16Decoder)()],
    ["liquidity", (0, import_kit19.getU128Decoder)()],
    ["sqrtPrice", (0, import_kit19.getU128Decoder)()],
    ["tickCurrentIndex", (0, import_kit19.getI32Decoder)()],
    ["protocolFeeOwedA", (0, import_kit19.getU64Decoder)()],
    ["protocolFeeOwedB", (0, import_kit19.getU64Decoder)()],
    ["tokenMintA", (0, import_kit19.getAddressDecoder)()],
    ["tokenVaultA", (0, import_kit19.getAddressDecoder)()],
    ["feeGrowthGlobalA", (0, import_kit19.getU128Decoder)()],
    ["tokenMintB", (0, import_kit19.getAddressDecoder)()],
    ["tokenVaultB", (0, import_kit19.getAddressDecoder)()],
    ["feeGrowthGlobalB", (0, import_kit19.getU128Decoder)()],
    ["rewardLastUpdatedTimestamp", (0, import_kit19.getU64Decoder)()],
    [
      "rewardInfos",
      (0, import_kit19.getArrayDecoder)(getWhirlpoolRewardInfoDecoder(), { size: 3 })
    ]
  ]);
}
function getWhirlpoolCodec() {
  return (0, import_kit19.combineCodec)(getWhirlpoolEncoder(), getWhirlpoolDecoder());
}
function decodeWhirlpool(encodedAccount) {
  return (0, import_kit19.decodeAccount)(
    encodedAccount,
    getWhirlpoolDecoder()
  );
}
async function fetchWhirlpool(rpc, address, config) {
  const maybeAccount = await fetchMaybeWhirlpool(rpc, address, config);
  (0, import_kit19.assertAccountExists)(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeWhirlpool(rpc, address, config) {
  const maybeAccount = await (0, import_kit19.fetchEncodedAccount)(rpc, address, config);
  return decodeWhirlpool(maybeAccount);
}
async function fetchAllWhirlpool(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeWhirlpool(rpc, addresses, config);
  (0, import_kit19.assertAccountsExist)(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeWhirlpool(rpc, addresses, config) {
  const maybeAccounts = await (0, import_kit19.fetchEncodedAccounts)(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeWhirlpool(maybeAccount));
}
function getWhirlpoolSize() {
  return 653;
}

// src/generated/accounts/whirlpoolsConfig.ts
var import_kit20 = require("@solana/kit");
var WHIRLPOOLS_CONFIG_DISCRIMINATOR = new Uint8Array([
  157,
  20,
  49,
  224,
  217,
  87,
  193,
  254
]);
function getWhirlpoolsConfigDiscriminatorBytes() {
  return (0, import_kit20.fixEncoderSize)((0, import_kit20.getBytesEncoder)(), 8).encode(
    WHIRLPOOLS_CONFIG_DISCRIMINATOR
  );
}
function getWhirlpoolsConfigEncoder() {
  return (0, import_kit20.transformEncoder)(
    (0, import_kit20.getStructEncoder)([
      ["discriminator", (0, import_kit20.fixEncoderSize)((0, import_kit20.getBytesEncoder)(), 8)],
      ["feeAuthority", (0, import_kit20.getAddressEncoder)()],
      ["collectProtocolFeesAuthority", (0, import_kit20.getAddressEncoder)()],
      ["rewardEmissionsSuperAuthority", (0, import_kit20.getAddressEncoder)()],
      ["defaultProtocolFeeRate", (0, import_kit20.getU16Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: WHIRLPOOLS_CONFIG_DISCRIMINATOR })
  );
}
function getWhirlpoolsConfigDecoder() {
  return (0, import_kit20.getStructDecoder)([
    ["discriminator", (0, import_kit20.fixDecoderSize)((0, import_kit20.getBytesDecoder)(), 8)],
    ["feeAuthority", (0, import_kit20.getAddressDecoder)()],
    ["collectProtocolFeesAuthority", (0, import_kit20.getAddressDecoder)()],
    ["rewardEmissionsSuperAuthority", (0, import_kit20.getAddressDecoder)()],
    ["defaultProtocolFeeRate", (0, import_kit20.getU16Decoder)()]
  ]);
}
function getWhirlpoolsConfigCodec() {
  return (0, import_kit20.combineCodec)(
    getWhirlpoolsConfigEncoder(),
    getWhirlpoolsConfigDecoder()
  );
}
function decodeWhirlpoolsConfig(encodedAccount) {
  return (0, import_kit20.decodeAccount)(
    encodedAccount,
    getWhirlpoolsConfigDecoder()
  );
}
async function fetchWhirlpoolsConfig(rpc, address, config) {
  const maybeAccount = await fetchMaybeWhirlpoolsConfig(rpc, address, config);
  (0, import_kit20.assertAccountExists)(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeWhirlpoolsConfig(rpc, address, config) {
  const maybeAccount = await (0, import_kit20.fetchEncodedAccount)(rpc, address, config);
  return decodeWhirlpoolsConfig(maybeAccount);
}
async function fetchAllWhirlpoolsConfig(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeWhirlpoolsConfig(
    rpc,
    addresses,
    config
  );
  (0, import_kit20.assertAccountsExist)(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeWhirlpoolsConfig(rpc, addresses, config) {
  const maybeAccounts = await (0, import_kit20.fetchEncodedAccounts)(rpc, addresses, config);
  return maybeAccounts.map(
    (maybeAccount) => decodeWhirlpoolsConfig(maybeAccount)
  );
}
function getWhirlpoolsConfigSize() {
  return 106;
}

// src/generated/accounts/whirlpoolsConfigExtension.ts
var import_kit21 = require("@solana/kit");
var WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR = new Uint8Array([
  2,
  99,
  215,
  163,
  240,
  26,
  153,
  58
]);
function getWhirlpoolsConfigExtensionDiscriminatorBytes() {
  return (0, import_kit21.fixEncoderSize)((0, import_kit21.getBytesEncoder)(), 8).encode(
    WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR
  );
}
function getWhirlpoolsConfigExtensionEncoder() {
  return (0, import_kit21.transformEncoder)(
    (0, import_kit21.getStructEncoder)([
      ["discriminator", (0, import_kit21.fixEncoderSize)((0, import_kit21.getBytesEncoder)(), 8)],
      ["whirlpoolsConfig", (0, import_kit21.getAddressEncoder)()],
      ["configExtensionAuthority", (0, import_kit21.getAddressEncoder)()],
      ["tokenBadgeAuthority", (0, import_kit21.getAddressEncoder)()]
    ]),
    (value) => ({
      ...value,
      discriminator: WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR
    })
  );
}
function getWhirlpoolsConfigExtensionDecoder() {
  return (0, import_kit21.getStructDecoder)([
    ["discriminator", (0, import_kit21.fixDecoderSize)((0, import_kit21.getBytesDecoder)(), 8)],
    ["whirlpoolsConfig", (0, import_kit21.getAddressDecoder)()],
    ["configExtensionAuthority", (0, import_kit21.getAddressDecoder)()],
    ["tokenBadgeAuthority", (0, import_kit21.getAddressDecoder)()]
  ]);
}
function getWhirlpoolsConfigExtensionCodec() {
  return (0, import_kit21.combineCodec)(
    getWhirlpoolsConfigExtensionEncoder(),
    getWhirlpoolsConfigExtensionDecoder()
  );
}
function decodeWhirlpoolsConfigExtension(encodedAccount) {
  return (0, import_kit21.decodeAccount)(
    encodedAccount,
    getWhirlpoolsConfigExtensionDecoder()
  );
}
async function fetchWhirlpoolsConfigExtension(rpc, address, config) {
  const maybeAccount = await fetchMaybeWhirlpoolsConfigExtension(
    rpc,
    address,
    config
  );
  (0, import_kit21.assertAccountExists)(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeWhirlpoolsConfigExtension(rpc, address, config) {
  const maybeAccount = await (0, import_kit21.fetchEncodedAccount)(rpc, address, config);
  return decodeWhirlpoolsConfigExtension(maybeAccount);
}
async function fetchAllWhirlpoolsConfigExtension(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeWhirlpoolsConfigExtension(
    rpc,
    addresses,
    config
  );
  (0, import_kit21.assertAccountsExist)(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeWhirlpoolsConfigExtension(rpc, addresses, config) {
  const maybeAccounts = await (0, import_kit21.fetchEncodedAccounts)(rpc, addresses, config);
  return maybeAccounts.map(
    (maybeAccount) => decodeWhirlpoolsConfigExtension(maybeAccount)
  );
}
function getWhirlpoolsConfigExtensionSize() {
  return 104;
}

// src/generated/errors/whirlpool.ts
var import_kit23 = require("@solana/kit");

// src/generated/programs/whirlpool.ts
var import_kit22 = require("@solana/kit");
var WHIRLPOOL_PROGRAM_ADDRESS = "whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc";
var WhirlpoolAccount = /* @__PURE__ */ ((WhirlpoolAccount2) => {
  WhirlpoolAccount2[WhirlpoolAccount2["AdaptiveFeeTier"] = 0] = "AdaptiveFeeTier";
  WhirlpoolAccount2[WhirlpoolAccount2["WhirlpoolsConfig"] = 1] = "WhirlpoolsConfig";
  WhirlpoolAccount2[WhirlpoolAccount2["WhirlpoolsConfigExtension"] = 2] = "WhirlpoolsConfigExtension";
  WhirlpoolAccount2[WhirlpoolAccount2["FeeTier"] = 3] = "FeeTier";
  WhirlpoolAccount2[WhirlpoolAccount2["LockConfig"] = 4] = "LockConfig";
  WhirlpoolAccount2[WhirlpoolAccount2["Oracle"] = 5] = "Oracle";
  WhirlpoolAccount2[WhirlpoolAccount2["Position"] = 6] = "Position";
  WhirlpoolAccount2[WhirlpoolAccount2["PositionBundle"] = 7] = "PositionBundle";
  WhirlpoolAccount2[WhirlpoolAccount2["TickArray"] = 8] = "TickArray";
  WhirlpoolAccount2[WhirlpoolAccount2["TokenBadge"] = 9] = "TokenBadge";
  WhirlpoolAccount2[WhirlpoolAccount2["Whirlpool"] = 10] = "Whirlpool";
  return WhirlpoolAccount2;
})(WhirlpoolAccount || {});
function identifyWhirlpoolAccount(account) {
  const data = "data" in account ? account.data : account;
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([147, 16, 144, 116, 47, 146, 149, 46])
    ),
    0
  )) {
    return 0 /* AdaptiveFeeTier */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([157, 20, 49, 224, 217, 87, 193, 254])
    ),
    0
  )) {
    return 1 /* WhirlpoolsConfig */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([2, 99, 215, 163, 240, 26, 153, 58])
    ),
    0
  )) {
    return 2 /* WhirlpoolsConfigExtension */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([56, 75, 159, 76, 142, 68, 190, 105])
    ),
    0
  )) {
    return 3 /* FeeTier */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([106, 47, 238, 159, 124, 12, 160, 192])
    ),
    0
  )) {
    return 4 /* LockConfig */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([139, 194, 131, 179, 140, 179, 229, 244])
    ),
    0
  )) {
    return 5 /* Oracle */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([170, 188, 143, 228, 122, 64, 247, 208])
    ),
    0
  )) {
    return 6 /* Position */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([129, 169, 175, 65, 185, 95, 32, 100])
    ),
    0
  )) {
    return 7 /* PositionBundle */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([69, 97, 189, 190, 110, 7, 66, 187])
    ),
    0
  )) {
    return 8 /* TickArray */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([116, 219, 204, 229, 249, 116, 255, 150])
    ),
    0
  )) {
    return 9 /* TokenBadge */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([63, 149, 209, 12, 225, 128, 99, 9])
    ),
    0
  )) {
    return 10 /* Whirlpool */;
  }
  throw new Error(
    "The provided account could not be identified as a whirlpool account."
  );
}
var WhirlpoolInstruction = /* @__PURE__ */ ((WhirlpoolInstruction2) => {
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeConfig"] = 0] = "InitializeConfig";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializePool"] = 1] = "InitializePool";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeTickArray"] = 2] = "InitializeTickArray";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeFeeTier"] = 3] = "InitializeFeeTier";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeReward"] = 4] = "InitializeReward";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetRewardEmissions"] = 5] = "SetRewardEmissions";
  WhirlpoolInstruction2[WhirlpoolInstruction2["OpenPosition"] = 6] = "OpenPosition";
  WhirlpoolInstruction2[WhirlpoolInstruction2["OpenPositionWithMetadata"] = 7] = "OpenPositionWithMetadata";
  WhirlpoolInstruction2[WhirlpoolInstruction2["IncreaseLiquidity"] = 8] = "IncreaseLiquidity";
  WhirlpoolInstruction2[WhirlpoolInstruction2["DecreaseLiquidity"] = 9] = "DecreaseLiquidity";
  WhirlpoolInstruction2[WhirlpoolInstruction2["UpdateFeesAndRewards"] = 10] = "UpdateFeesAndRewards";
  WhirlpoolInstruction2[WhirlpoolInstruction2["CollectFees"] = 11] = "CollectFees";
  WhirlpoolInstruction2[WhirlpoolInstruction2["CollectReward"] = 12] = "CollectReward";
  WhirlpoolInstruction2[WhirlpoolInstruction2["CollectProtocolFees"] = 13] = "CollectProtocolFees";
  WhirlpoolInstruction2[WhirlpoolInstruction2["Swap"] = 14] = "Swap";
  WhirlpoolInstruction2[WhirlpoolInstruction2["ClosePosition"] = 15] = "ClosePosition";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetDefaultFeeRate"] = 16] = "SetDefaultFeeRate";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetDefaultProtocolFeeRate"] = 17] = "SetDefaultProtocolFeeRate";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetFeeRate"] = 18] = "SetFeeRate";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetProtocolFeeRate"] = 19] = "SetProtocolFeeRate";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetFeeAuthority"] = 20] = "SetFeeAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetCollectProtocolFeesAuthority"] = 21] = "SetCollectProtocolFeesAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetRewardAuthority"] = 22] = "SetRewardAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetRewardAuthorityBySuperAuthority"] = 23] = "SetRewardAuthorityBySuperAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetRewardEmissionsSuperAuthority"] = 24] = "SetRewardEmissionsSuperAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["TwoHopSwap"] = 25] = "TwoHopSwap";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializePositionBundle"] = 26] = "InitializePositionBundle";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializePositionBundleWithMetadata"] = 27] = "InitializePositionBundleWithMetadata";
  WhirlpoolInstruction2[WhirlpoolInstruction2["DeletePositionBundle"] = 28] = "DeletePositionBundle";
  WhirlpoolInstruction2[WhirlpoolInstruction2["OpenBundledPosition"] = 29] = "OpenBundledPosition";
  WhirlpoolInstruction2[WhirlpoolInstruction2["CloseBundledPosition"] = 30] = "CloseBundledPosition";
  WhirlpoolInstruction2[WhirlpoolInstruction2["OpenPositionWithTokenExtensions"] = 31] = "OpenPositionWithTokenExtensions";
  WhirlpoolInstruction2[WhirlpoolInstruction2["ClosePositionWithTokenExtensions"] = 32] = "ClosePositionWithTokenExtensions";
  WhirlpoolInstruction2[WhirlpoolInstruction2["LockPosition"] = 33] = "LockPosition";
  WhirlpoolInstruction2[WhirlpoolInstruction2["ResetPositionRange"] = 34] = "ResetPositionRange";
  WhirlpoolInstruction2[WhirlpoolInstruction2["TransferLockedPosition"] = 35] = "TransferLockedPosition";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeAdaptiveFeeTier"] = 36] = "InitializeAdaptiveFeeTier";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetDefaultBaseFeeRate"] = 37] = "SetDefaultBaseFeeRate";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetDelegatedFeeAuthority"] = 38] = "SetDelegatedFeeAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetInitializePoolAuthority"] = 39] = "SetInitializePoolAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetPresetAdaptiveFeeConstants"] = 40] = "SetPresetAdaptiveFeeConstants";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializePoolWithAdaptiveFee"] = 41] = "InitializePoolWithAdaptiveFee";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetFeeRateByDelegatedFeeAuthority"] = 42] = "SetFeeRateByDelegatedFeeAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["CollectFeesV2"] = 43] = "CollectFeesV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["CollectProtocolFeesV2"] = 44] = "CollectProtocolFeesV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["CollectRewardV2"] = 45] = "CollectRewardV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["DecreaseLiquidityV2"] = 46] = "DecreaseLiquidityV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["IncreaseLiquidityV2"] = 47] = "IncreaseLiquidityV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializePoolV2"] = 48] = "InitializePoolV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeRewardV2"] = 49] = "InitializeRewardV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetRewardEmissionsV2"] = 50] = "SetRewardEmissionsV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SwapV2"] = 51] = "SwapV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["TwoHopSwapV2"] = 52] = "TwoHopSwapV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeConfigExtension"] = 53] = "InitializeConfigExtension";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetConfigExtensionAuthority"] = 54] = "SetConfigExtensionAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetTokenBadgeAuthority"] = 55] = "SetTokenBadgeAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeTokenBadge"] = 56] = "InitializeTokenBadge";
  WhirlpoolInstruction2[WhirlpoolInstruction2["DeleteTokenBadge"] = 57] = "DeleteTokenBadge";
  return WhirlpoolInstruction2;
})(WhirlpoolInstruction || {});
function identifyWhirlpoolInstruction(instruction) {
  const data = "data" in instruction ? instruction.data : instruction;
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([208, 127, 21, 1, 194, 190, 196, 70])
    ),
    0
  )) {
    return 0 /* InitializeConfig */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([95, 180, 10, 172, 84, 174, 232, 40])
    ),
    0
  )) {
    return 1 /* InitializePool */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([11, 188, 193, 214, 141, 91, 149, 184])
    ),
    0
  )) {
    return 2 /* InitializeTickArray */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([183, 74, 156, 160, 112, 2, 42, 30])
    ),
    0
  )) {
    return 3 /* InitializeFeeTier */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([95, 135, 192, 196, 242, 129, 230, 68])
    ),
    0
  )) {
    return 4 /* InitializeReward */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([13, 197, 86, 168, 109, 176, 27, 244])
    ),
    0
  )) {
    return 5 /* SetRewardEmissions */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([135, 128, 47, 77, 15, 152, 240, 49])
    ),
    0
  )) {
    return 6 /* OpenPosition */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([242, 29, 134, 48, 58, 110, 14, 60])
    ),
    0
  )) {
    return 7 /* OpenPositionWithMetadata */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([46, 156, 243, 118, 13, 205, 251, 178])
    ),
    0
  )) {
    return 8 /* IncreaseLiquidity */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([160, 38, 208, 111, 104, 91, 44, 1])
    ),
    0
  )) {
    return 9 /* DecreaseLiquidity */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([154, 230, 250, 13, 236, 209, 75, 223])
    ),
    0
  )) {
    return 10 /* UpdateFeesAndRewards */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([164, 152, 207, 99, 30, 186, 19, 182])
    ),
    0
  )) {
    return 11 /* CollectFees */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([70, 5, 132, 87, 86, 235, 177, 34])
    ),
    0
  )) {
    return 12 /* CollectReward */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([22, 67, 23, 98, 150, 178, 70, 220])
    ),
    0
  )) {
    return 13 /* CollectProtocolFees */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([248, 198, 158, 145, 225, 117, 135, 200])
    ),
    0
  )) {
    return 14 /* Swap */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([123, 134, 81, 0, 49, 68, 98, 98])
    ),
    0
  )) {
    return 15 /* ClosePosition */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([118, 215, 214, 157, 182, 229, 208, 228])
    ),
    0
  )) {
    return 16 /* SetDefaultFeeRate */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([107, 205, 249, 226, 151, 35, 86, 0])
    ),
    0
  )) {
    return 17 /* SetDefaultProtocolFeeRate */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([53, 243, 137, 65, 8, 140, 158, 6])
    ),
    0
  )) {
    return 18 /* SetFeeRate */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([95, 7, 4, 50, 154, 79, 156, 131])
    ),
    0
  )) {
    return 19 /* SetProtocolFeeRate */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([31, 1, 50, 87, 237, 101, 97, 132])
    ),
    0
  )) {
    return 20 /* SetFeeAuthority */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([34, 150, 93, 244, 139, 225, 233, 67])
    ),
    0
  )) {
    return 21 /* SetCollectProtocolFeesAuthority */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([34, 39, 183, 252, 83, 28, 85, 127])
    ),
    0
  )) {
    return 22 /* SetRewardAuthority */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([240, 154, 201, 198, 148, 93, 56, 25])
    ),
    0
  )) {
    return 23 /* SetRewardAuthorityBySuperAuthority */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([207, 5, 200, 209, 122, 56, 82, 183])
    ),
    0
  )) {
    return 24 /* SetRewardEmissionsSuperAuthority */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([195, 96, 237, 108, 68, 162, 219, 230])
    ),
    0
  )) {
    return 25 /* TwoHopSwap */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([117, 45, 241, 149, 24, 18, 194, 65])
    ),
    0
  )) {
    return 26 /* InitializePositionBundle */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([93, 124, 16, 179, 249, 131, 115, 245])
    ),
    0
  )) {
    return 27 /* InitializePositionBundleWithMetadata */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([100, 25, 99, 2, 217, 239, 124, 173])
    ),
    0
  )) {
    return 28 /* DeletePositionBundle */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([169, 113, 126, 171, 213, 172, 212, 49])
    ),
    0
  )) {
    return 29 /* OpenBundledPosition */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([41, 36, 216, 245, 27, 85, 103, 67])
    ),
    0
  )) {
    return 30 /* CloseBundledPosition */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([212, 47, 95, 92, 114, 102, 131, 250])
    ),
    0
  )) {
    return 31 /* OpenPositionWithTokenExtensions */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([1, 182, 135, 59, 155, 25, 99, 223])
    ),
    0
  )) {
    return 32 /* ClosePositionWithTokenExtensions */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([227, 62, 2, 252, 247, 10, 171, 185])
    ),
    0
  )) {
    return 33 /* LockPosition */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([164, 123, 180, 141, 194, 100, 160, 175])
    ),
    0
  )) {
    return 34 /* ResetPositionRange */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([179, 121, 229, 46, 67, 138, 194, 138])
    ),
    0
  )) {
    return 35 /* TransferLockedPosition */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([77, 99, 208, 200, 141, 123, 117, 48])
    ),
    0
  )) {
    return 36 /* InitializeAdaptiveFeeTier */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([229, 66, 84, 251, 164, 134, 183, 7])
    ),
    0
  )) {
    return 37 /* SetDefaultBaseFeeRate */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([193, 234, 231, 147, 138, 57, 3, 122])
    ),
    0
  )) {
    return 38 /* SetDelegatedFeeAuthority */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([125, 43, 127, 235, 149, 26, 106, 236])
    ),
    0
  )) {
    return 39 /* SetInitializePoolAuthority */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([132, 185, 66, 148, 83, 88, 134, 198])
    ),
    0
  )) {
    return 40 /* SetPresetAdaptiveFeeConstants */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([143, 94, 96, 76, 172, 124, 119, 199])
    ),
    0
  )) {
    return 41 /* InitializePoolWithAdaptiveFee */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([121, 121, 54, 114, 131, 230, 162, 104])
    ),
    0
  )) {
    return 42 /* SetFeeRateByDelegatedFeeAuthority */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([207, 117, 95, 191, 229, 180, 226, 15])
    ),
    0
  )) {
    return 43 /* CollectFeesV2 */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([103, 128, 222, 134, 114, 200, 22, 200])
    ),
    0
  )) {
    return 44 /* CollectProtocolFeesV2 */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([177, 107, 37, 180, 160, 19, 49, 209])
    ),
    0
  )) {
    return 45 /* CollectRewardV2 */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([58, 127, 188, 62, 79, 82, 196, 96])
    ),
    0
  )) {
    return 46 /* DecreaseLiquidityV2 */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([133, 29, 89, 223, 69, 238, 176, 10])
    ),
    0
  )) {
    return 47 /* IncreaseLiquidityV2 */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([207, 45, 87, 242, 27, 63, 204, 67])
    ),
    0
  )) {
    return 48 /* InitializePoolV2 */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([91, 1, 77, 50, 235, 229, 133, 49])
    ),
    0
  )) {
    return 49 /* InitializeRewardV2 */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([114, 228, 72, 32, 193, 48, 160, 102])
    ),
    0
  )) {
    return 50 /* SetRewardEmissionsV2 */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([43, 4, 237, 11, 26, 201, 30, 98])
    ),
    0
  )) {
    return 51 /* SwapV2 */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([186, 143, 209, 29, 254, 2, 194, 117])
    ),
    0
  )) {
    return 52 /* TwoHopSwapV2 */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([55, 9, 53, 9, 114, 57, 209, 52])
    ),
    0
  )) {
    return 53 /* InitializeConfigExtension */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([44, 94, 241, 116, 24, 188, 60, 143])
    ),
    0
  )) {
    return 54 /* SetConfigExtensionAuthority */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([207, 202, 4, 32, 205, 79, 13, 178])
    ),
    0
  )) {
    return 55 /* SetTokenBadgeAuthority */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([253, 77, 205, 95, 27, 224, 89, 223])
    ),
    0
  )) {
    return 56 /* InitializeTokenBadge */;
  }
  if ((0, import_kit22.containsBytes)(
    data,
    (0, import_kit22.fixEncoderSize)((0, import_kit22.getBytesEncoder)(), 8).encode(
      new Uint8Array([53, 146, 68, 8, 18, 117, 17, 185])
    ),
    0
  )) {
    return 57 /* DeleteTokenBadge */;
  }
  throw new Error(
    "The provided instruction could not be identified as a whirlpool instruction."
  );
}

// src/generated/errors/whirlpool.ts
var WHIRLPOOL_ERROR__INVALID_ENUM = 6e3;
var WHIRLPOOL_ERROR__INVALID_START_TICK = 6001;
var WHIRLPOOL_ERROR__TICK_ARRAY_EXIST_IN_POOL = 6002;
var WHIRLPOOL_ERROR__TICK_ARRAY_INDEX_OUTOF_BOUNDS = 6003;
var WHIRLPOOL_ERROR__INVALID_TICK_SPACING = 6004;
var WHIRLPOOL_ERROR__CLOSE_POSITION_NOT_EMPTY = 6005;
var WHIRLPOOL_ERROR__DIVIDE_BY_ZERO = 6006;
var WHIRLPOOL_ERROR__NUMBER_CAST_ERROR = 6007;
var WHIRLPOOL_ERROR__NUMBER_DOWN_CAST_ERROR = 6008;
var WHIRLPOOL_ERROR__TICK_NOT_FOUND = 6009;
var WHIRLPOOL_ERROR__INVALID_TICK_INDEX = 6010;
var WHIRLPOOL_ERROR__SQRT_PRICE_OUT_OF_BOUNDS = 6011;
var WHIRLPOOL_ERROR__LIQUIDITY_ZERO = 6012;
var WHIRLPOOL_ERROR__LIQUIDITY_TOO_HIGH = 6013;
var WHIRLPOOL_ERROR__LIQUIDITY_OVERFLOW = 6014;
var WHIRLPOOL_ERROR__LIQUIDITY_UNDERFLOW = 6015;
var WHIRLPOOL_ERROR__LIQUIDITY_NET_ERROR = 6016;
var WHIRLPOOL_ERROR__TOKEN_MAX_EXCEEDED = 6017;
var WHIRLPOOL_ERROR__TOKEN_MIN_SUBCEEDED = 6018;
var WHIRLPOOL_ERROR__MISSING_OR_INVALID_DELEGATE = 6019;
var WHIRLPOOL_ERROR__INVALID_POSITION_TOKEN_AMOUNT = 6020;
var WHIRLPOOL_ERROR__INVALID_TIMESTAMP_CONVERSION = 6021;
var WHIRLPOOL_ERROR__INVALID_TIMESTAMP = 6022;
var WHIRLPOOL_ERROR__INVALID_TICK_ARRAY_SEQUENCE = 6023;
var WHIRLPOOL_ERROR__INVALID_TOKEN_MINT_ORDER = 6024;
var WHIRLPOOL_ERROR__REWARD_NOT_INITIALIZED = 6025;
var WHIRLPOOL_ERROR__INVALID_REWARD_INDEX = 6026;
var WHIRLPOOL_ERROR__REWARD_VAULT_AMOUNT_INSUFFICIENT = 6027;
var WHIRLPOOL_ERROR__FEE_RATE_MAX_EXCEEDED = 6028;
var WHIRLPOOL_ERROR__PROTOCOL_FEE_RATE_MAX_EXCEEDED = 6029;
var WHIRLPOOL_ERROR__MULTIPLICATION_SHIFT_RIGHT_OVERFLOW = 6030;
var WHIRLPOOL_ERROR__MUL_DIV_OVERFLOW = 6031;
var WHIRLPOOL_ERROR__MUL_DIV_INVALID_INPUT = 6032;
var WHIRLPOOL_ERROR__MULTIPLICATION_OVERFLOW = 6033;
var WHIRLPOOL_ERROR__INVALID_SQRT_PRICE_LIMIT_DIRECTION = 6034;
var WHIRLPOOL_ERROR__ZERO_TRADABLE_AMOUNT = 6035;
var WHIRLPOOL_ERROR__AMOUNT_OUT_BELOW_MINIMUM = 6036;
var WHIRLPOOL_ERROR__AMOUNT_IN_ABOVE_MAXIMUM = 6037;
var WHIRLPOOL_ERROR__TICK_ARRAY_SEQUENCE_INVALID_INDEX = 6038;
var WHIRLPOOL_ERROR__AMOUNT_CALC_OVERFLOW = 6039;
var WHIRLPOOL_ERROR__AMOUNT_REMAINING_OVERFLOW = 6040;
var WHIRLPOOL_ERROR__INVALID_INTERMEDIARY_MINT = 6041;
var WHIRLPOOL_ERROR__DUPLICATE_TWO_HOP_POOL = 6042;
var WHIRLPOOL_ERROR__INVALID_BUNDLE_INDEX = 6043;
var WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_OPENED = 6044;
var WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_CLOSED = 6045;
var WHIRLPOOL_ERROR__POSITION_BUNDLE_NOT_DELETABLE = 6046;
var WHIRLPOOL_ERROR__UNSUPPORTED_TOKEN_MINT = 6047;
var WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INVALID_SLICE = 6048;
var WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INSUFFICIENT = 6049;
var WHIRLPOOL_ERROR__NO_EXTRA_ACCOUNTS_FOR_TRANSFER_HOOK = 6050;
var WHIRLPOOL_ERROR__INTERMEDIATE_TOKEN_AMOUNT_MISMATCH = 6051;
var WHIRLPOOL_ERROR__TRANSFER_FEE_CALCULATION_ERROR = 6052;
var WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_DUPLICATED_ACCOUNTS_TYPE = 6053;
var WHIRLPOOL_ERROR__FULL_RANGE_ONLY_POOL = 6054;
var WHIRLPOOL_ERROR__TOO_MANY_SUPPLEMENTAL_TICK_ARRAYS = 6055;
var WHIRLPOOL_ERROR__DIFFERENT_WHIRLPOOL_TICK_ARRAY_ACCOUNT = 6056;
var WHIRLPOOL_ERROR__PARTIAL_FILL_ERROR = 6057;
var WHIRLPOOL_ERROR__POSITION_NOT_LOCKABLE = 6058;
var WHIRLPOOL_ERROR__OPERATION_NOT_ALLOWED_ON_LOCKED_POSITION = 6059;
var WHIRLPOOL_ERROR__SAME_TICK_RANGE_NOT_ALLOWED = 6060;
var WHIRLPOOL_ERROR__INVALID_ADAPTIVE_FEE_CONSTANTS = 6061;
var WHIRLPOOL_ERROR__INVALID_FEE_TIER_INDEX = 6062;
var WHIRLPOOL_ERROR__INVALID_TRADE_ENABLE_TIMESTAMP = 6063;
var WHIRLPOOL_ERROR__TRADE_IS_NOT_ENABLED = 6064;
var whirlpoolErrorMessages;
if (process.env.NODE_ENV !== "production") {
  whirlpoolErrorMessages = {
    [WHIRLPOOL_ERROR__AMOUNT_CALC_OVERFLOW]: `Amount calculated overflows`,
    [WHIRLPOOL_ERROR__AMOUNT_IN_ABOVE_MAXIMUM]: `Amount in above maximum threshold`,
    [WHIRLPOOL_ERROR__AMOUNT_OUT_BELOW_MINIMUM]: `Amount out below minimum threshold`,
    [WHIRLPOOL_ERROR__AMOUNT_REMAINING_OVERFLOW]: `Amount remaining overflows`,
    [WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_CLOSED]: `Position has already been closed`,
    [WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_OPENED]: `Position has already been opened`,
    [WHIRLPOOL_ERROR__CLOSE_POSITION_NOT_EMPTY]: `Position is not empty It cannot be closed`,
    [WHIRLPOOL_ERROR__DIFFERENT_WHIRLPOOL_TICK_ARRAY_ACCOUNT]: `TickArray account for different whirlpool provided`,
    [WHIRLPOOL_ERROR__DIVIDE_BY_ZERO]: `Unable to divide by zero`,
    [WHIRLPOOL_ERROR__DUPLICATE_TWO_HOP_POOL]: `Duplicate two hop pool`,
    [WHIRLPOOL_ERROR__FEE_RATE_MAX_EXCEEDED]: `Exceeded max fee rate`,
    [WHIRLPOOL_ERROR__FULL_RANGE_ONLY_POOL]: `This whirlpool only supports full-range positions`,
    [WHIRLPOOL_ERROR__INTERMEDIATE_TOKEN_AMOUNT_MISMATCH]: `Output and input amount mismatch`,
    [WHIRLPOOL_ERROR__INVALID_ADAPTIVE_FEE_CONSTANTS]: `Invalid adaptive fee constants`,
    [WHIRLPOOL_ERROR__INVALID_BUNDLE_INDEX]: `Bundle index is out of bounds`,
    [WHIRLPOOL_ERROR__INVALID_ENUM]: `Enum value could not be converted`,
    [WHIRLPOOL_ERROR__INVALID_FEE_TIER_INDEX]: `Invalid fee tier index`,
    [WHIRLPOOL_ERROR__INVALID_INTERMEDIARY_MINT]: `Invalid intermediary mint`,
    [WHIRLPOOL_ERROR__INVALID_POSITION_TOKEN_AMOUNT]: `Position token amount must be 1`,
    [WHIRLPOOL_ERROR__INVALID_REWARD_INDEX]: `Invalid reward index`,
    [WHIRLPOOL_ERROR__INVALID_SQRT_PRICE_LIMIT_DIRECTION]: `Provided SqrtPriceLimit not in the same direction as the swap.`,
    [WHIRLPOOL_ERROR__INVALID_START_TICK]: `Invalid start tick index provided.`,
    [WHIRLPOOL_ERROR__INVALID_TICK_ARRAY_SEQUENCE]: `Invalid tick array sequence provided for instruction.`,
    [WHIRLPOOL_ERROR__INVALID_TICK_INDEX]: `Provided tick index is either out of bounds or uninitializable`,
    [WHIRLPOOL_ERROR__INVALID_TICK_SPACING]: `Tick-spacing is not supported`,
    [WHIRLPOOL_ERROR__INVALID_TIMESTAMP]: `Timestamp should be greater than the last updated timestamp`,
    [WHIRLPOOL_ERROR__INVALID_TIMESTAMP_CONVERSION]: `Timestamp should be convertible from i64 to u64`,
    [WHIRLPOOL_ERROR__INVALID_TOKEN_MINT_ORDER]: `Token Mint in wrong order`,
    [WHIRLPOOL_ERROR__INVALID_TRADE_ENABLE_TIMESTAMP]: `Invalid trade enable timestamp`,
    [WHIRLPOOL_ERROR__LIQUIDITY_NET_ERROR]: `Tick liquidity net underflowed or overflowed`,
    [WHIRLPOOL_ERROR__LIQUIDITY_OVERFLOW]: `Liquidity overflow`,
    [WHIRLPOOL_ERROR__LIQUIDITY_TOO_HIGH]: `Liquidity amount must be less than i64::MAX`,
    [WHIRLPOOL_ERROR__LIQUIDITY_UNDERFLOW]: `Liquidity underflow`,
    [WHIRLPOOL_ERROR__LIQUIDITY_ZERO]: `Liquidity amount must be greater than zero`,
    [WHIRLPOOL_ERROR__MISSING_OR_INVALID_DELEGATE]: `Position token account has a missing or invalid delegate`,
    [WHIRLPOOL_ERROR__MUL_DIV_INVALID_INPUT]: `Invalid div_u256 input`,
    [WHIRLPOOL_ERROR__MUL_DIV_OVERFLOW]: `Muldiv overflow`,
    [WHIRLPOOL_ERROR__MULTIPLICATION_OVERFLOW]: `Multiplication overflow`,
    [WHIRLPOOL_ERROR__MULTIPLICATION_SHIFT_RIGHT_OVERFLOW]: `Multiplication with shift right overflow`,
    [WHIRLPOOL_ERROR__NO_EXTRA_ACCOUNTS_FOR_TRANSFER_HOOK]: `Unable to call transfer hook without extra accounts`,
    [WHIRLPOOL_ERROR__NUMBER_CAST_ERROR]: `Unable to cast number into BigInt`,
    [WHIRLPOOL_ERROR__NUMBER_DOWN_CAST_ERROR]: `Unable to down cast number`,
    [WHIRLPOOL_ERROR__OPERATION_NOT_ALLOWED_ON_LOCKED_POSITION]: `Operation not allowed on locked position`,
    [WHIRLPOOL_ERROR__PARTIAL_FILL_ERROR]: `Trade resulted in partial fill`,
    [WHIRLPOOL_ERROR__POSITION_BUNDLE_NOT_DELETABLE]: `Unable to delete PositionBundle with open positions`,
    [WHIRLPOOL_ERROR__POSITION_NOT_LOCKABLE]: `Position is not lockable`,
    [WHIRLPOOL_ERROR__PROTOCOL_FEE_RATE_MAX_EXCEEDED]: `Exceeded max protocol fee rate`,
    [WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_DUPLICATED_ACCOUNTS_TYPE]: `Same accounts type is provided more than once`,
    [WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INSUFFICIENT]: `Insufficient remaining accounts`,
    [WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INVALID_SLICE]: `Invalid remaining accounts`,
    [WHIRLPOOL_ERROR__REWARD_NOT_INITIALIZED]: `Reward not initialized`,
    [WHIRLPOOL_ERROR__REWARD_VAULT_AMOUNT_INSUFFICIENT]: `Reward vault requires amount to support emissions for at least one day`,
    [WHIRLPOOL_ERROR__SAME_TICK_RANGE_NOT_ALLOWED]: `Cannot reset position range with same tick range`,
    [WHIRLPOOL_ERROR__SQRT_PRICE_OUT_OF_BOUNDS]: `Provided sqrt price out of bounds`,
    [WHIRLPOOL_ERROR__TICK_ARRAY_EXIST_IN_POOL]: `Tick-array already exists in this whirlpool`,
    [WHIRLPOOL_ERROR__TICK_ARRAY_INDEX_OUTOF_BOUNDS]: `Attempt to search for a tick-array failed`,
    [WHIRLPOOL_ERROR__TICK_ARRAY_SEQUENCE_INVALID_INDEX]: `Invalid index for tick array sequence`,
    [WHIRLPOOL_ERROR__TICK_NOT_FOUND]: `Tick not found within tick array`,
    [WHIRLPOOL_ERROR__TOKEN_MAX_EXCEEDED]: `Exceeded token max`,
    [WHIRLPOOL_ERROR__TOKEN_MIN_SUBCEEDED]: `Did not meet token min`,
    [WHIRLPOOL_ERROR__TOO_MANY_SUPPLEMENTAL_TICK_ARRAYS]: `Too many supplemental tick arrays provided`,
    [WHIRLPOOL_ERROR__TRADE_IS_NOT_ENABLED]: `Trade is not enabled yet`,
    [WHIRLPOOL_ERROR__TRANSFER_FEE_CALCULATION_ERROR]: `Transfer fee calculation failed`,
    [WHIRLPOOL_ERROR__UNSUPPORTED_TOKEN_MINT]: `Token mint has unsupported attributes`,
    [WHIRLPOOL_ERROR__ZERO_TRADABLE_AMOUNT]: `There are no tradable amount to swap.`
  };
}
function getWhirlpoolErrorMessage(code) {
  if (process.env.NODE_ENV !== "production") {
    return whirlpoolErrorMessages[code];
  }
  return "Error message not available in production bundles.";
}
function isWhirlpoolError(error, transactionMessage, code) {
  return (0, import_kit23.isProgramError)(
    error,
    transactionMessage,
    WHIRLPOOL_PROGRAM_ADDRESS,
    code
  );
}

// src/generated/instructions/closeBundledPosition.ts
var import_kit25 = require("@solana/kit");

// src/generated/shared/index.ts
var import_kit24 = require("@solana/kit");
function expectAddress(value) {
  if (!value) {
    throw new Error("Expected a Address.");
  }
  if (typeof value === "object" && "address" in value) {
    return value.address;
  }
  if (Array.isArray(value)) {
    return value[0];
  }
  return value;
}
function getAccountMetaFactory(programAddress, optionalAccountStrategy) {
  return (account) => {
    if (!account.value) {
      if (optionalAccountStrategy === "omitted") return;
      return Object.freeze({
        address: programAddress,
        role: import_kit24.AccountRole.READONLY
      });
    }
    const writableRole = account.isWritable ? import_kit24.AccountRole.WRITABLE : import_kit24.AccountRole.READONLY;
    return Object.freeze({
      address: expectAddress(account.value),
      role: isTransactionSigner(account.value) ? (0, import_kit24.upgradeRoleToSigner)(writableRole) : writableRole,
      ...isTransactionSigner(account.value) ? { signer: account.value } : {}
    });
  };
}
function isTransactionSigner(value) {
  return !!value && typeof value === "object" && "address" in value && (0, import_kit24.isTransactionSigner)(value);
}

// src/generated/instructions/closeBundledPosition.ts
var CLOSE_BUNDLED_POSITION_DISCRIMINATOR = new Uint8Array([
  41,
  36,
  216,
  245,
  27,
  85,
  103,
  67
]);
function getCloseBundledPositionDiscriminatorBytes() {
  return (0, import_kit25.fixEncoderSize)((0, import_kit25.getBytesEncoder)(), 8).encode(
    CLOSE_BUNDLED_POSITION_DISCRIMINATOR
  );
}
function getCloseBundledPositionInstructionDataEncoder() {
  return (0, import_kit25.transformEncoder)(
    (0, import_kit25.getStructEncoder)([
      ["discriminator", (0, import_kit25.fixEncoderSize)((0, import_kit25.getBytesEncoder)(), 8)],
      ["bundleIndex", (0, import_kit25.getU16Encoder)()]
    ]),
    (value) => ({
      ...value,
      discriminator: CLOSE_BUNDLED_POSITION_DISCRIMINATOR
    })
  );
}
function getCloseBundledPositionInstructionDataDecoder() {
  return (0, import_kit25.getStructDecoder)([
    ["discriminator", (0, import_kit25.fixDecoderSize)((0, import_kit25.getBytesDecoder)(), 8)],
    ["bundleIndex", (0, import_kit25.getU16Decoder)()]
  ]);
}
function getCloseBundledPositionInstructionDataCodec() {
  return (0, import_kit25.combineCodec)(
    getCloseBundledPositionInstructionDataEncoder(),
    getCloseBundledPositionInstructionDataDecoder()
  );
}
function getCloseBundledPositionInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    bundledPosition: { value: input.bundledPosition ?? null, isWritable: true },
    positionBundle: { value: input.positionBundle ?? null, isWritable: true },
    positionBundleTokenAccount: {
      value: input.positionBundleTokenAccount ?? null,
      isWritable: false
    },
    positionBundleAuthority: {
      value: input.positionBundleAuthority ?? null,
      isWritable: false
    },
    receiver: { value: input.receiver ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.bundledPosition),
      getAccountMeta(accounts.positionBundle),
      getAccountMeta(accounts.positionBundleTokenAccount),
      getAccountMeta(accounts.positionBundleAuthority),
      getAccountMeta(accounts.receiver)
    ],
    programAddress,
    data: getCloseBundledPositionInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseCloseBundledPositionInstruction(instruction) {
  if (instruction.accounts.length < 5) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      bundledPosition: getNextAccount(),
      positionBundle: getNextAccount(),
      positionBundleTokenAccount: getNextAccount(),
      positionBundleAuthority: getNextAccount(),
      receiver: getNextAccount()
    },
    data: getCloseBundledPositionInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/closePosition.ts
var import_kit26 = require("@solana/kit");
var CLOSE_POSITION_DISCRIMINATOR = new Uint8Array([
  123,
  134,
  81,
  0,
  49,
  68,
  98,
  98
]);
function getClosePositionDiscriminatorBytes() {
  return (0, import_kit26.fixEncoderSize)((0, import_kit26.getBytesEncoder)(), 8).encode(
    CLOSE_POSITION_DISCRIMINATOR
  );
}
function getClosePositionInstructionDataEncoder() {
  return (0, import_kit26.transformEncoder)(
    (0, import_kit26.getStructEncoder)([["discriminator", (0, import_kit26.fixEncoderSize)((0, import_kit26.getBytesEncoder)(), 8)]]),
    (value) => ({ ...value, discriminator: CLOSE_POSITION_DISCRIMINATOR })
  );
}
function getClosePositionInstructionDataDecoder() {
  return (0, import_kit26.getStructDecoder)([
    ["discriminator", (0, import_kit26.fixDecoderSize)((0, import_kit26.getBytesDecoder)(), 8)]
  ]);
}
function getClosePositionInstructionDataCodec() {
  return (0, import_kit26.combineCodec)(
    getClosePositionInstructionDataEncoder(),
    getClosePositionInstructionDataDecoder()
  );
}
function getClosePositionInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    receiver: { value: input.receiver ?? null, isWritable: true },
    position: { value: input.position ?? null, isWritable: true },
    positionMint: { value: input.positionMint ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: true
    },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.receiver),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionMint),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.tokenProgram)
    ],
    programAddress,
    data: getClosePositionInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseClosePositionInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      positionAuthority: getNextAccount(),
      receiver: getNextAccount(),
      position: getNextAccount(),
      positionMint: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getClosePositionInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/closePositionWithTokenExtensions.ts
var import_kit27 = require("@solana/kit");
var CLOSE_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR = new Uint8Array([1, 182, 135, 59, 155, 25, 99, 223]);
function getClosePositionWithTokenExtensionsDiscriminatorBytes() {
  return (0, import_kit27.fixEncoderSize)((0, import_kit27.getBytesEncoder)(), 8).encode(
    CLOSE_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR
  );
}
function getClosePositionWithTokenExtensionsInstructionDataEncoder() {
  return (0, import_kit27.transformEncoder)(
    (0, import_kit27.getStructEncoder)([["discriminator", (0, import_kit27.fixEncoderSize)((0, import_kit27.getBytesEncoder)(), 8)]]),
    (value) => ({
      ...value,
      discriminator: CLOSE_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR
    })
  );
}
function getClosePositionWithTokenExtensionsInstructionDataDecoder() {
  return (0, import_kit27.getStructDecoder)([
    ["discriminator", (0, import_kit27.fixDecoderSize)((0, import_kit27.getBytesDecoder)(), 8)]
  ]);
}
function getClosePositionWithTokenExtensionsInstructionDataCodec() {
  return (0, import_kit27.combineCodec)(
    getClosePositionWithTokenExtensionsInstructionDataEncoder(),
    getClosePositionWithTokenExtensionsInstructionDataDecoder()
  );
}
function getClosePositionWithTokenExtensionsInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    receiver: { value: input.receiver ?? null, isWritable: true },
    position: { value: input.position ?? null, isWritable: true },
    positionMint: { value: input.positionMint ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: true
    },
    token2022Program: {
      value: input.token2022Program ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.receiver),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionMint),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.token2022Program)
    ],
    programAddress,
    data: getClosePositionWithTokenExtensionsInstructionDataEncoder().encode(
      {}
    )
  };
  return instruction;
}
function parseClosePositionWithTokenExtensionsInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      positionAuthority: getNextAccount(),
      receiver: getNextAccount(),
      position: getNextAccount(),
      positionMint: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      token2022Program: getNextAccount()
    },
    data: getClosePositionWithTokenExtensionsInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/collectFees.ts
var import_kit28 = require("@solana/kit");
var COLLECT_FEES_DISCRIMINATOR = new Uint8Array([
  164,
  152,
  207,
  99,
  30,
  186,
  19,
  182
]);
function getCollectFeesDiscriminatorBytes() {
  return (0, import_kit28.fixEncoderSize)((0, import_kit28.getBytesEncoder)(), 8).encode(
    COLLECT_FEES_DISCRIMINATOR
  );
}
function getCollectFeesInstructionDataEncoder() {
  return (0, import_kit28.transformEncoder)(
    (0, import_kit28.getStructEncoder)([["discriminator", (0, import_kit28.fixEncoderSize)((0, import_kit28.getBytesEncoder)(), 8)]]),
    (value) => ({ ...value, discriminator: COLLECT_FEES_DISCRIMINATOR })
  );
}
function getCollectFeesInstructionDataDecoder() {
  return (0, import_kit28.getStructDecoder)([
    ["discriminator", (0, import_kit28.fixDecoderSize)((0, import_kit28.getBytesDecoder)(), 8)]
  ]);
}
function getCollectFeesInstructionDataCodec() {
  return (0, import_kit28.combineCodec)(
    getCollectFeesInstructionDataEncoder(),
    getCollectFeesInstructionDataDecoder()
  );
}
function getCollectFeesInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tokenProgram)
    ],
    programAddress,
    data: getCollectFeesInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseCollectFeesInstruction(instruction) {
  if (instruction.accounts.length < 9) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getCollectFeesInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/collectFeesV2.ts
var import_kit29 = require("@solana/kit");
var COLLECT_FEES_V2_DISCRIMINATOR = new Uint8Array([
  207,
  117,
  95,
  191,
  229,
  180,
  226,
  15
]);
function getCollectFeesV2DiscriminatorBytes() {
  return (0, import_kit29.fixEncoderSize)((0, import_kit29.getBytesEncoder)(), 8).encode(
    COLLECT_FEES_V2_DISCRIMINATOR
  );
}
function getCollectFeesV2InstructionDataEncoder() {
  return (0, import_kit29.transformEncoder)(
    (0, import_kit29.getStructEncoder)([
      ["discriminator", (0, import_kit29.fixEncoderSize)((0, import_kit29.getBytesEncoder)(), 8)],
      [
        "remainingAccountsInfo",
        (0, import_kit29.getOptionEncoder)(getRemainingAccountsInfoEncoder())
      ]
    ]),
    (value) => ({ ...value, discriminator: COLLECT_FEES_V2_DISCRIMINATOR })
  );
}
function getCollectFeesV2InstructionDataDecoder() {
  return (0, import_kit29.getStructDecoder)([
    ["discriminator", (0, import_kit29.fixDecoderSize)((0, import_kit29.getBytesDecoder)(), 8)],
    [
      "remainingAccountsInfo",
      (0, import_kit29.getOptionDecoder)(getRemainingAccountsInfoDecoder())
    ]
  ]);
}
function getCollectFeesV2InstructionDataCodec() {
  return (0, import_kit29.combineCodec)(
    getCollectFeesV2InstructionDataEncoder(),
    getCollectFeesV2InstructionDataDecoder()
  );
}
function getCollectFeesV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },
    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tokenProgramA),
      getAccountMeta(accounts.tokenProgramB),
      getAccountMeta(accounts.memoProgram)
    ],
    programAddress,
    data: getCollectFeesV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseCollectFeesV2Instruction(instruction) {
  if (instruction.accounts.length < 13) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tokenProgramA: getNextAccount(),
      tokenProgramB: getNextAccount(),
      memoProgram: getNextAccount()
    },
    data: getCollectFeesV2InstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/collectProtocolFees.ts
var import_kit30 = require("@solana/kit");
var COLLECT_PROTOCOL_FEES_DISCRIMINATOR = new Uint8Array([
  22,
  67,
  23,
  98,
  150,
  178,
  70,
  220
]);
function getCollectProtocolFeesDiscriminatorBytes() {
  return (0, import_kit30.fixEncoderSize)((0, import_kit30.getBytesEncoder)(), 8).encode(
    COLLECT_PROTOCOL_FEES_DISCRIMINATOR
  );
}
function getCollectProtocolFeesInstructionDataEncoder() {
  return (0, import_kit30.transformEncoder)(
    (0, import_kit30.getStructEncoder)([["discriminator", (0, import_kit30.fixEncoderSize)((0, import_kit30.getBytesEncoder)(), 8)]]),
    (value) => ({
      ...value,
      discriminator: COLLECT_PROTOCOL_FEES_DISCRIMINATOR
    })
  );
}
function getCollectProtocolFeesInstructionDataDecoder() {
  return (0, import_kit30.getStructDecoder)([
    ["discriminator", (0, import_kit30.fixDecoderSize)((0, import_kit30.getBytesDecoder)(), 8)]
  ]);
}
function getCollectProtocolFeesInstructionDataCodec() {
  return (0, import_kit30.combineCodec)(
    getCollectProtocolFeesInstructionDataEncoder(),
    getCollectProtocolFeesInstructionDataDecoder()
  );
}
function getCollectProtocolFeesInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    collectProtocolFeesAuthority: {
      value: input.collectProtocolFeesAuthority ?? null,
      isWritable: false
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tokenDestinationA: {
      value: input.tokenDestinationA ?? null,
      isWritable: true
    },
    tokenDestinationB: {
      value: input.tokenDestinationB ?? null,
      isWritable: true
    },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.collectProtocolFeesAuthority),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tokenDestinationA),
      getAccountMeta(accounts.tokenDestinationB),
      getAccountMeta(accounts.tokenProgram)
    ],
    programAddress,
    data: getCollectProtocolFeesInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseCollectProtocolFeesInstruction(instruction) {
  if (instruction.accounts.length < 8) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpool: getNextAccount(),
      collectProtocolFeesAuthority: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tokenDestinationA: getNextAccount(),
      tokenDestinationB: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getCollectProtocolFeesInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/collectProtocolFeesV2.ts
var import_kit31 = require("@solana/kit");
var COLLECT_PROTOCOL_FEES_V2_DISCRIMINATOR = new Uint8Array([
  103,
  128,
  222,
  134,
  114,
  200,
  22,
  200
]);
function getCollectProtocolFeesV2DiscriminatorBytes() {
  return (0, import_kit31.fixEncoderSize)((0, import_kit31.getBytesEncoder)(), 8).encode(
    COLLECT_PROTOCOL_FEES_V2_DISCRIMINATOR
  );
}
function getCollectProtocolFeesV2InstructionDataEncoder() {
  return (0, import_kit31.transformEncoder)(
    (0, import_kit31.getStructEncoder)([
      ["discriminator", (0, import_kit31.fixEncoderSize)((0, import_kit31.getBytesEncoder)(), 8)],
      [
        "remainingAccountsInfo",
        (0, import_kit31.getOptionEncoder)(getRemainingAccountsInfoEncoder())
      ]
    ]),
    (value) => ({
      ...value,
      discriminator: COLLECT_PROTOCOL_FEES_V2_DISCRIMINATOR
    })
  );
}
function getCollectProtocolFeesV2InstructionDataDecoder() {
  return (0, import_kit31.getStructDecoder)([
    ["discriminator", (0, import_kit31.fixDecoderSize)((0, import_kit31.getBytesDecoder)(), 8)],
    [
      "remainingAccountsInfo",
      (0, import_kit31.getOptionDecoder)(getRemainingAccountsInfoDecoder())
    ]
  ]);
}
function getCollectProtocolFeesV2InstructionDataCodec() {
  return (0, import_kit31.combineCodec)(
    getCollectProtocolFeesV2InstructionDataEncoder(),
    getCollectProtocolFeesV2InstructionDataDecoder()
  );
}
function getCollectProtocolFeesV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    collectProtocolFeesAuthority: {
      value: input.collectProtocolFeesAuthority ?? null,
      isWritable: false
    },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tokenDestinationA: {
      value: input.tokenDestinationA ?? null,
      isWritable: true
    },
    tokenDestinationB: {
      value: input.tokenDestinationB ?? null,
      isWritable: true
    },
    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },
    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.collectProtocolFeesAuthority),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tokenDestinationA),
      getAccountMeta(accounts.tokenDestinationB),
      getAccountMeta(accounts.tokenProgramA),
      getAccountMeta(accounts.tokenProgramB),
      getAccountMeta(accounts.memoProgram)
    ],
    programAddress,
    data: getCollectProtocolFeesV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseCollectProtocolFeesV2Instruction(instruction) {
  if (instruction.accounts.length < 12) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpool: getNextAccount(),
      collectProtocolFeesAuthority: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tokenDestinationA: getNextAccount(),
      tokenDestinationB: getNextAccount(),
      tokenProgramA: getNextAccount(),
      tokenProgramB: getNextAccount(),
      memoProgram: getNextAccount()
    },
    data: getCollectProtocolFeesV2InstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/collectReward.ts
var import_kit32 = require("@solana/kit");
var COLLECT_REWARD_DISCRIMINATOR = new Uint8Array([
  70,
  5,
  132,
  87,
  86,
  235,
  177,
  34
]);
function getCollectRewardDiscriminatorBytes() {
  return (0, import_kit32.fixEncoderSize)((0, import_kit32.getBytesEncoder)(), 8).encode(
    COLLECT_REWARD_DISCRIMINATOR
  );
}
function getCollectRewardInstructionDataEncoder() {
  return (0, import_kit32.transformEncoder)(
    (0, import_kit32.getStructEncoder)([
      ["discriminator", (0, import_kit32.fixEncoderSize)((0, import_kit32.getBytesEncoder)(), 8)],
      ["rewardIndex", (0, import_kit32.getU8Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: COLLECT_REWARD_DISCRIMINATOR })
  );
}
function getCollectRewardInstructionDataDecoder() {
  return (0, import_kit32.getStructDecoder)([
    ["discriminator", (0, import_kit32.fixDecoderSize)((0, import_kit32.getBytesDecoder)(), 8)],
    ["rewardIndex", (0, import_kit32.getU8Decoder)()]
  ]);
}
function getCollectRewardInstructionDataCodec() {
  return (0, import_kit32.combineCodec)(
    getCollectRewardInstructionDataEncoder(),
    getCollectRewardInstructionDataDecoder()
  );
}
function getCollectRewardInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    rewardOwnerAccount: {
      value: input.rewardOwnerAccount ?? null,
      isWritable: true
    },
    rewardVault: { value: input.rewardVault ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.rewardOwnerAccount),
      getAccountMeta(accounts.rewardVault),
      getAccountMeta(accounts.tokenProgram)
    ],
    programAddress,
    data: getCollectRewardInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseCollectRewardInstruction(instruction) {
  if (instruction.accounts.length < 7) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      rewardOwnerAccount: getNextAccount(),
      rewardVault: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getCollectRewardInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/collectRewardV2.ts
var import_kit33 = require("@solana/kit");
var COLLECT_REWARD_V2_DISCRIMINATOR = new Uint8Array([
  177,
  107,
  37,
  180,
  160,
  19,
  49,
  209
]);
function getCollectRewardV2DiscriminatorBytes() {
  return (0, import_kit33.fixEncoderSize)((0, import_kit33.getBytesEncoder)(), 8).encode(
    COLLECT_REWARD_V2_DISCRIMINATOR
  );
}
function getCollectRewardV2InstructionDataEncoder() {
  return (0, import_kit33.transformEncoder)(
    (0, import_kit33.getStructEncoder)([
      ["discriminator", (0, import_kit33.fixEncoderSize)((0, import_kit33.getBytesEncoder)(), 8)],
      ["rewardIndex", (0, import_kit33.getU8Encoder)()],
      [
        "remainingAccountsInfo",
        (0, import_kit33.getOptionEncoder)(getRemainingAccountsInfoEncoder())
      ]
    ]),
    (value) => ({ ...value, discriminator: COLLECT_REWARD_V2_DISCRIMINATOR })
  );
}
function getCollectRewardV2InstructionDataDecoder() {
  return (0, import_kit33.getStructDecoder)([
    ["discriminator", (0, import_kit33.fixDecoderSize)((0, import_kit33.getBytesDecoder)(), 8)],
    ["rewardIndex", (0, import_kit33.getU8Decoder)()],
    [
      "remainingAccountsInfo",
      (0, import_kit33.getOptionDecoder)(getRemainingAccountsInfoDecoder())
    ]
  ]);
}
function getCollectRewardV2InstructionDataCodec() {
  return (0, import_kit33.combineCodec)(
    getCollectRewardV2InstructionDataEncoder(),
    getCollectRewardV2InstructionDataDecoder()
  );
}
function getCollectRewardV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    rewardOwnerAccount: {
      value: input.rewardOwnerAccount ?? null,
      isWritable: true
    },
    rewardMint: { value: input.rewardMint ?? null, isWritable: false },
    rewardVault: { value: input.rewardVault ?? null, isWritable: true },
    rewardTokenProgram: {
      value: input.rewardTokenProgram ?? null,
      isWritable: false
    },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.rewardOwnerAccount),
      getAccountMeta(accounts.rewardMint),
      getAccountMeta(accounts.rewardVault),
      getAccountMeta(accounts.rewardTokenProgram),
      getAccountMeta(accounts.memoProgram)
    ],
    programAddress,
    data: getCollectRewardV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseCollectRewardV2Instruction(instruction) {
  if (instruction.accounts.length < 9) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      rewardOwnerAccount: getNextAccount(),
      rewardMint: getNextAccount(),
      rewardVault: getNextAccount(),
      rewardTokenProgram: getNextAccount(),
      memoProgram: getNextAccount()
    },
    data: getCollectRewardV2InstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/decreaseLiquidity.ts
var import_kit34 = require("@solana/kit");
var DECREASE_LIQUIDITY_DISCRIMINATOR = new Uint8Array([
  160,
  38,
  208,
  111,
  104,
  91,
  44,
  1
]);
function getDecreaseLiquidityDiscriminatorBytes() {
  return (0, import_kit34.fixEncoderSize)((0, import_kit34.getBytesEncoder)(), 8).encode(
    DECREASE_LIQUIDITY_DISCRIMINATOR
  );
}
function getDecreaseLiquidityInstructionDataEncoder() {
  return (0, import_kit34.transformEncoder)(
    (0, import_kit34.getStructEncoder)([
      ["discriminator", (0, import_kit34.fixEncoderSize)((0, import_kit34.getBytesEncoder)(), 8)],
      ["liquidityAmount", (0, import_kit34.getU128Encoder)()],
      ["tokenMinA", (0, import_kit34.getU64Encoder)()],
      ["tokenMinB", (0, import_kit34.getU64Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: DECREASE_LIQUIDITY_DISCRIMINATOR })
  );
}
function getDecreaseLiquidityInstructionDataDecoder() {
  return (0, import_kit34.getStructDecoder)([
    ["discriminator", (0, import_kit34.fixDecoderSize)((0, import_kit34.getBytesDecoder)(), 8)],
    ["liquidityAmount", (0, import_kit34.getU128Decoder)()],
    ["tokenMinA", (0, import_kit34.getU64Decoder)()],
    ["tokenMinB", (0, import_kit34.getU64Decoder)()]
  ]);
}
function getDecreaseLiquidityInstructionDataCodec() {
  return (0, import_kit34.combineCodec)(
    getDecreaseLiquidityInstructionDataEncoder(),
    getDecreaseLiquidityInstructionDataDecoder()
  );
}
function getDecreaseLiquidityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper)
    ],
    programAddress,
    data: getDecreaseLiquidityInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseDecreaseLiquidityInstruction(instruction) {
  if (instruction.accounts.length < 11) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      tokenProgram: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tickArrayLower: getNextAccount(),
      tickArrayUpper: getNextAccount()
    },
    data: getDecreaseLiquidityInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/decreaseLiquidityV2.ts
var import_kit35 = require("@solana/kit");
var DECREASE_LIQUIDITY_V2_DISCRIMINATOR = new Uint8Array([
  58,
  127,
  188,
  62,
  79,
  82,
  196,
  96
]);
function getDecreaseLiquidityV2DiscriminatorBytes() {
  return (0, import_kit35.fixEncoderSize)((0, import_kit35.getBytesEncoder)(), 8).encode(
    DECREASE_LIQUIDITY_V2_DISCRIMINATOR
  );
}
function getDecreaseLiquidityV2InstructionDataEncoder() {
  return (0, import_kit35.transformEncoder)(
    (0, import_kit35.getStructEncoder)([
      ["discriminator", (0, import_kit35.fixEncoderSize)((0, import_kit35.getBytesEncoder)(), 8)],
      ["liquidityAmount", (0, import_kit35.getU128Encoder)()],
      ["tokenMinA", (0, import_kit35.getU64Encoder)()],
      ["tokenMinB", (0, import_kit35.getU64Encoder)()],
      [
        "remainingAccountsInfo",
        (0, import_kit35.getOptionEncoder)(getRemainingAccountsInfoEncoder())
      ]
    ]),
    (value) => ({
      ...value,
      discriminator: DECREASE_LIQUIDITY_V2_DISCRIMINATOR
    })
  );
}
function getDecreaseLiquidityV2InstructionDataDecoder() {
  return (0, import_kit35.getStructDecoder)([
    ["discriminator", (0, import_kit35.fixDecoderSize)((0, import_kit35.getBytesDecoder)(), 8)],
    ["liquidityAmount", (0, import_kit35.getU128Decoder)()],
    ["tokenMinA", (0, import_kit35.getU64Decoder)()],
    ["tokenMinB", (0, import_kit35.getU64Decoder)()],
    [
      "remainingAccountsInfo",
      (0, import_kit35.getOptionDecoder)(getRemainingAccountsInfoDecoder())
    ]
  ]);
}
function getDecreaseLiquidityV2InstructionDataCodec() {
  return (0, import_kit35.combineCodec)(
    getDecreaseLiquidityV2InstructionDataEncoder(),
    getDecreaseLiquidityV2InstructionDataDecoder()
  );
}
function getDecreaseLiquidityV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },
    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenProgramA),
      getAccountMeta(accounts.tokenProgramB),
      getAccountMeta(accounts.memoProgram),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper)
    ],
    programAddress,
    data: getDecreaseLiquidityV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseDecreaseLiquidityV2Instruction(instruction) {
  if (instruction.accounts.length < 15) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      tokenProgramA: getNextAccount(),
      tokenProgramB: getNextAccount(),
      memoProgram: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tickArrayLower: getNextAccount(),
      tickArrayUpper: getNextAccount()
    },
    data: getDecreaseLiquidityV2InstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/deletePositionBundle.ts
var import_kit36 = require("@solana/kit");
var DELETE_POSITION_BUNDLE_DISCRIMINATOR = new Uint8Array([
  100,
  25,
  99,
  2,
  217,
  239,
  124,
  173
]);
function getDeletePositionBundleDiscriminatorBytes() {
  return (0, import_kit36.fixEncoderSize)((0, import_kit36.getBytesEncoder)(), 8).encode(
    DELETE_POSITION_BUNDLE_DISCRIMINATOR
  );
}
function getDeletePositionBundleInstructionDataEncoder() {
  return (0, import_kit36.transformEncoder)(
    (0, import_kit36.getStructEncoder)([["discriminator", (0, import_kit36.fixEncoderSize)((0, import_kit36.getBytesEncoder)(), 8)]]),
    (value) => ({
      ...value,
      discriminator: DELETE_POSITION_BUNDLE_DISCRIMINATOR
    })
  );
}
function getDeletePositionBundleInstructionDataDecoder() {
  return (0, import_kit36.getStructDecoder)([
    ["discriminator", (0, import_kit36.fixDecoderSize)((0, import_kit36.getBytesDecoder)(), 8)]
  ]);
}
function getDeletePositionBundleInstructionDataCodec() {
  return (0, import_kit36.combineCodec)(
    getDeletePositionBundleInstructionDataEncoder(),
    getDeletePositionBundleInstructionDataDecoder()
  );
}
function getDeletePositionBundleInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    positionBundle: { value: input.positionBundle ?? null, isWritable: true },
    positionBundleMint: {
      value: input.positionBundleMint ?? null,
      isWritable: true
    },
    positionBundleTokenAccount: {
      value: input.positionBundleTokenAccount ?? null,
      isWritable: true
    },
    positionBundleOwner: {
      value: input.positionBundleOwner ?? null,
      isWritable: false
    },
    receiver: { value: input.receiver ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.positionBundle),
      getAccountMeta(accounts.positionBundleMint),
      getAccountMeta(accounts.positionBundleTokenAccount),
      getAccountMeta(accounts.positionBundleOwner),
      getAccountMeta(accounts.receiver),
      getAccountMeta(accounts.tokenProgram)
    ],
    programAddress,
    data: getDeletePositionBundleInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseDeletePositionBundleInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      positionBundle: getNextAccount(),
      positionBundleMint: getNextAccount(),
      positionBundleTokenAccount: getNextAccount(),
      positionBundleOwner: getNextAccount(),
      receiver: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getDeletePositionBundleInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/deleteTokenBadge.ts
var import_kit37 = require("@solana/kit");
var DELETE_TOKEN_BADGE_DISCRIMINATOR = new Uint8Array([
  53,
  146,
  68,
  8,
  18,
  117,
  17,
  185
]);
function getDeleteTokenBadgeDiscriminatorBytes() {
  return (0, import_kit37.fixEncoderSize)((0, import_kit37.getBytesEncoder)(), 8).encode(
    DELETE_TOKEN_BADGE_DISCRIMINATOR
  );
}
function getDeleteTokenBadgeInstructionDataEncoder() {
  return (0, import_kit37.transformEncoder)(
    (0, import_kit37.getStructEncoder)([["discriminator", (0, import_kit37.fixEncoderSize)((0, import_kit37.getBytesEncoder)(), 8)]]),
    (value) => ({ ...value, discriminator: DELETE_TOKEN_BADGE_DISCRIMINATOR })
  );
}
function getDeleteTokenBadgeInstructionDataDecoder() {
  return (0, import_kit37.getStructDecoder)([
    ["discriminator", (0, import_kit37.fixDecoderSize)((0, import_kit37.getBytesDecoder)(), 8)]
  ]);
}
function getDeleteTokenBadgeInstructionDataCodec() {
  return (0, import_kit37.combineCodec)(
    getDeleteTokenBadgeInstructionDataEncoder(),
    getDeleteTokenBadgeInstructionDataDecoder()
  );
}
function getDeleteTokenBadgeInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpoolsConfigExtension: {
      value: input.whirlpoolsConfigExtension ?? null,
      isWritable: false
    },
    tokenBadgeAuthority: {
      value: input.tokenBadgeAuthority ?? null,
      isWritable: false
    },
    tokenMint: { value: input.tokenMint ?? null, isWritable: false },
    tokenBadge: { value: input.tokenBadge ?? null, isWritable: true },
    receiver: { value: input.receiver ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpoolsConfigExtension),
      getAccountMeta(accounts.tokenBadgeAuthority),
      getAccountMeta(accounts.tokenMint),
      getAccountMeta(accounts.tokenBadge),
      getAccountMeta(accounts.receiver)
    ],
    programAddress,
    data: getDeleteTokenBadgeInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseDeleteTokenBadgeInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpoolsConfigExtension: getNextAccount(),
      tokenBadgeAuthority: getNextAccount(),
      tokenMint: getNextAccount(),
      tokenBadge: getNextAccount(),
      receiver: getNextAccount()
    },
    data: getDeleteTokenBadgeInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/increaseLiquidity.ts
var import_kit38 = require("@solana/kit");
var INCREASE_LIQUIDITY_DISCRIMINATOR = new Uint8Array([
  46,
  156,
  243,
  118,
  13,
  205,
  251,
  178
]);
function getIncreaseLiquidityDiscriminatorBytes() {
  return (0, import_kit38.fixEncoderSize)((0, import_kit38.getBytesEncoder)(), 8).encode(
    INCREASE_LIQUIDITY_DISCRIMINATOR
  );
}
function getIncreaseLiquidityInstructionDataEncoder() {
  return (0, import_kit38.transformEncoder)(
    (0, import_kit38.getStructEncoder)([
      ["discriminator", (0, import_kit38.fixEncoderSize)((0, import_kit38.getBytesEncoder)(), 8)],
      ["liquidityAmount", (0, import_kit38.getU128Encoder)()],
      ["tokenMaxA", (0, import_kit38.getU64Encoder)()],
      ["tokenMaxB", (0, import_kit38.getU64Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: INCREASE_LIQUIDITY_DISCRIMINATOR })
  );
}
function getIncreaseLiquidityInstructionDataDecoder() {
  return (0, import_kit38.getStructDecoder)([
    ["discriminator", (0, import_kit38.fixDecoderSize)((0, import_kit38.getBytesDecoder)(), 8)],
    ["liquidityAmount", (0, import_kit38.getU128Decoder)()],
    ["tokenMaxA", (0, import_kit38.getU64Decoder)()],
    ["tokenMaxB", (0, import_kit38.getU64Decoder)()]
  ]);
}
function getIncreaseLiquidityInstructionDataCodec() {
  return (0, import_kit38.combineCodec)(
    getIncreaseLiquidityInstructionDataEncoder(),
    getIncreaseLiquidityInstructionDataDecoder()
  );
}
function getIncreaseLiquidityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper)
    ],
    programAddress,
    data: getIncreaseLiquidityInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseIncreaseLiquidityInstruction(instruction) {
  if (instruction.accounts.length < 11) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      tokenProgram: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tickArrayLower: getNextAccount(),
      tickArrayUpper: getNextAccount()
    },
    data: getIncreaseLiquidityInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/increaseLiquidityV2.ts
var import_kit39 = require("@solana/kit");
var INCREASE_LIQUIDITY_V2_DISCRIMINATOR = new Uint8Array([
  133,
  29,
  89,
  223,
  69,
  238,
  176,
  10
]);
function getIncreaseLiquidityV2DiscriminatorBytes() {
  return (0, import_kit39.fixEncoderSize)((0, import_kit39.getBytesEncoder)(), 8).encode(
    INCREASE_LIQUIDITY_V2_DISCRIMINATOR
  );
}
function getIncreaseLiquidityV2InstructionDataEncoder() {
  return (0, import_kit39.transformEncoder)(
    (0, import_kit39.getStructEncoder)([
      ["discriminator", (0, import_kit39.fixEncoderSize)((0, import_kit39.getBytesEncoder)(), 8)],
      ["liquidityAmount", (0, import_kit39.getU128Encoder)()],
      ["tokenMaxA", (0, import_kit39.getU64Encoder)()],
      ["tokenMaxB", (0, import_kit39.getU64Encoder)()],
      [
        "remainingAccountsInfo",
        (0, import_kit39.getOptionEncoder)(getRemainingAccountsInfoEncoder())
      ]
    ]),
    (value) => ({
      ...value,
      discriminator: INCREASE_LIQUIDITY_V2_DISCRIMINATOR
    })
  );
}
function getIncreaseLiquidityV2InstructionDataDecoder() {
  return (0, import_kit39.getStructDecoder)([
    ["discriminator", (0, import_kit39.fixDecoderSize)((0, import_kit39.getBytesDecoder)(), 8)],
    ["liquidityAmount", (0, import_kit39.getU128Decoder)()],
    ["tokenMaxA", (0, import_kit39.getU64Decoder)()],
    ["tokenMaxB", (0, import_kit39.getU64Decoder)()],
    [
      "remainingAccountsInfo",
      (0, import_kit39.getOptionDecoder)(getRemainingAccountsInfoDecoder())
    ]
  ]);
}
function getIncreaseLiquidityV2InstructionDataCodec() {
  return (0, import_kit39.combineCodec)(
    getIncreaseLiquidityV2InstructionDataEncoder(),
    getIncreaseLiquidityV2InstructionDataDecoder()
  );
}
function getIncreaseLiquidityV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },
    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenProgramA),
      getAccountMeta(accounts.tokenProgramB),
      getAccountMeta(accounts.memoProgram),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper)
    ],
    programAddress,
    data: getIncreaseLiquidityV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseIncreaseLiquidityV2Instruction(instruction) {
  if (instruction.accounts.length < 15) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      tokenProgramA: getNextAccount(),
      tokenProgramB: getNextAccount(),
      memoProgram: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tickArrayLower: getNextAccount(),
      tickArrayUpper: getNextAccount()
    },
    data: getIncreaseLiquidityV2InstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializeAdaptiveFeeTier.ts
var import_kit40 = require("@solana/kit");
var INITIALIZE_ADAPTIVE_FEE_TIER_DISCRIMINATOR = new Uint8Array([
  77,
  99,
  208,
  200,
  141,
  123,
  117,
  48
]);
function getInitializeAdaptiveFeeTierDiscriminatorBytes() {
  return (0, import_kit40.fixEncoderSize)((0, import_kit40.getBytesEncoder)(), 8).encode(
    INITIALIZE_ADAPTIVE_FEE_TIER_DISCRIMINATOR
  );
}
function getInitializeAdaptiveFeeTierInstructionDataEncoder() {
  return (0, import_kit40.transformEncoder)(
    (0, import_kit40.getStructEncoder)([
      ["discriminator", (0, import_kit40.fixEncoderSize)((0, import_kit40.getBytesEncoder)(), 8)],
      ["feeTierIndex", (0, import_kit40.getU16Encoder)()],
      ["tickSpacing", (0, import_kit40.getU16Encoder)()],
      ["initializePoolAuthority", (0, import_kit40.getAddressEncoder)()],
      ["delegatedFeeAuthority", (0, import_kit40.getAddressEncoder)()],
      ["defaultBaseFeeRate", (0, import_kit40.getU16Encoder)()],
      ["filterPeriod", (0, import_kit40.getU16Encoder)()],
      ["decayPeriod", (0, import_kit40.getU16Encoder)()],
      ["reductionFactor", (0, import_kit40.getU16Encoder)()],
      ["adaptiveFeeControlFactor", (0, import_kit40.getU32Encoder)()],
      ["maxVolatilityAccumulator", (0, import_kit40.getU32Encoder)()],
      ["tickGroupSize", (0, import_kit40.getU16Encoder)()],
      ["majorSwapThresholdTicks", (0, import_kit40.getU16Encoder)()]
    ]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_ADAPTIVE_FEE_TIER_DISCRIMINATOR
    })
  );
}
function getInitializeAdaptiveFeeTierInstructionDataDecoder() {
  return (0, import_kit40.getStructDecoder)([
    ["discriminator", (0, import_kit40.fixDecoderSize)((0, import_kit40.getBytesDecoder)(), 8)],
    ["feeTierIndex", (0, import_kit40.getU16Decoder)()],
    ["tickSpacing", (0, import_kit40.getU16Decoder)()],
    ["initializePoolAuthority", (0, import_kit40.getAddressDecoder)()],
    ["delegatedFeeAuthority", (0, import_kit40.getAddressDecoder)()],
    ["defaultBaseFeeRate", (0, import_kit40.getU16Decoder)()],
    ["filterPeriod", (0, import_kit40.getU16Decoder)()],
    ["decayPeriod", (0, import_kit40.getU16Decoder)()],
    ["reductionFactor", (0, import_kit40.getU16Decoder)()],
    ["adaptiveFeeControlFactor", (0, import_kit40.getU32Decoder)()],
    ["maxVolatilityAccumulator", (0, import_kit40.getU32Decoder)()],
    ["tickGroupSize", (0, import_kit40.getU16Decoder)()],
    ["majorSwapThresholdTicks", (0, import_kit40.getU16Decoder)()]
  ]);
}
function getInitializeAdaptiveFeeTierInstructionDataCodec() {
  return (0, import_kit40.combineCodec)(
    getInitializeAdaptiveFeeTierInstructionDataEncoder(),
    getInitializeAdaptiveFeeTierInstructionDataDecoder()
  );
}
function getInitializeAdaptiveFeeTierInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    adaptiveFeeTier: { value: input.adaptiveFeeTier ?? null, isWritable: true },
    funder: { value: input.funder ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.adaptiveFeeTier),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.feeAuthority),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getInitializeAdaptiveFeeTierInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeAdaptiveFeeTierInstruction(instruction) {
  if (instruction.accounts.length < 5) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      adaptiveFeeTier: getNextAccount(),
      funder: getNextAccount(),
      feeAuthority: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeAdaptiveFeeTierInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializeConfig.ts
var import_kit41 = require("@solana/kit");
var INITIALIZE_CONFIG_DISCRIMINATOR = new Uint8Array([
  208,
  127,
  21,
  1,
  194,
  190,
  196,
  70
]);
function getInitializeConfigDiscriminatorBytes() {
  return (0, import_kit41.fixEncoderSize)((0, import_kit41.getBytesEncoder)(), 8).encode(
    INITIALIZE_CONFIG_DISCRIMINATOR
  );
}
function getInitializeConfigInstructionDataEncoder() {
  return (0, import_kit41.transformEncoder)(
    (0, import_kit41.getStructEncoder)([
      ["discriminator", (0, import_kit41.fixEncoderSize)((0, import_kit41.getBytesEncoder)(), 8)],
      ["feeAuthority", (0, import_kit41.getAddressEncoder)()],
      ["collectProtocolFeesAuthority", (0, import_kit41.getAddressEncoder)()],
      ["rewardEmissionsSuperAuthority", (0, import_kit41.getAddressEncoder)()],
      ["defaultProtocolFeeRate", (0, import_kit41.getU16Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_CONFIG_DISCRIMINATOR })
  );
}
function getInitializeConfigInstructionDataDecoder() {
  return (0, import_kit41.getStructDecoder)([
    ["discriminator", (0, import_kit41.fixDecoderSize)((0, import_kit41.getBytesDecoder)(), 8)],
    ["feeAuthority", (0, import_kit41.getAddressDecoder)()],
    ["collectProtocolFeesAuthority", (0, import_kit41.getAddressDecoder)()],
    ["rewardEmissionsSuperAuthority", (0, import_kit41.getAddressDecoder)()],
    ["defaultProtocolFeeRate", (0, import_kit41.getU16Decoder)()]
  ]);
}
function getInitializeConfigInstructionDataCodec() {
  return (0, import_kit41.combineCodec)(
    getInitializeConfigInstructionDataEncoder(),
    getInitializeConfigInstructionDataDecoder()
  );
}
function getInitializeConfigInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: true },
    funder: { value: input.funder ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.config),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getInitializeConfigInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeConfigInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      config: getNextAccount(),
      funder: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeConfigInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/initializeConfigExtension.ts
var import_kit42 = require("@solana/kit");
var INITIALIZE_CONFIG_EXTENSION_DISCRIMINATOR = new Uint8Array([
  55,
  9,
  53,
  9,
  114,
  57,
  209,
  52
]);
function getInitializeConfigExtensionDiscriminatorBytes() {
  return (0, import_kit42.fixEncoderSize)((0, import_kit42.getBytesEncoder)(), 8).encode(
    INITIALIZE_CONFIG_EXTENSION_DISCRIMINATOR
  );
}
function getInitializeConfigExtensionInstructionDataEncoder() {
  return (0, import_kit42.transformEncoder)(
    (0, import_kit42.getStructEncoder)([["discriminator", (0, import_kit42.fixEncoderSize)((0, import_kit42.getBytesEncoder)(), 8)]]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_CONFIG_EXTENSION_DISCRIMINATOR
    })
  );
}
function getInitializeConfigExtensionInstructionDataDecoder() {
  return (0, import_kit42.getStructDecoder)([
    ["discriminator", (0, import_kit42.fixDecoderSize)((0, import_kit42.getBytesDecoder)(), 8)]
  ]);
}
function getInitializeConfigExtensionInstructionDataCodec() {
  return (0, import_kit42.combineCodec)(
    getInitializeConfigExtensionInstructionDataEncoder(),
    getInitializeConfigExtensionInstructionDataDecoder()
  );
}
function getInitializeConfigExtensionInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: false },
    configExtension: { value: input.configExtension ?? null, isWritable: true },
    funder: { value: input.funder ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.config),
      getAccountMeta(accounts.configExtension),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.feeAuthority),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getInitializeConfigExtensionInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseInitializeConfigExtensionInstruction(instruction) {
  if (instruction.accounts.length < 5) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      config: getNextAccount(),
      configExtension: getNextAccount(),
      funder: getNextAccount(),
      feeAuthority: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeConfigExtensionInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializeFeeTier.ts
var import_kit43 = require("@solana/kit");
var INITIALIZE_FEE_TIER_DISCRIMINATOR = new Uint8Array([
  183,
  74,
  156,
  160,
  112,
  2,
  42,
  30
]);
function getInitializeFeeTierDiscriminatorBytes() {
  return (0, import_kit43.fixEncoderSize)((0, import_kit43.getBytesEncoder)(), 8).encode(
    INITIALIZE_FEE_TIER_DISCRIMINATOR
  );
}
function getInitializeFeeTierInstructionDataEncoder() {
  return (0, import_kit43.transformEncoder)(
    (0, import_kit43.getStructEncoder)([
      ["discriminator", (0, import_kit43.fixEncoderSize)((0, import_kit43.getBytesEncoder)(), 8)],
      ["tickSpacing", (0, import_kit43.getU16Encoder)()],
      ["defaultFeeRate", (0, import_kit43.getU16Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_FEE_TIER_DISCRIMINATOR })
  );
}
function getInitializeFeeTierInstructionDataDecoder() {
  return (0, import_kit43.getStructDecoder)([
    ["discriminator", (0, import_kit43.fixDecoderSize)((0, import_kit43.getBytesDecoder)(), 8)],
    ["tickSpacing", (0, import_kit43.getU16Decoder)()],
    ["defaultFeeRate", (0, import_kit43.getU16Decoder)()]
  ]);
}
function getInitializeFeeTierInstructionDataCodec() {
  return (0, import_kit43.combineCodec)(
    getInitializeFeeTierInstructionDataEncoder(),
    getInitializeFeeTierInstructionDataDecoder()
  );
}
function getInitializeFeeTierInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: false },
    feeTier: { value: input.feeTier ?? null, isWritable: true },
    funder: { value: input.funder ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.config),
      getAccountMeta(accounts.feeTier),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.feeAuthority),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getInitializeFeeTierInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeFeeTierInstruction(instruction) {
  if (instruction.accounts.length < 5) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      config: getNextAccount(),
      feeTier: getNextAccount(),
      funder: getNextAccount(),
      feeAuthority: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeFeeTierInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/initializePool.ts
var import_kit44 = require("@solana/kit");
var INITIALIZE_POOL_DISCRIMINATOR = new Uint8Array([
  95,
  180,
  10,
  172,
  84,
  174,
  232,
  40
]);
function getInitializePoolDiscriminatorBytes() {
  return (0, import_kit44.fixEncoderSize)((0, import_kit44.getBytesEncoder)(), 8).encode(
    INITIALIZE_POOL_DISCRIMINATOR
  );
}
function getInitializePoolInstructionDataEncoder() {
  return (0, import_kit44.transformEncoder)(
    (0, import_kit44.getStructEncoder)([
      ["discriminator", (0, import_kit44.fixEncoderSize)((0, import_kit44.getBytesEncoder)(), 8)],
      ["whirlpoolBump", (0, import_kit44.getU8Encoder)()],
      ["tickSpacing", (0, import_kit44.getU16Encoder)()],
      ["initialSqrtPrice", (0, import_kit44.getU128Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_POOL_DISCRIMINATOR })
  );
}
function getInitializePoolInstructionDataDecoder() {
  return (0, import_kit44.getStructDecoder)([
    ["discriminator", (0, import_kit44.fixDecoderSize)((0, import_kit44.getBytesDecoder)(), 8)],
    ["whirlpoolBump", (0, import_kit44.getU8Decoder)()],
    ["tickSpacing", (0, import_kit44.getU16Decoder)()],
    ["initialSqrtPrice", (0, import_kit44.getU128Decoder)()]
  ]);
}
function getInitializePoolInstructionDataCodec() {
  return (0, import_kit44.combineCodec)(
    getInitializePoolInstructionDataEncoder(),
    getInitializePoolInstructionDataDecoder()
  );
}
function getInitializePoolInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    funder: { value: input.funder ?? null, isWritable: true },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    feeTier: { value: input.feeTier ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.feeTier),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent)
    ],
    programAddress,
    data: getInitializePoolInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializePoolInstruction(instruction) {
  if (instruction.accounts.length < 11) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      funder: getNextAccount(),
      whirlpool: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      feeTier: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount()
    },
    data: getInitializePoolInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/initializePoolV2.ts
var import_kit45 = require("@solana/kit");
var INITIALIZE_POOL_V2_DISCRIMINATOR = new Uint8Array([
  207,
  45,
  87,
  242,
  27,
  63,
  204,
  67
]);
function getInitializePoolV2DiscriminatorBytes() {
  return (0, import_kit45.fixEncoderSize)((0, import_kit45.getBytesEncoder)(), 8).encode(
    INITIALIZE_POOL_V2_DISCRIMINATOR
  );
}
function getInitializePoolV2InstructionDataEncoder() {
  return (0, import_kit45.transformEncoder)(
    (0, import_kit45.getStructEncoder)([
      ["discriminator", (0, import_kit45.fixEncoderSize)((0, import_kit45.getBytesEncoder)(), 8)],
      ["tickSpacing", (0, import_kit45.getU16Encoder)()],
      ["initialSqrtPrice", (0, import_kit45.getU128Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_POOL_V2_DISCRIMINATOR })
  );
}
function getInitializePoolV2InstructionDataDecoder() {
  return (0, import_kit45.getStructDecoder)([
    ["discriminator", (0, import_kit45.fixDecoderSize)((0, import_kit45.getBytesDecoder)(), 8)],
    ["tickSpacing", (0, import_kit45.getU16Decoder)()],
    ["initialSqrtPrice", (0, import_kit45.getU128Decoder)()]
  ]);
}
function getInitializePoolV2InstructionDataCodec() {
  return (0, import_kit45.combineCodec)(
    getInitializePoolV2InstructionDataEncoder(),
    getInitializePoolV2InstructionDataDecoder()
  );
}
function getInitializePoolV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    tokenBadgeA: { value: input.tokenBadgeA ?? null, isWritable: false },
    tokenBadgeB: { value: input.tokenBadgeB ?? null, isWritable: false },
    funder: { value: input.funder ?? null, isWritable: true },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    feeTier: { value: input.feeTier ?? null, isWritable: false },
    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },
    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.tokenBadgeA),
      getAccountMeta(accounts.tokenBadgeB),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.feeTier),
      getAccountMeta(accounts.tokenProgramA),
      getAccountMeta(accounts.tokenProgramB),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent)
    ],
    programAddress,
    data: getInitializePoolV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializePoolV2Instruction(instruction) {
  if (instruction.accounts.length < 14) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      tokenBadgeA: getNextAccount(),
      tokenBadgeB: getNextAccount(),
      funder: getNextAccount(),
      whirlpool: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      feeTier: getNextAccount(),
      tokenProgramA: getNextAccount(),
      tokenProgramB: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount()
    },
    data: getInitializePoolV2InstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/initializePoolWithAdaptiveFee.ts
var import_kit46 = require("@solana/kit");
var INITIALIZE_POOL_WITH_ADAPTIVE_FEE_DISCRIMINATOR = new Uint8Array([
  143,
  94,
  96,
  76,
  172,
  124,
  119,
  199
]);
function getInitializePoolWithAdaptiveFeeDiscriminatorBytes() {
  return (0, import_kit46.fixEncoderSize)((0, import_kit46.getBytesEncoder)(), 8).encode(
    INITIALIZE_POOL_WITH_ADAPTIVE_FEE_DISCRIMINATOR
  );
}
function getInitializePoolWithAdaptiveFeeInstructionDataEncoder() {
  return (0, import_kit46.transformEncoder)(
    (0, import_kit46.getStructEncoder)([
      ["discriminator", (0, import_kit46.fixEncoderSize)((0, import_kit46.getBytesEncoder)(), 8)],
      ["initialSqrtPrice", (0, import_kit46.getU128Encoder)()],
      ["tradeEnableTimestamp", (0, import_kit46.getOptionEncoder)((0, import_kit46.getU64Encoder)())]
    ]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_POOL_WITH_ADAPTIVE_FEE_DISCRIMINATOR
    })
  );
}
function getInitializePoolWithAdaptiveFeeInstructionDataDecoder() {
  return (0, import_kit46.getStructDecoder)([
    ["discriminator", (0, import_kit46.fixDecoderSize)((0, import_kit46.getBytesDecoder)(), 8)],
    ["initialSqrtPrice", (0, import_kit46.getU128Decoder)()],
    ["tradeEnableTimestamp", (0, import_kit46.getOptionDecoder)((0, import_kit46.getU64Decoder)())]
  ]);
}
function getInitializePoolWithAdaptiveFeeInstructionDataCodec() {
  return (0, import_kit46.combineCodec)(
    getInitializePoolWithAdaptiveFeeInstructionDataEncoder(),
    getInitializePoolWithAdaptiveFeeInstructionDataDecoder()
  );
}
function getInitializePoolWithAdaptiveFeeInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    tokenBadgeA: { value: input.tokenBadgeA ?? null, isWritable: false },
    tokenBadgeB: { value: input.tokenBadgeB ?? null, isWritable: false },
    funder: { value: input.funder ?? null, isWritable: true },
    initializePoolAuthority: {
      value: input.initializePoolAuthority ?? null,
      isWritable: false
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    oracle: { value: input.oracle ?? null, isWritable: true },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    adaptiveFeeTier: {
      value: input.adaptiveFeeTier ?? null,
      isWritable: false
    },
    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },
    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.tokenBadgeA),
      getAccountMeta(accounts.tokenBadgeB),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.initializePoolAuthority),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.oracle),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.adaptiveFeeTier),
      getAccountMeta(accounts.tokenProgramA),
      getAccountMeta(accounts.tokenProgramB),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent)
    ],
    programAddress,
    data: getInitializePoolWithAdaptiveFeeInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializePoolWithAdaptiveFeeInstruction(instruction) {
  if (instruction.accounts.length < 16) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      tokenBadgeA: getNextAccount(),
      tokenBadgeB: getNextAccount(),
      funder: getNextAccount(),
      initializePoolAuthority: getNextAccount(),
      whirlpool: getNextAccount(),
      oracle: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      adaptiveFeeTier: getNextAccount(),
      tokenProgramA: getNextAccount(),
      tokenProgramB: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount()
    },
    data: getInitializePoolWithAdaptiveFeeInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializePositionBundle.ts
var import_kit47 = require("@solana/kit");
var INITIALIZE_POSITION_BUNDLE_DISCRIMINATOR = new Uint8Array([
  117,
  45,
  241,
  149,
  24,
  18,
  194,
  65
]);
function getInitializePositionBundleDiscriminatorBytes() {
  return (0, import_kit47.fixEncoderSize)((0, import_kit47.getBytesEncoder)(), 8).encode(
    INITIALIZE_POSITION_BUNDLE_DISCRIMINATOR
  );
}
function getInitializePositionBundleInstructionDataEncoder() {
  return (0, import_kit47.transformEncoder)(
    (0, import_kit47.getStructEncoder)([["discriminator", (0, import_kit47.fixEncoderSize)((0, import_kit47.getBytesEncoder)(), 8)]]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_POSITION_BUNDLE_DISCRIMINATOR
    })
  );
}
function getInitializePositionBundleInstructionDataDecoder() {
  return (0, import_kit47.getStructDecoder)([
    ["discriminator", (0, import_kit47.fixDecoderSize)((0, import_kit47.getBytesDecoder)(), 8)]
  ]);
}
function getInitializePositionBundleInstructionDataCodec() {
  return (0, import_kit47.combineCodec)(
    getInitializePositionBundleInstructionDataEncoder(),
    getInitializePositionBundleInstructionDataDecoder()
  );
}
function getInitializePositionBundleInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    positionBundle: { value: input.positionBundle ?? null, isWritable: true },
    positionBundleMint: {
      value: input.positionBundleMint ?? null,
      isWritable: true
    },
    positionBundleTokenAccount: {
      value: input.positionBundleTokenAccount ?? null,
      isWritable: true
    },
    positionBundleOwner: {
      value: input.positionBundleOwner ?? null,
      isWritable: false
    },
    funder: { value: input.funder ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.positionBundle),
      getAccountMeta(accounts.positionBundleMint),
      getAccountMeta(accounts.positionBundleTokenAccount),
      getAccountMeta(accounts.positionBundleOwner),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.associatedTokenProgram)
    ],
    programAddress,
    data: getInitializePositionBundleInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseInitializePositionBundleInstruction(instruction) {
  if (instruction.accounts.length < 9) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      positionBundle: getNextAccount(),
      positionBundleMint: getNextAccount(),
      positionBundleTokenAccount: getNextAccount(),
      positionBundleOwner: getNextAccount(),
      funder: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount(),
      associatedTokenProgram: getNextAccount()
    },
    data: getInitializePositionBundleInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializePositionBundleWithMetadata.ts
var import_kit48 = require("@solana/kit");
var INITIALIZE_POSITION_BUNDLE_WITH_METADATA_DISCRIMINATOR = new Uint8Array([93, 124, 16, 179, 249, 131, 115, 245]);
function getInitializePositionBundleWithMetadataDiscriminatorBytes() {
  return (0, import_kit48.fixEncoderSize)((0, import_kit48.getBytesEncoder)(), 8).encode(
    INITIALIZE_POSITION_BUNDLE_WITH_METADATA_DISCRIMINATOR
  );
}
function getInitializePositionBundleWithMetadataInstructionDataEncoder() {
  return (0, import_kit48.transformEncoder)(
    (0, import_kit48.getStructEncoder)([["discriminator", (0, import_kit48.fixEncoderSize)((0, import_kit48.getBytesEncoder)(), 8)]]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_POSITION_BUNDLE_WITH_METADATA_DISCRIMINATOR
    })
  );
}
function getInitializePositionBundleWithMetadataInstructionDataDecoder() {
  return (0, import_kit48.getStructDecoder)([
    ["discriminator", (0, import_kit48.fixDecoderSize)((0, import_kit48.getBytesDecoder)(), 8)]
  ]);
}
function getInitializePositionBundleWithMetadataInstructionDataCodec() {
  return (0, import_kit48.combineCodec)(
    getInitializePositionBundleWithMetadataInstructionDataEncoder(),
    getInitializePositionBundleWithMetadataInstructionDataDecoder()
  );
}
function getInitializePositionBundleWithMetadataInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    positionBundle: { value: input.positionBundle ?? null, isWritable: true },
    positionBundleMint: {
      value: input.positionBundleMint ?? null,
      isWritable: true
    },
    positionBundleMetadata: {
      value: input.positionBundleMetadata ?? null,
      isWritable: true
    },
    positionBundleTokenAccount: {
      value: input.positionBundleTokenAccount ?? null,
      isWritable: true
    },
    positionBundleOwner: {
      value: input.positionBundleOwner ?? null,
      isWritable: false
    },
    funder: { value: input.funder ?? null, isWritable: true },
    metadataUpdateAuth: {
      value: input.metadataUpdateAuth ?? null,
      isWritable: false
    },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false
    },
    metadataProgram: {
      value: input.metadataProgram ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.positionBundle),
      getAccountMeta(accounts.positionBundleMint),
      getAccountMeta(accounts.positionBundleMetadata),
      getAccountMeta(accounts.positionBundleTokenAccount),
      getAccountMeta(accounts.positionBundleOwner),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.metadataUpdateAuth),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.metadataProgram)
    ],
    programAddress,
    data: getInitializePositionBundleWithMetadataInstructionDataEncoder().encode(
      {}
    )
  };
  return instruction;
}
function parseInitializePositionBundleWithMetadataInstruction(instruction) {
  if (instruction.accounts.length < 12) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      positionBundle: getNextAccount(),
      positionBundleMint: getNextAccount(),
      positionBundleMetadata: getNextAccount(),
      positionBundleTokenAccount: getNextAccount(),
      positionBundleOwner: getNextAccount(),
      funder: getNextAccount(),
      metadataUpdateAuth: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount(),
      associatedTokenProgram: getNextAccount(),
      metadataProgram: getNextAccount()
    },
    data: getInitializePositionBundleWithMetadataInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializeReward.ts
var import_kit49 = require("@solana/kit");
var INITIALIZE_REWARD_DISCRIMINATOR = new Uint8Array([
  95,
  135,
  192,
  196,
  242,
  129,
  230,
  68
]);
function getInitializeRewardDiscriminatorBytes() {
  return (0, import_kit49.fixEncoderSize)((0, import_kit49.getBytesEncoder)(), 8).encode(
    INITIALIZE_REWARD_DISCRIMINATOR
  );
}
function getInitializeRewardInstructionDataEncoder() {
  return (0, import_kit49.transformEncoder)(
    (0, import_kit49.getStructEncoder)([
      ["discriminator", (0, import_kit49.fixEncoderSize)((0, import_kit49.getBytesEncoder)(), 8)],
      ["rewardIndex", (0, import_kit49.getU8Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_REWARD_DISCRIMINATOR })
  );
}
function getInitializeRewardInstructionDataDecoder() {
  return (0, import_kit49.getStructDecoder)([
    ["discriminator", (0, import_kit49.fixDecoderSize)((0, import_kit49.getBytesDecoder)(), 8)],
    ["rewardIndex", (0, import_kit49.getU8Decoder)()]
  ]);
}
function getInitializeRewardInstructionDataCodec() {
  return (0, import_kit49.combineCodec)(
    getInitializeRewardInstructionDataEncoder(),
    getInitializeRewardInstructionDataDecoder()
  );
}
function getInitializeRewardInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    rewardAuthority: {
      value: input.rewardAuthority ?? null,
      isWritable: false
    },
    funder: { value: input.funder ?? null, isWritable: true },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    rewardMint: { value: input.rewardMint ?? null, isWritable: false },
    rewardVault: { value: input.rewardVault ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.rewardAuthority),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.rewardMint),
      getAccountMeta(accounts.rewardVault),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent)
    ],
    programAddress,
    data: getInitializeRewardInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeRewardInstruction(instruction) {
  if (instruction.accounts.length < 8) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      rewardAuthority: getNextAccount(),
      funder: getNextAccount(),
      whirlpool: getNextAccount(),
      rewardMint: getNextAccount(),
      rewardVault: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount()
    },
    data: getInitializeRewardInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/initializeRewardV2.ts
var import_kit50 = require("@solana/kit");
var INITIALIZE_REWARD_V2_DISCRIMINATOR = new Uint8Array([
  91,
  1,
  77,
  50,
  235,
  229,
  133,
  49
]);
function getInitializeRewardV2DiscriminatorBytes() {
  return (0, import_kit50.fixEncoderSize)((0, import_kit50.getBytesEncoder)(), 8).encode(
    INITIALIZE_REWARD_V2_DISCRIMINATOR
  );
}
function getInitializeRewardV2InstructionDataEncoder() {
  return (0, import_kit50.transformEncoder)(
    (0, import_kit50.getStructEncoder)([
      ["discriminator", (0, import_kit50.fixEncoderSize)((0, import_kit50.getBytesEncoder)(), 8)],
      ["rewardIndex", (0, import_kit50.getU8Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_REWARD_V2_DISCRIMINATOR })
  );
}
function getInitializeRewardV2InstructionDataDecoder() {
  return (0, import_kit50.getStructDecoder)([
    ["discriminator", (0, import_kit50.fixDecoderSize)((0, import_kit50.getBytesDecoder)(), 8)],
    ["rewardIndex", (0, import_kit50.getU8Decoder)()]
  ]);
}
function getInitializeRewardV2InstructionDataCodec() {
  return (0, import_kit50.combineCodec)(
    getInitializeRewardV2InstructionDataEncoder(),
    getInitializeRewardV2InstructionDataDecoder()
  );
}
function getInitializeRewardV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    rewardAuthority: {
      value: input.rewardAuthority ?? null,
      isWritable: false
    },
    funder: { value: input.funder ?? null, isWritable: true },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    rewardMint: { value: input.rewardMint ?? null, isWritable: false },
    rewardTokenBadge: {
      value: input.rewardTokenBadge ?? null,
      isWritable: false
    },
    rewardVault: { value: input.rewardVault ?? null, isWritable: true },
    rewardTokenProgram: {
      value: input.rewardTokenProgram ?? null,
      isWritable: false
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.rewardAuthority),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.rewardMint),
      getAccountMeta(accounts.rewardTokenBadge),
      getAccountMeta(accounts.rewardVault),
      getAccountMeta(accounts.rewardTokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent)
    ],
    programAddress,
    data: getInitializeRewardV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeRewardV2Instruction(instruction) {
  if (instruction.accounts.length < 9) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      rewardAuthority: getNextAccount(),
      funder: getNextAccount(),
      whirlpool: getNextAccount(),
      rewardMint: getNextAccount(),
      rewardTokenBadge: getNextAccount(),
      rewardVault: getNextAccount(),
      rewardTokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount()
    },
    data: getInitializeRewardV2InstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializeTickArray.ts
var import_kit51 = require("@solana/kit");
var INITIALIZE_TICK_ARRAY_DISCRIMINATOR = new Uint8Array([
  11,
  188,
  193,
  214,
  141,
  91,
  149,
  184
]);
function getInitializeTickArrayDiscriminatorBytes() {
  return (0, import_kit51.fixEncoderSize)((0, import_kit51.getBytesEncoder)(), 8).encode(
    INITIALIZE_TICK_ARRAY_DISCRIMINATOR
  );
}
function getInitializeTickArrayInstructionDataEncoder() {
  return (0, import_kit51.transformEncoder)(
    (0, import_kit51.getStructEncoder)([
      ["discriminator", (0, import_kit51.fixEncoderSize)((0, import_kit51.getBytesEncoder)(), 8)],
      ["startTickIndex", (0, import_kit51.getI32Encoder)()]
    ]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_TICK_ARRAY_DISCRIMINATOR
    })
  );
}
function getInitializeTickArrayInstructionDataDecoder() {
  return (0, import_kit51.getStructDecoder)([
    ["discriminator", (0, import_kit51.fixDecoderSize)((0, import_kit51.getBytesDecoder)(), 8)],
    ["startTickIndex", (0, import_kit51.getI32Decoder)()]
  ]);
}
function getInitializeTickArrayInstructionDataCodec() {
  return (0, import_kit51.combineCodec)(
    getInitializeTickArrayInstructionDataEncoder(),
    getInitializeTickArrayInstructionDataDecoder()
  );
}
function getInitializeTickArrayInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    funder: { value: input.funder ?? null, isWritable: true },
    tickArray: { value: input.tickArray ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.tickArray),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getInitializeTickArrayInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeTickArrayInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      funder: getNextAccount(),
      tickArray: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeTickArrayInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializeTokenBadge.ts
var import_kit52 = require("@solana/kit");
var INITIALIZE_TOKEN_BADGE_DISCRIMINATOR = new Uint8Array([
  253,
  77,
  205,
  95,
  27,
  224,
  89,
  223
]);
function getInitializeTokenBadgeDiscriminatorBytes() {
  return (0, import_kit52.fixEncoderSize)((0, import_kit52.getBytesEncoder)(), 8).encode(
    INITIALIZE_TOKEN_BADGE_DISCRIMINATOR
  );
}
function getInitializeTokenBadgeInstructionDataEncoder() {
  return (0, import_kit52.transformEncoder)(
    (0, import_kit52.getStructEncoder)([["discriminator", (0, import_kit52.fixEncoderSize)((0, import_kit52.getBytesEncoder)(), 8)]]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_TOKEN_BADGE_DISCRIMINATOR
    })
  );
}
function getInitializeTokenBadgeInstructionDataDecoder() {
  return (0, import_kit52.getStructDecoder)([
    ["discriminator", (0, import_kit52.fixDecoderSize)((0, import_kit52.getBytesDecoder)(), 8)]
  ]);
}
function getInitializeTokenBadgeInstructionDataCodec() {
  return (0, import_kit52.combineCodec)(
    getInitializeTokenBadgeInstructionDataEncoder(),
    getInitializeTokenBadgeInstructionDataDecoder()
  );
}
function getInitializeTokenBadgeInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpoolsConfigExtension: {
      value: input.whirlpoolsConfigExtension ?? null,
      isWritable: false
    },
    tokenBadgeAuthority: {
      value: input.tokenBadgeAuthority ?? null,
      isWritable: false
    },
    tokenMint: { value: input.tokenMint ?? null, isWritable: false },
    tokenBadge: { value: input.tokenBadge ?? null, isWritable: true },
    funder: { value: input.funder ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpoolsConfigExtension),
      getAccountMeta(accounts.tokenBadgeAuthority),
      getAccountMeta(accounts.tokenMint),
      getAccountMeta(accounts.tokenBadge),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getInitializeTokenBadgeInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseInitializeTokenBadgeInstruction(instruction) {
  if (instruction.accounts.length < 7) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpoolsConfigExtension: getNextAccount(),
      tokenBadgeAuthority: getNextAccount(),
      tokenMint: getNextAccount(),
      tokenBadge: getNextAccount(),
      funder: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeTokenBadgeInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/lockPosition.ts
var import_kit53 = require("@solana/kit");
var LOCK_POSITION_DISCRIMINATOR = new Uint8Array([
  227,
  62,
  2,
  252,
  247,
  10,
  171,
  185
]);
function getLockPositionDiscriminatorBytes() {
  return (0, import_kit53.fixEncoderSize)((0, import_kit53.getBytesEncoder)(), 8).encode(
    LOCK_POSITION_DISCRIMINATOR
  );
}
function getLockPositionInstructionDataEncoder() {
  return (0, import_kit53.transformEncoder)(
    (0, import_kit53.getStructEncoder)([
      ["discriminator", (0, import_kit53.fixEncoderSize)((0, import_kit53.getBytesEncoder)(), 8)],
      ["lockType", getLockTypeEncoder()]
    ]),
    (value) => ({ ...value, discriminator: LOCK_POSITION_DISCRIMINATOR })
  );
}
function getLockPositionInstructionDataDecoder() {
  return (0, import_kit53.getStructDecoder)([
    ["discriminator", (0, import_kit53.fixDecoderSize)((0, import_kit53.getBytesDecoder)(), 8)],
    ["lockType", getLockTypeDecoder()]
  ]);
}
function getLockPositionInstructionDataCodec() {
  return (0, import_kit53.combineCodec)(
    getLockPositionInstructionDataEncoder(),
    getLockPositionInstructionDataDecoder()
  );
}
function getLockPositionInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    funder: { value: input.funder ?? null, isWritable: true },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: false },
    positionMint: { value: input.positionMint ?? null, isWritable: false },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: true
    },
    lockConfig: { value: input.lockConfig ?? null, isWritable: true },
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    token2022Program: {
      value: input.token2022Program ?? null,
      isWritable: false
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionMint),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.lockConfig),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.token2022Program),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getLockPositionInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseLockPositionInstruction(instruction) {
  if (instruction.accounts.length < 9) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      funder: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionMint: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      lockConfig: getNextAccount(),
      whirlpool: getNextAccount(),
      token2022Program: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getLockPositionInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/openBundledPosition.ts
var import_kit54 = require("@solana/kit");
var OPEN_BUNDLED_POSITION_DISCRIMINATOR = new Uint8Array([
  169,
  113,
  126,
  171,
  213,
  172,
  212,
  49
]);
function getOpenBundledPositionDiscriminatorBytes() {
  return (0, import_kit54.fixEncoderSize)((0, import_kit54.getBytesEncoder)(), 8).encode(
    OPEN_BUNDLED_POSITION_DISCRIMINATOR
  );
}
function getOpenBundledPositionInstructionDataEncoder() {
  return (0, import_kit54.transformEncoder)(
    (0, import_kit54.getStructEncoder)([
      ["discriminator", (0, import_kit54.fixEncoderSize)((0, import_kit54.getBytesEncoder)(), 8)],
      ["bundleIndex", (0, import_kit54.getU16Encoder)()],
      ["tickLowerIndex", (0, import_kit54.getI32Encoder)()],
      ["tickUpperIndex", (0, import_kit54.getI32Encoder)()]
    ]),
    (value) => ({
      ...value,
      discriminator: OPEN_BUNDLED_POSITION_DISCRIMINATOR
    })
  );
}
function getOpenBundledPositionInstructionDataDecoder() {
  return (0, import_kit54.getStructDecoder)([
    ["discriminator", (0, import_kit54.fixDecoderSize)((0, import_kit54.getBytesDecoder)(), 8)],
    ["bundleIndex", (0, import_kit54.getU16Decoder)()],
    ["tickLowerIndex", (0, import_kit54.getI32Decoder)()],
    ["tickUpperIndex", (0, import_kit54.getI32Decoder)()]
  ]);
}
function getOpenBundledPositionInstructionDataCodec() {
  return (0, import_kit54.combineCodec)(
    getOpenBundledPositionInstructionDataEncoder(),
    getOpenBundledPositionInstructionDataDecoder()
  );
}
function getOpenBundledPositionInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    bundledPosition: { value: input.bundledPosition ?? null, isWritable: true },
    positionBundle: { value: input.positionBundle ?? null, isWritable: true },
    positionBundleTokenAccount: {
      value: input.positionBundleTokenAccount ?? null,
      isWritable: false
    },
    positionBundleAuthority: {
      value: input.positionBundleAuthority ?? null,
      isWritable: false
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    funder: { value: input.funder ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.bundledPosition),
      getAccountMeta(accounts.positionBundle),
      getAccountMeta(accounts.positionBundleTokenAccount),
      getAccountMeta(accounts.positionBundleAuthority),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent)
    ],
    programAddress,
    data: getOpenBundledPositionInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseOpenBundledPositionInstruction(instruction) {
  if (instruction.accounts.length < 8) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      bundledPosition: getNextAccount(),
      positionBundle: getNextAccount(),
      positionBundleTokenAccount: getNextAccount(),
      positionBundleAuthority: getNextAccount(),
      whirlpool: getNextAccount(),
      funder: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount()
    },
    data: getOpenBundledPositionInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/openPosition.ts
var import_kit55 = require("@solana/kit");
var OPEN_POSITION_DISCRIMINATOR = new Uint8Array([
  135,
  128,
  47,
  77,
  15,
  152,
  240,
  49
]);
function getOpenPositionDiscriminatorBytes() {
  return (0, import_kit55.fixEncoderSize)((0, import_kit55.getBytesEncoder)(), 8).encode(
    OPEN_POSITION_DISCRIMINATOR
  );
}
function getOpenPositionInstructionDataEncoder() {
  return (0, import_kit55.transformEncoder)(
    (0, import_kit55.getStructEncoder)([
      ["discriminator", (0, import_kit55.fixEncoderSize)((0, import_kit55.getBytesEncoder)(), 8)],
      ["positionBump", (0, import_kit55.getU8Encoder)()],
      ["tickLowerIndex", (0, import_kit55.getI32Encoder)()],
      ["tickUpperIndex", (0, import_kit55.getI32Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: OPEN_POSITION_DISCRIMINATOR })
  );
}
function getOpenPositionInstructionDataDecoder() {
  return (0, import_kit55.getStructDecoder)([
    ["discriminator", (0, import_kit55.fixDecoderSize)((0, import_kit55.getBytesDecoder)(), 8)],
    ["positionBump", (0, import_kit55.getU8Decoder)()],
    ["tickLowerIndex", (0, import_kit55.getI32Decoder)()],
    ["tickUpperIndex", (0, import_kit55.getI32Decoder)()]
  ]);
}
function getOpenPositionInstructionDataCodec() {
  return (0, import_kit55.combineCodec)(
    getOpenPositionInstructionDataEncoder(),
    getOpenPositionInstructionDataDecoder()
  );
}
function getOpenPositionInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    funder: { value: input.funder ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false },
    position: { value: input.position ?? null, isWritable: true },
    positionMint: { value: input.positionMint ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: true
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionMint),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.associatedTokenProgram)
    ],
    programAddress,
    data: getOpenPositionInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseOpenPositionInstruction(instruction) {
  if (instruction.accounts.length < 10) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      funder: getNextAccount(),
      owner: getNextAccount(),
      position: getNextAccount(),
      positionMint: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      whirlpool: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount(),
      associatedTokenProgram: getNextAccount()
    },
    data: getOpenPositionInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/openPositionWithMetadata.ts
var import_kit56 = require("@solana/kit");
var OPEN_POSITION_WITH_METADATA_DISCRIMINATOR = new Uint8Array([
  242,
  29,
  134,
  48,
  58,
  110,
  14,
  60
]);
function getOpenPositionWithMetadataDiscriminatorBytes() {
  return (0, import_kit56.fixEncoderSize)((0, import_kit56.getBytesEncoder)(), 8).encode(
    OPEN_POSITION_WITH_METADATA_DISCRIMINATOR
  );
}
function getOpenPositionWithMetadataInstructionDataEncoder() {
  return (0, import_kit56.transformEncoder)(
    (0, import_kit56.getStructEncoder)([
      ["discriminator", (0, import_kit56.fixEncoderSize)((0, import_kit56.getBytesEncoder)(), 8)],
      ["positionBump", (0, import_kit56.getU8Encoder)()],
      ["metadataBump", (0, import_kit56.getU8Encoder)()],
      ["tickLowerIndex", (0, import_kit56.getI32Encoder)()],
      ["tickUpperIndex", (0, import_kit56.getI32Encoder)()]
    ]),
    (value) => ({
      ...value,
      discriminator: OPEN_POSITION_WITH_METADATA_DISCRIMINATOR
    })
  );
}
function getOpenPositionWithMetadataInstructionDataDecoder() {
  return (0, import_kit56.getStructDecoder)([
    ["discriminator", (0, import_kit56.fixDecoderSize)((0, import_kit56.getBytesDecoder)(), 8)],
    ["positionBump", (0, import_kit56.getU8Decoder)()],
    ["metadataBump", (0, import_kit56.getU8Decoder)()],
    ["tickLowerIndex", (0, import_kit56.getI32Decoder)()],
    ["tickUpperIndex", (0, import_kit56.getI32Decoder)()]
  ]);
}
function getOpenPositionWithMetadataInstructionDataCodec() {
  return (0, import_kit56.combineCodec)(
    getOpenPositionWithMetadataInstructionDataEncoder(),
    getOpenPositionWithMetadataInstructionDataDecoder()
  );
}
function getOpenPositionWithMetadataInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    funder: { value: input.funder ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false },
    position: { value: input.position ?? null, isWritable: true },
    positionMint: { value: input.positionMint ?? null, isWritable: true },
    positionMetadataAccount: {
      value: input.positionMetadataAccount ?? null,
      isWritable: true
    },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: true
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false
    },
    metadataProgram: {
      value: input.metadataProgram ?? null,
      isWritable: false
    },
    metadataUpdateAuth: {
      value: input.metadataUpdateAuth ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionMint),
      getAccountMeta(accounts.positionMetadataAccount),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.metadataProgram),
      getAccountMeta(accounts.metadataUpdateAuth)
    ],
    programAddress,
    data: getOpenPositionWithMetadataInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseOpenPositionWithMetadataInstruction(instruction) {
  if (instruction.accounts.length < 13) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      funder: getNextAccount(),
      owner: getNextAccount(),
      position: getNextAccount(),
      positionMint: getNextAccount(),
      positionMetadataAccount: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      whirlpool: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount(),
      associatedTokenProgram: getNextAccount(),
      metadataProgram: getNextAccount(),
      metadataUpdateAuth: getNextAccount()
    },
    data: getOpenPositionWithMetadataInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/openPositionWithTokenExtensions.ts
var import_kit57 = require("@solana/kit");
var OPEN_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR = new Uint8Array(
  [212, 47, 95, 92, 114, 102, 131, 250]
);
function getOpenPositionWithTokenExtensionsDiscriminatorBytes() {
  return (0, import_kit57.fixEncoderSize)((0, import_kit57.getBytesEncoder)(), 8).encode(
    OPEN_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR
  );
}
function getOpenPositionWithTokenExtensionsInstructionDataEncoder() {
  return (0, import_kit57.transformEncoder)(
    (0, import_kit57.getStructEncoder)([
      ["discriminator", (0, import_kit57.fixEncoderSize)((0, import_kit57.getBytesEncoder)(), 8)],
      ["tickLowerIndex", (0, import_kit57.getI32Encoder)()],
      ["tickUpperIndex", (0, import_kit57.getI32Encoder)()],
      ["withTokenMetadataExtension", (0, import_kit57.getBooleanEncoder)()]
    ]),
    (value) => ({
      ...value,
      discriminator: OPEN_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR
    })
  );
}
function getOpenPositionWithTokenExtensionsInstructionDataDecoder() {
  return (0, import_kit57.getStructDecoder)([
    ["discriminator", (0, import_kit57.fixDecoderSize)((0, import_kit57.getBytesDecoder)(), 8)],
    ["tickLowerIndex", (0, import_kit57.getI32Decoder)()],
    ["tickUpperIndex", (0, import_kit57.getI32Decoder)()],
    ["withTokenMetadataExtension", (0, import_kit57.getBooleanDecoder)()]
  ]);
}
function getOpenPositionWithTokenExtensionsInstructionDataCodec() {
  return (0, import_kit57.combineCodec)(
    getOpenPositionWithTokenExtensionsInstructionDataEncoder(),
    getOpenPositionWithTokenExtensionsInstructionDataDecoder()
  );
}
function getOpenPositionWithTokenExtensionsInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    funder: { value: input.funder ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false },
    position: { value: input.position ?? null, isWritable: true },
    positionMint: { value: input.positionMint ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: true
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    token2022Program: {
      value: input.token2022Program ?? null,
      isWritable: false
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false
    },
    metadataUpdateAuth: {
      value: input.metadataUpdateAuth ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionMint),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.token2022Program),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.metadataUpdateAuth)
    ],
    programAddress,
    data: getOpenPositionWithTokenExtensionsInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseOpenPositionWithTokenExtensionsInstruction(instruction) {
  if (instruction.accounts.length < 10) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      funder: getNextAccount(),
      owner: getNextAccount(),
      position: getNextAccount(),
      positionMint: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      whirlpool: getNextAccount(),
      token2022Program: getNextAccount(),
      systemProgram: getNextAccount(),
      associatedTokenProgram: getNextAccount(),
      metadataUpdateAuth: getNextAccount()
    },
    data: getOpenPositionWithTokenExtensionsInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/resetPositionRange.ts
var import_kit58 = require("@solana/kit");
var RESET_POSITION_RANGE_DISCRIMINATOR = new Uint8Array([
  164,
  123,
  180,
  141,
  194,
  100,
  160,
  175
]);
function getResetPositionRangeDiscriminatorBytes() {
  return (0, import_kit58.fixEncoderSize)((0, import_kit58.getBytesEncoder)(), 8).encode(
    RESET_POSITION_RANGE_DISCRIMINATOR
  );
}
function getResetPositionRangeInstructionDataEncoder() {
  return (0, import_kit58.transformEncoder)(
    (0, import_kit58.getStructEncoder)([
      ["discriminator", (0, import_kit58.fixEncoderSize)((0, import_kit58.getBytesEncoder)(), 8)],
      ["newTickLowerIndex", (0, import_kit58.getI32Encoder)()],
      ["newTickUpperIndex", (0, import_kit58.getI32Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: RESET_POSITION_RANGE_DISCRIMINATOR })
  );
}
function getResetPositionRangeInstructionDataDecoder() {
  return (0, import_kit58.getStructDecoder)([
    ["discriminator", (0, import_kit58.fixDecoderSize)((0, import_kit58.getBytesDecoder)(), 8)],
    ["newTickLowerIndex", (0, import_kit58.getI32Decoder)()],
    ["newTickUpperIndex", (0, import_kit58.getI32Decoder)()]
  ]);
}
function getResetPositionRangeInstructionDataCodec() {
  return (0, import_kit58.combineCodec)(
    getResetPositionRangeInstructionDataEncoder(),
    getResetPositionRangeInstructionDataDecoder()
  );
}
function getResetPositionRangeInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    funder: { value: input.funder ?? null, isWritable: true },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getResetPositionRangeInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseResetPositionRangeInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      funder: getNextAccount(),
      positionAuthority: getNextAccount(),
      whirlpool: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getResetPositionRangeInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setCollectProtocolFeesAuthority.ts
var import_kit59 = require("@solana/kit");
var SET_COLLECT_PROTOCOL_FEES_AUTHORITY_DISCRIMINATOR = new Uint8Array(
  [34, 150, 93, 244, 139, 225, 233, 67]
);
function getSetCollectProtocolFeesAuthorityDiscriminatorBytes() {
  return (0, import_kit59.fixEncoderSize)((0, import_kit59.getBytesEncoder)(), 8).encode(
    SET_COLLECT_PROTOCOL_FEES_AUTHORITY_DISCRIMINATOR
  );
}
function getSetCollectProtocolFeesAuthorityInstructionDataEncoder() {
  return (0, import_kit59.transformEncoder)(
    (0, import_kit59.getStructEncoder)([["discriminator", (0, import_kit59.fixEncoderSize)((0, import_kit59.getBytesEncoder)(), 8)]]),
    (value) => ({
      ...value,
      discriminator: SET_COLLECT_PROTOCOL_FEES_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getSetCollectProtocolFeesAuthorityInstructionDataDecoder() {
  return (0, import_kit59.getStructDecoder)([
    ["discriminator", (0, import_kit59.fixDecoderSize)((0, import_kit59.getBytesDecoder)(), 8)]
  ]);
}
function getSetCollectProtocolFeesAuthorityInstructionDataCodec() {
  return (0, import_kit59.combineCodec)(
    getSetCollectProtocolFeesAuthorityInstructionDataEncoder(),
    getSetCollectProtocolFeesAuthorityInstructionDataDecoder()
  );
}
function getSetCollectProtocolFeesAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: true
    },
    collectProtocolFeesAuthority: {
      value: input.collectProtocolFeesAuthority ?? null,
      isWritable: false
    },
    newCollectProtocolFeesAuthority: {
      value: input.newCollectProtocolFeesAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.collectProtocolFeesAuthority),
      getAccountMeta(accounts.newCollectProtocolFeesAuthority)
    ],
    programAddress,
    data: getSetCollectProtocolFeesAuthorityInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseSetCollectProtocolFeesAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      collectProtocolFeesAuthority: getNextAccount(),
      newCollectProtocolFeesAuthority: getNextAccount()
    },
    data: getSetCollectProtocolFeesAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setConfigExtensionAuthority.ts
var import_kit60 = require("@solana/kit");
var SET_CONFIG_EXTENSION_AUTHORITY_DISCRIMINATOR = new Uint8Array([
  44,
  94,
  241,
  116,
  24,
  188,
  60,
  143
]);
function getSetConfigExtensionAuthorityDiscriminatorBytes() {
  return (0, import_kit60.fixEncoderSize)((0, import_kit60.getBytesEncoder)(), 8).encode(
    SET_CONFIG_EXTENSION_AUTHORITY_DISCRIMINATOR
  );
}
function getSetConfigExtensionAuthorityInstructionDataEncoder() {
  return (0, import_kit60.transformEncoder)(
    (0, import_kit60.getStructEncoder)([["discriminator", (0, import_kit60.fixEncoderSize)((0, import_kit60.getBytesEncoder)(), 8)]]),
    (value) => ({
      ...value,
      discriminator: SET_CONFIG_EXTENSION_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getSetConfigExtensionAuthorityInstructionDataDecoder() {
  return (0, import_kit60.getStructDecoder)([
    ["discriminator", (0, import_kit60.fixDecoderSize)((0, import_kit60.getBytesDecoder)(), 8)]
  ]);
}
function getSetConfigExtensionAuthorityInstructionDataCodec() {
  return (0, import_kit60.combineCodec)(
    getSetConfigExtensionAuthorityInstructionDataEncoder(),
    getSetConfigExtensionAuthorityInstructionDataDecoder()
  );
}
function getSetConfigExtensionAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpoolsConfigExtension: {
      value: input.whirlpoolsConfigExtension ?? null,
      isWritable: true
    },
    configExtensionAuthority: {
      value: input.configExtensionAuthority ?? null,
      isWritable: false
    },
    newConfigExtensionAuthority: {
      value: input.newConfigExtensionAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpoolsConfigExtension),
      getAccountMeta(accounts.configExtensionAuthority),
      getAccountMeta(accounts.newConfigExtensionAuthority)
    ],
    programAddress,
    data: getSetConfigExtensionAuthorityInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseSetConfigExtensionAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpoolsConfigExtension: getNextAccount(),
      configExtensionAuthority: getNextAccount(),
      newConfigExtensionAuthority: getNextAccount()
    },
    data: getSetConfigExtensionAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setDefaultBaseFeeRate.ts
var import_kit61 = require("@solana/kit");
var SET_DEFAULT_BASE_FEE_RATE_DISCRIMINATOR = new Uint8Array([
  229,
  66,
  84,
  251,
  164,
  134,
  183,
  7
]);
function getSetDefaultBaseFeeRateDiscriminatorBytes() {
  return (0, import_kit61.fixEncoderSize)((0, import_kit61.getBytesEncoder)(), 8).encode(
    SET_DEFAULT_BASE_FEE_RATE_DISCRIMINATOR
  );
}
function getSetDefaultBaseFeeRateInstructionDataEncoder() {
  return (0, import_kit61.transformEncoder)(
    (0, import_kit61.getStructEncoder)([
      ["discriminator", (0, import_kit61.fixEncoderSize)((0, import_kit61.getBytesEncoder)(), 8)],
      ["defaultBaseFeeRate", (0, import_kit61.getU16Encoder)()]
    ]),
    (value) => ({
      ...value,
      discriminator: SET_DEFAULT_BASE_FEE_RATE_DISCRIMINATOR
    })
  );
}
function getSetDefaultBaseFeeRateInstructionDataDecoder() {
  return (0, import_kit61.getStructDecoder)([
    ["discriminator", (0, import_kit61.fixDecoderSize)((0, import_kit61.getBytesDecoder)(), 8)],
    ["defaultBaseFeeRate", (0, import_kit61.getU16Decoder)()]
  ]);
}
function getSetDefaultBaseFeeRateInstructionDataCodec() {
  return (0, import_kit61.combineCodec)(
    getSetDefaultBaseFeeRateInstructionDataEncoder(),
    getSetDefaultBaseFeeRateInstructionDataDecoder()
  );
}
function getSetDefaultBaseFeeRateInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    adaptiveFeeTier: { value: input.adaptiveFeeTier ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.adaptiveFeeTier),
      getAccountMeta(accounts.feeAuthority)
    ],
    programAddress,
    data: getSetDefaultBaseFeeRateInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetDefaultBaseFeeRateInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      adaptiveFeeTier: getNextAccount(),
      feeAuthority: getNextAccount()
    },
    data: getSetDefaultBaseFeeRateInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setDefaultFeeRate.ts
var import_kit62 = require("@solana/kit");
var SET_DEFAULT_FEE_RATE_DISCRIMINATOR = new Uint8Array([
  118,
  215,
  214,
  157,
  182,
  229,
  208,
  228
]);
function getSetDefaultFeeRateDiscriminatorBytes() {
  return (0, import_kit62.fixEncoderSize)((0, import_kit62.getBytesEncoder)(), 8).encode(
    SET_DEFAULT_FEE_RATE_DISCRIMINATOR
  );
}
function getSetDefaultFeeRateInstructionDataEncoder() {
  return (0, import_kit62.transformEncoder)(
    (0, import_kit62.getStructEncoder)([
      ["discriminator", (0, import_kit62.fixEncoderSize)((0, import_kit62.getBytesEncoder)(), 8)],
      ["defaultFeeRate", (0, import_kit62.getU16Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: SET_DEFAULT_FEE_RATE_DISCRIMINATOR })
  );
}
function getSetDefaultFeeRateInstructionDataDecoder() {
  return (0, import_kit62.getStructDecoder)([
    ["discriminator", (0, import_kit62.fixDecoderSize)((0, import_kit62.getBytesDecoder)(), 8)],
    ["defaultFeeRate", (0, import_kit62.getU16Decoder)()]
  ]);
}
function getSetDefaultFeeRateInstructionDataCodec() {
  return (0, import_kit62.combineCodec)(
    getSetDefaultFeeRateInstructionDataEncoder(),
    getSetDefaultFeeRateInstructionDataDecoder()
  );
}
function getSetDefaultFeeRateInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    feeTier: { value: input.feeTier ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.feeTier),
      getAccountMeta(accounts.feeAuthority)
    ],
    programAddress,
    data: getSetDefaultFeeRateInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetDefaultFeeRateInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      feeTier: getNextAccount(),
      feeAuthority: getNextAccount()
    },
    data: getSetDefaultFeeRateInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/setDefaultProtocolFeeRate.ts
var import_kit63 = require("@solana/kit");
var SET_DEFAULT_PROTOCOL_FEE_RATE_DISCRIMINATOR = new Uint8Array([
  107,
  205,
  249,
  226,
  151,
  35,
  86,
  0
]);
function getSetDefaultProtocolFeeRateDiscriminatorBytes() {
  return (0, import_kit63.fixEncoderSize)((0, import_kit63.getBytesEncoder)(), 8).encode(
    SET_DEFAULT_PROTOCOL_FEE_RATE_DISCRIMINATOR
  );
}
function getSetDefaultProtocolFeeRateInstructionDataEncoder() {
  return (0, import_kit63.transformEncoder)(
    (0, import_kit63.getStructEncoder)([
      ["discriminator", (0, import_kit63.fixEncoderSize)((0, import_kit63.getBytesEncoder)(), 8)],
      ["defaultProtocolFeeRate", (0, import_kit63.getU16Encoder)()]
    ]),
    (value) => ({
      ...value,
      discriminator: SET_DEFAULT_PROTOCOL_FEE_RATE_DISCRIMINATOR
    })
  );
}
function getSetDefaultProtocolFeeRateInstructionDataDecoder() {
  return (0, import_kit63.getStructDecoder)([
    ["discriminator", (0, import_kit63.fixDecoderSize)((0, import_kit63.getBytesDecoder)(), 8)],
    ["defaultProtocolFeeRate", (0, import_kit63.getU16Decoder)()]
  ]);
}
function getSetDefaultProtocolFeeRateInstructionDataCodec() {
  return (0, import_kit63.combineCodec)(
    getSetDefaultProtocolFeeRateInstructionDataEncoder(),
    getSetDefaultProtocolFeeRateInstructionDataDecoder()
  );
}
function getSetDefaultProtocolFeeRateInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: true
    },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.feeAuthority)
    ],
    programAddress,
    data: getSetDefaultProtocolFeeRateInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetDefaultProtocolFeeRateInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      feeAuthority: getNextAccount()
    },
    data: getSetDefaultProtocolFeeRateInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setDelegatedFeeAuthority.ts
var import_kit64 = require("@solana/kit");
var SET_DELEGATED_FEE_AUTHORITY_DISCRIMINATOR = new Uint8Array([
  193,
  234,
  231,
  147,
  138,
  57,
  3,
  122
]);
function getSetDelegatedFeeAuthorityDiscriminatorBytes() {
  return (0, import_kit64.fixEncoderSize)((0, import_kit64.getBytesEncoder)(), 8).encode(
    SET_DELEGATED_FEE_AUTHORITY_DISCRIMINATOR
  );
}
function getSetDelegatedFeeAuthorityInstructionDataEncoder() {
  return (0, import_kit64.transformEncoder)(
    (0, import_kit64.getStructEncoder)([["discriminator", (0, import_kit64.fixEncoderSize)((0, import_kit64.getBytesEncoder)(), 8)]]),
    (value) => ({
      ...value,
      discriminator: SET_DELEGATED_FEE_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getSetDelegatedFeeAuthorityInstructionDataDecoder() {
  return (0, import_kit64.getStructDecoder)([
    ["discriminator", (0, import_kit64.fixDecoderSize)((0, import_kit64.getBytesDecoder)(), 8)]
  ]);
}
function getSetDelegatedFeeAuthorityInstructionDataCodec() {
  return (0, import_kit64.combineCodec)(
    getSetDelegatedFeeAuthorityInstructionDataEncoder(),
    getSetDelegatedFeeAuthorityInstructionDataDecoder()
  );
}
function getSetDelegatedFeeAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    adaptiveFeeTier: { value: input.adaptiveFeeTier ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },
    newDelegatedFeeAuthority: {
      value: input.newDelegatedFeeAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.adaptiveFeeTier),
      getAccountMeta(accounts.feeAuthority),
      getAccountMeta(accounts.newDelegatedFeeAuthority)
    ],
    programAddress,
    data: getSetDelegatedFeeAuthorityInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseSetDelegatedFeeAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      adaptiveFeeTier: getNextAccount(),
      feeAuthority: getNextAccount(),
      newDelegatedFeeAuthority: getNextAccount()
    },
    data: getSetDelegatedFeeAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setFeeAuthority.ts
var import_kit65 = require("@solana/kit");
var SET_FEE_AUTHORITY_DISCRIMINATOR = new Uint8Array([
  31,
  1,
  50,
  87,
  237,
  101,
  97,
  132
]);
function getSetFeeAuthorityDiscriminatorBytes() {
  return (0, import_kit65.fixEncoderSize)((0, import_kit65.getBytesEncoder)(), 8).encode(
    SET_FEE_AUTHORITY_DISCRIMINATOR
  );
}
function getSetFeeAuthorityInstructionDataEncoder() {
  return (0, import_kit65.transformEncoder)(
    (0, import_kit65.getStructEncoder)([["discriminator", (0, import_kit65.fixEncoderSize)((0, import_kit65.getBytesEncoder)(), 8)]]),
    (value) => ({ ...value, discriminator: SET_FEE_AUTHORITY_DISCRIMINATOR })
  );
}
function getSetFeeAuthorityInstructionDataDecoder() {
  return (0, import_kit65.getStructDecoder)([
    ["discriminator", (0, import_kit65.fixDecoderSize)((0, import_kit65.getBytesDecoder)(), 8)]
  ]);
}
function getSetFeeAuthorityInstructionDataCodec() {
  return (0, import_kit65.combineCodec)(
    getSetFeeAuthorityInstructionDataEncoder(),
    getSetFeeAuthorityInstructionDataDecoder()
  );
}
function getSetFeeAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: true
    },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },
    newFeeAuthority: {
      value: input.newFeeAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.feeAuthority),
      getAccountMeta(accounts.newFeeAuthority)
    ],
    programAddress,
    data: getSetFeeAuthorityInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseSetFeeAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      feeAuthority: getNextAccount(),
      newFeeAuthority: getNextAccount()
    },
    data: getSetFeeAuthorityInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/setFeeRate.ts
var import_kit66 = require("@solana/kit");
var SET_FEE_RATE_DISCRIMINATOR = new Uint8Array([
  53,
  243,
  137,
  65,
  8,
  140,
  158,
  6
]);
function getSetFeeRateDiscriminatorBytes() {
  return (0, import_kit66.fixEncoderSize)((0, import_kit66.getBytesEncoder)(), 8).encode(
    SET_FEE_RATE_DISCRIMINATOR
  );
}
function getSetFeeRateInstructionDataEncoder() {
  return (0, import_kit66.transformEncoder)(
    (0, import_kit66.getStructEncoder)([
      ["discriminator", (0, import_kit66.fixEncoderSize)((0, import_kit66.getBytesEncoder)(), 8)],
      ["feeRate", (0, import_kit66.getU16Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: SET_FEE_RATE_DISCRIMINATOR })
  );
}
function getSetFeeRateInstructionDataDecoder() {
  return (0, import_kit66.getStructDecoder)([
    ["discriminator", (0, import_kit66.fixDecoderSize)((0, import_kit66.getBytesDecoder)(), 8)],
    ["feeRate", (0, import_kit66.getU16Decoder)()]
  ]);
}
function getSetFeeRateInstructionDataCodec() {
  return (0, import_kit66.combineCodec)(
    getSetFeeRateInstructionDataEncoder(),
    getSetFeeRateInstructionDataDecoder()
  );
}
function getSetFeeRateInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.feeAuthority)
    ],
    programAddress,
    data: getSetFeeRateInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetFeeRateInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpool: getNextAccount(),
      feeAuthority: getNextAccount()
    },
    data: getSetFeeRateInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/setFeeRateByDelegatedFeeAuthority.ts
var import_kit67 = require("@solana/kit");
var SET_FEE_RATE_BY_DELEGATED_FEE_AUTHORITY_DISCRIMINATOR = new Uint8Array([121, 121, 54, 114, 131, 230, 162, 104]);
function getSetFeeRateByDelegatedFeeAuthorityDiscriminatorBytes() {
  return (0, import_kit67.fixEncoderSize)((0, import_kit67.getBytesEncoder)(), 8).encode(
    SET_FEE_RATE_BY_DELEGATED_FEE_AUTHORITY_DISCRIMINATOR
  );
}
function getSetFeeRateByDelegatedFeeAuthorityInstructionDataEncoder() {
  return (0, import_kit67.transformEncoder)(
    (0, import_kit67.getStructEncoder)([
      ["discriminator", (0, import_kit67.fixEncoderSize)((0, import_kit67.getBytesEncoder)(), 8)],
      ["feeRate", (0, import_kit67.getU16Encoder)()]
    ]),
    (value) => ({
      ...value,
      discriminator: SET_FEE_RATE_BY_DELEGATED_FEE_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getSetFeeRateByDelegatedFeeAuthorityInstructionDataDecoder() {
  return (0, import_kit67.getStructDecoder)([
    ["discriminator", (0, import_kit67.fixDecoderSize)((0, import_kit67.getBytesDecoder)(), 8)],
    ["feeRate", (0, import_kit67.getU16Decoder)()]
  ]);
}
function getSetFeeRateByDelegatedFeeAuthorityInstructionDataCodec() {
  return (0, import_kit67.combineCodec)(
    getSetFeeRateByDelegatedFeeAuthorityInstructionDataEncoder(),
    getSetFeeRateByDelegatedFeeAuthorityInstructionDataDecoder()
  );
}
function getSetFeeRateByDelegatedFeeAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    adaptiveFeeTier: {
      value: input.adaptiveFeeTier ?? null,
      isWritable: false
    },
    delegatedFeeAuthority: {
      value: input.delegatedFeeAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.adaptiveFeeTier),
      getAccountMeta(accounts.delegatedFeeAuthority)
    ],
    programAddress,
    data: getSetFeeRateByDelegatedFeeAuthorityInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetFeeRateByDelegatedFeeAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      adaptiveFeeTier: getNextAccount(),
      delegatedFeeAuthority: getNextAccount()
    },
    data: getSetFeeRateByDelegatedFeeAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setInitializePoolAuthority.ts
var import_kit68 = require("@solana/kit");
var SET_INITIALIZE_POOL_AUTHORITY_DISCRIMINATOR = new Uint8Array([
  125,
  43,
  127,
  235,
  149,
  26,
  106,
  236
]);
function getSetInitializePoolAuthorityDiscriminatorBytes() {
  return (0, import_kit68.fixEncoderSize)((0, import_kit68.getBytesEncoder)(), 8).encode(
    SET_INITIALIZE_POOL_AUTHORITY_DISCRIMINATOR
  );
}
function getSetInitializePoolAuthorityInstructionDataEncoder() {
  return (0, import_kit68.transformEncoder)(
    (0, import_kit68.getStructEncoder)([["discriminator", (0, import_kit68.fixEncoderSize)((0, import_kit68.getBytesEncoder)(), 8)]]),
    (value) => ({
      ...value,
      discriminator: SET_INITIALIZE_POOL_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getSetInitializePoolAuthorityInstructionDataDecoder() {
  return (0, import_kit68.getStructDecoder)([
    ["discriminator", (0, import_kit68.fixDecoderSize)((0, import_kit68.getBytesDecoder)(), 8)]
  ]);
}
function getSetInitializePoolAuthorityInstructionDataCodec() {
  return (0, import_kit68.combineCodec)(
    getSetInitializePoolAuthorityInstructionDataEncoder(),
    getSetInitializePoolAuthorityInstructionDataDecoder()
  );
}
function getSetInitializePoolAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    adaptiveFeeTier: { value: input.adaptiveFeeTier ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },
    newInitializePoolAuthority: {
      value: input.newInitializePoolAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.adaptiveFeeTier),
      getAccountMeta(accounts.feeAuthority),
      getAccountMeta(accounts.newInitializePoolAuthority)
    ],
    programAddress,
    data: getSetInitializePoolAuthorityInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseSetInitializePoolAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      adaptiveFeeTier: getNextAccount(),
      feeAuthority: getNextAccount(),
      newInitializePoolAuthority: getNextAccount()
    },
    data: getSetInitializePoolAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setPresetAdaptiveFeeConstants.ts
var import_kit69 = require("@solana/kit");
var SET_PRESET_ADAPTIVE_FEE_CONSTANTS_DISCRIMINATOR = new Uint8Array([
  132,
  185,
  66,
  148,
  83,
  88,
  134,
  198
]);
function getSetPresetAdaptiveFeeConstantsDiscriminatorBytes() {
  return (0, import_kit69.fixEncoderSize)((0, import_kit69.getBytesEncoder)(), 8).encode(
    SET_PRESET_ADAPTIVE_FEE_CONSTANTS_DISCRIMINATOR
  );
}
function getSetPresetAdaptiveFeeConstantsInstructionDataEncoder() {
  return (0, import_kit69.transformEncoder)(
    (0, import_kit69.getStructEncoder)([
      ["discriminator", (0, import_kit69.fixEncoderSize)((0, import_kit69.getBytesEncoder)(), 8)],
      ["filterPeriod", (0, import_kit69.getU16Encoder)()],
      ["decayPeriod", (0, import_kit69.getU16Encoder)()],
      ["reductionFactor", (0, import_kit69.getU16Encoder)()],
      ["adaptiveFeeControlFactor", (0, import_kit69.getU32Encoder)()],
      ["maxVolatilityAccumulator", (0, import_kit69.getU32Encoder)()],
      ["tickGroupSize", (0, import_kit69.getU16Encoder)()],
      ["majorSwapThresholdTicks", (0, import_kit69.getU16Encoder)()]
    ]),
    (value) => ({
      ...value,
      discriminator: SET_PRESET_ADAPTIVE_FEE_CONSTANTS_DISCRIMINATOR
    })
  );
}
function getSetPresetAdaptiveFeeConstantsInstructionDataDecoder() {
  return (0, import_kit69.getStructDecoder)([
    ["discriminator", (0, import_kit69.fixDecoderSize)((0, import_kit69.getBytesDecoder)(), 8)],
    ["filterPeriod", (0, import_kit69.getU16Decoder)()],
    ["decayPeriod", (0, import_kit69.getU16Decoder)()],
    ["reductionFactor", (0, import_kit69.getU16Decoder)()],
    ["adaptiveFeeControlFactor", (0, import_kit69.getU32Decoder)()],
    ["maxVolatilityAccumulator", (0, import_kit69.getU32Decoder)()],
    ["tickGroupSize", (0, import_kit69.getU16Decoder)()],
    ["majorSwapThresholdTicks", (0, import_kit69.getU16Decoder)()]
  ]);
}
function getSetPresetAdaptiveFeeConstantsInstructionDataCodec() {
  return (0, import_kit69.combineCodec)(
    getSetPresetAdaptiveFeeConstantsInstructionDataEncoder(),
    getSetPresetAdaptiveFeeConstantsInstructionDataDecoder()
  );
}
function getSetPresetAdaptiveFeeConstantsInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    adaptiveFeeTier: { value: input.adaptiveFeeTier ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.adaptiveFeeTier),
      getAccountMeta(accounts.feeAuthority)
    ],
    programAddress,
    data: getSetPresetAdaptiveFeeConstantsInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetPresetAdaptiveFeeConstantsInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      adaptiveFeeTier: getNextAccount(),
      feeAuthority: getNextAccount()
    },
    data: getSetPresetAdaptiveFeeConstantsInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setProtocolFeeRate.ts
var import_kit70 = require("@solana/kit");
var SET_PROTOCOL_FEE_RATE_DISCRIMINATOR = new Uint8Array([
  95,
  7,
  4,
  50,
  154,
  79,
  156,
  131
]);
function getSetProtocolFeeRateDiscriminatorBytes() {
  return (0, import_kit70.fixEncoderSize)((0, import_kit70.getBytesEncoder)(), 8).encode(
    SET_PROTOCOL_FEE_RATE_DISCRIMINATOR
  );
}
function getSetProtocolFeeRateInstructionDataEncoder() {
  return (0, import_kit70.transformEncoder)(
    (0, import_kit70.getStructEncoder)([
      ["discriminator", (0, import_kit70.fixEncoderSize)((0, import_kit70.getBytesEncoder)(), 8)],
      ["protocolFeeRate", (0, import_kit70.getU16Encoder)()]
    ]),
    (value) => ({
      ...value,
      discriminator: SET_PROTOCOL_FEE_RATE_DISCRIMINATOR
    })
  );
}
function getSetProtocolFeeRateInstructionDataDecoder() {
  return (0, import_kit70.getStructDecoder)([
    ["discriminator", (0, import_kit70.fixDecoderSize)((0, import_kit70.getBytesDecoder)(), 8)],
    ["protocolFeeRate", (0, import_kit70.getU16Decoder)()]
  ]);
}
function getSetProtocolFeeRateInstructionDataCodec() {
  return (0, import_kit70.combineCodec)(
    getSetProtocolFeeRateInstructionDataEncoder(),
    getSetProtocolFeeRateInstructionDataDecoder()
  );
}
function getSetProtocolFeeRateInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.feeAuthority)
    ],
    programAddress,
    data: getSetProtocolFeeRateInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetProtocolFeeRateInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpool: getNextAccount(),
      feeAuthority: getNextAccount()
    },
    data: getSetProtocolFeeRateInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setRewardAuthority.ts
var import_kit71 = require("@solana/kit");
var SET_REWARD_AUTHORITY_DISCRIMINATOR = new Uint8Array([
  34,
  39,
  183,
  252,
  83,
  28,
  85,
  127
]);
function getSetRewardAuthorityDiscriminatorBytes() {
  return (0, import_kit71.fixEncoderSize)((0, import_kit71.getBytesEncoder)(), 8).encode(
    SET_REWARD_AUTHORITY_DISCRIMINATOR
  );
}
function getSetRewardAuthorityInstructionDataEncoder() {
  return (0, import_kit71.transformEncoder)(
    (0, import_kit71.getStructEncoder)([
      ["discriminator", (0, import_kit71.fixEncoderSize)((0, import_kit71.getBytesEncoder)(), 8)],
      ["rewardIndex", (0, import_kit71.getU8Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: SET_REWARD_AUTHORITY_DISCRIMINATOR })
  );
}
function getSetRewardAuthorityInstructionDataDecoder() {
  return (0, import_kit71.getStructDecoder)([
    ["discriminator", (0, import_kit71.fixDecoderSize)((0, import_kit71.getBytesDecoder)(), 8)],
    ["rewardIndex", (0, import_kit71.getU8Decoder)()]
  ]);
}
function getSetRewardAuthorityInstructionDataCodec() {
  return (0, import_kit71.combineCodec)(
    getSetRewardAuthorityInstructionDataEncoder(),
    getSetRewardAuthorityInstructionDataDecoder()
  );
}
function getSetRewardAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    rewardAuthority: {
      value: input.rewardAuthority ?? null,
      isWritable: false
    },
    newRewardAuthority: {
      value: input.newRewardAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.rewardAuthority),
      getAccountMeta(accounts.newRewardAuthority)
    ],
    programAddress,
    data: getSetRewardAuthorityInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetRewardAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      rewardAuthority: getNextAccount(),
      newRewardAuthority: getNextAccount()
    },
    data: getSetRewardAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setRewardAuthorityBySuperAuthority.ts
var import_kit72 = require("@solana/kit");
var SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_DISCRIMINATOR = new Uint8Array([240, 154, 201, 198, 148, 93, 56, 25]);
function getSetRewardAuthorityBySuperAuthorityDiscriminatorBytes() {
  return (0, import_kit72.fixEncoderSize)((0, import_kit72.getBytesEncoder)(), 8).encode(
    SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_DISCRIMINATOR
  );
}
function getSetRewardAuthorityBySuperAuthorityInstructionDataEncoder() {
  return (0, import_kit72.transformEncoder)(
    (0, import_kit72.getStructEncoder)([
      ["discriminator", (0, import_kit72.fixEncoderSize)((0, import_kit72.getBytesEncoder)(), 8)],
      ["rewardIndex", (0, import_kit72.getU8Encoder)()]
    ]),
    (value) => ({
      ...value,
      discriminator: SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getSetRewardAuthorityBySuperAuthorityInstructionDataDecoder() {
  return (0, import_kit72.getStructDecoder)([
    ["discriminator", (0, import_kit72.fixDecoderSize)((0, import_kit72.getBytesDecoder)(), 8)],
    ["rewardIndex", (0, import_kit72.getU8Decoder)()]
  ]);
}
function getSetRewardAuthorityBySuperAuthorityInstructionDataCodec() {
  return (0, import_kit72.combineCodec)(
    getSetRewardAuthorityBySuperAuthorityInstructionDataEncoder(),
    getSetRewardAuthorityBySuperAuthorityInstructionDataDecoder()
  );
}
function getSetRewardAuthorityBySuperAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    rewardEmissionsSuperAuthority: {
      value: input.rewardEmissionsSuperAuthority ?? null,
      isWritable: false
    },
    newRewardAuthority: {
      value: input.newRewardAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.rewardEmissionsSuperAuthority),
      getAccountMeta(accounts.newRewardAuthority)
    ],
    programAddress,
    data: getSetRewardAuthorityBySuperAuthorityInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetRewardAuthorityBySuperAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpool: getNextAccount(),
      rewardEmissionsSuperAuthority: getNextAccount(),
      newRewardAuthority: getNextAccount()
    },
    data: getSetRewardAuthorityBySuperAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setRewardEmissions.ts
var import_kit73 = require("@solana/kit");
var SET_REWARD_EMISSIONS_DISCRIMINATOR = new Uint8Array([
  13,
  197,
  86,
  168,
  109,
  176,
  27,
  244
]);
function getSetRewardEmissionsDiscriminatorBytes() {
  return (0, import_kit73.fixEncoderSize)((0, import_kit73.getBytesEncoder)(), 8).encode(
    SET_REWARD_EMISSIONS_DISCRIMINATOR
  );
}
function getSetRewardEmissionsInstructionDataEncoder() {
  return (0, import_kit73.transformEncoder)(
    (0, import_kit73.getStructEncoder)([
      ["discriminator", (0, import_kit73.fixEncoderSize)((0, import_kit73.getBytesEncoder)(), 8)],
      ["rewardIndex", (0, import_kit73.getU8Encoder)()],
      ["emissionsPerSecondX64", (0, import_kit73.getU128Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: SET_REWARD_EMISSIONS_DISCRIMINATOR })
  );
}
function getSetRewardEmissionsInstructionDataDecoder() {
  return (0, import_kit73.getStructDecoder)([
    ["discriminator", (0, import_kit73.fixDecoderSize)((0, import_kit73.getBytesDecoder)(), 8)],
    ["rewardIndex", (0, import_kit73.getU8Decoder)()],
    ["emissionsPerSecondX64", (0, import_kit73.getU128Decoder)()]
  ]);
}
function getSetRewardEmissionsInstructionDataCodec() {
  return (0, import_kit73.combineCodec)(
    getSetRewardEmissionsInstructionDataEncoder(),
    getSetRewardEmissionsInstructionDataDecoder()
  );
}
function getSetRewardEmissionsInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    rewardAuthority: {
      value: input.rewardAuthority ?? null,
      isWritable: false
    },
    rewardVault: { value: input.rewardVault ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.rewardAuthority),
      getAccountMeta(accounts.rewardVault)
    ],
    programAddress,
    data: getSetRewardEmissionsInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetRewardEmissionsInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      rewardAuthority: getNextAccount(),
      rewardVault: getNextAccount()
    },
    data: getSetRewardEmissionsInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setRewardEmissionsSuperAuthority.ts
var import_kit74 = require("@solana/kit");
var SET_REWARD_EMISSIONS_SUPER_AUTHORITY_DISCRIMINATOR = new Uint8Array([207, 5, 200, 209, 122, 56, 82, 183]);
function getSetRewardEmissionsSuperAuthorityDiscriminatorBytes() {
  return (0, import_kit74.fixEncoderSize)((0, import_kit74.getBytesEncoder)(), 8).encode(
    SET_REWARD_EMISSIONS_SUPER_AUTHORITY_DISCRIMINATOR
  );
}
function getSetRewardEmissionsSuperAuthorityInstructionDataEncoder() {
  return (0, import_kit74.transformEncoder)(
    (0, import_kit74.getStructEncoder)([["discriminator", (0, import_kit74.fixEncoderSize)((0, import_kit74.getBytesEncoder)(), 8)]]),
    (value) => ({
      ...value,
      discriminator: SET_REWARD_EMISSIONS_SUPER_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getSetRewardEmissionsSuperAuthorityInstructionDataDecoder() {
  return (0, import_kit74.getStructDecoder)([
    ["discriminator", (0, import_kit74.fixDecoderSize)((0, import_kit74.getBytesDecoder)(), 8)]
  ]);
}
function getSetRewardEmissionsSuperAuthorityInstructionDataCodec() {
  return (0, import_kit74.combineCodec)(
    getSetRewardEmissionsSuperAuthorityInstructionDataEncoder(),
    getSetRewardEmissionsSuperAuthorityInstructionDataDecoder()
  );
}
function getSetRewardEmissionsSuperAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: true
    },
    rewardEmissionsSuperAuthority: {
      value: input.rewardEmissionsSuperAuthority ?? null,
      isWritable: false
    },
    newRewardEmissionsSuperAuthority: {
      value: input.newRewardEmissionsSuperAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.rewardEmissionsSuperAuthority),
      getAccountMeta(accounts.newRewardEmissionsSuperAuthority)
    ],
    programAddress,
    data: getSetRewardEmissionsSuperAuthorityInstructionDataEncoder().encode(
      {}
    )
  };
  return instruction;
}
function parseSetRewardEmissionsSuperAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      rewardEmissionsSuperAuthority: getNextAccount(),
      newRewardEmissionsSuperAuthority: getNextAccount()
    },
    data: getSetRewardEmissionsSuperAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setRewardEmissionsV2.ts
var import_kit75 = require("@solana/kit");
var SET_REWARD_EMISSIONS_V2_DISCRIMINATOR = new Uint8Array([
  114,
  228,
  72,
  32,
  193,
  48,
  160,
  102
]);
function getSetRewardEmissionsV2DiscriminatorBytes() {
  return (0, import_kit75.fixEncoderSize)((0, import_kit75.getBytesEncoder)(), 8).encode(
    SET_REWARD_EMISSIONS_V2_DISCRIMINATOR
  );
}
function getSetRewardEmissionsV2InstructionDataEncoder() {
  return (0, import_kit75.transformEncoder)(
    (0, import_kit75.getStructEncoder)([
      ["discriminator", (0, import_kit75.fixEncoderSize)((0, import_kit75.getBytesEncoder)(), 8)],
      ["rewardIndex", (0, import_kit75.getU8Encoder)()],
      ["emissionsPerSecondX64", (0, import_kit75.getU128Encoder)()]
    ]),
    (value) => ({
      ...value,
      discriminator: SET_REWARD_EMISSIONS_V2_DISCRIMINATOR
    })
  );
}
function getSetRewardEmissionsV2InstructionDataDecoder() {
  return (0, import_kit75.getStructDecoder)([
    ["discriminator", (0, import_kit75.fixDecoderSize)((0, import_kit75.getBytesDecoder)(), 8)],
    ["rewardIndex", (0, import_kit75.getU8Decoder)()],
    ["emissionsPerSecondX64", (0, import_kit75.getU128Decoder)()]
  ]);
}
function getSetRewardEmissionsV2InstructionDataCodec() {
  return (0, import_kit75.combineCodec)(
    getSetRewardEmissionsV2InstructionDataEncoder(),
    getSetRewardEmissionsV2InstructionDataDecoder()
  );
}
function getSetRewardEmissionsV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    rewardAuthority: {
      value: input.rewardAuthority ?? null,
      isWritable: false
    },
    rewardVault: { value: input.rewardVault ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.rewardAuthority),
      getAccountMeta(accounts.rewardVault)
    ],
    programAddress,
    data: getSetRewardEmissionsV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetRewardEmissionsV2Instruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      rewardAuthority: getNextAccount(),
      rewardVault: getNextAccount()
    },
    data: getSetRewardEmissionsV2InstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setTokenBadgeAuthority.ts
var import_kit76 = require("@solana/kit");
var SET_TOKEN_BADGE_AUTHORITY_DISCRIMINATOR = new Uint8Array([
  207,
  202,
  4,
  32,
  205,
  79,
  13,
  178
]);
function getSetTokenBadgeAuthorityDiscriminatorBytes() {
  return (0, import_kit76.fixEncoderSize)((0, import_kit76.getBytesEncoder)(), 8).encode(
    SET_TOKEN_BADGE_AUTHORITY_DISCRIMINATOR
  );
}
function getSetTokenBadgeAuthorityInstructionDataEncoder() {
  return (0, import_kit76.transformEncoder)(
    (0, import_kit76.getStructEncoder)([["discriminator", (0, import_kit76.fixEncoderSize)((0, import_kit76.getBytesEncoder)(), 8)]]),
    (value) => ({
      ...value,
      discriminator: SET_TOKEN_BADGE_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getSetTokenBadgeAuthorityInstructionDataDecoder() {
  return (0, import_kit76.getStructDecoder)([
    ["discriminator", (0, import_kit76.fixDecoderSize)((0, import_kit76.getBytesDecoder)(), 8)]
  ]);
}
function getSetTokenBadgeAuthorityInstructionDataCodec() {
  return (0, import_kit76.combineCodec)(
    getSetTokenBadgeAuthorityInstructionDataEncoder(),
    getSetTokenBadgeAuthorityInstructionDataDecoder()
  );
}
function getSetTokenBadgeAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpoolsConfigExtension: {
      value: input.whirlpoolsConfigExtension ?? null,
      isWritable: true
    },
    configExtensionAuthority: {
      value: input.configExtensionAuthority ?? null,
      isWritable: false
    },
    newTokenBadgeAuthority: {
      value: input.newTokenBadgeAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpoolsConfigExtension),
      getAccountMeta(accounts.configExtensionAuthority),
      getAccountMeta(accounts.newTokenBadgeAuthority)
    ],
    programAddress,
    data: getSetTokenBadgeAuthorityInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseSetTokenBadgeAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpoolsConfigExtension: getNextAccount(),
      configExtensionAuthority: getNextAccount(),
      newTokenBadgeAuthority: getNextAccount()
    },
    data: getSetTokenBadgeAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/swap.ts
var import_kit77 = require("@solana/kit");
var SWAP_DISCRIMINATOR = new Uint8Array([
  248,
  198,
  158,
  145,
  225,
  117,
  135,
  200
]);
function getSwapDiscriminatorBytes() {
  return (0, import_kit77.fixEncoderSize)((0, import_kit77.getBytesEncoder)(), 8).encode(SWAP_DISCRIMINATOR);
}
function getSwapInstructionDataEncoder() {
  return (0, import_kit77.transformEncoder)(
    (0, import_kit77.getStructEncoder)([
      ["discriminator", (0, import_kit77.fixEncoderSize)((0, import_kit77.getBytesEncoder)(), 8)],
      ["amount", (0, import_kit77.getU64Encoder)()],
      ["otherAmountThreshold", (0, import_kit77.getU64Encoder)()],
      ["sqrtPriceLimit", (0, import_kit77.getU128Encoder)()],
      ["amountSpecifiedIsInput", (0, import_kit77.getBooleanEncoder)()],
      ["aToB", (0, import_kit77.getBooleanEncoder)()]
    ]),
    (value) => ({ ...value, discriminator: SWAP_DISCRIMINATOR })
  );
}
function getSwapInstructionDataDecoder() {
  return (0, import_kit77.getStructDecoder)([
    ["discriminator", (0, import_kit77.fixDecoderSize)((0, import_kit77.getBytesDecoder)(), 8)],
    ["amount", (0, import_kit77.getU64Decoder)()],
    ["otherAmountThreshold", (0, import_kit77.getU64Decoder)()],
    ["sqrtPriceLimit", (0, import_kit77.getU128Decoder)()],
    ["amountSpecifiedIsInput", (0, import_kit77.getBooleanDecoder)()],
    ["aToB", (0, import_kit77.getBooleanDecoder)()]
  ]);
}
function getSwapInstructionDataCodec() {
  return (0, import_kit77.combineCodec)(
    getSwapInstructionDataEncoder(),
    getSwapInstructionDataDecoder()
  );
}
function getSwapInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    tokenAuthority: { value: input.tokenAuthority ?? null, isWritable: false },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tickArray0: { value: input.tickArray0 ?? null, isWritable: true },
    tickArray1: { value: input.tickArray1 ?? null, isWritable: true },
    tickArray2: { value: input.tickArray2 ?? null, isWritable: true },
    oracle: { value: input.oracle ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.tokenAuthority),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tickArray0),
      getAccountMeta(accounts.tickArray1),
      getAccountMeta(accounts.tickArray2),
      getAccountMeta(accounts.oracle)
    ],
    programAddress,
    data: getSwapInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSwapInstruction(instruction) {
  if (instruction.accounts.length < 11) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      tokenProgram: getNextAccount(),
      tokenAuthority: getNextAccount(),
      whirlpool: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tickArray0: getNextAccount(),
      tickArray1: getNextAccount(),
      tickArray2: getNextAccount(),
      oracle: getNextAccount()
    },
    data: getSwapInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/swapV2.ts
var import_kit78 = require("@solana/kit");
var SWAP_V2_DISCRIMINATOR = new Uint8Array([
  43,
  4,
  237,
  11,
  26,
  201,
  30,
  98
]);
function getSwapV2DiscriminatorBytes() {
  return (0, import_kit78.fixEncoderSize)((0, import_kit78.getBytesEncoder)(), 8).encode(SWAP_V2_DISCRIMINATOR);
}
function getSwapV2InstructionDataEncoder() {
  return (0, import_kit78.transformEncoder)(
    (0, import_kit78.getStructEncoder)([
      ["discriminator", (0, import_kit78.fixEncoderSize)((0, import_kit78.getBytesEncoder)(), 8)],
      ["amount", (0, import_kit78.getU64Encoder)()],
      ["otherAmountThreshold", (0, import_kit78.getU64Encoder)()],
      ["sqrtPriceLimit", (0, import_kit78.getU128Encoder)()],
      ["amountSpecifiedIsInput", (0, import_kit78.getBooleanEncoder)()],
      ["aToB", (0, import_kit78.getBooleanEncoder)()],
      [
        "remainingAccountsInfo",
        (0, import_kit78.getOptionEncoder)(getRemainingAccountsInfoEncoder())
      ]
    ]),
    (value) => ({ ...value, discriminator: SWAP_V2_DISCRIMINATOR })
  );
}
function getSwapV2InstructionDataDecoder() {
  return (0, import_kit78.getStructDecoder)([
    ["discriminator", (0, import_kit78.fixDecoderSize)((0, import_kit78.getBytesDecoder)(), 8)],
    ["amount", (0, import_kit78.getU64Decoder)()],
    ["otherAmountThreshold", (0, import_kit78.getU64Decoder)()],
    ["sqrtPriceLimit", (0, import_kit78.getU128Decoder)()],
    ["amountSpecifiedIsInput", (0, import_kit78.getBooleanDecoder)()],
    ["aToB", (0, import_kit78.getBooleanDecoder)()],
    [
      "remainingAccountsInfo",
      (0, import_kit78.getOptionDecoder)(getRemainingAccountsInfoDecoder())
    ]
  ]);
}
function getSwapV2InstructionDataCodec() {
  return (0, import_kit78.combineCodec)(
    getSwapV2InstructionDataEncoder(),
    getSwapV2InstructionDataDecoder()
  );
}
function getSwapV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },
    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false },
    tokenAuthority: { value: input.tokenAuthority ?? null, isWritable: false },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tickArray0: { value: input.tickArray0 ?? null, isWritable: true },
    tickArray1: { value: input.tickArray1 ?? null, isWritable: true },
    tickArray2: { value: input.tickArray2 ?? null, isWritable: true },
    oracle: { value: input.oracle ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.tokenProgramA),
      getAccountMeta(accounts.tokenProgramB),
      getAccountMeta(accounts.memoProgram),
      getAccountMeta(accounts.tokenAuthority),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tickArray0),
      getAccountMeta(accounts.tickArray1),
      getAccountMeta(accounts.tickArray2),
      getAccountMeta(accounts.oracle)
    ],
    programAddress,
    data: getSwapV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSwapV2Instruction(instruction) {
  if (instruction.accounts.length < 15) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      tokenProgramA: getNextAccount(),
      tokenProgramB: getNextAccount(),
      memoProgram: getNextAccount(),
      tokenAuthority: getNextAccount(),
      whirlpool: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tickArray0: getNextAccount(),
      tickArray1: getNextAccount(),
      tickArray2: getNextAccount(),
      oracle: getNextAccount()
    },
    data: getSwapV2InstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/transferLockedPosition.ts
var import_kit79 = require("@solana/kit");
var TRANSFER_LOCKED_POSITION_DISCRIMINATOR = new Uint8Array([
  179,
  121,
  229,
  46,
  67,
  138,
  194,
  138
]);
function getTransferLockedPositionDiscriminatorBytes() {
  return (0, import_kit79.fixEncoderSize)((0, import_kit79.getBytesEncoder)(), 8).encode(
    TRANSFER_LOCKED_POSITION_DISCRIMINATOR
  );
}
function getTransferLockedPositionInstructionDataEncoder() {
  return (0, import_kit79.transformEncoder)(
    (0, import_kit79.getStructEncoder)([["discriminator", (0, import_kit79.fixEncoderSize)((0, import_kit79.getBytesEncoder)(), 8)]]),
    (value) => ({
      ...value,
      discriminator: TRANSFER_LOCKED_POSITION_DISCRIMINATOR
    })
  );
}
function getTransferLockedPositionInstructionDataDecoder() {
  return (0, import_kit79.getStructDecoder)([
    ["discriminator", (0, import_kit79.fixDecoderSize)((0, import_kit79.getBytesDecoder)(), 8)]
  ]);
}
function getTransferLockedPositionInstructionDataCodec() {
  return (0, import_kit79.combineCodec)(
    getTransferLockedPositionInstructionDataEncoder(),
    getTransferLockedPositionInstructionDataDecoder()
  );
}
function getTransferLockedPositionInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    receiver: { value: input.receiver ?? null, isWritable: true },
    position: { value: input.position ?? null, isWritable: false },
    positionMint: { value: input.positionMint ?? null, isWritable: false },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: true
    },
    destinationTokenAccount: {
      value: input.destinationTokenAccount ?? null,
      isWritable: true
    },
    lockConfig: { value: input.lockConfig ?? null, isWritable: true },
    token2022Program: {
      value: input.token2022Program ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.receiver),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionMint),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.destinationTokenAccount),
      getAccountMeta(accounts.lockConfig),
      getAccountMeta(accounts.token2022Program)
    ],
    programAddress,
    data: getTransferLockedPositionInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseTransferLockedPositionInstruction(instruction) {
  if (instruction.accounts.length < 8) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      positionAuthority: getNextAccount(),
      receiver: getNextAccount(),
      position: getNextAccount(),
      positionMint: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      destinationTokenAccount: getNextAccount(),
      lockConfig: getNextAccount(),
      token2022Program: getNextAccount()
    },
    data: getTransferLockedPositionInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/twoHopSwap.ts
var import_kit80 = require("@solana/kit");
var TWO_HOP_SWAP_DISCRIMINATOR = new Uint8Array([
  195,
  96,
  237,
  108,
  68,
  162,
  219,
  230
]);
function getTwoHopSwapDiscriminatorBytes() {
  return (0, import_kit80.fixEncoderSize)((0, import_kit80.getBytesEncoder)(), 8).encode(
    TWO_HOP_SWAP_DISCRIMINATOR
  );
}
function getTwoHopSwapInstructionDataEncoder() {
  return (0, import_kit80.transformEncoder)(
    (0, import_kit80.getStructEncoder)([
      ["discriminator", (0, import_kit80.fixEncoderSize)((0, import_kit80.getBytesEncoder)(), 8)],
      ["amount", (0, import_kit80.getU64Encoder)()],
      ["otherAmountThreshold", (0, import_kit80.getU64Encoder)()],
      ["amountSpecifiedIsInput", (0, import_kit80.getBooleanEncoder)()],
      ["aToBOne", (0, import_kit80.getBooleanEncoder)()],
      ["aToBTwo", (0, import_kit80.getBooleanEncoder)()],
      ["sqrtPriceLimitOne", (0, import_kit80.getU128Encoder)()],
      ["sqrtPriceLimitTwo", (0, import_kit80.getU128Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: TWO_HOP_SWAP_DISCRIMINATOR })
  );
}
function getTwoHopSwapInstructionDataDecoder() {
  return (0, import_kit80.getStructDecoder)([
    ["discriminator", (0, import_kit80.fixDecoderSize)((0, import_kit80.getBytesDecoder)(), 8)],
    ["amount", (0, import_kit80.getU64Decoder)()],
    ["otherAmountThreshold", (0, import_kit80.getU64Decoder)()],
    ["amountSpecifiedIsInput", (0, import_kit80.getBooleanDecoder)()],
    ["aToBOne", (0, import_kit80.getBooleanDecoder)()],
    ["aToBTwo", (0, import_kit80.getBooleanDecoder)()],
    ["sqrtPriceLimitOne", (0, import_kit80.getU128Decoder)()],
    ["sqrtPriceLimitTwo", (0, import_kit80.getU128Decoder)()]
  ]);
}
function getTwoHopSwapInstructionDataCodec() {
  return (0, import_kit80.combineCodec)(
    getTwoHopSwapInstructionDataEncoder(),
    getTwoHopSwapInstructionDataDecoder()
  );
}
function getTwoHopSwapInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    tokenAuthority: { value: input.tokenAuthority ?? null, isWritable: false },
    whirlpoolOne: { value: input.whirlpoolOne ?? null, isWritable: true },
    whirlpoolTwo: { value: input.whirlpoolTwo ?? null, isWritable: true },
    tokenOwnerAccountOneA: {
      value: input.tokenOwnerAccountOneA ?? null,
      isWritable: true
    },
    tokenVaultOneA: { value: input.tokenVaultOneA ?? null, isWritable: true },
    tokenOwnerAccountOneB: {
      value: input.tokenOwnerAccountOneB ?? null,
      isWritable: true
    },
    tokenVaultOneB: { value: input.tokenVaultOneB ?? null, isWritable: true },
    tokenOwnerAccountTwoA: {
      value: input.tokenOwnerAccountTwoA ?? null,
      isWritable: true
    },
    tokenVaultTwoA: { value: input.tokenVaultTwoA ?? null, isWritable: true },
    tokenOwnerAccountTwoB: {
      value: input.tokenOwnerAccountTwoB ?? null,
      isWritable: true
    },
    tokenVaultTwoB: { value: input.tokenVaultTwoB ?? null, isWritable: true },
    tickArrayOne0: { value: input.tickArrayOne0 ?? null, isWritable: true },
    tickArrayOne1: { value: input.tickArrayOne1 ?? null, isWritable: true },
    tickArrayOne2: { value: input.tickArrayOne2 ?? null, isWritable: true },
    tickArrayTwo0: { value: input.tickArrayTwo0 ?? null, isWritable: true },
    tickArrayTwo1: { value: input.tickArrayTwo1 ?? null, isWritable: true },
    tickArrayTwo2: { value: input.tickArrayTwo2 ?? null, isWritable: true },
    oracleOne: { value: input.oracleOne ?? null, isWritable: false },
    oracleTwo: { value: input.oracleTwo ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.tokenAuthority),
      getAccountMeta(accounts.whirlpoolOne),
      getAccountMeta(accounts.whirlpoolTwo),
      getAccountMeta(accounts.tokenOwnerAccountOneA),
      getAccountMeta(accounts.tokenVaultOneA),
      getAccountMeta(accounts.tokenOwnerAccountOneB),
      getAccountMeta(accounts.tokenVaultOneB),
      getAccountMeta(accounts.tokenOwnerAccountTwoA),
      getAccountMeta(accounts.tokenVaultTwoA),
      getAccountMeta(accounts.tokenOwnerAccountTwoB),
      getAccountMeta(accounts.tokenVaultTwoB),
      getAccountMeta(accounts.tickArrayOne0),
      getAccountMeta(accounts.tickArrayOne1),
      getAccountMeta(accounts.tickArrayOne2),
      getAccountMeta(accounts.tickArrayTwo0),
      getAccountMeta(accounts.tickArrayTwo1),
      getAccountMeta(accounts.tickArrayTwo2),
      getAccountMeta(accounts.oracleOne),
      getAccountMeta(accounts.oracleTwo)
    ],
    programAddress,
    data: getTwoHopSwapInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseTwoHopSwapInstruction(instruction) {
  if (instruction.accounts.length < 20) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      tokenProgram: getNextAccount(),
      tokenAuthority: getNextAccount(),
      whirlpoolOne: getNextAccount(),
      whirlpoolTwo: getNextAccount(),
      tokenOwnerAccountOneA: getNextAccount(),
      tokenVaultOneA: getNextAccount(),
      tokenOwnerAccountOneB: getNextAccount(),
      tokenVaultOneB: getNextAccount(),
      tokenOwnerAccountTwoA: getNextAccount(),
      tokenVaultTwoA: getNextAccount(),
      tokenOwnerAccountTwoB: getNextAccount(),
      tokenVaultTwoB: getNextAccount(),
      tickArrayOne0: getNextAccount(),
      tickArrayOne1: getNextAccount(),
      tickArrayOne2: getNextAccount(),
      tickArrayTwo0: getNextAccount(),
      tickArrayTwo1: getNextAccount(),
      tickArrayTwo2: getNextAccount(),
      oracleOne: getNextAccount(),
      oracleTwo: getNextAccount()
    },
    data: getTwoHopSwapInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/twoHopSwapV2.ts
var import_kit81 = require("@solana/kit");
var TWO_HOP_SWAP_V2_DISCRIMINATOR = new Uint8Array([
  186,
  143,
  209,
  29,
  254,
  2,
  194,
  117
]);
function getTwoHopSwapV2DiscriminatorBytes() {
  return (0, import_kit81.fixEncoderSize)((0, import_kit81.getBytesEncoder)(), 8).encode(
    TWO_HOP_SWAP_V2_DISCRIMINATOR
  );
}
function getTwoHopSwapV2InstructionDataEncoder() {
  return (0, import_kit81.transformEncoder)(
    (0, import_kit81.getStructEncoder)([
      ["discriminator", (0, import_kit81.fixEncoderSize)((0, import_kit81.getBytesEncoder)(), 8)],
      ["amount", (0, import_kit81.getU64Encoder)()],
      ["otherAmountThreshold", (0, import_kit81.getU64Encoder)()],
      ["amountSpecifiedIsInput", (0, import_kit81.getBooleanEncoder)()],
      ["aToBOne", (0, import_kit81.getBooleanEncoder)()],
      ["aToBTwo", (0, import_kit81.getBooleanEncoder)()],
      ["sqrtPriceLimitOne", (0, import_kit81.getU128Encoder)()],
      ["sqrtPriceLimitTwo", (0, import_kit81.getU128Encoder)()],
      [
        "remainingAccountsInfo",
        (0, import_kit81.getOptionEncoder)(getRemainingAccountsInfoEncoder())
      ]
    ]),
    (value) => ({ ...value, discriminator: TWO_HOP_SWAP_V2_DISCRIMINATOR })
  );
}
function getTwoHopSwapV2InstructionDataDecoder() {
  return (0, import_kit81.getStructDecoder)([
    ["discriminator", (0, import_kit81.fixDecoderSize)((0, import_kit81.getBytesDecoder)(), 8)],
    ["amount", (0, import_kit81.getU64Decoder)()],
    ["otherAmountThreshold", (0, import_kit81.getU64Decoder)()],
    ["amountSpecifiedIsInput", (0, import_kit81.getBooleanDecoder)()],
    ["aToBOne", (0, import_kit81.getBooleanDecoder)()],
    ["aToBTwo", (0, import_kit81.getBooleanDecoder)()],
    ["sqrtPriceLimitOne", (0, import_kit81.getU128Decoder)()],
    ["sqrtPriceLimitTwo", (0, import_kit81.getU128Decoder)()],
    [
      "remainingAccountsInfo",
      (0, import_kit81.getOptionDecoder)(getRemainingAccountsInfoDecoder())
    ]
  ]);
}
function getTwoHopSwapV2InstructionDataCodec() {
  return (0, import_kit81.combineCodec)(
    getTwoHopSwapV2InstructionDataEncoder(),
    getTwoHopSwapV2InstructionDataDecoder()
  );
}
function getTwoHopSwapV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolOne: { value: input.whirlpoolOne ?? null, isWritable: true },
    whirlpoolTwo: { value: input.whirlpoolTwo ?? null, isWritable: true },
    tokenMintInput: { value: input.tokenMintInput ?? null, isWritable: false },
    tokenMintIntermediate: {
      value: input.tokenMintIntermediate ?? null,
      isWritable: false
    },
    tokenMintOutput: {
      value: input.tokenMintOutput ?? null,
      isWritable: false
    },
    tokenProgramInput: {
      value: input.tokenProgramInput ?? null,
      isWritable: false
    },
    tokenProgramIntermediate: {
      value: input.tokenProgramIntermediate ?? null,
      isWritable: false
    },
    tokenProgramOutput: {
      value: input.tokenProgramOutput ?? null,
      isWritable: false
    },
    tokenOwnerAccountInput: {
      value: input.tokenOwnerAccountInput ?? null,
      isWritable: true
    },
    tokenVaultOneInput: {
      value: input.tokenVaultOneInput ?? null,
      isWritable: true
    },
    tokenVaultOneIntermediate: {
      value: input.tokenVaultOneIntermediate ?? null,
      isWritable: true
    },
    tokenVaultTwoIntermediate: {
      value: input.tokenVaultTwoIntermediate ?? null,
      isWritable: true
    },
    tokenVaultTwoOutput: {
      value: input.tokenVaultTwoOutput ?? null,
      isWritable: true
    },
    tokenOwnerAccountOutput: {
      value: input.tokenOwnerAccountOutput ?? null,
      isWritable: true
    },
    tokenAuthority: { value: input.tokenAuthority ?? null, isWritable: false },
    tickArrayOne0: { value: input.tickArrayOne0 ?? null, isWritable: true },
    tickArrayOne1: { value: input.tickArrayOne1 ?? null, isWritable: true },
    tickArrayOne2: { value: input.tickArrayOne2 ?? null, isWritable: true },
    tickArrayTwo0: { value: input.tickArrayTwo0 ?? null, isWritable: true },
    tickArrayTwo1: { value: input.tickArrayTwo1 ?? null, isWritable: true },
    tickArrayTwo2: { value: input.tickArrayTwo2 ?? null, isWritable: true },
    oracleOne: { value: input.oracleOne ?? null, isWritable: true },
    oracleTwo: { value: input.oracleTwo ?? null, isWritable: true },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolOne),
      getAccountMeta(accounts.whirlpoolTwo),
      getAccountMeta(accounts.tokenMintInput),
      getAccountMeta(accounts.tokenMintIntermediate),
      getAccountMeta(accounts.tokenMintOutput),
      getAccountMeta(accounts.tokenProgramInput),
      getAccountMeta(accounts.tokenProgramIntermediate),
      getAccountMeta(accounts.tokenProgramOutput),
      getAccountMeta(accounts.tokenOwnerAccountInput),
      getAccountMeta(accounts.tokenVaultOneInput),
      getAccountMeta(accounts.tokenVaultOneIntermediate),
      getAccountMeta(accounts.tokenVaultTwoIntermediate),
      getAccountMeta(accounts.tokenVaultTwoOutput),
      getAccountMeta(accounts.tokenOwnerAccountOutput),
      getAccountMeta(accounts.tokenAuthority),
      getAccountMeta(accounts.tickArrayOne0),
      getAccountMeta(accounts.tickArrayOne1),
      getAccountMeta(accounts.tickArrayOne2),
      getAccountMeta(accounts.tickArrayTwo0),
      getAccountMeta(accounts.tickArrayTwo1),
      getAccountMeta(accounts.tickArrayTwo2),
      getAccountMeta(accounts.oracleOne),
      getAccountMeta(accounts.oracleTwo),
      getAccountMeta(accounts.memoProgram)
    ],
    programAddress,
    data: getTwoHopSwapV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseTwoHopSwapV2Instruction(instruction) {
  if (instruction.accounts.length < 24) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolOne: getNextAccount(),
      whirlpoolTwo: getNextAccount(),
      tokenMintInput: getNextAccount(),
      tokenMintIntermediate: getNextAccount(),
      tokenMintOutput: getNextAccount(),
      tokenProgramInput: getNextAccount(),
      tokenProgramIntermediate: getNextAccount(),
      tokenProgramOutput: getNextAccount(),
      tokenOwnerAccountInput: getNextAccount(),
      tokenVaultOneInput: getNextAccount(),
      tokenVaultOneIntermediate: getNextAccount(),
      tokenVaultTwoIntermediate: getNextAccount(),
      tokenVaultTwoOutput: getNextAccount(),
      tokenOwnerAccountOutput: getNextAccount(),
      tokenAuthority: getNextAccount(),
      tickArrayOne0: getNextAccount(),
      tickArrayOne1: getNextAccount(),
      tickArrayOne2: getNextAccount(),
      tickArrayTwo0: getNextAccount(),
      tickArrayTwo1: getNextAccount(),
      tickArrayTwo2: getNextAccount(),
      oracleOne: getNextAccount(),
      oracleTwo: getNextAccount(),
      memoProgram: getNextAccount()
    },
    data: getTwoHopSwapV2InstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/updateFeesAndRewards.ts
var import_kit82 = require("@solana/kit");
var UPDATE_FEES_AND_REWARDS_DISCRIMINATOR = new Uint8Array([
  154,
  230,
  250,
  13,
  236,
  209,
  75,
  223
]);
function getUpdateFeesAndRewardsDiscriminatorBytes() {
  return (0, import_kit82.fixEncoderSize)((0, import_kit82.getBytesEncoder)(), 8).encode(
    UPDATE_FEES_AND_REWARDS_DISCRIMINATOR
  );
}
function getUpdateFeesAndRewardsInstructionDataEncoder() {
  return (0, import_kit82.transformEncoder)(
    (0, import_kit82.getStructEncoder)([["discriminator", (0, import_kit82.fixEncoderSize)((0, import_kit82.getBytesEncoder)(), 8)]]),
    (value) => ({
      ...value,
      discriminator: UPDATE_FEES_AND_REWARDS_DISCRIMINATOR
    })
  );
}
function getUpdateFeesAndRewardsInstructionDataDecoder() {
  return (0, import_kit82.getStructDecoder)([
    ["discriminator", (0, import_kit82.fixDecoderSize)((0, import_kit82.getBytesDecoder)(), 8)]
  ]);
}
function getUpdateFeesAndRewardsInstructionDataCodec() {
  return (0, import_kit82.combineCodec)(
    getUpdateFeesAndRewardsInstructionDataEncoder(),
    getUpdateFeesAndRewardsInstructionDataDecoder()
  );
}
function getUpdateFeesAndRewardsInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    position: { value: input.position ?? null, isWritable: true },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: false },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper)
    ],
    programAddress,
    data: getUpdateFeesAndRewardsInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseUpdateFeesAndRewardsInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      position: getNextAccount(),
      tickArrayLower: getNextAccount(),
      tickArrayUpper: getNextAccount()
    },
    data: getUpdateFeesAndRewardsInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/gpa/adaptiveFeeTier.ts
var import_kit84 = require("@solana/kit");

// src/gpa/utils.ts
var import_kit83 = require("@solana/kit");
async function fetchDecodedProgramAccounts(rpc, programAddress, filters, decoder) {
  const accountInfos = await rpc.getProgramAccounts(programAddress, {
    encoding: "base64",
    filters
  }).send();
  const encoder = (0, import_kit83.getBase64Encoder)();
  const datas = accountInfos.map((x) => encoder.encode(x.account.data[0]));
  const decoded = datas.map((x) => decoder.decode(x));
  return decoded.map((data, i) => ({
    ...accountInfos[i].account,
    address: accountInfos[i].pubkey,
    programAddress,
    data
  }));
}

// src/gpa/adaptiveFeeTier.ts
function adaptiveFeeTierWhirlpoolsConfigFilter(address) {
  return {
    memcmp: {
      offset: 8n,
      bytes: (0, import_kit84.getBase58Decoder)().decode((0, import_kit84.getAddressEncoder)().encode(address)),
      encoding: "base58"
    }
  };
}
function adaptiveFeeTierFeeTierIndexFilter(feeTierIndex) {
  return {
    memcmp: {
      offset: 40n,
      bytes: (0, import_kit84.getBase58Decoder)().decode((0, import_kit84.getU16Encoder)().encode(feeTierIndex)),
      encoding: "base58"
    }
  };
}
function adaptiveFeeTierTickSpacingFilter(tickSpacing) {
  return {
    memcmp: {
      offset: 42n,
      bytes: (0, import_kit84.getBase58Decoder)().decode((0, import_kit84.getU16Encoder)().encode(tickSpacing)),
      encoding: "base58"
    }
  };
}
function adaptiveFeeTierInitializePoolAuthorityFilter(address) {
  return {
    memcmp: {
      offset: 44n,
      bytes: (0, import_kit84.getBase58Decoder)().decode((0, import_kit84.getAddressEncoder)().encode(address)),
      encoding: "base58"
    }
  };
}
function adaptiveFeeTierDelegatedFeeAuthorityFilter(address) {
  return {
    memcmp: {
      offset: 76n,
      bytes: (0, import_kit84.getBase58Decoder)().decode((0, import_kit84.getAddressEncoder)().encode(address)),
      encoding: "base58"
    }
  };
}
function adaptiveFeeTierDefaultBaseFeeRateFilter(feeRate) {
  return {
    memcmp: {
      offset: 108n,
      bytes: (0, import_kit84.getBase58Decoder)().decode((0, import_kit84.getU16Encoder)().encode(feeRate)),
      encoding: "base58"
    }
  };
}
function adaptiveFeeTierFilterPeriodFilter(filterPeriod) {
  return {
    memcmp: {
      offset: 110n,
      bytes: (0, import_kit84.getBase58Decoder)().decode((0, import_kit84.getU16Encoder)().encode(filterPeriod)),
      encoding: "base58"
    }
  };
}
function adaptiveFeeTierDecayPeriodFilter(decayPeriod) {
  return {
    memcmp: {
      offset: 112n,
      bytes: (0, import_kit84.getBase58Decoder)().decode((0, import_kit84.getU16Encoder)().encode(decayPeriod)),
      encoding: "base58"
    }
  };
}
function adaptiveFeeTierReductionFactorFilter(reductionFactor) {
  return {
    memcmp: {
      offset: 114n,
      bytes: (0, import_kit84.getBase58Decoder)().decode((0, import_kit84.getU16Encoder)().encode(reductionFactor)),
      encoding: "base58"
    }
  };
}
function adaptiveFeeTierAdaptiveFeeControlFactorFilter(adaptiveFeeControlFactor) {
  return {
    memcmp: {
      offset: 116n,
      bytes: (0, import_kit84.getBase58Decoder)().decode(
        (0, import_kit84.getU32Encoder)().encode(adaptiveFeeControlFactor)
      ),
      encoding: "base58"
    }
  };
}
function adaptiveFeeTierMaxVolatilityFilter(maxVolatility) {
  return {
    memcmp: {
      offset: 120n,
      bytes: (0, import_kit84.getBase58Decoder)().decode((0, import_kit84.getU32Encoder)().encode(maxVolatility)),
      encoding: "base58"
    }
  };
}
function adaptiveFeeTierTickGroupSizeFilter(tickGroupSize) {
  return {
    memcmp: {
      offset: 124n,
      bytes: (0, import_kit84.getBase58Decoder)().decode((0, import_kit84.getU16Encoder)().encode(tickGroupSize)),
      encoding: "base58"
    }
  };
}
function adaptiveFeeTierMajorSwapThresholdTicksFilter(majorSwapThresholdTicks) {
  return {
    memcmp: {
      offset: 126n,
      bytes: (0, import_kit84.getBase58Decoder)().decode(
        (0, import_kit84.getU16Encoder)().encode(majorSwapThresholdTicks)
      ),
      encoding: "base58"
    }
  };
}
async function fetchAllAdaptiveFeeTierWithFilter(rpc, ...filters) {
  const discriminator = (0, import_kit84.getBase58Decoder)().decode(
    ADAPTIVE_FEE_TIER_DISCRIMINATOR
  );
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getAdaptiveFeeTierDecoder()
  );
}

// src/gpa/feeTier.ts
var import_kit85 = require("@solana/kit");
function feeTierWhirlpoolsConfigFilter(address) {
  return {
    memcmp: {
      offset: 8n,
      bytes: (0, import_kit85.getBase58Decoder)().decode((0, import_kit85.getAddressEncoder)().encode(address)),
      encoding: "base58"
    }
  };
}
function feeTierTickSpacingFilter(tickSpacing) {
  return {
    memcmp: {
      offset: 40n,
      bytes: (0, import_kit85.getBase58Decoder)().decode((0, import_kit85.getU16Encoder)().encode(tickSpacing)),
      encoding: "base58"
    }
  };
}
function feeTierFeeRateFilter(defaultFeeRate) {
  return {
    memcmp: {
      offset: 42n,
      bytes: (0, import_kit85.getBase58Decoder)().decode((0, import_kit85.getU16Encoder)().encode(defaultFeeRate)),
      encoding: "base58"
    }
  };
}
async function fetchAllFeeTierWithFilter(rpc, ...filters) {
  const discriminator = (0, import_kit85.getBase58Decoder)().decode(FEE_TIER_DISCRIMINATOR);
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getFeeTierDecoder()
  );
}

// src/gpa/oracle.ts
var import_kit86 = require("@solana/kit");
function oracleWhirlpoolFilter(address) {
  return {
    memcmp: {
      offset: 8n,
      bytes: (0, import_kit86.getBase58Decoder)().decode((0, import_kit86.getAddressEncoder)().encode(address)),
      encoding: "base58"
    }
  };
}
function oracleTradeEnableTimestampFilter(timestamp) {
  return {
    memcmp: {
      offset: 40n,
      bytes: (0, import_kit86.getBase58Decoder)().decode((0, import_kit86.getU64Encoder)().encode(timestamp)),
      encoding: "base58"
    }
  };
}
function oracleFilterPeriodFilter(filterPeriod) {
  return {
    memcmp: {
      offset: 48n,
      bytes: (0, import_kit86.getBase58Decoder)().decode((0, import_kit86.getU16Encoder)().encode(filterPeriod)),
      encoding: "base58"
    }
  };
}
function oracleDecayPeriodFilter(decayPeriod) {
  return {
    memcmp: {
      offset: 50n,
      bytes: (0, import_kit86.getBase58Decoder)().decode((0, import_kit86.getU16Encoder)().encode(decayPeriod)),
      encoding: "base58"
    }
  };
}
function oracleReductionFactorFilter(reductionFactor) {
  return {
    memcmp: {
      offset: 52n,
      bytes: (0, import_kit86.getBase58Decoder)().decode((0, import_kit86.getU16Encoder)().encode(reductionFactor)),
      encoding: "base58"
    }
  };
}
function oracleAdaptiveFeeControlFactorFilter(adaptiveFeeControlFactor) {
  return {
    memcmp: {
      offset: 54n,
      bytes: (0, import_kit86.getBase58Decoder)().decode(
        (0, import_kit86.getU32Encoder)().encode(adaptiveFeeControlFactor)
      ),
      encoding: "base58"
    }
  };
}
function oracleMaxVolatilityFilter(maxVolatility) {
  return {
    memcmp: {
      offset: 58n,
      bytes: (0, import_kit86.getBase58Decoder)().decode((0, import_kit86.getU32Encoder)().encode(maxVolatility)),
      encoding: "base58"
    }
  };
}
function oracleTickGroupSizeFilter(tickGroupSize) {
  return {
    memcmp: {
      offset: 62n,
      bytes: (0, import_kit86.getBase58Decoder)().decode((0, import_kit86.getU16Encoder)().encode(tickGroupSize)),
      encoding: "base58"
    }
  };
}
function oracleMajorSwapThresholdTicksFilter(majorSwapThresholdTicks) {
  return {
    memcmp: {
      offset: 64n,
      bytes: (0, import_kit86.getBase58Decoder)().decode(
        (0, import_kit86.getU16Encoder)().encode(majorSwapThresholdTicks)
      ),
      encoding: "base58"
    }
  };
}
async function fetchAllOracleWithFilter(rpc, ...filters) {
  const discriminator = (0, import_kit86.getBase58Decoder)().decode(ORACLE_DISCRIMINATOR);
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getOracleDecoder()
  );
}

// src/gpa/position.ts
var import_kit87 = require("@solana/kit");
function positionWhirlpoolFilter(address) {
  return {
    memcmp: {
      offset: 8n,
      bytes: (0, import_kit87.getBase58Decoder)().decode((0, import_kit87.getAddressEncoder)().encode(address)),
      encoding: "base58"
    }
  };
}
function positionMintFilter(address) {
  return {
    memcmp: {
      offset: 40n,
      bytes: (0, import_kit87.getBase58Decoder)().decode((0, import_kit87.getAddressEncoder)().encode(address)),
      encoding: "base58"
    }
  };
}
function positionTickLowerIndexFilter(tickLowerIndex) {
  return {
    memcmp: {
      offset: 88n,
      bytes: (0, import_kit87.getBase58Decoder)().decode((0, import_kit87.getI32Encoder)().encode(tickLowerIndex)),
      encoding: "base58"
    }
  };
}
function positionTickUpperIndexFilter(tickUpperIndex) {
  return {
    memcmp: {
      offset: 92n,
      bytes: (0, import_kit87.getBase58Decoder)().decode((0, import_kit87.getI32Encoder)().encode(tickUpperIndex)),
      encoding: "base58"
    }
  };
}
async function fetchAllPositionWithFilter(rpc, ...filters) {
  const discriminator = (0, import_kit87.getBase58Decoder)().decode(POSITION_DISCRIMINATOR);
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getPositionDecoder()
  );
}

// src/gpa/positionBundle.ts
var import_kit88 = require("@solana/kit");
function positionBundleMintFilter(address) {
  return {
    memcmp: {
      offset: 8n,
      bytes: (0, import_kit88.getBase58Decoder)().decode((0, import_kit88.getAddressEncoder)().encode(address)),
      encoding: "base58"
    }
  };
}
async function fetchAllPositionBundleWithFilter(rpc, ...filters) {
  const discriminator = (0, import_kit88.getBase58Decoder)().decode(
    POSITION_BUNDLE_DISCRIMINATOR
  );
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getPositionBundleDecoder()
  );
}

// src/gpa/tickArray.ts
var import_kit89 = require("@solana/kit");
function tickArrayStartTickIndexFilter(startTickIndex) {
  return {
    memcmp: {
      offset: 8n,
      bytes: (0, import_kit89.getBase58Decoder)().decode((0, import_kit89.getI32Encoder)().encode(startTickIndex)),
      encoding: "base58"
    }
  };
}
function tickArrayWhirlpoolFilter(address) {
  return {
    memcmp: {
      offset: 9956n,
      bytes: (0, import_kit89.getBase58Decoder)().decode((0, import_kit89.getAddressEncoder)().encode(address)),
      encoding: "base58"
    }
  };
}
async function fetchAllTickArrayWithFilter(rpc, ...filters) {
  const discriminator = (0, import_kit89.getBase58Decoder)().decode(TICK_ARRAY_DISCRIMINATOR);
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getTickArrayDecoder()
  );
}

// src/gpa/tokenBadge.ts
var import_kit90 = require("@solana/kit");
function tokenBadgeWhirlpoolsConfigFilter(address) {
  return {
    memcmp: {
      offset: 8n,
      bytes: (0, import_kit90.getBase58Decoder)().decode((0, import_kit90.getAddressEncoder)().encode(address)),
      encoding: "base58"
    }
  };
}
function tokenBadgeTokenMintFilter(address) {
  return {
    memcmp: {
      offset: 40n,
      bytes: (0, import_kit90.getBase58Decoder)().decode((0, import_kit90.getAddressEncoder)().encode(address)),
      encoding: "base58"
    }
  };
}
async function fetchAllTokenBadgeWithFilter(rpc, ...filters) {
  const discriminator = (0, import_kit90.getBase58Decoder)().decode(TOKEN_BADGE_DISCRIMINATOR);
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getTokenBadgeDecoder()
  );
}

// src/gpa/whirlpool.ts
var import_kit91 = require("@solana/kit");
function whirlpoolWhirlpoolConfigFilter(address) {
  return {
    memcmp: {
      offset: 8n,
      bytes: (0, import_kit91.getBase58Decoder)().decode((0, import_kit91.getAddressEncoder)().encode(address)),
      encoding: "base58"
    }
  };
}
function whirlpoolTickSpacingFilter(tickSpacing) {
  return {
    memcmp: {
      offset: 41n,
      bytes: (0, import_kit91.getBase58Decoder)().decode((0, import_kit91.getU16Encoder)().encode(tickSpacing)),
      encoding: "base58"
    }
  };
}
function whirlpoolFeeRateFilter(defaultFeeRate) {
  return {
    memcmp: {
      offset: 45n,
      bytes: (0, import_kit91.getBase58Decoder)().decode((0, import_kit91.getU16Encoder)().encode(defaultFeeRate)),
      encoding: "base58"
    }
  };
}
function whirlpoolProtocolFeeRateFilter(protocolFeeRate) {
  return {
    memcmp: {
      offset: 47n,
      bytes: (0, import_kit91.getBase58Decoder)().decode((0, import_kit91.getU16Encoder)().encode(protocolFeeRate)),
      encoding: "base58"
    }
  };
}
function whirlpoolTokenMintAFilter(tokenMintA) {
  return {
    memcmp: {
      offset: 101n,
      bytes: (0, import_kit91.getBase58Decoder)().decode((0, import_kit91.getAddressEncoder)().encode(tokenMintA)),
      encoding: "base58"
    }
  };
}
function whirlpoolTokenVaultAFilter(tokenVaultA) {
  return {
    memcmp: {
      offset: 133n,
      bytes: (0, import_kit91.getBase58Decoder)().decode((0, import_kit91.getAddressEncoder)().encode(tokenVaultA)),
      encoding: "base58"
    }
  };
}
function whirlpoolTokenMintBFilter(tokenMintB) {
  return {
    memcmp: {
      offset: 181n,
      bytes: (0, import_kit91.getBase58Decoder)().decode((0, import_kit91.getAddressEncoder)().encode(tokenMintB)),
      encoding: "base58"
    }
  };
}
function whirlpoolTokenVaultBFilter(tokenVaultB) {
  return {
    memcmp: {
      offset: 213n,
      bytes: (0, import_kit91.getBase58Decoder)().decode((0, import_kit91.getAddressEncoder)().encode(tokenVaultB)),
      encoding: "base58"
    }
  };
}
function whirlpoolRewardMint1Filter(rewardMint1) {
  return {
    memcmp: {
      offset: 269n,
      bytes: (0, import_kit91.getBase58Decoder)().decode((0, import_kit91.getAddressEncoder)().encode(rewardMint1)),
      encoding: "base58"
    }
  };
}
function whirlpoolRewardVault1Filter(rewardVault1) {
  return {
    memcmp: {
      offset: 301n,
      bytes: (0, import_kit91.getBase58Decoder)().decode(
        (0, import_kit91.getAddressEncoder)().encode(rewardVault1)
      ),
      encoding: "base58"
    }
  };
}
function whirlpoolRewardMint2Filter(rewardMint2) {
  return {
    memcmp: {
      offset: 397n,
      bytes: (0, import_kit91.getBase58Decoder)().decode((0, import_kit91.getAddressEncoder)().encode(rewardMint2)),
      encoding: "base58"
    }
  };
}
function whirlpoolRewardVault2Filter(rewardVault2) {
  return {
    memcmp: {
      offset: 429n,
      bytes: (0, import_kit91.getBase58Decoder)().decode(
        (0, import_kit91.getAddressEncoder)().encode(rewardVault2)
      ),
      encoding: "base58"
    }
  };
}
function whirlpoolRewardMint3Filter(rewardMint3) {
  return {
    memcmp: {
      offset: 525n,
      bytes: (0, import_kit91.getBase58Decoder)().decode((0, import_kit91.getAddressEncoder)().encode(rewardMint3)),
      encoding: "base58"
    }
  };
}
function whirlpoolRewardVault3Filter(rewardVault3) {
  return {
    memcmp: {
      offset: 557n,
      bytes: (0, import_kit91.getBase58Decoder)().decode(
        (0, import_kit91.getAddressEncoder)().encode(rewardVault3)
      ),
      encoding: "base58"
    }
  };
}
async function fetchAllWhirlpoolWithFilter(rpc, ...filters) {
  const discriminator = (0, import_kit91.getBase58Decoder)().decode(WHIRLPOOL_DISCRIMINATOR);
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getWhirlpoolDecoder()
  );
}

// src/gpa/whirlpoolsConfig.ts
var import_kit92 = require("@solana/kit");
function whirlpoolsConfigFeeAuthorityFilter(feeAuthority) {
  return {
    memcmp: {
      offset: 8n,
      bytes: (0, import_kit92.getBase58Decoder)().decode(
        (0, import_kit92.getAddressEncoder)().encode(feeAuthority)
      ),
      encoding: "base58"
    }
  };
}
function whirlpoolsConfigCollectProtocolFeesAuthorityFilter(collectProtocolFeesAuthority) {
  return {
    memcmp: {
      offset: 40n,
      bytes: (0, import_kit92.getBase58Decoder)().decode(
        (0, import_kit92.getAddressEncoder)().encode(collectProtocolFeesAuthority)
      ),
      encoding: "base58"
    }
  };
}
function whirlpoolsConfigRewardEmissionsSuperAuthorityFilter(rewardEmissionsSuperAuthority) {
  return {
    memcmp: {
      offset: 72n,
      bytes: (0, import_kit92.getBase58Decoder)().decode(
        (0, import_kit92.getAddressEncoder)().encode(rewardEmissionsSuperAuthority)
      ),
      encoding: "base58"
    }
  };
}
function whirlpoolsConfigDefaultProtocolFeeRateFilter(defaultFeeRate) {
  return {
    memcmp: {
      offset: 104n,
      bytes: (0, import_kit92.getBase58Decoder)().decode((0, import_kit92.getU16Encoder)().encode(defaultFeeRate)),
      encoding: "base58"
    }
  };
}
async function fetchAllWhirlpoolsConfigWithFilter(rpc, ...filters) {
  const discriminator = (0, import_kit92.getBase58Decoder)().decode(
    WHIRLPOOLS_CONFIG_DISCRIMINATOR
  );
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getWhirlpoolsConfigDecoder()
  );
}

// src/gpa/whirlpoolsConfigExtension.ts
var import_kit93 = require("@solana/kit");
function whirlpoolsConfigExtensionWhirlpoolsConfigFilter(address) {
  return {
    memcmp: {
      offset: 8n,
      bytes: (0, import_kit93.getBase58Decoder)().decode((0, import_kit93.getAddressEncoder)().encode(address)),
      encoding: "base58"
    }
  };
}
function whirlpoolsConfigExtensionConfigExtensionAuthorityFilter(configExtensionAuthority) {
  return {
    memcmp: {
      offset: 40n,
      bytes: (0, import_kit93.getBase58Decoder)().decode(
        (0, import_kit93.getAddressEncoder)().encode(configExtensionAuthority)
      ),
      encoding: "base58"
    }
  };
}
function whirlpoolsConfigExtensionConfigTokenBadgeAuthorityFilter(configTokenBadgeAuthority) {
  return {
    memcmp: {
      offset: 72n,
      bytes: (0, import_kit93.getBase58Decoder)().decode(
        (0, import_kit93.getAddressEncoder)().encode(configTokenBadgeAuthority)
      ),
      encoding: "base58"
    }
  };
}
async function fetchAllWhirlpoolsConfigExtensionWithFilter(rpc, ...filters) {
  const discriminator = (0, import_kit93.getBase58Decoder)().decode(
    WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR
  );
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getWhirlpoolsConfigExtensionDecoder()
  );
}

// src/pda/feeTier.ts
var import_kit94 = require("@solana/kit");
async function getFeeTierAddress(whirlpoolsConfig, feeTierIndex) {
  return await (0, import_kit94.getProgramDerivedAddress)({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: [
      "fee_tier",
      (0, import_kit94.getAddressEncoder)().encode(whirlpoolsConfig),
      (0, import_kit94.getU16Encoder)().encode(feeTierIndex)
    ]
  });
}

// src/pda/oracle.ts
var import_kit95 = require("@solana/kit");
async function getOracleAddress(whirlpool) {
  return await (0, import_kit95.getProgramDerivedAddress)({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: ["oracle", (0, import_kit95.getAddressEncoder)().encode(whirlpool)]
  });
}

// src/pda/position.ts
var import_kit96 = require("@solana/kit");
async function getPositionAddress(positionMint) {
  return await (0, import_kit96.getProgramDerivedAddress)({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: ["position", (0, import_kit96.getAddressEncoder)().encode(positionMint)]
  });
}

// src/pda/positionBundle.ts
var import_kit97 = require("@solana/kit");
async function getPositionBundleAddress(positionBundleMint) {
  return await (0, import_kit97.getProgramDerivedAddress)({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: ["position_bundle", (0, import_kit97.getAddressEncoder)().encode(positionBundleMint)]
  });
}
async function getBundledPositionAddress(positionBundleAddress, bundleIndex) {
  return await (0, import_kit97.getProgramDerivedAddress)({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: [
      "bundled_position",
      (0, import_kit97.getAddressEncoder)().encode(positionBundleAddress),
      Buffer.from(bundleIndex.toString())
    ]
  });
}

// src/pda/tickArray.ts
var import_kit98 = require("@solana/kit");
async function getTickArrayAddress(whirlpool, startTickIndex) {
  return await (0, import_kit98.getProgramDerivedAddress)({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: [
      "tick_array",
      (0, import_kit98.getAddressEncoder)().encode(whirlpool),
      `${startTickIndex}`
    ]
  });
}

// src/pda/tokenBadge.ts
var import_kit99 = require("@solana/kit");
async function getTokenBadgeAddress(whirlpoolsConfig, tokenMint) {
  return await (0, import_kit99.getProgramDerivedAddress)({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: [
      "token_badge",
      (0, import_kit99.getAddressEncoder)().encode(whirlpoolsConfig),
      (0, import_kit99.getAddressEncoder)().encode(tokenMint)
    ]
  });
}

// src/pda/whirlpool.ts
var import_kit100 = require("@solana/kit");
async function getWhirlpoolAddress(whirlpoolsConfig, tokenMintA, tokenMintB, feeTierIndex) {
  return await (0, import_kit100.getProgramDerivedAddress)({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: [
      "whirlpool",
      (0, import_kit100.getAddressEncoder)().encode(whirlpoolsConfig),
      (0, import_kit100.getAddressEncoder)().encode(tokenMintA),
      (0, import_kit100.getAddressEncoder)().encode(tokenMintB),
      (0, import_kit100.getU16Encoder)().encode(feeTierIndex)
    ]
  });
}

// src/pda/whirlpoolsConfigExtension.ts
var import_kit101 = require("@solana/kit");
async function getWhirlpoolsConfigExtensionAddress(configAddress) {
  return await (0, import_kit101.getProgramDerivedAddress)({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: ["config_extension", (0, import_kit101.getAddressEncoder)().encode(configAddress)]
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ADAPTIVE_FEE_TIER_DISCRIMINATOR,
  AccountsType,
  CLOSE_BUNDLED_POSITION_DISCRIMINATOR,
  CLOSE_POSITION_DISCRIMINATOR,
  CLOSE_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR,
  COLLECT_FEES_DISCRIMINATOR,
  COLLECT_FEES_V2_DISCRIMINATOR,
  COLLECT_PROTOCOL_FEES_DISCRIMINATOR,
  COLLECT_PROTOCOL_FEES_V2_DISCRIMINATOR,
  COLLECT_REWARD_DISCRIMINATOR,
  COLLECT_REWARD_V2_DISCRIMINATOR,
  DECREASE_LIQUIDITY_DISCRIMINATOR,
  DECREASE_LIQUIDITY_V2_DISCRIMINATOR,
  DELETE_POSITION_BUNDLE_DISCRIMINATOR,
  DELETE_TOKEN_BADGE_DISCRIMINATOR,
  FEE_TIER_DISCRIMINATOR,
  INCREASE_LIQUIDITY_DISCRIMINATOR,
  INCREASE_LIQUIDITY_V2_DISCRIMINATOR,
  INITIALIZE_ADAPTIVE_FEE_TIER_DISCRIMINATOR,
  INITIALIZE_CONFIG_DISCRIMINATOR,
  INITIALIZE_CONFIG_EXTENSION_DISCRIMINATOR,
  INITIALIZE_FEE_TIER_DISCRIMINATOR,
  INITIALIZE_POOL_DISCRIMINATOR,
  INITIALIZE_POOL_V2_DISCRIMINATOR,
  INITIALIZE_POOL_WITH_ADAPTIVE_FEE_DISCRIMINATOR,
  INITIALIZE_POSITION_BUNDLE_DISCRIMINATOR,
  INITIALIZE_POSITION_BUNDLE_WITH_METADATA_DISCRIMINATOR,
  INITIALIZE_REWARD_DISCRIMINATOR,
  INITIALIZE_REWARD_V2_DISCRIMINATOR,
  INITIALIZE_TICK_ARRAY_DISCRIMINATOR,
  INITIALIZE_TOKEN_BADGE_DISCRIMINATOR,
  LOCK_CONFIG_DISCRIMINATOR,
  LOCK_POSITION_DISCRIMINATOR,
  LockType,
  LockTypeLabel,
  OPEN_BUNDLED_POSITION_DISCRIMINATOR,
  OPEN_POSITION_DISCRIMINATOR,
  OPEN_POSITION_WITH_METADATA_DISCRIMINATOR,
  OPEN_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR,
  ORACLE_DISCRIMINATOR,
  POSITION_BUNDLE_DISCRIMINATOR,
  POSITION_DISCRIMINATOR,
  RESET_POSITION_RANGE_DISCRIMINATOR,
  SET_COLLECT_PROTOCOL_FEES_AUTHORITY_DISCRIMINATOR,
  SET_CONFIG_EXTENSION_AUTHORITY_DISCRIMINATOR,
  SET_DEFAULT_BASE_FEE_RATE_DISCRIMINATOR,
  SET_DEFAULT_FEE_RATE_DISCRIMINATOR,
  SET_DEFAULT_PROTOCOL_FEE_RATE_DISCRIMINATOR,
  SET_DELEGATED_FEE_AUTHORITY_DISCRIMINATOR,
  SET_FEE_AUTHORITY_DISCRIMINATOR,
  SET_FEE_RATE_BY_DELEGATED_FEE_AUTHORITY_DISCRIMINATOR,
  SET_FEE_RATE_DISCRIMINATOR,
  SET_INITIALIZE_POOL_AUTHORITY_DISCRIMINATOR,
  SET_PRESET_ADAPTIVE_FEE_CONSTANTS_DISCRIMINATOR,
  SET_PROTOCOL_FEE_RATE_DISCRIMINATOR,
  SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_DISCRIMINATOR,
  SET_REWARD_AUTHORITY_DISCRIMINATOR,
  SET_REWARD_EMISSIONS_DISCRIMINATOR,
  SET_REWARD_EMISSIONS_SUPER_AUTHORITY_DISCRIMINATOR,
  SET_REWARD_EMISSIONS_V2_DISCRIMINATOR,
  SET_TOKEN_BADGE_AUTHORITY_DISCRIMINATOR,
  SWAP_DISCRIMINATOR,
  SWAP_V2_DISCRIMINATOR,
  TICK_ARRAY_DISCRIMINATOR,
  TOKEN_BADGE_DISCRIMINATOR,
  TRANSFER_LOCKED_POSITION_DISCRIMINATOR,
  TWO_HOP_SWAP_DISCRIMINATOR,
  TWO_HOP_SWAP_V2_DISCRIMINATOR,
  UPDATE_FEES_AND_REWARDS_DISCRIMINATOR,
  WHIRLPOOLS_CONFIG_DISCRIMINATOR,
  WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR,
  WHIRLPOOL_DISCRIMINATOR,
  WHIRLPOOL_ERROR__AMOUNT_CALC_OVERFLOW,
  WHIRLPOOL_ERROR__AMOUNT_IN_ABOVE_MAXIMUM,
  WHIRLPOOL_ERROR__AMOUNT_OUT_BELOW_MINIMUM,
  WHIRLPOOL_ERROR__AMOUNT_REMAINING_OVERFLOW,
  WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_CLOSED,
  WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_OPENED,
  WHIRLPOOL_ERROR__CLOSE_POSITION_NOT_EMPTY,
  WHIRLPOOL_ERROR__DIFFERENT_WHIRLPOOL_TICK_ARRAY_ACCOUNT,
  WHIRLPOOL_ERROR__DIVIDE_BY_ZERO,
  WHIRLPOOL_ERROR__DUPLICATE_TWO_HOP_POOL,
  WHIRLPOOL_ERROR__FEE_RATE_MAX_EXCEEDED,
  WHIRLPOOL_ERROR__FULL_RANGE_ONLY_POOL,
  WHIRLPOOL_ERROR__INTERMEDIATE_TOKEN_AMOUNT_MISMATCH,
  WHIRLPOOL_ERROR__INVALID_ADAPTIVE_FEE_CONSTANTS,
  WHIRLPOOL_ERROR__INVALID_BUNDLE_INDEX,
  WHIRLPOOL_ERROR__INVALID_ENUM,
  WHIRLPOOL_ERROR__INVALID_FEE_TIER_INDEX,
  WHIRLPOOL_ERROR__INVALID_INTERMEDIARY_MINT,
  WHIRLPOOL_ERROR__INVALID_POSITION_TOKEN_AMOUNT,
  WHIRLPOOL_ERROR__INVALID_REWARD_INDEX,
  WHIRLPOOL_ERROR__INVALID_SQRT_PRICE_LIMIT_DIRECTION,
  WHIRLPOOL_ERROR__INVALID_START_TICK,
  WHIRLPOOL_ERROR__INVALID_TICK_ARRAY_SEQUENCE,
  WHIRLPOOL_ERROR__INVALID_TICK_INDEX,
  WHIRLPOOL_ERROR__INVALID_TICK_SPACING,
  WHIRLPOOL_ERROR__INVALID_TIMESTAMP,
  WHIRLPOOL_ERROR__INVALID_TIMESTAMP_CONVERSION,
  WHIRLPOOL_ERROR__INVALID_TOKEN_MINT_ORDER,
  WHIRLPOOL_ERROR__INVALID_TRADE_ENABLE_TIMESTAMP,
  WHIRLPOOL_ERROR__LIQUIDITY_NET_ERROR,
  WHIRLPOOL_ERROR__LIQUIDITY_OVERFLOW,
  WHIRLPOOL_ERROR__LIQUIDITY_TOO_HIGH,
  WHIRLPOOL_ERROR__LIQUIDITY_UNDERFLOW,
  WHIRLPOOL_ERROR__LIQUIDITY_ZERO,
  WHIRLPOOL_ERROR__MISSING_OR_INVALID_DELEGATE,
  WHIRLPOOL_ERROR__MULTIPLICATION_OVERFLOW,
  WHIRLPOOL_ERROR__MULTIPLICATION_SHIFT_RIGHT_OVERFLOW,
  WHIRLPOOL_ERROR__MUL_DIV_INVALID_INPUT,
  WHIRLPOOL_ERROR__MUL_DIV_OVERFLOW,
  WHIRLPOOL_ERROR__NO_EXTRA_ACCOUNTS_FOR_TRANSFER_HOOK,
  WHIRLPOOL_ERROR__NUMBER_CAST_ERROR,
  WHIRLPOOL_ERROR__NUMBER_DOWN_CAST_ERROR,
  WHIRLPOOL_ERROR__OPERATION_NOT_ALLOWED_ON_LOCKED_POSITION,
  WHIRLPOOL_ERROR__PARTIAL_FILL_ERROR,
  WHIRLPOOL_ERROR__POSITION_BUNDLE_NOT_DELETABLE,
  WHIRLPOOL_ERROR__POSITION_NOT_LOCKABLE,
  WHIRLPOOL_ERROR__PROTOCOL_FEE_RATE_MAX_EXCEEDED,
  WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_DUPLICATED_ACCOUNTS_TYPE,
  WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INSUFFICIENT,
  WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INVALID_SLICE,
  WHIRLPOOL_ERROR__REWARD_NOT_INITIALIZED,
  WHIRLPOOL_ERROR__REWARD_VAULT_AMOUNT_INSUFFICIENT,
  WHIRLPOOL_ERROR__SAME_TICK_RANGE_NOT_ALLOWED,
  WHIRLPOOL_ERROR__SQRT_PRICE_OUT_OF_BOUNDS,
  WHIRLPOOL_ERROR__TICK_ARRAY_EXIST_IN_POOL,
  WHIRLPOOL_ERROR__TICK_ARRAY_INDEX_OUTOF_BOUNDS,
  WHIRLPOOL_ERROR__TICK_ARRAY_SEQUENCE_INVALID_INDEX,
  WHIRLPOOL_ERROR__TICK_NOT_FOUND,
  WHIRLPOOL_ERROR__TOKEN_MAX_EXCEEDED,
  WHIRLPOOL_ERROR__TOKEN_MIN_SUBCEEDED,
  WHIRLPOOL_ERROR__TOO_MANY_SUPPLEMENTAL_TICK_ARRAYS,
  WHIRLPOOL_ERROR__TRADE_IS_NOT_ENABLED,
  WHIRLPOOL_ERROR__TRANSFER_FEE_CALCULATION_ERROR,
  WHIRLPOOL_ERROR__UNSUPPORTED_TOKEN_MINT,
  WHIRLPOOL_ERROR__ZERO_TRADABLE_AMOUNT,
  WHIRLPOOL_PROGRAM_ADDRESS,
  WhirlpoolAccount,
  WhirlpoolInstruction,
  adaptiveFeeTierAdaptiveFeeControlFactorFilter,
  adaptiveFeeTierDecayPeriodFilter,
  adaptiveFeeTierDefaultBaseFeeRateFilter,
  adaptiveFeeTierDelegatedFeeAuthorityFilter,
  adaptiveFeeTierFeeTierIndexFilter,
  adaptiveFeeTierFilterPeriodFilter,
  adaptiveFeeTierInitializePoolAuthorityFilter,
  adaptiveFeeTierMajorSwapThresholdTicksFilter,
  adaptiveFeeTierMaxVolatilityFilter,
  adaptiveFeeTierReductionFactorFilter,
  adaptiveFeeTierTickGroupSizeFilter,
  adaptiveFeeTierTickSpacingFilter,
  adaptiveFeeTierWhirlpoolsConfigFilter,
  decodeAdaptiveFeeTier,
  decodeFeeTier,
  decodeLockConfig,
  decodeOracle,
  decodePosition,
  decodePositionBundle,
  decodeTickArray,
  decodeTokenBadge,
  decodeWhirlpool,
  decodeWhirlpoolsConfig,
  decodeWhirlpoolsConfigExtension,
  feeTierFeeRateFilter,
  feeTierTickSpacingFilter,
  feeTierWhirlpoolsConfigFilter,
  fetchAdaptiveFeeTier,
  fetchAllAdaptiveFeeTier,
  fetchAllAdaptiveFeeTierWithFilter,
  fetchAllFeeTier,
  fetchAllFeeTierWithFilter,
  fetchAllLockConfig,
  fetchAllMaybeAdaptiveFeeTier,
  fetchAllMaybeFeeTier,
  fetchAllMaybeLockConfig,
  fetchAllMaybeOracle,
  fetchAllMaybePosition,
  fetchAllMaybePositionBundle,
  fetchAllMaybeTickArray,
  fetchAllMaybeTokenBadge,
  fetchAllMaybeWhirlpool,
  fetchAllMaybeWhirlpoolsConfig,
  fetchAllMaybeWhirlpoolsConfigExtension,
  fetchAllOracle,
  fetchAllOracleWithFilter,
  fetchAllPosition,
  fetchAllPositionBundle,
  fetchAllPositionBundleWithFilter,
  fetchAllPositionWithFilter,
  fetchAllTickArray,
  fetchAllTickArrayWithFilter,
  fetchAllTokenBadge,
  fetchAllTokenBadgeWithFilter,
  fetchAllWhirlpool,
  fetchAllWhirlpoolWithFilter,
  fetchAllWhirlpoolsConfig,
  fetchAllWhirlpoolsConfigExtension,
  fetchAllWhirlpoolsConfigExtensionWithFilter,
  fetchAllWhirlpoolsConfigWithFilter,
  fetchFeeTier,
  fetchLockConfig,
  fetchMaybeAdaptiveFeeTier,
  fetchMaybeFeeTier,
  fetchMaybeLockConfig,
  fetchMaybeOracle,
  fetchMaybePosition,
  fetchMaybePositionBundle,
  fetchMaybeTickArray,
  fetchMaybeTokenBadge,
  fetchMaybeWhirlpool,
  fetchMaybeWhirlpoolsConfig,
  fetchMaybeWhirlpoolsConfigExtension,
  fetchOracle,
  fetchPosition,
  fetchPositionBundle,
  fetchTickArray,
  fetchTokenBadge,
  fetchWhirlpool,
  fetchWhirlpoolsConfig,
  fetchWhirlpoolsConfigExtension,
  getAccountsTypeCodec,
  getAccountsTypeDecoder,
  getAccountsTypeEncoder,
  getAdaptiveFeeConstantsCodec,
  getAdaptiveFeeConstantsDecoder,
  getAdaptiveFeeConstantsEncoder,
  getAdaptiveFeeTierCodec,
  getAdaptiveFeeTierDecoder,
  getAdaptiveFeeTierDiscriminatorBytes,
  getAdaptiveFeeTierEncoder,
  getAdaptiveFeeTierSize,
  getAdaptiveFeeVariablesCodec,
  getAdaptiveFeeVariablesDecoder,
  getAdaptiveFeeVariablesEncoder,
  getBundledPositionAddress,
  getCloseBundledPositionDiscriminatorBytes,
  getCloseBundledPositionInstruction,
  getCloseBundledPositionInstructionDataCodec,
  getCloseBundledPositionInstructionDataDecoder,
  getCloseBundledPositionInstructionDataEncoder,
  getClosePositionDiscriminatorBytes,
  getClosePositionInstruction,
  getClosePositionInstructionDataCodec,
  getClosePositionInstructionDataDecoder,
  getClosePositionInstructionDataEncoder,
  getClosePositionWithTokenExtensionsDiscriminatorBytes,
  getClosePositionWithTokenExtensionsInstruction,
  getClosePositionWithTokenExtensionsInstructionDataCodec,
  getClosePositionWithTokenExtensionsInstructionDataDecoder,
  getClosePositionWithTokenExtensionsInstructionDataEncoder,
  getCollectFeesDiscriminatorBytes,
  getCollectFeesInstruction,
  getCollectFeesInstructionDataCodec,
  getCollectFeesInstructionDataDecoder,
  getCollectFeesInstructionDataEncoder,
  getCollectFeesV2DiscriminatorBytes,
  getCollectFeesV2Instruction,
  getCollectFeesV2InstructionDataCodec,
  getCollectFeesV2InstructionDataDecoder,
  getCollectFeesV2InstructionDataEncoder,
  getCollectProtocolFeesDiscriminatorBytes,
  getCollectProtocolFeesInstruction,
  getCollectProtocolFeesInstructionDataCodec,
  getCollectProtocolFeesInstructionDataDecoder,
  getCollectProtocolFeesInstructionDataEncoder,
  getCollectProtocolFeesV2DiscriminatorBytes,
  getCollectProtocolFeesV2Instruction,
  getCollectProtocolFeesV2InstructionDataCodec,
  getCollectProtocolFeesV2InstructionDataDecoder,
  getCollectProtocolFeesV2InstructionDataEncoder,
  getCollectRewardDiscriminatorBytes,
  getCollectRewardInstruction,
  getCollectRewardInstructionDataCodec,
  getCollectRewardInstructionDataDecoder,
  getCollectRewardInstructionDataEncoder,
  getCollectRewardV2DiscriminatorBytes,
  getCollectRewardV2Instruction,
  getCollectRewardV2InstructionDataCodec,
  getCollectRewardV2InstructionDataDecoder,
  getCollectRewardV2InstructionDataEncoder,
  getDecreaseLiquidityDiscriminatorBytes,
  getDecreaseLiquidityInstruction,
  getDecreaseLiquidityInstructionDataCodec,
  getDecreaseLiquidityInstructionDataDecoder,
  getDecreaseLiquidityInstructionDataEncoder,
  getDecreaseLiquidityV2DiscriminatorBytes,
  getDecreaseLiquidityV2Instruction,
  getDecreaseLiquidityV2InstructionDataCodec,
  getDecreaseLiquidityV2InstructionDataDecoder,
  getDecreaseLiquidityV2InstructionDataEncoder,
  getDeletePositionBundleDiscriminatorBytes,
  getDeletePositionBundleInstruction,
  getDeletePositionBundleInstructionDataCodec,
  getDeletePositionBundleInstructionDataDecoder,
  getDeletePositionBundleInstructionDataEncoder,
  getDeleteTokenBadgeDiscriminatorBytes,
  getDeleteTokenBadgeInstruction,
  getDeleteTokenBadgeInstructionDataCodec,
  getDeleteTokenBadgeInstructionDataDecoder,
  getDeleteTokenBadgeInstructionDataEncoder,
  getFeeTierAddress,
  getFeeTierCodec,
  getFeeTierDecoder,
  getFeeTierDiscriminatorBytes,
  getFeeTierEncoder,
  getFeeTierSize,
  getIncreaseLiquidityDiscriminatorBytes,
  getIncreaseLiquidityInstruction,
  getIncreaseLiquidityInstructionDataCodec,
  getIncreaseLiquidityInstructionDataDecoder,
  getIncreaseLiquidityInstructionDataEncoder,
  getIncreaseLiquidityV2DiscriminatorBytes,
  getIncreaseLiquidityV2Instruction,
  getIncreaseLiquidityV2InstructionDataCodec,
  getIncreaseLiquidityV2InstructionDataDecoder,
  getIncreaseLiquidityV2InstructionDataEncoder,
  getInitializeAdaptiveFeeTierDiscriminatorBytes,
  getInitializeAdaptiveFeeTierInstruction,
  getInitializeAdaptiveFeeTierInstructionDataCodec,
  getInitializeAdaptiveFeeTierInstructionDataDecoder,
  getInitializeAdaptiveFeeTierInstructionDataEncoder,
  getInitializeConfigDiscriminatorBytes,
  getInitializeConfigExtensionDiscriminatorBytes,
  getInitializeConfigExtensionInstruction,
  getInitializeConfigExtensionInstructionDataCodec,
  getInitializeConfigExtensionInstructionDataDecoder,
  getInitializeConfigExtensionInstructionDataEncoder,
  getInitializeConfigInstruction,
  getInitializeConfigInstructionDataCodec,
  getInitializeConfigInstructionDataDecoder,
  getInitializeConfigInstructionDataEncoder,
  getInitializeFeeTierDiscriminatorBytes,
  getInitializeFeeTierInstruction,
  getInitializeFeeTierInstructionDataCodec,
  getInitializeFeeTierInstructionDataDecoder,
  getInitializeFeeTierInstructionDataEncoder,
  getInitializePoolDiscriminatorBytes,
  getInitializePoolInstruction,
  getInitializePoolInstructionDataCodec,
  getInitializePoolInstructionDataDecoder,
  getInitializePoolInstructionDataEncoder,
  getInitializePoolV2DiscriminatorBytes,
  getInitializePoolV2Instruction,
  getInitializePoolV2InstructionDataCodec,
  getInitializePoolV2InstructionDataDecoder,
  getInitializePoolV2InstructionDataEncoder,
  getInitializePoolWithAdaptiveFeeDiscriminatorBytes,
  getInitializePoolWithAdaptiveFeeInstruction,
  getInitializePoolWithAdaptiveFeeInstructionDataCodec,
  getInitializePoolWithAdaptiveFeeInstructionDataDecoder,
  getInitializePoolWithAdaptiveFeeInstructionDataEncoder,
  getInitializePositionBundleDiscriminatorBytes,
  getInitializePositionBundleInstruction,
  getInitializePositionBundleInstructionDataCodec,
  getInitializePositionBundleInstructionDataDecoder,
  getInitializePositionBundleInstructionDataEncoder,
  getInitializePositionBundleWithMetadataDiscriminatorBytes,
  getInitializePositionBundleWithMetadataInstruction,
  getInitializePositionBundleWithMetadataInstructionDataCodec,
  getInitializePositionBundleWithMetadataInstructionDataDecoder,
  getInitializePositionBundleWithMetadataInstructionDataEncoder,
  getInitializeRewardDiscriminatorBytes,
  getInitializeRewardInstruction,
  getInitializeRewardInstructionDataCodec,
  getInitializeRewardInstructionDataDecoder,
  getInitializeRewardInstructionDataEncoder,
  getInitializeRewardV2DiscriminatorBytes,
  getInitializeRewardV2Instruction,
  getInitializeRewardV2InstructionDataCodec,
  getInitializeRewardV2InstructionDataDecoder,
  getInitializeRewardV2InstructionDataEncoder,
  getInitializeTickArrayDiscriminatorBytes,
  getInitializeTickArrayInstruction,
  getInitializeTickArrayInstructionDataCodec,
  getInitializeTickArrayInstructionDataDecoder,
  getInitializeTickArrayInstructionDataEncoder,
  getInitializeTokenBadgeDiscriminatorBytes,
  getInitializeTokenBadgeInstruction,
  getInitializeTokenBadgeInstructionDataCodec,
  getInitializeTokenBadgeInstructionDataDecoder,
  getInitializeTokenBadgeInstructionDataEncoder,
  getLockConfigCodec,
  getLockConfigDecoder,
  getLockConfigDiscriminatorBytes,
  getLockConfigEncoder,
  getLockConfigSize,
  getLockPositionDiscriminatorBytes,
  getLockPositionInstruction,
  getLockPositionInstructionDataCodec,
  getLockPositionInstructionDataDecoder,
  getLockPositionInstructionDataEncoder,
  getLockTypeCodec,
  getLockTypeDecoder,
  getLockTypeEncoder,
  getLockTypeLabelCodec,
  getLockTypeLabelDecoder,
  getLockTypeLabelEncoder,
  getOpenBundledPositionDiscriminatorBytes,
  getOpenBundledPositionInstruction,
  getOpenBundledPositionInstructionDataCodec,
  getOpenBundledPositionInstructionDataDecoder,
  getOpenBundledPositionInstructionDataEncoder,
  getOpenPositionDiscriminatorBytes,
  getOpenPositionInstruction,
  getOpenPositionInstructionDataCodec,
  getOpenPositionInstructionDataDecoder,
  getOpenPositionInstructionDataEncoder,
  getOpenPositionWithMetadataDiscriminatorBytes,
  getOpenPositionWithMetadataInstruction,
  getOpenPositionWithMetadataInstructionDataCodec,
  getOpenPositionWithMetadataInstructionDataDecoder,
  getOpenPositionWithMetadataInstructionDataEncoder,
  getOpenPositionWithTokenExtensionsDiscriminatorBytes,
  getOpenPositionWithTokenExtensionsInstruction,
  getOpenPositionWithTokenExtensionsInstructionDataCodec,
  getOpenPositionWithTokenExtensionsInstructionDataDecoder,
  getOpenPositionWithTokenExtensionsInstructionDataEncoder,
  getOracleAddress,
  getOracleCodec,
  getOracleDecoder,
  getOracleDiscriminatorBytes,
  getOracleEncoder,
  getOracleSize,
  getPositionAddress,
  getPositionBundleAddress,
  getPositionBundleCodec,
  getPositionBundleDecoder,
  getPositionBundleDiscriminatorBytes,
  getPositionBundleEncoder,
  getPositionBundleSize,
  getPositionCodec,
  getPositionDecoder,
  getPositionDiscriminatorBytes,
  getPositionEncoder,
  getPositionRewardInfoCodec,
  getPositionRewardInfoDecoder,
  getPositionRewardInfoEncoder,
  getPositionSize,
  getRemainingAccountsInfoCodec,
  getRemainingAccountsInfoDecoder,
  getRemainingAccountsInfoEncoder,
  getRemainingAccountsSliceCodec,
  getRemainingAccountsSliceDecoder,
  getRemainingAccountsSliceEncoder,
  getResetPositionRangeDiscriminatorBytes,
  getResetPositionRangeInstruction,
  getResetPositionRangeInstructionDataCodec,
  getResetPositionRangeInstructionDataDecoder,
  getResetPositionRangeInstructionDataEncoder,
  getSetCollectProtocolFeesAuthorityDiscriminatorBytes,
  getSetCollectProtocolFeesAuthorityInstruction,
  getSetCollectProtocolFeesAuthorityInstructionDataCodec,
  getSetCollectProtocolFeesAuthorityInstructionDataDecoder,
  getSetCollectProtocolFeesAuthorityInstructionDataEncoder,
  getSetConfigExtensionAuthorityDiscriminatorBytes,
  getSetConfigExtensionAuthorityInstruction,
  getSetConfigExtensionAuthorityInstructionDataCodec,
  getSetConfigExtensionAuthorityInstructionDataDecoder,
  getSetConfigExtensionAuthorityInstructionDataEncoder,
  getSetDefaultBaseFeeRateDiscriminatorBytes,
  getSetDefaultBaseFeeRateInstruction,
  getSetDefaultBaseFeeRateInstructionDataCodec,
  getSetDefaultBaseFeeRateInstructionDataDecoder,
  getSetDefaultBaseFeeRateInstructionDataEncoder,
  getSetDefaultFeeRateDiscriminatorBytes,
  getSetDefaultFeeRateInstruction,
  getSetDefaultFeeRateInstructionDataCodec,
  getSetDefaultFeeRateInstructionDataDecoder,
  getSetDefaultFeeRateInstructionDataEncoder,
  getSetDefaultProtocolFeeRateDiscriminatorBytes,
  getSetDefaultProtocolFeeRateInstruction,
  getSetDefaultProtocolFeeRateInstructionDataCodec,
  getSetDefaultProtocolFeeRateInstructionDataDecoder,
  getSetDefaultProtocolFeeRateInstructionDataEncoder,
  getSetDelegatedFeeAuthorityDiscriminatorBytes,
  getSetDelegatedFeeAuthorityInstruction,
  getSetDelegatedFeeAuthorityInstructionDataCodec,
  getSetDelegatedFeeAuthorityInstructionDataDecoder,
  getSetDelegatedFeeAuthorityInstructionDataEncoder,
  getSetFeeAuthorityDiscriminatorBytes,
  getSetFeeAuthorityInstruction,
  getSetFeeAuthorityInstructionDataCodec,
  getSetFeeAuthorityInstructionDataDecoder,
  getSetFeeAuthorityInstructionDataEncoder,
  getSetFeeRateByDelegatedFeeAuthorityDiscriminatorBytes,
  getSetFeeRateByDelegatedFeeAuthorityInstruction,
  getSetFeeRateByDelegatedFeeAuthorityInstructionDataCodec,
  getSetFeeRateByDelegatedFeeAuthorityInstructionDataDecoder,
  getSetFeeRateByDelegatedFeeAuthorityInstructionDataEncoder,
  getSetFeeRateDiscriminatorBytes,
  getSetFeeRateInstruction,
  getSetFeeRateInstructionDataCodec,
  getSetFeeRateInstructionDataDecoder,
  getSetFeeRateInstructionDataEncoder,
  getSetInitializePoolAuthorityDiscriminatorBytes,
  getSetInitializePoolAuthorityInstruction,
  getSetInitializePoolAuthorityInstructionDataCodec,
  getSetInitializePoolAuthorityInstructionDataDecoder,
  getSetInitializePoolAuthorityInstructionDataEncoder,
  getSetPresetAdaptiveFeeConstantsDiscriminatorBytes,
  getSetPresetAdaptiveFeeConstantsInstruction,
  getSetPresetAdaptiveFeeConstantsInstructionDataCodec,
  getSetPresetAdaptiveFeeConstantsInstructionDataDecoder,
  getSetPresetAdaptiveFeeConstantsInstructionDataEncoder,
  getSetProtocolFeeRateDiscriminatorBytes,
  getSetProtocolFeeRateInstruction,
  getSetProtocolFeeRateInstructionDataCodec,
  getSetProtocolFeeRateInstructionDataDecoder,
  getSetProtocolFeeRateInstructionDataEncoder,
  getSetRewardAuthorityBySuperAuthorityDiscriminatorBytes,
  getSetRewardAuthorityBySuperAuthorityInstruction,
  getSetRewardAuthorityBySuperAuthorityInstructionDataCodec,
  getSetRewardAuthorityBySuperAuthorityInstructionDataDecoder,
  getSetRewardAuthorityBySuperAuthorityInstructionDataEncoder,
  getSetRewardAuthorityDiscriminatorBytes,
  getSetRewardAuthorityInstruction,
  getSetRewardAuthorityInstructionDataCodec,
  getSetRewardAuthorityInstructionDataDecoder,
  getSetRewardAuthorityInstructionDataEncoder,
  getSetRewardEmissionsDiscriminatorBytes,
  getSetRewardEmissionsInstruction,
  getSetRewardEmissionsInstructionDataCodec,
  getSetRewardEmissionsInstructionDataDecoder,
  getSetRewardEmissionsInstructionDataEncoder,
  getSetRewardEmissionsSuperAuthorityDiscriminatorBytes,
  getSetRewardEmissionsSuperAuthorityInstruction,
  getSetRewardEmissionsSuperAuthorityInstructionDataCodec,
  getSetRewardEmissionsSuperAuthorityInstructionDataDecoder,
  getSetRewardEmissionsSuperAuthorityInstructionDataEncoder,
  getSetRewardEmissionsV2DiscriminatorBytes,
  getSetRewardEmissionsV2Instruction,
  getSetRewardEmissionsV2InstructionDataCodec,
  getSetRewardEmissionsV2InstructionDataDecoder,
  getSetRewardEmissionsV2InstructionDataEncoder,
  getSetTokenBadgeAuthorityDiscriminatorBytes,
  getSetTokenBadgeAuthorityInstruction,
  getSetTokenBadgeAuthorityInstructionDataCodec,
  getSetTokenBadgeAuthorityInstructionDataDecoder,
  getSetTokenBadgeAuthorityInstructionDataEncoder,
  getSwapDiscriminatorBytes,
  getSwapInstruction,
  getSwapInstructionDataCodec,
  getSwapInstructionDataDecoder,
  getSwapInstructionDataEncoder,
  getSwapV2DiscriminatorBytes,
  getSwapV2Instruction,
  getSwapV2InstructionDataCodec,
  getSwapV2InstructionDataDecoder,
  getSwapV2InstructionDataEncoder,
  getTickArrayAddress,
  getTickArrayCodec,
  getTickArrayDecoder,
  getTickArrayDiscriminatorBytes,
  getTickArrayEncoder,
  getTickArraySize,
  getTickCodec,
  getTickDecoder,
  getTickEncoder,
  getTokenBadgeAddress,
  getTokenBadgeCodec,
  getTokenBadgeDecoder,
  getTokenBadgeDiscriminatorBytes,
  getTokenBadgeEncoder,
  getTokenBadgeSize,
  getTransferLockedPositionDiscriminatorBytes,
  getTransferLockedPositionInstruction,
  getTransferLockedPositionInstructionDataCodec,
  getTransferLockedPositionInstructionDataDecoder,
  getTransferLockedPositionInstructionDataEncoder,
  getTwoHopSwapDiscriminatorBytes,
  getTwoHopSwapInstruction,
  getTwoHopSwapInstructionDataCodec,
  getTwoHopSwapInstructionDataDecoder,
  getTwoHopSwapInstructionDataEncoder,
  getTwoHopSwapV2DiscriminatorBytes,
  getTwoHopSwapV2Instruction,
  getTwoHopSwapV2InstructionDataCodec,
  getTwoHopSwapV2InstructionDataDecoder,
  getTwoHopSwapV2InstructionDataEncoder,
  getUpdateFeesAndRewardsDiscriminatorBytes,
  getUpdateFeesAndRewardsInstruction,
  getUpdateFeesAndRewardsInstructionDataCodec,
  getUpdateFeesAndRewardsInstructionDataDecoder,
  getUpdateFeesAndRewardsInstructionDataEncoder,
  getWhirlpoolAddress,
  getWhirlpoolCodec,
  getWhirlpoolDecoder,
  getWhirlpoolDiscriminatorBytes,
  getWhirlpoolEncoder,
  getWhirlpoolErrorMessage,
  getWhirlpoolRewardInfoCodec,
  getWhirlpoolRewardInfoDecoder,
  getWhirlpoolRewardInfoEncoder,
  getWhirlpoolSize,
  getWhirlpoolsConfigCodec,
  getWhirlpoolsConfigDecoder,
  getWhirlpoolsConfigDiscriminatorBytes,
  getWhirlpoolsConfigEncoder,
  getWhirlpoolsConfigExtensionAddress,
  getWhirlpoolsConfigExtensionCodec,
  getWhirlpoolsConfigExtensionDecoder,
  getWhirlpoolsConfigExtensionDiscriminatorBytes,
  getWhirlpoolsConfigExtensionEncoder,
  getWhirlpoolsConfigExtensionSize,
  getWhirlpoolsConfigSize,
  identifyWhirlpoolAccount,
  identifyWhirlpoolInstruction,
  isWhirlpoolError,
  oracleAdaptiveFeeControlFactorFilter,
  oracleDecayPeriodFilter,
  oracleFilterPeriodFilter,
  oracleMajorSwapThresholdTicksFilter,
  oracleMaxVolatilityFilter,
  oracleReductionFactorFilter,
  oracleTickGroupSizeFilter,
  oracleTradeEnableTimestampFilter,
  oracleWhirlpoolFilter,
  parseCloseBundledPositionInstruction,
  parseClosePositionInstruction,
  parseClosePositionWithTokenExtensionsInstruction,
  parseCollectFeesInstruction,
  parseCollectFeesV2Instruction,
  parseCollectProtocolFeesInstruction,
  parseCollectProtocolFeesV2Instruction,
  parseCollectRewardInstruction,
  parseCollectRewardV2Instruction,
  parseDecreaseLiquidityInstruction,
  parseDecreaseLiquidityV2Instruction,
  parseDeletePositionBundleInstruction,
  parseDeleteTokenBadgeInstruction,
  parseIncreaseLiquidityInstruction,
  parseIncreaseLiquidityV2Instruction,
  parseInitializeAdaptiveFeeTierInstruction,
  parseInitializeConfigExtensionInstruction,
  parseInitializeConfigInstruction,
  parseInitializeFeeTierInstruction,
  parseInitializePoolInstruction,
  parseInitializePoolV2Instruction,
  parseInitializePoolWithAdaptiveFeeInstruction,
  parseInitializePositionBundleInstruction,
  parseInitializePositionBundleWithMetadataInstruction,
  parseInitializeRewardInstruction,
  parseInitializeRewardV2Instruction,
  parseInitializeTickArrayInstruction,
  parseInitializeTokenBadgeInstruction,
  parseLockPositionInstruction,
  parseOpenBundledPositionInstruction,
  parseOpenPositionInstruction,
  parseOpenPositionWithMetadataInstruction,
  parseOpenPositionWithTokenExtensionsInstruction,
  parseResetPositionRangeInstruction,
  parseSetCollectProtocolFeesAuthorityInstruction,
  parseSetConfigExtensionAuthorityInstruction,
  parseSetDefaultBaseFeeRateInstruction,
  parseSetDefaultFeeRateInstruction,
  parseSetDefaultProtocolFeeRateInstruction,
  parseSetDelegatedFeeAuthorityInstruction,
  parseSetFeeAuthorityInstruction,
  parseSetFeeRateByDelegatedFeeAuthorityInstruction,
  parseSetFeeRateInstruction,
  parseSetInitializePoolAuthorityInstruction,
  parseSetPresetAdaptiveFeeConstantsInstruction,
  parseSetProtocolFeeRateInstruction,
  parseSetRewardAuthorityBySuperAuthorityInstruction,
  parseSetRewardAuthorityInstruction,
  parseSetRewardEmissionsInstruction,
  parseSetRewardEmissionsSuperAuthorityInstruction,
  parseSetRewardEmissionsV2Instruction,
  parseSetTokenBadgeAuthorityInstruction,
  parseSwapInstruction,
  parseSwapV2Instruction,
  parseTransferLockedPositionInstruction,
  parseTwoHopSwapInstruction,
  parseTwoHopSwapV2Instruction,
  parseUpdateFeesAndRewardsInstruction,
  positionBundleMintFilter,
  positionMintFilter,
  positionTickLowerIndexFilter,
  positionTickUpperIndexFilter,
  positionWhirlpoolFilter,
  tickArrayStartTickIndexFilter,
  tickArrayWhirlpoolFilter,
  tokenBadgeTokenMintFilter,
  tokenBadgeWhirlpoolsConfigFilter,
  whirlpoolFeeRateFilter,
  whirlpoolProtocolFeeRateFilter,
  whirlpoolRewardMint1Filter,
  whirlpoolRewardMint2Filter,
  whirlpoolRewardMint3Filter,
  whirlpoolRewardVault1Filter,
  whirlpoolRewardVault2Filter,
  whirlpoolRewardVault3Filter,
  whirlpoolTickSpacingFilter,
  whirlpoolTokenMintAFilter,
  whirlpoolTokenMintBFilter,
  whirlpoolTokenVaultAFilter,
  whirlpoolTokenVaultBFilter,
  whirlpoolWhirlpoolConfigFilter,
  whirlpoolsConfigCollectProtocolFeesAuthorityFilter,
  whirlpoolsConfigDefaultProtocolFeeRateFilter,
  whirlpoolsConfigExtensionConfigExtensionAuthorityFilter,
  whirlpoolsConfigExtensionConfigTokenBadgeAuthorityFilter,
  whirlpoolsConfigExtensionWhirlpoolsConfigFilter,
  whirlpoolsConfigFeeAuthorityFilter,
  whirlpoolsConfigRewardEmissionsSuperAuthorityFilter
});
//# sourceMappingURL=index.cjs.map
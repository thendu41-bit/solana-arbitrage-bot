'use strict';

var kit = require('@solana/kit');

// src/generated/accounts/addressLookupTable.ts
async function findAddressLookupTablePda(seeds, config = {}) {
  const {
    programAddress = "AddressLookupTab1e1111111111111111111111111"
  } = config;
  return await kit.getProgramDerivedAddress({
    programAddress,
    seeds: [
      kit.getAddressEncoder().encode(seeds.authority),
      kit.getU64Encoder().encode(seeds.recentSlot)
    ]
  });
}

// src/generated/accounts/addressLookupTable.ts
var ADDRESS_LOOKUP_TABLE_DISCRIMINATOR = 1;
function getAddressLookupTableDiscriminatorBytes() {
  return kit.getU32Encoder().encode(ADDRESS_LOOKUP_TABLE_DISCRIMINATOR);
}
function getAddressLookupTableEncoder() {
  return kit.transformEncoder(
    kit.getStructEncoder([
      ["discriminator", kit.getU32Encoder()],
      ["deactivationSlot", kit.getU64Encoder()],
      ["lastExtendedSlot", kit.getU64Encoder()],
      ["lastExtendedSlotStartIndex", kit.getU8Encoder()],
      [
        "authority",
        kit.getOptionEncoder(kit.getAddressEncoder(), { noneValue: "zeroes" })
      ],
      ["padding", kit.getU16Encoder()],
      [
        "addresses",
        kit.getArrayEncoder(kit.getAddressEncoder(), { size: "remainder" })
      ]
    ]),
    (value) => ({
      ...value,
      discriminator: ADDRESS_LOOKUP_TABLE_DISCRIMINATOR,
      padding: 0
    })
  );
}
function getAddressLookupTableDecoder() {
  return kit.getStructDecoder([
    ["discriminator", kit.getU32Decoder()],
    ["deactivationSlot", kit.getU64Decoder()],
    ["lastExtendedSlot", kit.getU64Decoder()],
    ["lastExtendedSlotStartIndex", kit.getU8Decoder()],
    [
      "authority",
      kit.getOptionDecoder(kit.getAddressDecoder(), { noneValue: "zeroes" })
    ],
    ["padding", kit.getU16Decoder()],
    ["addresses", kit.getArrayDecoder(kit.getAddressDecoder(), { size: "remainder" })]
  ]);
}
function getAddressLookupTableCodec() {
  return kit.combineCodec(
    getAddressLookupTableEncoder(),
    getAddressLookupTableDecoder()
  );
}
function decodeAddressLookupTable(encodedAccount) {
  return kit.decodeAccount(
    encodedAccount,
    getAddressLookupTableDecoder()
  );
}
async function fetchAddressLookupTable(rpc, address, config) {
  const maybeAccount = await fetchMaybeAddressLookupTable(rpc, address, config);
  kit.assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeAddressLookupTable(rpc, address, config) {
  const maybeAccount = await kit.fetchEncodedAccount(rpc, address, config);
  return decodeAddressLookupTable(maybeAccount);
}
async function fetchAllAddressLookupTable(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeAddressLookupTable(
    rpc,
    addresses,
    config
  );
  kit.assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeAddressLookupTable(rpc, addresses, config) {
  const maybeAccounts = await kit.fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map(
    (maybeAccount) => decodeAddressLookupTable(maybeAccount)
  );
}
async function fetchAddressLookupTableFromSeeds(rpc, seeds, config = {}) {
  const maybeAccount = await fetchMaybeAddressLookupTableFromSeeds(
    rpc,
    seeds,
    config
  );
  kit.assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeAddressLookupTableFromSeeds(rpc, seeds, config = {}) {
  const { programAddress, ...fetchConfig } = config;
  const [address] = await findAddressLookupTablePda(seeds, { programAddress });
  return await fetchMaybeAddressLookupTable(rpc, address, fetchConfig);
}
var ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS = "AddressLookupTab1e1111111111111111111111111";
var AddressLookupTableAccount = /* @__PURE__ */ ((AddressLookupTableAccount2) => {
  AddressLookupTableAccount2[AddressLookupTableAccount2["AddressLookupTable"] = 0] = "AddressLookupTable";
  return AddressLookupTableAccount2;
})(AddressLookupTableAccount || {});
function identifyAddressLookupTableAccount(account) {
  const data = "data" in account ? account.data : account;
  if (kit.containsBytes(data, kit.getU32Encoder().encode(1), 0)) {
    return 0 /* AddressLookupTable */;
  }
  throw new Error(
    "The provided account could not be identified as a addressLookupTable account."
  );
}
var AddressLookupTableInstruction = /* @__PURE__ */ ((AddressLookupTableInstruction2) => {
  AddressLookupTableInstruction2[AddressLookupTableInstruction2["CreateLookupTable"] = 0] = "CreateLookupTable";
  AddressLookupTableInstruction2[AddressLookupTableInstruction2["FreezeLookupTable"] = 1] = "FreezeLookupTable";
  AddressLookupTableInstruction2[AddressLookupTableInstruction2["ExtendLookupTable"] = 2] = "ExtendLookupTable";
  AddressLookupTableInstruction2[AddressLookupTableInstruction2["DeactivateLookupTable"] = 3] = "DeactivateLookupTable";
  AddressLookupTableInstruction2[AddressLookupTableInstruction2["CloseLookupTable"] = 4] = "CloseLookupTable";
  return AddressLookupTableInstruction2;
})(AddressLookupTableInstruction || {});
function identifyAddressLookupTableInstruction(instruction) {
  const data = "data" in instruction ? instruction.data : instruction;
  if (kit.containsBytes(data, kit.getU32Encoder().encode(0), 0)) {
    return 0 /* CreateLookupTable */;
  }
  if (kit.containsBytes(data, kit.getU32Encoder().encode(1), 0)) {
    return 1 /* FreezeLookupTable */;
  }
  if (kit.containsBytes(data, kit.getU32Encoder().encode(2), 0)) {
    return 2 /* ExtendLookupTable */;
  }
  if (kit.containsBytes(data, kit.getU32Encoder().encode(3), 0)) {
    return 3 /* DeactivateLookupTable */;
  }
  if (kit.containsBytes(data, kit.getU32Encoder().encode(4), 0)) {
    return 4 /* CloseLookupTable */;
  }
  throw new Error(
    "The provided instruction could not be identified as a addressLookupTable instruction."
  );
}
function expectSome(value) {
  if (value == null) {
    throw new Error("Expected a value but received null or undefined.");
  }
  return value;
}
function expectAddress(value) {
  if (!value) {
    throw new Error("Expected a Address.");
  }
  if (typeof value === "object" && "address" in value) {
    return value.address;
  }
  if (Array.isArray(value)) {
    return value[0];
  }
  return value;
}
function expectProgramDerivedAddress(value) {
  if (!value || !Array.isArray(value) || !kit.isProgramDerivedAddress(value)) {
    throw new Error("Expected a ProgramDerivedAddress.");
  }
  return value;
}
function getAccountMetaFactory(programAddress, optionalAccountStrategy) {
  return (account) => {
    if (!account.value) {
      return Object.freeze({
        address: programAddress,
        role: kit.AccountRole.READONLY
      });
    }
    const writableRole = account.isWritable ? kit.AccountRole.WRITABLE : kit.AccountRole.READONLY;
    return Object.freeze({
      address: expectAddress(account.value),
      role: isTransactionSigner(account.value) ? kit.upgradeRoleToSigner(writableRole) : writableRole,
      ...isTransactionSigner(account.value) ? { signer: account.value } : {}
    });
  };
}
function isTransactionSigner(value) {
  return !!value && typeof value === "object" && "address" in value && kit.isTransactionSigner(value);
}

// src/generated/instructions/closeLookupTable.ts
var CLOSE_LOOKUP_TABLE_DISCRIMINATOR = 4;
function getCloseLookupTableDiscriminatorBytes() {
  return kit.getU32Encoder().encode(CLOSE_LOOKUP_TABLE_DISCRIMINATOR);
}
function getCloseLookupTableInstructionDataEncoder() {
  return kit.transformEncoder(
    kit.getStructEncoder([["discriminator", kit.getU32Encoder()]]),
    (value) => ({ ...value, discriminator: CLOSE_LOOKUP_TABLE_DISCRIMINATOR })
  );
}
function getCloseLookupTableInstructionDataDecoder() {
  return kit.getStructDecoder([["discriminator", kit.getU32Decoder()]]);
}
function getCloseLookupTableInstructionDataCodec() {
  return kit.combineCodec(
    getCloseLookupTableInstructionDataEncoder(),
    getCloseLookupTableInstructionDataDecoder()
  );
}
function getCloseLookupTableInstruction(input, config) {
  const programAddress = config?.programAddress ?? ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS;
  const originalAccounts = {
    address: { value: input.address ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    recipient: { value: input.recipient ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.address),
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.recipient)
    ],
    programAddress,
    data: getCloseLookupTableInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseCloseLookupTableInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      address: getNextAccount(),
      authority: getNextAccount(),
      recipient: getNextAccount()
    },
    data: getCloseLookupTableInstructionDataDecoder().decode(instruction.data)
  };
}
var CREATE_LOOKUP_TABLE_DISCRIMINATOR = 0;
function getCreateLookupTableDiscriminatorBytes() {
  return kit.getU32Encoder().encode(CREATE_LOOKUP_TABLE_DISCRIMINATOR);
}
function getCreateLookupTableInstructionDataEncoder() {
  return kit.transformEncoder(
    kit.getStructEncoder([
      ["discriminator", kit.getU32Encoder()],
      ["recentSlot", kit.getU64Encoder()],
      ["bump", kit.getU8Encoder()]
    ]),
    (value) => ({ ...value, discriminator: CREATE_LOOKUP_TABLE_DISCRIMINATOR })
  );
}
function getCreateLookupTableInstructionDataDecoder() {
  return kit.getStructDecoder([
    ["discriminator", kit.getU32Decoder()],
    ["recentSlot", kit.getU64Decoder()],
    ["bump", kit.getU8Decoder()]
  ]);
}
function getCreateLookupTableInstructionDataCodec() {
  return kit.combineCodec(
    getCreateLookupTableInstructionDataEncoder(),
    getCreateLookupTableInstructionDataDecoder()
  );
}
async function getCreateLookupTableInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS;
  const originalAccounts = {
    address: { value: input.address ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    payer: { value: input.payer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.address.value) {
    accounts.address.value = await findAddressLookupTablePda({
      authority: expectAddress(accounts.authority.value),
      recentSlot: expectSome(args.recentSlot)
    });
  }
  if (!accounts.payer.value) {
    accounts.payer.value = expectSome(accounts.authority.value);
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!args.bump) {
    args.bump = expectProgramDerivedAddress(accounts.address.value)[1];
  }
  const byteDelta = [56 + kit.BASE_ACCOUNT_SIZE].reduce((a, b) => a + b, 0);
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.address),
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getCreateLookupTableInstructionDataEncoder().encode(
      args
    )
  };
  return Object.freeze({ ...instruction, byteDelta });
}
function getCreateLookupTableInstruction(input, config) {
  const programAddress = config?.programAddress ?? ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS;
  const originalAccounts = {
    address: { value: input.address ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    payer: { value: input.payer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.payer.value) {
    accounts.payer.value = expectSome(accounts.authority.value);
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!args.bump) {
    args.bump = expectProgramDerivedAddress(accounts.address.value)[1];
  }
  const byteDelta = [56 + kit.BASE_ACCOUNT_SIZE].reduce((a, b) => a + b, 0);
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.address),
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getCreateLookupTableInstructionDataEncoder().encode(
      args
    )
  };
  return Object.freeze({ ...instruction, byteDelta });
}
function parseCreateLookupTableInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      address: getNextAccount(),
      authority: getNextAccount(),
      payer: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getCreateLookupTableInstructionDataDecoder().decode(instruction.data)
  };
}
var DEACTIVATE_LOOKUP_TABLE_DISCRIMINATOR = 3;
function getDeactivateLookupTableDiscriminatorBytes() {
  return kit.getU32Encoder().encode(DEACTIVATE_LOOKUP_TABLE_DISCRIMINATOR);
}
function getDeactivateLookupTableInstructionDataEncoder() {
  return kit.transformEncoder(
    kit.getStructEncoder([["discriminator", kit.getU32Encoder()]]),
    (value) => ({
      ...value,
      discriminator: DEACTIVATE_LOOKUP_TABLE_DISCRIMINATOR
    })
  );
}
function getDeactivateLookupTableInstructionDataDecoder() {
  return kit.getStructDecoder([["discriminator", kit.getU32Decoder()]]);
}
function getDeactivateLookupTableInstructionDataCodec() {
  return kit.combineCodec(
    getDeactivateLookupTableInstructionDataEncoder(),
    getDeactivateLookupTableInstructionDataDecoder()
  );
}
function getDeactivateLookupTableInstruction(input, config) {
  const programAddress = config?.programAddress ?? ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS;
  const originalAccounts = {
    address: { value: input.address ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.address),
      getAccountMeta(accounts.authority)
    ],
    programAddress,
    data: getDeactivateLookupTableInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseDeactivateLookupTableInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      address: getNextAccount(),
      authority: getNextAccount()
    },
    data: getDeactivateLookupTableInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/hooked/resolvers.ts
var resolveExtendLookupTableBytes = (scope) => 32 * scope.args.addresses.length;

// src/generated/instructions/extendLookupTable.ts
var EXTEND_LOOKUP_TABLE_DISCRIMINATOR = 2;
function getExtendLookupTableDiscriminatorBytes() {
  return kit.getU32Encoder().encode(EXTEND_LOOKUP_TABLE_DISCRIMINATOR);
}
function getExtendLookupTableInstructionDataEncoder() {
  return kit.transformEncoder(
    kit.getStructEncoder([
      ["discriminator", kit.getU32Encoder()],
      [
        "addresses",
        kit.getArrayEncoder(kit.getAddressEncoder(), { size: kit.getU64Encoder() })
      ]
    ]),
    (value) => ({ ...value, discriminator: EXTEND_LOOKUP_TABLE_DISCRIMINATOR })
  );
}
function getExtendLookupTableInstructionDataDecoder() {
  return kit.getStructDecoder([
    ["discriminator", kit.getU32Decoder()],
    [
      "addresses",
      kit.getArrayDecoder(kit.getAddressDecoder(), { size: kit.getU64Decoder() })
    ]
  ]);
}
function getExtendLookupTableInstructionDataCodec() {
  return kit.combineCodec(
    getExtendLookupTableInstructionDataEncoder(),
    getExtendLookupTableInstructionDataDecoder()
  );
}
function getExtendLookupTableInstruction(input, config) {
  const programAddress = config?.programAddress ?? ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS;
  const originalAccounts = {
    address: { value: input.address ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    payer: { value: input.payer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const resolverScope = { programAddress, accounts, args };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const byteDelta = [
    resolveExtendLookupTableBytes(resolverScope)
  ].reduce((a, b) => a + b, 0);
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.address),
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getExtendLookupTableInstructionDataEncoder().encode(
      args
    )
  };
  return Object.freeze({ ...instruction, byteDelta });
}
function parseExtendLookupTableInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      address: getNextAccount(),
      authority: getNextAccount(),
      payer: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getExtendLookupTableInstructionDataDecoder().decode(instruction.data)
  };
}
var FREEZE_LOOKUP_TABLE_DISCRIMINATOR = 1;
function getFreezeLookupTableDiscriminatorBytes() {
  return kit.getU32Encoder().encode(FREEZE_LOOKUP_TABLE_DISCRIMINATOR);
}
function getFreezeLookupTableInstructionDataEncoder() {
  return kit.transformEncoder(
    kit.getStructEncoder([["discriminator", kit.getU32Encoder()]]),
    (value) => ({ ...value, discriminator: FREEZE_LOOKUP_TABLE_DISCRIMINATOR })
  );
}
function getFreezeLookupTableInstructionDataDecoder() {
  return kit.getStructDecoder([["discriminator", kit.getU32Decoder()]]);
}
function getFreezeLookupTableInstructionDataCodec() {
  return kit.combineCodec(
    getFreezeLookupTableInstructionDataEncoder(),
    getFreezeLookupTableInstructionDataDecoder()
  );
}
function getFreezeLookupTableInstruction(input, config) {
  const programAddress = config?.programAddress ?? ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS;
  const originalAccounts = {
    address: { value: input.address ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.address),
      getAccountMeta(accounts.authority)
    ],
    programAddress,
    data: getFreezeLookupTableInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseFreezeLookupTableInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      address: getNextAccount(),
      authority: getNextAccount()
    },
    data: getFreezeLookupTableInstructionDataDecoder().decode(instruction.data)
  };
}

exports.ADDRESS_LOOKUP_TABLE_DISCRIMINATOR = ADDRESS_LOOKUP_TABLE_DISCRIMINATOR;
exports.ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS = ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS;
exports.AddressLookupTableAccount = AddressLookupTableAccount;
exports.AddressLookupTableInstruction = AddressLookupTableInstruction;
exports.CLOSE_LOOKUP_TABLE_DISCRIMINATOR = CLOSE_LOOKUP_TABLE_DISCRIMINATOR;
exports.CREATE_LOOKUP_TABLE_DISCRIMINATOR = CREATE_LOOKUP_TABLE_DISCRIMINATOR;
exports.DEACTIVATE_LOOKUP_TABLE_DISCRIMINATOR = DEACTIVATE_LOOKUP_TABLE_DISCRIMINATOR;
exports.EXTEND_LOOKUP_TABLE_DISCRIMINATOR = EXTEND_LOOKUP_TABLE_DISCRIMINATOR;
exports.FREEZE_LOOKUP_TABLE_DISCRIMINATOR = FREEZE_LOOKUP_TABLE_DISCRIMINATOR;
exports.decodeAddressLookupTable = decodeAddressLookupTable;
exports.fetchAddressLookupTable = fetchAddressLookupTable;
exports.fetchAddressLookupTableFromSeeds = fetchAddressLookupTableFromSeeds;
exports.fetchAllAddressLookupTable = fetchAllAddressLookupTable;
exports.fetchAllMaybeAddressLookupTable = fetchAllMaybeAddressLookupTable;
exports.fetchMaybeAddressLookupTable = fetchMaybeAddressLookupTable;
exports.fetchMaybeAddressLookupTableFromSeeds = fetchMaybeAddressLookupTableFromSeeds;
exports.findAddressLookupTablePda = findAddressLookupTablePda;
exports.getAddressLookupTableCodec = getAddressLookupTableCodec;
exports.getAddressLookupTableDecoder = getAddressLookupTableDecoder;
exports.getAddressLookupTableDiscriminatorBytes = getAddressLookupTableDiscriminatorBytes;
exports.getAddressLookupTableEncoder = getAddressLookupTableEncoder;
exports.getCloseLookupTableDiscriminatorBytes = getCloseLookupTableDiscriminatorBytes;
exports.getCloseLookupTableInstruction = getCloseLookupTableInstruction;
exports.getCloseLookupTableInstructionDataCodec = getCloseLookupTableInstructionDataCodec;
exports.getCloseLookupTableInstructionDataDecoder = getCloseLookupTableInstructionDataDecoder;
exports.getCloseLookupTableInstructionDataEncoder = getCloseLookupTableInstructionDataEncoder;
exports.getCreateLookupTableDiscriminatorBytes = getCreateLookupTableDiscriminatorBytes;
exports.getCreateLookupTableInstruction = getCreateLookupTableInstruction;
exports.getCreateLookupTableInstructionAsync = getCreateLookupTableInstructionAsync;
exports.getCreateLookupTableInstructionDataCodec = getCreateLookupTableInstructionDataCodec;
exports.getCreateLookupTableInstructionDataDecoder = getCreateLookupTableInstructionDataDecoder;
exports.getCreateLookupTableInstructionDataEncoder = getCreateLookupTableInstructionDataEncoder;
exports.getDeactivateLookupTableDiscriminatorBytes = getDeactivateLookupTableDiscriminatorBytes;
exports.getDeactivateLookupTableInstruction = getDeactivateLookupTableInstruction;
exports.getDeactivateLookupTableInstructionDataCodec = getDeactivateLookupTableInstructionDataCodec;
exports.getDeactivateLookupTableInstructionDataDecoder = getDeactivateLookupTableInstructionDataDecoder;
exports.getDeactivateLookupTableInstructionDataEncoder = getDeactivateLookupTableInstructionDataEncoder;
exports.getExtendLookupTableDiscriminatorBytes = getExtendLookupTableDiscriminatorBytes;
exports.getExtendLookupTableInstruction = getExtendLookupTableInstruction;
exports.getExtendLookupTableInstructionDataCodec = getExtendLookupTableInstructionDataCodec;
exports.getExtendLookupTableInstructionDataDecoder = getExtendLookupTableInstructionDataDecoder;
exports.getExtendLookupTableInstructionDataEncoder = getExtendLookupTableInstructionDataEncoder;
exports.getFreezeLookupTableDiscriminatorBytes = getFreezeLookupTableDiscriminatorBytes;
exports.getFreezeLookupTableInstruction = getFreezeLookupTableInstruction;
exports.getFreezeLookupTableInstructionDataCodec = getFreezeLookupTableInstructionDataCodec;
exports.getFreezeLookupTableInstructionDataDecoder = getFreezeLookupTableInstructionDataDecoder;
exports.getFreezeLookupTableInstructionDataEncoder = getFreezeLookupTableInstructionDataEncoder;
exports.identifyAddressLookupTableAccount = identifyAddressLookupTableAccount;
exports.identifyAddressLookupTableInstruction = identifyAddressLookupTableInstruction;
exports.parseCloseLookupTableInstruction = parseCloseLookupTableInstruction;
exports.parseCreateLookupTableInstruction = parseCreateLookupTableInstruction;
exports.parseDeactivateLookupTableInstruction = parseDeactivateLookupTableInstruction;
exports.parseExtendLookupTableInstruction = parseExtendLookupTableInstruction;
exports.parseFreezeLookupTableInstruction = parseFreezeLookupTableInstruction;
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map
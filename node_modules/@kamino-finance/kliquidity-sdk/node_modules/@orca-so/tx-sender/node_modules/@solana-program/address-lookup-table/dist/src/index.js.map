{"version":3,"sources":["../../src/generated/pdas/addressLookupTable.ts","../../src/generated/accounts/addressLookupTable.ts","../../src/generated/programs/addressLookupTable.ts","../../src/generated/shared/index.ts","../../src/generated/instructions/closeLookupTable.ts","../../src/generated/instructions/createLookupTable.ts","../../src/generated/instructions/deactivateLookupTable.ts","../../src/hooked/resolvers.ts","../../src/generated/instructions/extendLookupTable.ts","../../src/generated/instructions/freezeLookupTable.ts"],"names":["getProgramDerivedAddress","getAddressEncoder","getU64Encoder","getU32Encoder","transformEncoder","getStructEncoder","getU8Encoder","getOptionEncoder","getU16Encoder","getArrayEncoder","getStructDecoder","getU32Decoder","getU64Decoder","getU8Decoder","getOptionDecoder","getAddressDecoder","getU16Decoder","getArrayDecoder","combineCodec","decodeAccount","assertAccountExists","fetchEncodedAccount","assertAccountsExist","fetchEncodedAccounts","AddressLookupTableAccount","containsBytes","AddressLookupTableInstruction","isProgramDerivedAddress","AccountRole","upgradeRoleToSigner","kitIsTransactionSigner","BASE_ACCOUNT_SIZE"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  getAddressEncoder,\n  getProgramDerivedAddress,\n  getU64Encoder,\n  type Address,\n  type ProgramDerivedAddress,\n} from '@solana/kit';\n\nexport type AddressLookupTableSeeds = {\n  /** The address of the LUT's authority */\n  authority: Address;\n  /** The recent slot associated with the LUT */\n  recentSlot: number | bigint;\n};\n\nexport async function findAddressLookupTablePda(\n  seeds: AddressLookupTableSeeds,\n  config: { programAddress?: Address | undefined } = {}\n): Promise<ProgramDerivedAddress> {\n  const {\n    programAddress = 'AddressLookupTab1e1111111111111111111111111' as Address<'AddressLookupTab1e1111111111111111111111111'>,\n  } = config;\n  return await getProgramDerivedAddress({\n    programAddress,\n    seeds: [\n      getAddressEncoder().encode(seeds.authority),\n      getU64Encoder().encode(seeds.recentSlot),\n    ],\n  });\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  getAddressDecoder,\n  getAddressEncoder,\n  getArrayDecoder,\n  getArrayEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Account,\n  type Address,\n  type Codec,\n  type Decoder,\n  type EncodedAccount,\n  type Encoder,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n  type Option,\n  type OptionOrNullable,\n} from '@solana/kit';\nimport { AddressLookupTableSeeds, findAddressLookupTablePda } from '../pdas';\n\nexport const ADDRESS_LOOKUP_TABLE_DISCRIMINATOR = 1;\n\nexport function getAddressLookupTableDiscriminatorBytes() {\n  return getU32Encoder().encode(ADDRESS_LOOKUP_TABLE_DISCRIMINATOR);\n}\n\nexport type AddressLookupTable = {\n  discriminator: number;\n  deactivationSlot: bigint;\n  lastExtendedSlot: bigint;\n  lastExtendedSlotStartIndex: number;\n  authority: Option<Address>;\n  padding: number;\n  addresses: Array<Address>;\n};\n\nexport type AddressLookupTableArgs = {\n  deactivationSlot: number | bigint;\n  lastExtendedSlot: number | bigint;\n  lastExtendedSlotStartIndex: number;\n  authority: OptionOrNullable<Address>;\n  addresses: Array<Address>;\n};\n\nexport function getAddressLookupTableEncoder(): Encoder<AddressLookupTableArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['deactivationSlot', getU64Encoder()],\n      ['lastExtendedSlot', getU64Encoder()],\n      ['lastExtendedSlotStartIndex', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), { noneValue: 'zeroes' }),\n      ],\n      ['padding', getU16Encoder()],\n      [\n        'addresses',\n        getArrayEncoder(getAddressEncoder(), { size: 'remainder' }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: ADDRESS_LOOKUP_TABLE_DISCRIMINATOR,\n      padding: 0,\n    })\n  );\n}\n\nexport function getAddressLookupTableDecoder(): Decoder<AddressLookupTable> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['deactivationSlot', getU64Decoder()],\n    ['lastExtendedSlot', getU64Decoder()],\n    ['lastExtendedSlotStartIndex', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), { noneValue: 'zeroes' }),\n    ],\n    ['padding', getU16Decoder()],\n    ['addresses', getArrayDecoder(getAddressDecoder(), { size: 'remainder' })],\n  ]);\n}\n\nexport function getAddressLookupTableCodec(): Codec<\n  AddressLookupTableArgs,\n  AddressLookupTable\n> {\n  return combineCodec(\n    getAddressLookupTableEncoder(),\n    getAddressLookupTableDecoder()\n  );\n}\n\nexport function decodeAddressLookupTable<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<AddressLookupTable, TAddress>;\nexport function decodeAddressLookupTable<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<AddressLookupTable, TAddress>;\nexport function decodeAddressLookupTable<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n):\n  | Account<AddressLookupTable, TAddress>\n  | MaybeAccount<AddressLookupTable, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getAddressLookupTableDecoder()\n  );\n}\n\nexport async function fetchAddressLookupTable<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<AddressLookupTable, TAddress>> {\n  const maybeAccount = await fetchMaybeAddressLookupTable(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeAddressLookupTable<\n  TAddress extends string = string,\n>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<AddressLookupTable, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeAddressLookupTable(maybeAccount);\n}\n\nexport async function fetchAllAddressLookupTable(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<AddressLookupTable>[]> {\n  const maybeAccounts = await fetchAllMaybeAddressLookupTable(\n    rpc,\n    addresses,\n    config\n  );\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeAddressLookupTable(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<AddressLookupTable>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) =>\n    decodeAddressLookupTable(maybeAccount)\n  );\n}\n\nexport async function fetchAddressLookupTableFromSeeds(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  seeds: AddressLookupTableSeeds,\n  config: FetchAccountConfig & { programAddress?: Address } = {}\n): Promise<Account<AddressLookupTable>> {\n  const maybeAccount = await fetchMaybeAddressLookupTableFromSeeds(\n    rpc,\n    seeds,\n    config\n  );\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeAddressLookupTableFromSeeds(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  seeds: AddressLookupTableSeeds,\n  config: FetchAccountConfig & { programAddress?: Address } = {}\n): Promise<MaybeAccount<AddressLookupTable>> {\n  const { programAddress, ...fetchConfig } = config;\n  const [address] = await findAddressLookupTablePda(seeds, { programAddress });\n  return await fetchMaybeAddressLookupTable(rpc, address, fetchConfig);\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  containsBytes,\n  getU32Encoder,\n  type Address,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  type ParsedCloseLookupTableInstruction,\n  type ParsedCreateLookupTableInstruction,\n  type ParsedDeactivateLookupTableInstruction,\n  type ParsedExtendLookupTableInstruction,\n  type ParsedFreezeLookupTableInstruction,\n} from '../instructions';\n\nexport const ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS =\n  'AddressLookupTab1e1111111111111111111111111' as Address<'AddressLookupTab1e1111111111111111111111111'>;\n\nexport enum AddressLookupTableAccount {\n  AddressLookupTable,\n}\n\nexport function identifyAddressLookupTableAccount(\n  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): AddressLookupTableAccount {\n  const data = 'data' in account ? account.data : account;\n  if (containsBytes(data, getU32Encoder().encode(1), 0)) {\n    return AddressLookupTableAccount.AddressLookupTable;\n  }\n  throw new Error(\n    'The provided account could not be identified as a addressLookupTable account.'\n  );\n}\n\nexport enum AddressLookupTableInstruction {\n  CreateLookupTable,\n  FreezeLookupTable,\n  ExtendLookupTable,\n  DeactivateLookupTable,\n  CloseLookupTable,\n}\n\nexport function identifyAddressLookupTableInstruction(\n  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): AddressLookupTableInstruction {\n  const data = 'data' in instruction ? instruction.data : instruction;\n  if (containsBytes(data, getU32Encoder().encode(0), 0)) {\n    return AddressLookupTableInstruction.CreateLookupTable;\n  }\n  if (containsBytes(data, getU32Encoder().encode(1), 0)) {\n    return AddressLookupTableInstruction.FreezeLookupTable;\n  }\n  if (containsBytes(data, getU32Encoder().encode(2), 0)) {\n    return AddressLookupTableInstruction.ExtendLookupTable;\n  }\n  if (containsBytes(data, getU32Encoder().encode(3), 0)) {\n    return AddressLookupTableInstruction.DeactivateLookupTable;\n  }\n  if (containsBytes(data, getU32Encoder().encode(4), 0)) {\n    return AddressLookupTableInstruction.CloseLookupTable;\n  }\n  throw new Error(\n    'The provided instruction could not be identified as a addressLookupTable instruction.'\n  );\n}\n\nexport type ParsedAddressLookupTableInstruction<\n  TProgram extends string = 'AddressLookupTab1e1111111111111111111111111',\n> =\n  | ({\n      instructionType: AddressLookupTableInstruction.CreateLookupTable;\n    } & ParsedCreateLookupTableInstruction<TProgram>)\n  | ({\n      instructionType: AddressLookupTableInstruction.FreezeLookupTable;\n    } & ParsedFreezeLookupTableInstruction<TProgram>)\n  | ({\n      instructionType: AddressLookupTableInstruction.ExtendLookupTable;\n    } & ParsedExtendLookupTableInstruction<TProgram>)\n  | ({\n      instructionType: AddressLookupTableInstruction.DeactivateLookupTable;\n    } & ParsedDeactivateLookupTableInstruction<TProgram>)\n  | ({\n      instructionType: AddressLookupTableInstruction.CloseLookupTable;\n    } & ParsedCloseLookupTableInstruction<TProgram>);\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  isProgramDerivedAddress,\n  isTransactionSigner as kitIsTransactionSigner,\n  type Address,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type ProgramDerivedAddress,\n  type TransactionSigner,\n  upgradeRoleToSigner,\n} from '@solana/kit';\n\n/**\n * Asserts that the given value is not null or undefined.\n * @internal\n */\nexport function expectSome<T>(value: T | null | undefined): T {\n  if (value == null) {\n    throw new Error('Expected a value but received null or undefined.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a PublicKey.\n * @internal\n */\nexport function expectAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): Address<T> {\n  if (!value) {\n    throw new Error('Expected a Address.');\n  }\n  if (typeof value === 'object' && 'address' in value) {\n    return value.address;\n  }\n  if (Array.isArray(value)) {\n    return value[0];\n  }\n  return value as Address<T>;\n}\n\n/**\n * Asserts that the given value is a PDA.\n * @internal\n */\nexport function expectProgramDerivedAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): ProgramDerivedAddress<T> {\n  if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {\n    throw new Error('Expected a ProgramDerivedAddress.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a TransactionSigner.\n * @internal\n */\nexport function expectTransactionSigner<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): TransactionSigner<T> {\n  if (!value || !isTransactionSigner(value)) {\n    throw new Error('Expected a TransactionSigner.');\n  }\n  return value;\n}\n\n/**\n * Defines an instruction account to resolve.\n * @internal\n */\nexport type ResolvedAccount<\n  T extends string = string,\n  U extends\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null =\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null,\n> = {\n  isWritable: boolean;\n  value: U;\n};\n\n/**\n * Defines an instruction that stores additional bytes on-chain.\n * @internal\n */\nexport type IInstructionWithByteDelta = {\n  byteDelta: number;\n};\n\n/**\n * Get account metas and signers from resolved accounts.\n * @internal\n */\nexport function getAccountMetaFactory(\n  programAddress: Address,\n  optionalAccountStrategy: 'omitted' | 'programId'\n) {\n  return (\n    account: ResolvedAccount\n  ): IAccountMeta | IAccountSignerMeta | undefined => {\n    if (!account.value) {\n      if (optionalAccountStrategy === 'omitted') return;\n      return Object.freeze({\n        address: programAddress,\n        role: AccountRole.READONLY,\n      });\n    }\n\n    const writableRole = account.isWritable\n      ? AccountRole.WRITABLE\n      : AccountRole.READONLY;\n    return Object.freeze({\n      address: expectAddress(account.value),\n      role: isTransactionSigner(account.value)\n        ? upgradeRoleToSigner(writableRole)\n        : writableRole,\n      ...(isTransactionSigner(account.value) ? { signer: account.value } : {}),\n    });\n  };\n}\n\nexport function isTransactionSigner<TAddress extends string = string>(\n  value:\n    | Address<TAddress>\n    | ProgramDerivedAddress<TAddress>\n    | TransactionSigner<TAddress>\n): value is TransactionSigner<TAddress> {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    'address' in value &&\n    kitIsTransactionSigner(value)\n  );\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const CLOSE_LOOKUP_TABLE_DISCRIMINATOR = 4;\n\nexport function getCloseLookupTableDiscriminatorBytes() {\n  return getU32Encoder().encode(CLOSE_LOOKUP_TABLE_DISCRIMINATOR);\n}\n\nexport type CloseLookupTableInstruction<\n  TProgram extends string = typeof ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS,\n  TAccountAddress extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TAccountRecipient extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAddress extends string\n        ? WritableAccount<TAccountAddress>\n        : TAccountAddress,\n      TAccountAuthority extends string\n        ? ReadonlySignerAccount<TAccountAuthority> &\n            IAccountSignerMeta<TAccountAuthority>\n        : TAccountAuthority,\n      TAccountRecipient extends string\n        ? WritableAccount<TAccountRecipient>\n        : TAccountRecipient,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CloseLookupTableInstructionData = { discriminator: number };\n\nexport type CloseLookupTableInstructionDataArgs = {};\n\nexport function getCloseLookupTableInstructionDataEncoder(): Encoder<CloseLookupTableInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU32Encoder()]]),\n    (value) => ({ ...value, discriminator: CLOSE_LOOKUP_TABLE_DISCRIMINATOR })\n  );\n}\n\nexport function getCloseLookupTableInstructionDataDecoder(): Decoder<CloseLookupTableInstructionData> {\n  return getStructDecoder([['discriminator', getU32Decoder()]]);\n}\n\nexport function getCloseLookupTableInstructionDataCodec(): Codec<\n  CloseLookupTableInstructionDataArgs,\n  CloseLookupTableInstructionData\n> {\n  return combineCodec(\n    getCloseLookupTableInstructionDataEncoder(),\n    getCloseLookupTableInstructionDataDecoder()\n  );\n}\n\nexport type CloseLookupTableInput<\n  TAccountAddress extends string = string,\n  TAccountAuthority extends string = string,\n  TAccountRecipient extends string = string,\n> = {\n  address: Address<TAccountAddress>;\n  authority: TransactionSigner<TAccountAuthority>;\n  recipient: Address<TAccountRecipient>;\n};\n\nexport function getCloseLookupTableInstruction<\n  TAccountAddress extends string,\n  TAccountAuthority extends string,\n  TAccountRecipient extends string,\n  TProgramAddress extends Address = typeof ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS,\n>(\n  input: CloseLookupTableInput<\n    TAccountAddress,\n    TAccountAuthority,\n    TAccountRecipient\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CloseLookupTableInstruction<\n  TProgramAddress,\n  TAccountAddress,\n  TAccountAuthority,\n  TAccountRecipient\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    address: { value: input.address ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n    recipient: { value: input.recipient ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.address),\n      getAccountMeta(accounts.authority),\n      getAccountMeta(accounts.recipient),\n    ],\n    programAddress,\n    data: getCloseLookupTableInstructionDataEncoder().encode({}),\n  } as CloseLookupTableInstruction<\n    TProgramAddress,\n    TAccountAddress,\n    TAccountAuthority,\n    TAccountRecipient\n  >;\n\n  return instruction;\n}\n\nexport type ParsedCloseLookupTableInstruction<\n  TProgram extends string = typeof ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    address: TAccountMetas[0];\n    authority: TAccountMetas[1];\n    recipient: TAccountMetas[2];\n  };\n  data: CloseLookupTableInstructionData;\n};\n\nexport function parseCloseLookupTableInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedCloseLookupTableInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      address: getNextAccount(),\n      authority: getNextAccount(),\n      recipient: getNextAccount(),\n    },\n    data: getCloseLookupTableInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  BASE_ACCOUNT_SIZE,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ProgramDerivedAddress,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { findAddressLookupTablePda } from '../pdas';\nimport { ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS } from '../programs';\nimport {\n  expectAddress,\n  expectProgramDerivedAddress,\n  expectSome,\n  getAccountMetaFactory,\n  type IInstructionWithByteDelta,\n  type ResolvedAccount,\n} from '../shared';\n\nexport const CREATE_LOOKUP_TABLE_DISCRIMINATOR = 0;\n\nexport function getCreateLookupTableDiscriminatorBytes() {\n  return getU32Encoder().encode(CREATE_LOOKUP_TABLE_DISCRIMINATOR);\n}\n\nexport type CreateLookupTableInstruction<\n  TProgram extends string = typeof ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS,\n  TAccountAddress extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAddress extends string\n        ? WritableAccount<TAccountAddress>\n        : TAccountAddress,\n      TAccountAuthority extends string\n        ? ReadonlySignerAccount<TAccountAuthority> &\n            IAccountSignerMeta<TAccountAuthority>\n        : TAccountAuthority,\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            IAccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateLookupTableInstructionData = {\n  discriminator: number;\n  recentSlot: bigint;\n  bump: number;\n};\n\nexport type CreateLookupTableInstructionDataArgs = {\n  recentSlot: number | bigint;\n  bump: number;\n};\n\nexport function getCreateLookupTableInstructionDataEncoder(): Encoder<CreateLookupTableInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      ['recentSlot', getU64Encoder()],\n      ['bump', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: CREATE_LOOKUP_TABLE_DISCRIMINATOR })\n  );\n}\n\nexport function getCreateLookupTableInstructionDataDecoder(): Decoder<CreateLookupTableInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    ['recentSlot', getU64Decoder()],\n    ['bump', getU8Decoder()],\n  ]);\n}\n\nexport function getCreateLookupTableInstructionDataCodec(): Codec<\n  CreateLookupTableInstructionDataArgs,\n  CreateLookupTableInstructionData\n> {\n  return combineCodec(\n    getCreateLookupTableInstructionDataEncoder(),\n    getCreateLookupTableInstructionDataDecoder()\n  );\n}\n\nexport type CreateLookupTableAsyncInput<\n  TAccountAddress extends string = string,\n  TAccountAuthority extends string = string,\n  TAccountPayer extends string = string,\n  TAccountSystemProgram extends string = string,\n> = {\n  address?: ProgramDerivedAddress<TAccountAddress>;\n  authority: TransactionSigner<TAccountAuthority>;\n  payer?: TransactionSigner<TAccountPayer>;\n  systemProgram?: Address<TAccountSystemProgram>;\n  recentSlot: CreateLookupTableInstructionDataArgs['recentSlot'];\n  bump?: CreateLookupTableInstructionDataArgs['bump'];\n};\n\nexport async function getCreateLookupTableInstructionAsync<\n  TAccountAddress extends string,\n  TAccountAuthority extends string,\n  TAccountPayer extends string,\n  TAccountSystemProgram extends string,\n  TProgramAddress extends Address = typeof ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS,\n>(\n  input: CreateLookupTableAsyncInput<\n    TAccountAddress,\n    TAccountAuthority,\n    TAccountPayer,\n    TAccountSystemProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): Promise<\n  CreateLookupTableInstruction<\n    TProgramAddress,\n    TAccountAddress,\n    TAccountAuthority,\n    TAccountPayer,\n    TAccountSystemProgram\n  > &\n    IInstructionWithByteDelta\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    address: { value: input.address ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n    payer: { value: input.payer ?? null, isWritable: true },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.address.value) {\n    accounts.address.value = await findAddressLookupTablePda({\n      authority: expectAddress(accounts.authority.value),\n      recentSlot: expectSome(args.recentSlot),\n    });\n  }\n  if (!accounts.payer.value) {\n    accounts.payer.value = expectSome(accounts.authority.value);\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n  if (!args.bump) {\n    args.bump = expectProgramDerivedAddress(accounts.address.value)[1];\n  }\n\n  // Bytes created or reallocated by the instruction.\n  const byteDelta: number = [56 + BASE_ACCOUNT_SIZE].reduce((a, b) => a + b, 0);\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.address),\n      getAccountMeta(accounts.authority),\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.systemProgram),\n    ],\n    programAddress,\n    data: getCreateLookupTableInstructionDataEncoder().encode(\n      args as CreateLookupTableInstructionDataArgs\n    ),\n  } as CreateLookupTableInstruction<\n    TProgramAddress,\n    TAccountAddress,\n    TAccountAuthority,\n    TAccountPayer,\n    TAccountSystemProgram\n  >;\n\n  return Object.freeze({ ...instruction, byteDelta });\n}\n\nexport type CreateLookupTableInput<\n  TAccountAddress extends string = string,\n  TAccountAuthority extends string = string,\n  TAccountPayer extends string = string,\n  TAccountSystemProgram extends string = string,\n> = {\n  address: ProgramDerivedAddress<TAccountAddress>;\n  authority: TransactionSigner<TAccountAuthority>;\n  payer?: TransactionSigner<TAccountPayer>;\n  systemProgram?: Address<TAccountSystemProgram>;\n  recentSlot: CreateLookupTableInstructionDataArgs['recentSlot'];\n  bump?: CreateLookupTableInstructionDataArgs['bump'];\n};\n\nexport function getCreateLookupTableInstruction<\n  TAccountAddress extends string,\n  TAccountAuthority extends string,\n  TAccountPayer extends string,\n  TAccountSystemProgram extends string,\n  TProgramAddress extends Address = typeof ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS,\n>(\n  input: CreateLookupTableInput<\n    TAccountAddress,\n    TAccountAuthority,\n    TAccountPayer,\n    TAccountSystemProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CreateLookupTableInstruction<\n  TProgramAddress,\n  TAccountAddress,\n  TAccountAuthority,\n  TAccountPayer,\n  TAccountSystemProgram\n> &\n  IInstructionWithByteDelta {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    address: { value: input.address ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n    payer: { value: input.payer ?? null, isWritable: true },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.payer.value) {\n    accounts.payer.value = expectSome(accounts.authority.value);\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n  if (!args.bump) {\n    args.bump = expectProgramDerivedAddress(accounts.address.value)[1];\n  }\n\n  // Bytes created or reallocated by the instruction.\n  const byteDelta: number = [56 + BASE_ACCOUNT_SIZE].reduce((a, b) => a + b, 0);\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.address),\n      getAccountMeta(accounts.authority),\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.systemProgram),\n    ],\n    programAddress,\n    data: getCreateLookupTableInstructionDataEncoder().encode(\n      args as CreateLookupTableInstructionDataArgs\n    ),\n  } as CreateLookupTableInstruction<\n    TProgramAddress,\n    TAccountAddress,\n    TAccountAuthority,\n    TAccountPayer,\n    TAccountSystemProgram\n  >;\n\n  return Object.freeze({ ...instruction, byteDelta });\n}\n\nexport type ParsedCreateLookupTableInstruction<\n  TProgram extends string = typeof ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    address: TAccountMetas[0];\n    authority: TAccountMetas[1];\n    payer: TAccountMetas[2];\n    systemProgram: TAccountMetas[3];\n  };\n  data: CreateLookupTableInstructionData;\n};\n\nexport function parseCreateLookupTableInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedCreateLookupTableInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      address: getNextAccount(),\n      authority: getNextAccount(),\n      payer: getNextAccount(),\n      systemProgram: getNextAccount(),\n    },\n    data: getCreateLookupTableInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const DEACTIVATE_LOOKUP_TABLE_DISCRIMINATOR = 3;\n\nexport function getDeactivateLookupTableDiscriminatorBytes() {\n  return getU32Encoder().encode(DEACTIVATE_LOOKUP_TABLE_DISCRIMINATOR);\n}\n\nexport type DeactivateLookupTableInstruction<\n  TProgram extends string = typeof ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS,\n  TAccountAddress extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAddress extends string\n        ? WritableAccount<TAccountAddress>\n        : TAccountAddress,\n      TAccountAuthority extends string\n        ? ReadonlySignerAccount<TAccountAuthority> &\n            IAccountSignerMeta<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type DeactivateLookupTableInstructionData = { discriminator: number };\n\nexport type DeactivateLookupTableInstructionDataArgs = {};\n\nexport function getDeactivateLookupTableInstructionDataEncoder(): Encoder<DeactivateLookupTableInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU32Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: DEACTIVATE_LOOKUP_TABLE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getDeactivateLookupTableInstructionDataDecoder(): Decoder<DeactivateLookupTableInstructionData> {\n  return getStructDecoder([['discriminator', getU32Decoder()]]);\n}\n\nexport function getDeactivateLookupTableInstructionDataCodec(): Codec<\n  DeactivateLookupTableInstructionDataArgs,\n  DeactivateLookupTableInstructionData\n> {\n  return combineCodec(\n    getDeactivateLookupTableInstructionDataEncoder(),\n    getDeactivateLookupTableInstructionDataDecoder()\n  );\n}\n\nexport type DeactivateLookupTableInput<\n  TAccountAddress extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  address: Address<TAccountAddress>;\n  authority: TransactionSigner<TAccountAuthority>;\n};\n\nexport function getDeactivateLookupTableInstruction<\n  TAccountAddress extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS,\n>(\n  input: DeactivateLookupTableInput<TAccountAddress, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): DeactivateLookupTableInstruction<\n  TProgramAddress,\n  TAccountAddress,\n  TAccountAuthority\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    address: { value: input.address ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.address),\n      getAccountMeta(accounts.authority),\n    ],\n    programAddress,\n    data: getDeactivateLookupTableInstructionDataEncoder().encode({}),\n  } as DeactivateLookupTableInstruction<\n    TProgramAddress,\n    TAccountAddress,\n    TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedDeactivateLookupTableInstruction<\n  TProgram extends string = typeof ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    address: TAccountMetas[0];\n    authority: TAccountMetas[1];\n  };\n  data: DeactivateLookupTableInstructionData;\n};\n\nexport function parseDeactivateLookupTableInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedDeactivateLookupTableInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      address: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getDeactivateLookupTableInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","import type { Address } from '@solana/kit';\n\nexport const resolveExtendLookupTableBytes = (scope: {\n  args: { addresses: Array<Address> };\n}): number => 32 * scope.args.addresses.length;\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getArrayDecoder,\n  getArrayEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { resolveExtendLookupTableBytes } from '../../hooked';\nimport { ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS } from '../programs';\nimport {\n  getAccountMetaFactory,\n  type IInstructionWithByteDelta,\n  type ResolvedAccount,\n} from '../shared';\n\nexport const EXTEND_LOOKUP_TABLE_DISCRIMINATOR = 2;\n\nexport function getExtendLookupTableDiscriminatorBytes() {\n  return getU32Encoder().encode(EXTEND_LOOKUP_TABLE_DISCRIMINATOR);\n}\n\nexport type ExtendLookupTableInstruction<\n  TProgram extends string = typeof ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS,\n  TAccountAddress extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TAccountPayer extends string | IAccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | IAccountMeta<string> = '11111111111111111111111111111111',\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAddress extends string\n        ? WritableAccount<TAccountAddress>\n        : TAccountAddress,\n      TAccountAuthority extends string\n        ? ReadonlySignerAccount<TAccountAuthority> &\n            IAccountSignerMeta<TAccountAuthority>\n        : TAccountAuthority,\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            IAccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ExtendLookupTableInstructionData = {\n  discriminator: number;\n  addresses: Array<Address>;\n};\n\nexport type ExtendLookupTableInstructionDataArgs = {\n  addresses: Array<Address>;\n};\n\nexport function getExtendLookupTableInstructionDataEncoder(): Encoder<ExtendLookupTableInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU32Encoder()],\n      [\n        'addresses',\n        getArrayEncoder(getAddressEncoder(), { size: getU64Encoder() }),\n      ],\n    ]),\n    (value) => ({ ...value, discriminator: EXTEND_LOOKUP_TABLE_DISCRIMINATOR })\n  );\n}\n\nexport function getExtendLookupTableInstructionDataDecoder(): Decoder<ExtendLookupTableInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU32Decoder()],\n    [\n      'addresses',\n      getArrayDecoder(getAddressDecoder(), { size: getU64Decoder() }),\n    ],\n  ]);\n}\n\nexport function getExtendLookupTableInstructionDataCodec(): Codec<\n  ExtendLookupTableInstructionDataArgs,\n  ExtendLookupTableInstructionData\n> {\n  return combineCodec(\n    getExtendLookupTableInstructionDataEncoder(),\n    getExtendLookupTableInstructionDataDecoder()\n  );\n}\n\nexport type ExtendLookupTableInput<\n  TAccountAddress extends string = string,\n  TAccountAuthority extends string = string,\n  TAccountPayer extends string = string,\n  TAccountSystemProgram extends string = string,\n> = {\n  address: Address<TAccountAddress>;\n  authority: TransactionSigner<TAccountAuthority>;\n  payer: TransactionSigner<TAccountPayer>;\n  systemProgram?: Address<TAccountSystemProgram>;\n  addresses: ExtendLookupTableInstructionDataArgs['addresses'];\n};\n\nexport function getExtendLookupTableInstruction<\n  TAccountAddress extends string,\n  TAccountAuthority extends string,\n  TAccountPayer extends string,\n  TAccountSystemProgram extends string,\n  TProgramAddress extends Address = typeof ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS,\n>(\n  input: ExtendLookupTableInput<\n    TAccountAddress,\n    TAccountAuthority,\n    TAccountPayer,\n    TAccountSystemProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ExtendLookupTableInstruction<\n  TProgramAddress,\n  TAccountAddress,\n  TAccountAuthority,\n  TAccountPayer,\n  TAccountSystemProgram\n> &\n  IInstructionWithByteDelta {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    address: { value: input.address ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n    payer: { value: input.payer ?? null, isWritable: true },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolver scope.\n  const resolverScope = { programAddress, accounts, args };\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  // Bytes created or reallocated by the instruction.\n  const byteDelta: number = [\n    resolveExtendLookupTableBytes(resolverScope),\n  ].reduce((a, b) => a + b, 0);\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.address),\n      getAccountMeta(accounts.authority),\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.systemProgram),\n    ],\n    programAddress,\n    data: getExtendLookupTableInstructionDataEncoder().encode(\n      args as ExtendLookupTableInstructionDataArgs\n    ),\n  } as ExtendLookupTableInstruction<\n    TProgramAddress,\n    TAccountAddress,\n    TAccountAuthority,\n    TAccountPayer,\n    TAccountSystemProgram\n  >;\n\n  return Object.freeze({ ...instruction, byteDelta });\n}\n\nexport type ParsedExtendLookupTableInstruction<\n  TProgram extends string = typeof ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    address: TAccountMetas[0];\n    authority: TAccountMetas[1];\n    payer: TAccountMetas[2];\n    systemProgram: TAccountMetas[3];\n  };\n  data: ExtendLookupTableInstructionData;\n};\n\nexport function parseExtendLookupTableInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedExtendLookupTableInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      address: getNextAccount(),\n      authority: getNextAccount(),\n      payer: getNextAccount(),\n      systemProgram: getNextAccount(),\n    },\n    data: getExtendLookupTableInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  transformEncoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type IAccountMeta,\n  type IAccountSignerMeta,\n  type IInstruction,\n  type IInstructionWithAccounts,\n  type IInstructionWithData,\n  type ReadonlySignerAccount,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const FREEZE_LOOKUP_TABLE_DISCRIMINATOR = 1;\n\nexport function getFreezeLookupTableDiscriminatorBytes() {\n  return getU32Encoder().encode(FREEZE_LOOKUP_TABLE_DISCRIMINATOR);\n}\n\nexport type FreezeLookupTableInstruction<\n  TProgram extends string = typeof ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS,\n  TAccountAddress extends string | IAccountMeta<string> = string,\n  TAccountAuthority extends string | IAccountMeta<string> = string,\n  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],\n> = IInstruction<TProgram> &\n  IInstructionWithData<Uint8Array> &\n  IInstructionWithAccounts<\n    [\n      TAccountAddress extends string\n        ? WritableAccount<TAccountAddress>\n        : TAccountAddress,\n      TAccountAuthority extends string\n        ? ReadonlySignerAccount<TAccountAuthority> &\n            IAccountSignerMeta<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type FreezeLookupTableInstructionData = { discriminator: number };\n\nexport type FreezeLookupTableInstructionDataArgs = {};\n\nexport function getFreezeLookupTableInstructionDataEncoder(): Encoder<FreezeLookupTableInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU32Encoder()]]),\n    (value) => ({ ...value, discriminator: FREEZE_LOOKUP_TABLE_DISCRIMINATOR })\n  );\n}\n\nexport function getFreezeLookupTableInstructionDataDecoder(): Decoder<FreezeLookupTableInstructionData> {\n  return getStructDecoder([['discriminator', getU32Decoder()]]);\n}\n\nexport function getFreezeLookupTableInstructionDataCodec(): Codec<\n  FreezeLookupTableInstructionDataArgs,\n  FreezeLookupTableInstructionData\n> {\n  return combineCodec(\n    getFreezeLookupTableInstructionDataEncoder(),\n    getFreezeLookupTableInstructionDataDecoder()\n  );\n}\n\nexport type FreezeLookupTableInput<\n  TAccountAddress extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  address: Address<TAccountAddress>;\n  authority: TransactionSigner<TAccountAuthority>;\n};\n\nexport function getFreezeLookupTableInstruction<\n  TAccountAddress extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS,\n>(\n  input: FreezeLookupTableInput<TAccountAddress, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): FreezeLookupTableInstruction<\n  TProgramAddress,\n  TAccountAddress,\n  TAccountAuthority\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    address: { value: input.address ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  const instruction = {\n    accounts: [\n      getAccountMeta(accounts.address),\n      getAccountMeta(accounts.authority),\n    ],\n    programAddress,\n    data: getFreezeLookupTableInstructionDataEncoder().encode({}),\n  } as FreezeLookupTableInstruction<\n    TProgramAddress,\n    TAccountAddress,\n    TAccountAuthority\n  >;\n\n  return instruction;\n}\n\nexport type ParsedFreezeLookupTableInstruction<\n  TProgram extends string = typeof ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    address: TAccountMetas[0];\n    authority: TAccountMetas[1];\n  };\n  data: FreezeLookupTableInstructionData;\n};\n\nexport function parseFreezeLookupTableInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly IAccountMeta[],\n>(\n  instruction: IInstruction<TProgram> &\n    IInstructionWithAccounts<TAccountMetas> &\n    IInstructionWithData<Uint8Array>\n): ParsedFreezeLookupTableInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts![accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      address: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getFreezeLookupTableInstructionDataDecoder().decode(instruction.data),\n  };\n}\n"]}
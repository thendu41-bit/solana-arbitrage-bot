import { getProgramDerivedAddress, getAddressEncoder, getU64Encoder, getU32Encoder, transformEncoder, getStructEncoder, getU8Encoder, getOptionEncoder, getU16Encoder, getArrayEncoder, getStructDecoder, getU32Decoder, getU64Decoder, getU8Decoder, getOptionDecoder, getAddressDecoder, getU16Decoder, getArrayDecoder, combineCodec, decodeAccount, assertAccountExists, fetchEncodedAccount, assertAccountsExist, fetchEncodedAccounts, containsBytes, isProgramDerivedAddress, BASE_ACCOUNT_SIZE, AccountRole, upgradeRoleToSigner, isTransactionSigner as isTransactionSigner$1 } from '@solana/kit';

// src/generated/accounts/addressLookupTable.ts
async function findAddressLookupTablePda(seeds, config = {}) {
  const {
    programAddress = "AddressLookupTab1e1111111111111111111111111"
  } = config;
  return await getProgramDerivedAddress({
    programAddress,
    seeds: [
      getAddressEncoder().encode(seeds.authority),
      getU64Encoder().encode(seeds.recentSlot)
    ]
  });
}

// src/generated/accounts/addressLookupTable.ts
var ADDRESS_LOOKUP_TABLE_DISCRIMINATOR = 1;
function getAddressLookupTableDiscriminatorBytes() {
  return getU32Encoder().encode(ADDRESS_LOOKUP_TABLE_DISCRIMINATOR);
}
function getAddressLookupTableEncoder() {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", getU32Encoder()],
      ["deactivationSlot", getU64Encoder()],
      ["lastExtendedSlot", getU64Encoder()],
      ["lastExtendedSlotStartIndex", getU8Encoder()],
      [
        "authority",
        getOptionEncoder(getAddressEncoder(), { noneValue: "zeroes" })
      ],
      ["padding", getU16Encoder()],
      [
        "addresses",
        getArrayEncoder(getAddressEncoder(), { size: "remainder" })
      ]
    ]),
    (value) => ({
      ...value,
      discriminator: ADDRESS_LOOKUP_TABLE_DISCRIMINATOR,
      padding: 0
    })
  );
}
function getAddressLookupTableDecoder() {
  return getStructDecoder([
    ["discriminator", getU32Decoder()],
    ["deactivationSlot", getU64Decoder()],
    ["lastExtendedSlot", getU64Decoder()],
    ["lastExtendedSlotStartIndex", getU8Decoder()],
    [
      "authority",
      getOptionDecoder(getAddressDecoder(), { noneValue: "zeroes" })
    ],
    ["padding", getU16Decoder()],
    ["addresses", getArrayDecoder(getAddressDecoder(), { size: "remainder" })]
  ]);
}
function getAddressLookupTableCodec() {
  return combineCodec(
    getAddressLookupTableEncoder(),
    getAddressLookupTableDecoder()
  );
}
function decodeAddressLookupTable(encodedAccount) {
  return decodeAccount(
    encodedAccount,
    getAddressLookupTableDecoder()
  );
}
async function fetchAddressLookupTable(rpc, address, config) {
  const maybeAccount = await fetchMaybeAddressLookupTable(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeAddressLookupTable(rpc, address, config) {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeAddressLookupTable(maybeAccount);
}
async function fetchAllAddressLookupTable(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeAddressLookupTable(
    rpc,
    addresses,
    config
  );
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeAddressLookupTable(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map(
    (maybeAccount) => decodeAddressLookupTable(maybeAccount)
  );
}
async function fetchAddressLookupTableFromSeeds(rpc, seeds, config = {}) {
  const maybeAccount = await fetchMaybeAddressLookupTableFromSeeds(
    rpc,
    seeds,
    config
  );
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeAddressLookupTableFromSeeds(rpc, seeds, config = {}) {
  const { programAddress, ...fetchConfig } = config;
  const [address] = await findAddressLookupTablePda(seeds, { programAddress });
  return await fetchMaybeAddressLookupTable(rpc, address, fetchConfig);
}
var ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS = "AddressLookupTab1e1111111111111111111111111";
var AddressLookupTableAccount = /* @__PURE__ */ ((AddressLookupTableAccount2) => {
  AddressLookupTableAccount2[AddressLookupTableAccount2["AddressLookupTable"] = 0] = "AddressLookupTable";
  return AddressLookupTableAccount2;
})(AddressLookupTableAccount || {});
function identifyAddressLookupTableAccount(account) {
  const data = "data" in account ? account.data : account;
  if (containsBytes(data, getU32Encoder().encode(1), 0)) {
    return 0 /* AddressLookupTable */;
  }
  throw new Error(
    "The provided account could not be identified as a addressLookupTable account."
  );
}
var AddressLookupTableInstruction = /* @__PURE__ */ ((AddressLookupTableInstruction2) => {
  AddressLookupTableInstruction2[AddressLookupTableInstruction2["CreateLookupTable"] = 0] = "CreateLookupTable";
  AddressLookupTableInstruction2[AddressLookupTableInstruction2["FreezeLookupTable"] = 1] = "FreezeLookupTable";
  AddressLookupTableInstruction2[AddressLookupTableInstruction2["ExtendLookupTable"] = 2] = "ExtendLookupTable";
  AddressLookupTableInstruction2[AddressLookupTableInstruction2["DeactivateLookupTable"] = 3] = "DeactivateLookupTable";
  AddressLookupTableInstruction2[AddressLookupTableInstruction2["CloseLookupTable"] = 4] = "CloseLookupTable";
  return AddressLookupTableInstruction2;
})(AddressLookupTableInstruction || {});
function identifyAddressLookupTableInstruction(instruction) {
  const data = "data" in instruction ? instruction.data : instruction;
  if (containsBytes(data, getU32Encoder().encode(0), 0)) {
    return 0 /* CreateLookupTable */;
  }
  if (containsBytes(data, getU32Encoder().encode(1), 0)) {
    return 1 /* FreezeLookupTable */;
  }
  if (containsBytes(data, getU32Encoder().encode(2), 0)) {
    return 2 /* ExtendLookupTable */;
  }
  if (containsBytes(data, getU32Encoder().encode(3), 0)) {
    return 3 /* DeactivateLookupTable */;
  }
  if (containsBytes(data, getU32Encoder().encode(4), 0)) {
    return 4 /* CloseLookupTable */;
  }
  throw new Error(
    "The provided instruction could not be identified as a addressLookupTable instruction."
  );
}
function expectSome(value) {
  if (value == null) {
    throw new Error("Expected a value but received null or undefined.");
  }
  return value;
}
function expectAddress(value) {
  if (!value) {
    throw new Error("Expected a Address.");
  }
  if (typeof value === "object" && "address" in value) {
    return value.address;
  }
  if (Array.isArray(value)) {
    return value[0];
  }
  return value;
}
function expectProgramDerivedAddress(value) {
  if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {
    throw new Error("Expected a ProgramDerivedAddress.");
  }
  return value;
}
function getAccountMetaFactory(programAddress, optionalAccountStrategy) {
  return (account) => {
    if (!account.value) {
      return Object.freeze({
        address: programAddress,
        role: AccountRole.READONLY
      });
    }
    const writableRole = account.isWritable ? AccountRole.WRITABLE : AccountRole.READONLY;
    return Object.freeze({
      address: expectAddress(account.value),
      role: isTransactionSigner(account.value) ? upgradeRoleToSigner(writableRole) : writableRole,
      ...isTransactionSigner(account.value) ? { signer: account.value } : {}
    });
  };
}
function isTransactionSigner(value) {
  return !!value && typeof value === "object" && "address" in value && isTransactionSigner$1(value);
}

// src/generated/instructions/closeLookupTable.ts
var CLOSE_LOOKUP_TABLE_DISCRIMINATOR = 4;
function getCloseLookupTableDiscriminatorBytes() {
  return getU32Encoder().encode(CLOSE_LOOKUP_TABLE_DISCRIMINATOR);
}
function getCloseLookupTableInstructionDataEncoder() {
  return transformEncoder(
    getStructEncoder([["discriminator", getU32Encoder()]]),
    (value) => ({ ...value, discriminator: CLOSE_LOOKUP_TABLE_DISCRIMINATOR })
  );
}
function getCloseLookupTableInstructionDataDecoder() {
  return getStructDecoder([["discriminator", getU32Decoder()]]);
}
function getCloseLookupTableInstructionDataCodec() {
  return combineCodec(
    getCloseLookupTableInstructionDataEncoder(),
    getCloseLookupTableInstructionDataDecoder()
  );
}
function getCloseLookupTableInstruction(input, config) {
  const programAddress = config?.programAddress ?? ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS;
  const originalAccounts = {
    address: { value: input.address ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    recipient: { value: input.recipient ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.address),
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.recipient)
    ],
    programAddress,
    data: getCloseLookupTableInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseCloseLookupTableInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      address: getNextAccount(),
      authority: getNextAccount(),
      recipient: getNextAccount()
    },
    data: getCloseLookupTableInstructionDataDecoder().decode(instruction.data)
  };
}
var CREATE_LOOKUP_TABLE_DISCRIMINATOR = 0;
function getCreateLookupTableDiscriminatorBytes() {
  return getU32Encoder().encode(CREATE_LOOKUP_TABLE_DISCRIMINATOR);
}
function getCreateLookupTableInstructionDataEncoder() {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", getU32Encoder()],
      ["recentSlot", getU64Encoder()],
      ["bump", getU8Encoder()]
    ]),
    (value) => ({ ...value, discriminator: CREATE_LOOKUP_TABLE_DISCRIMINATOR })
  );
}
function getCreateLookupTableInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", getU32Decoder()],
    ["recentSlot", getU64Decoder()],
    ["bump", getU8Decoder()]
  ]);
}
function getCreateLookupTableInstructionDataCodec() {
  return combineCodec(
    getCreateLookupTableInstructionDataEncoder(),
    getCreateLookupTableInstructionDataDecoder()
  );
}
async function getCreateLookupTableInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS;
  const originalAccounts = {
    address: { value: input.address ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    payer: { value: input.payer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.address.value) {
    accounts.address.value = await findAddressLookupTablePda({
      authority: expectAddress(accounts.authority.value),
      recentSlot: expectSome(args.recentSlot)
    });
  }
  if (!accounts.payer.value) {
    accounts.payer.value = expectSome(accounts.authority.value);
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!args.bump) {
    args.bump = expectProgramDerivedAddress(accounts.address.value)[1];
  }
  const byteDelta = [56 + BASE_ACCOUNT_SIZE].reduce((a, b) => a + b, 0);
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.address),
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getCreateLookupTableInstructionDataEncoder().encode(
      args
    )
  };
  return Object.freeze({ ...instruction, byteDelta });
}
function getCreateLookupTableInstruction(input, config) {
  const programAddress = config?.programAddress ?? ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS;
  const originalAccounts = {
    address: { value: input.address ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    payer: { value: input.payer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.payer.value) {
    accounts.payer.value = expectSome(accounts.authority.value);
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!args.bump) {
    args.bump = expectProgramDerivedAddress(accounts.address.value)[1];
  }
  const byteDelta = [56 + BASE_ACCOUNT_SIZE].reduce((a, b) => a + b, 0);
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.address),
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getCreateLookupTableInstructionDataEncoder().encode(
      args
    )
  };
  return Object.freeze({ ...instruction, byteDelta });
}
function parseCreateLookupTableInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      address: getNextAccount(),
      authority: getNextAccount(),
      payer: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getCreateLookupTableInstructionDataDecoder().decode(instruction.data)
  };
}
var DEACTIVATE_LOOKUP_TABLE_DISCRIMINATOR = 3;
function getDeactivateLookupTableDiscriminatorBytes() {
  return getU32Encoder().encode(DEACTIVATE_LOOKUP_TABLE_DISCRIMINATOR);
}
function getDeactivateLookupTableInstructionDataEncoder() {
  return transformEncoder(
    getStructEncoder([["discriminator", getU32Encoder()]]),
    (value) => ({
      ...value,
      discriminator: DEACTIVATE_LOOKUP_TABLE_DISCRIMINATOR
    })
  );
}
function getDeactivateLookupTableInstructionDataDecoder() {
  return getStructDecoder([["discriminator", getU32Decoder()]]);
}
function getDeactivateLookupTableInstructionDataCodec() {
  return combineCodec(
    getDeactivateLookupTableInstructionDataEncoder(),
    getDeactivateLookupTableInstructionDataDecoder()
  );
}
function getDeactivateLookupTableInstruction(input, config) {
  const programAddress = config?.programAddress ?? ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS;
  const originalAccounts = {
    address: { value: input.address ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.address),
      getAccountMeta(accounts.authority)
    ],
    programAddress,
    data: getDeactivateLookupTableInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseDeactivateLookupTableInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      address: getNextAccount(),
      authority: getNextAccount()
    },
    data: getDeactivateLookupTableInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/hooked/resolvers.ts
var resolveExtendLookupTableBytes = (scope) => 32 * scope.args.addresses.length;

// src/generated/instructions/extendLookupTable.ts
var EXTEND_LOOKUP_TABLE_DISCRIMINATOR = 2;
function getExtendLookupTableDiscriminatorBytes() {
  return getU32Encoder().encode(EXTEND_LOOKUP_TABLE_DISCRIMINATOR);
}
function getExtendLookupTableInstructionDataEncoder() {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", getU32Encoder()],
      [
        "addresses",
        getArrayEncoder(getAddressEncoder(), { size: getU64Encoder() })
      ]
    ]),
    (value) => ({ ...value, discriminator: EXTEND_LOOKUP_TABLE_DISCRIMINATOR })
  );
}
function getExtendLookupTableInstructionDataDecoder() {
  return getStructDecoder([
    ["discriminator", getU32Decoder()],
    [
      "addresses",
      getArrayDecoder(getAddressDecoder(), { size: getU64Decoder() })
    ]
  ]);
}
function getExtendLookupTableInstructionDataCodec() {
  return combineCodec(
    getExtendLookupTableInstructionDataEncoder(),
    getExtendLookupTableInstructionDataDecoder()
  );
}
function getExtendLookupTableInstruction(input, config) {
  const programAddress = config?.programAddress ?? ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS;
  const originalAccounts = {
    address: { value: input.address ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false },
    payer: { value: input.payer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const resolverScope = { programAddress, accounts, args };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const byteDelta = [
    resolveExtendLookupTableBytes(resolverScope)
  ].reduce((a, b) => a + b, 0);
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.address),
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getExtendLookupTableInstructionDataEncoder().encode(
      args
    )
  };
  return Object.freeze({ ...instruction, byteDelta });
}
function parseExtendLookupTableInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      address: getNextAccount(),
      authority: getNextAccount(),
      payer: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getExtendLookupTableInstructionDataDecoder().decode(instruction.data)
  };
}
var FREEZE_LOOKUP_TABLE_DISCRIMINATOR = 1;
function getFreezeLookupTableDiscriminatorBytes() {
  return getU32Encoder().encode(FREEZE_LOOKUP_TABLE_DISCRIMINATOR);
}
function getFreezeLookupTableInstructionDataEncoder() {
  return transformEncoder(
    getStructEncoder([["discriminator", getU32Encoder()]]),
    (value) => ({ ...value, discriminator: FREEZE_LOOKUP_TABLE_DISCRIMINATOR })
  );
}
function getFreezeLookupTableInstructionDataDecoder() {
  return getStructDecoder([["discriminator", getU32Decoder()]]);
}
function getFreezeLookupTableInstructionDataCodec() {
  return combineCodec(
    getFreezeLookupTableInstructionDataEncoder(),
    getFreezeLookupTableInstructionDataDecoder()
  );
}
function getFreezeLookupTableInstruction(input, config) {
  const programAddress = config?.programAddress ?? ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS;
  const originalAccounts = {
    address: { value: input.address ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.address),
      getAccountMeta(accounts.authority)
    ],
    programAddress,
    data: getFreezeLookupTableInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseFreezeLookupTableInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      address: getNextAccount(),
      authority: getNextAccount()
    },
    data: getFreezeLookupTableInstructionDataDecoder().decode(instruction.data)
  };
}

export { ADDRESS_LOOKUP_TABLE_DISCRIMINATOR, ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS, AddressLookupTableAccount, AddressLookupTableInstruction, CLOSE_LOOKUP_TABLE_DISCRIMINATOR, CREATE_LOOKUP_TABLE_DISCRIMINATOR, DEACTIVATE_LOOKUP_TABLE_DISCRIMINATOR, EXTEND_LOOKUP_TABLE_DISCRIMINATOR, FREEZE_LOOKUP_TABLE_DISCRIMINATOR, decodeAddressLookupTable, fetchAddressLookupTable, fetchAddressLookupTableFromSeeds, fetchAllAddressLookupTable, fetchAllMaybeAddressLookupTable, fetchMaybeAddressLookupTable, fetchMaybeAddressLookupTableFromSeeds, findAddressLookupTablePda, getAddressLookupTableCodec, getAddressLookupTableDecoder, getAddressLookupTableDiscriminatorBytes, getAddressLookupTableEncoder, getCloseLookupTableDiscriminatorBytes, getCloseLookupTableInstruction, getCloseLookupTableInstructionDataCodec, getCloseLookupTableInstructionDataDecoder, getCloseLookupTableInstructionDataEncoder, getCreateLookupTableDiscriminatorBytes, getCreateLookupTableInstruction, getCreateLookupTableInstructionAsync, getCreateLookupTableInstructionDataCodec, getCreateLookupTableInstructionDataDecoder, getCreateLookupTableInstructionDataEncoder, getDeactivateLookupTableDiscriminatorBytes, getDeactivateLookupTableInstruction, getDeactivateLookupTableInstructionDataCodec, getDeactivateLookupTableInstructionDataDecoder, getDeactivateLookupTableInstructionDataEncoder, getExtendLookupTableDiscriminatorBytes, getExtendLookupTableInstruction, getExtendLookupTableInstructionDataCodec, getExtendLookupTableInstructionDataDecoder, getExtendLookupTableInstructionDataEncoder, getFreezeLookupTableDiscriminatorBytes, getFreezeLookupTableInstruction, getFreezeLookupTableInstructionDataCodec, getFreezeLookupTableInstructionDataDecoder, getFreezeLookupTableInstructionDataEncoder, identifyAddressLookupTableAccount, identifyAddressLookupTableInstruction, parseCloseLookupTableInstruction, parseCreateLookupTableInstruction, parseDeactivateLookupTableInstruction, parseExtendLookupTableInstruction, parseFreezeLookupTableInstruction };
//# sourceMappingURL=index.mjs.map
//# sourceMappingURL=index.mjs.map
// src/config.ts
import { getWhirlpoolsConfigExtensionAddress } from "@orca-so/whirlpools-client";
import {
  address,
  createNoopSigner,
  isAddress,
  createKeyPairFromBytes,
  createSignerFromKeyPair
} from "@solana/kit";
import {
  setComputeUnitMarginMultiplier,
  setJitoBlockEngineUrl,
  setJitoTipSetting,
  setPriorityFeeSetting,
  setRpc,
  setJitoFeePercentile,
  setPriorityFeePercentile,
  getRpcConfig
} from "@orca-so/tx-sender";
var DEFAULT_ADDRESS = address("11111111111111111111111111111111");
var DEFAULT_WHIRLPOOLS_CONFIG_ADDRESSES = {
  solanaMainnet: address("2LecshUwdy9xi7meFgHtFJQNSKk4KdTrcpvaB56dP2NQ"),
  solanaDevnet: address("FcrweFY1G9HJAHG5inkGB6pKg1HZ6x9UC2WioAfWrGkR"),
  eclipseMainnet: address("FVG4oDbGv16hqTUbovjyGmtYikn6UBEnazz6RVDMEFwv"),
  eclipseTestnet: address("FPydDjRdZu9sT7HVd6ANhfjh85KLq21Pefr5YWWMRPFp")
};
var DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS = address(
  "777H5H3Tp9U11uRVRzFwM8BinfiakbaLT8vQpeuhvEiH"
);
var WHIRLPOOLS_CONFIG_ADDRESS = DEFAULT_WHIRLPOOLS_CONFIG_ADDRESSES.solanaMainnet;
var WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS = DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS;
async function setWhirlpoolsConfig(config) {
  if (isAddress(config)) {
    WHIRLPOOLS_CONFIG_ADDRESS = config;
  } else {
    WHIRLPOOLS_CONFIG_ADDRESS = DEFAULT_WHIRLPOOLS_CONFIG_ADDRESSES[config];
  }
  WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS = await getWhirlpoolsConfigExtensionAddress(WHIRLPOOLS_CONFIG_ADDRESS).then(
    (x) => x[0]
  );
}
var SPLASH_POOL_TICK_SPACING = 32896;
var DEFAULT_FUNDER = createNoopSigner(DEFAULT_ADDRESS);
var FUNDER = DEFAULT_FUNDER;
function setDefaultFunder(funder) {
  if (typeof funder === "string") {
    FUNDER = createNoopSigner(funder);
  } else {
    FUNDER = funder ?? createNoopSigner(DEFAULT_ADDRESS);
  }
}
var DEFAULT_SLIPPAGE_TOLERANCE_BPS = 100;
var SLIPPAGE_TOLERANCE_BPS = DEFAULT_SLIPPAGE_TOLERANCE_BPS;
function setDefaultSlippageToleranceBps(slippageToleranceBps) {
  SLIPPAGE_TOLERANCE_BPS = Math.floor(slippageToleranceBps);
}
var DEFAULT_NATIVE_MINT_WRAPPING_STRATEGY = "keypair";
var NATIVE_MINT_WRAPPING_STRATEGY = DEFAULT_NATIVE_MINT_WRAPPING_STRATEGY;
function setNativeMintWrappingStrategy(strategy) {
  NATIVE_MINT_WRAPPING_STRATEGY = strategy;
}
var DEFAULT_ENFORCE_TOKEN_BALANCE_CHECK = false;
var ENFORCE_TOKEN_BALANCE_CHECK = DEFAULT_ENFORCE_TOKEN_BALANCE_CHECK;
function setEnforceTokenBalanceCheck(enforceBalanceCheck) {
  ENFORCE_TOKEN_BALANCE_CHECK = enforceBalanceCheck;
}
function resetConfiguration() {
  WHIRLPOOLS_CONFIG_ADDRESS = DEFAULT_WHIRLPOOLS_CONFIG_ADDRESSES.solanaMainnet;
  WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS = DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS;
  FUNDER = DEFAULT_FUNDER;
  SLIPPAGE_TOLERANCE_BPS = DEFAULT_SLIPPAGE_TOLERANCE_BPS;
  NATIVE_MINT_WRAPPING_STRATEGY = DEFAULT_NATIVE_MINT_WRAPPING_STRATEGY;
  ENFORCE_TOKEN_BALANCE_CHECK = DEFAULT_ENFORCE_TOKEN_BALANCE_CHECK;
}
var _payer;
async function setPayerFromBytes(pkBytes) {
  const kp = await createKeyPairFromBytes(pkBytes);
  const signer = await createSignerFromKeyPair(kp);
  _payer = signer;
  return signer;
}
function getPayer() {
  if (!_payer) {
    throw new Error("Payer not set. Call setPayer() first.");
  }
  return _payer;
}

// src/createPool.ts
import {
  getFeeTierAddress,
  getInitializePoolV2Instruction,
  getInitializeTickArrayInstruction,
  getTickArrayAddress,
  getTickArraySize,
  getTokenBadgeAddress,
  getWhirlpoolAddress,
  getWhirlpoolSize
} from "@orca-so/whirlpools-client";
import { generateKeyPairSigner as generateKeyPairSigner2, lamports as lamports2 } from "@solana/kit";
import { fetchSysvarRent } from "@solana/sysvars";
import {
  getFullRangeTickIndexes,
  getTickArrayStartTickIndex,
  priceToSqrtPrice,
  sqrtPriceToTickIndex
} from "@orca-so/whirlpools-core";
import { fetchAllMint as fetchAllMint2 } from "@solana-program/token-2022";
import assert2 from "assert";

// src/token.ts
import {
  fetchAllMaybeToken,
  fetchAllMint,
  findAssociatedTokenPda,
  getCloseAccountInstruction,
  getCreateAssociatedTokenInstruction,
  getInitializeAccount3Instruction,
  getSyncNativeInstruction,
  TOKEN_PROGRAM_ADDRESS
} from "@solana-program/token";
import {
  address as address2,
  generateKeyPairSigner,
  getAddressDecoder,
  getAddressEncoder,
  lamports
} from "@solana/kit";
import {
  getCreateAccountInstruction,
  getCreateAccountWithSeedInstruction,
  getTransferSolInstruction
} from "@solana-program/system";
import { getTokenSize } from "@solana-program/token";
import { getTokenSize as getTokenSizeWithExtensions } from "@solana-program/token-2022";
import assert from "assert";
var NATIVE_MINT = address2(
  "So11111111111111111111111111111111111111112"
);
function mintFilter(x) {
  if (NATIVE_MINT_WRAPPING_STRATEGY === "none" || NATIVE_MINT_WRAPPING_STRATEGY === "ata") {
    return true;
  }
  return x != NATIVE_MINT;
}
async function prepareTokenAccountsInstructions(rpc, owner, spec) {
  const mintAddresses = Array.isArray(spec) ? spec : Object.keys(spec);
  const nativeMintIndex = mintAddresses.indexOf(NATIVE_MINT);
  const hasNativeMint = nativeMintIndex !== -1;
  const mints = await fetchAllMint(rpc, mintAddresses.filter(mintFilter));
  const tokenAddresses = await Promise.all(
    mints.map(
      (mint) => findAssociatedTokenPda({
        owner: owner.address,
        mint: mint.address,
        tokenProgram: mint.programAddress
      }).then((x) => x[0])
    )
  );
  const tokenAccounts = await fetchAllMaybeToken(rpc, tokenAddresses);
  const tokenAccountAddresses = {};
  const createInstructions = [];
  const cleanupInstructions = [];
  for (let i = 0; i < mints.length; i++) {
    const mint = mints[i];
    const tokenAccount = tokenAccounts[i];
    tokenAccountAddresses[mint.address] = tokenAccount.address;
    if (tokenAccount.exists) {
      continue;
    }
    createInstructions.push(
      getCreateAssociatedTokenInstruction({
        payer: owner,
        owner: owner.address,
        ata: tokenAccount.address,
        mint: mint.address,
        tokenProgram: mint.programAddress
      })
    );
  }
  if (!Array.isArray(spec)) {
    for (let i = 0; i < mints.length; i++) {
      const mint = mints[i];
      if (mint.address === NATIVE_MINT && NATIVE_MINT_WRAPPING_STRATEGY !== "none") {
        continue;
      }
      const tokenAccount = tokenAccounts[i];
      const existingBalance = tokenAccount.exists ? tokenAccount.data.amount : 0n;
      if (ENFORCE_TOKEN_BALANCE_CHECK) {
        assert(
          BigInt(spec[mint.address]) <= existingBalance,
          `Token account for ${mint.address} does not have the required balance`
        );
      }
    }
  }
  if (hasNativeMint && NATIVE_MINT_WRAPPING_STRATEGY === "keypair") {
    const keypair = await generateKeyPairSigner();
    const space = getTokenSize();
    let amount = await rpc.getMinimumBalanceForRentExemption(BigInt(space)).send();
    if (!Array.isArray(spec)) {
      amount = lamports(amount + BigInt(spec[NATIVE_MINT]));
    }
    createInstructions.push(
      getCreateAccountInstruction({
        payer: owner,
        newAccount: keypair,
        lamports: amount,
        space,
        programAddress: TOKEN_PROGRAM_ADDRESS
      }),
      getInitializeAccount3Instruction({
        account: keypair.address,
        mint: NATIVE_MINT,
        owner: owner.address
      })
    );
    cleanupInstructions.push(
      getCloseAccountInstruction({
        account: keypair.address,
        owner,
        destination: owner.address
      })
    );
    tokenAccountAddresses[NATIVE_MINT] = keypair.address;
  }
  if (hasNativeMint && NATIVE_MINT_WRAPPING_STRATEGY === "seed") {
    const space = getTokenSize();
    let amount = await rpc.getMinimumBalanceForRentExemption(BigInt(space)).send();
    if (!Array.isArray(spec)) {
      amount = lamports(amount + BigInt(spec[NATIVE_MINT]));
    }
    const seed = Date.now().toString();
    const buffer = await crypto.subtle.digest(
      "SHA-256",
      Buffer.concat([
        Buffer.from(getAddressEncoder().encode(owner.address)),
        Buffer.from(seed),
        Buffer.from(getAddressEncoder().encode(TOKEN_PROGRAM_ADDRESS))
      ])
    );
    tokenAccountAddresses[NATIVE_MINT] = getAddressDecoder().decode(
      new Uint8Array(buffer)
    );
    createInstructions.push(
      getCreateAccountWithSeedInstruction({
        payer: owner,
        newAccount: tokenAccountAddresses[NATIVE_MINT],
        base: owner.address,
        baseAccount: owner,
        seed,
        space,
        amount,
        programAddress: TOKEN_PROGRAM_ADDRESS
      }),
      getInitializeAccount3Instruction({
        account: tokenAccountAddresses[NATIVE_MINT],
        mint: NATIVE_MINT,
        owner: owner.address
      })
    );
    cleanupInstructions.push(
      getCloseAccountInstruction({
        account: tokenAccountAddresses[NATIVE_MINT],
        owner,
        destination: owner.address
      })
    );
  }
  if (hasNativeMint && NATIVE_MINT_WRAPPING_STRATEGY === "ata") {
    const account = tokenAccounts[nativeMintIndex];
    const existingBalance = account.exists ? account.data.amount : 0n;
    if (!Array.isArray(spec) && existingBalance < BigInt(spec[NATIVE_MINT])) {
      createInstructions.push(
        getTransferSolInstruction({
          source: owner,
          destination: tokenAccountAddresses[NATIVE_MINT],
          amount: BigInt(spec[NATIVE_MINT]) - existingBalance
        }),
        getSyncNativeInstruction({
          account: tokenAccountAddresses[NATIVE_MINT]
        })
      );
    }
    if (!account.exists) {
      cleanupInstructions.push(
        getCloseAccountInstruction({
          account: account.address,
          owner,
          destination: owner.address
        })
      );
    }
  }
  return {
    createInstructions,
    cleanupInstructions,
    tokenAccountAddresses
  };
}
function getCurrentTransferFee(mint, currentEpoch) {
  if (mint == null || "exists" in mint && !mint.exists || mint.data.extensions.__option === "None") {
    return void 0;
  }
  const feeConfig = mint.data.extensions.value.find(
    (x) => x.__kind === "TransferFeeConfig"
  );
  if (feeConfig == null) {
    return void 0;
  }
  const transferFee = currentEpoch >= feeConfig.newerTransferFee.epoch ? feeConfig.newerTransferFee : feeConfig.olderTransferFee;
  return {
    feeBps: transferFee.transferFeeBasisPoints,
    maxFee: transferFee.maximumFee
  };
}
function getAccountExtensions(mint) {
  if (mint.extensions.__option === "None") {
    return [];
  }
  const extensions = [];
  for (const extension of mint.extensions.value) {
    switch (extension.__kind) {
      case "TransferFeeConfig":
        extensions.push({
          __kind: "TransferFeeAmount",
          withheldAmount: 0n
        });
        break;
      case "NonTransferable":
        extensions.push({
          __kind: "NonTransferableAccount"
        });
        break;
      case "TransferHook":
        extensions.push({
          __kind: "TransferHookAccount",
          transferring: false
        });
        break;
    }
  }
  return extensions;
}
function orderMints(mint1, mint2) {
  const encoder = getAddressEncoder();
  const mint1Bytes = new Uint8Array(encoder.encode(mint1));
  const mint2Bytes = new Uint8Array(encoder.encode(mint2));
  return Buffer.compare(mint1Bytes, mint2Bytes) < 0 ? [mint1, mint2] : [mint2, mint1];
}
function getTokenSizeForMint(mint) {
  const extensions = getAccountExtensions(mint.data);
  return extensions.length === 0 ? getTokenSize() : getTokenSizeWithExtensions(extensions);
}

// src/sysvar.ts
var ACCOUNT_STORAGE_OVERHEAD = 128;
function calculateMinimumBalanceForRentExemption(rent, dataSize) {
  const dataSizeForRent = BigInt(dataSize + ACCOUNT_STORAGE_OVERHEAD);
  const rentLamportsPerYear = rent.lamportsPerByteYear * dataSizeForRent;
  const minimumBalance = rentLamportsPerYear * BigInt(rent.exemptionThreshold);
  return minimumBalance;
}

// src/actionHelpers.ts
import {
  address as address3,
  createNoopSigner as createNoopSigner2,
  getBase64EncodedWireTransaction
} from "@solana/kit";
import {
  rpcFromUrl,
  buildAndSendTransaction,
  buildTransaction
} from "@orca-so/tx-sender";
function wrapFunctionWithExecution(instructionFn) {
  return async (...params) => {
    const { rpcUrl } = getRpcConfig();
    const rpc = rpcFromUrl(rpcUrl);
    const owner = getPayer();
    const result = await instructionFn(rpc, ...params, owner);
    return {
      ...result,
      callback: () => buildAndSendTransaction(result.instructions, owner)
    };
  };
}
async function wouldExceedTransactionSize(currentInstructions, instructionsToAdd) {
  const noopSginer = createNoopSigner2(
    address3("11111111111111111111111111111111")
  );
  const tx = await buildTransaction(
    [...currentInstructions, ...instructionsToAdd],
    noopSginer
  );
  const encodedTransaction = getBase64EncodedWireTransaction(tx);
  const TX_BASE64_ENCODED_SIZE_LIMIT = 1644;
  return encodedTransaction.length >= TX_BASE64_ENCODED_SIZE_LIMIT;
}

// src/createPool.ts
function createSplashPoolInstructions(rpc, tokenMintA, tokenMintB, initialPrice = 1, funder = FUNDER) {
  return createConcentratedLiquidityPoolInstructions(
    rpc,
    tokenMintA,
    tokenMintB,
    SPLASH_POOL_TICK_SPACING,
    initialPrice,
    funder
  );
}
async function createConcentratedLiquidityPoolInstructions(rpc, tokenMintA, tokenMintB, tickSpacing, initialPrice = 1, funder = FUNDER) {
  assert2(
    funder.address !== DEFAULT_ADDRESS,
    "Either supply a funder or set the default funder"
  );
  assert2(
    orderMints(tokenMintA, tokenMintB)[0] === tokenMintA,
    "Token order needs to be flipped to match the canonical ordering (i.e. sorted on the byte repr. of the mint pubkeys)"
  );
  const instructions = [];
  const rent = await fetchSysvarRent(rpc);
  let nonRefundableRent = 0n;
  const [mintA, mintB] = await fetchAllMint2(rpc, [tokenMintA, tokenMintB]);
  const decimalsA = mintA.data.decimals;
  const decimalsB = mintB.data.decimals;
  const tokenProgramA = mintA.programAddress;
  const tokenProgramB = mintB.programAddress;
  const initialSqrtPrice = priceToSqrtPrice(initialPrice, decimalsA, decimalsB);
  const [
    poolAddress,
    feeTier,
    tokenBadgeA,
    tokenBadgeB,
    tokenVaultA,
    tokenVaultB
  ] = await Promise.all([
    getWhirlpoolAddress(
      WHIRLPOOLS_CONFIG_ADDRESS,
      tokenMintA,
      tokenMintB,
      tickSpacing
    ).then((x) => x[0]),
    getFeeTierAddress(WHIRLPOOLS_CONFIG_ADDRESS, tickSpacing).then((x) => x[0]),
    getTokenBadgeAddress(WHIRLPOOLS_CONFIG_ADDRESS, tokenMintA).then(
      (x) => x[0]
    ),
    getTokenBadgeAddress(WHIRLPOOLS_CONFIG_ADDRESS, tokenMintB).then(
      (x) => x[0]
    ),
    generateKeyPairSigner2(),
    generateKeyPairSigner2()
  ]);
  instructions.push(
    getInitializePoolV2Instruction({
      whirlpoolsConfig: WHIRLPOOLS_CONFIG_ADDRESS,
      tokenMintA,
      tokenMintB,
      tokenBadgeA,
      tokenBadgeB,
      funder,
      whirlpool: poolAddress,
      tokenVaultA,
      tokenVaultB,
      tokenProgramA,
      tokenProgramB,
      feeTier,
      tickSpacing,
      initialSqrtPrice
    })
  );
  nonRefundableRent += calculateMinimumBalanceForRentExemption(
    rent,
    getTokenSizeForMint(mintA)
  );
  nonRefundableRent += calculateMinimumBalanceForRentExemption(
    rent,
    getTokenSizeForMint(mintB)
  );
  nonRefundableRent += calculateMinimumBalanceForRentExemption(
    rent,
    getWhirlpoolSize()
  );
  const fullRange = getFullRangeTickIndexes(tickSpacing);
  const lowerTickIndex = getTickArrayStartTickIndex(
    fullRange.tickLowerIndex,
    tickSpacing
  );
  const upperTickIndex = getTickArrayStartTickIndex(
    fullRange.tickUpperIndex,
    tickSpacing
  );
  const initialTickIndex = sqrtPriceToTickIndex(initialSqrtPrice);
  const currentTickIndex = getTickArrayStartTickIndex(
    initialTickIndex,
    tickSpacing
  );
  const tickArrayIndexes = Array.from(
    /* @__PURE__ */ new Set([lowerTickIndex, upperTickIndex, currentTickIndex])
  );
  const tickArrayAddresses = await Promise.all(
    tickArrayIndexes.map(
      (x) => getTickArrayAddress(poolAddress, x).then((x2) => x2[0])
    )
  );
  for (let i = 0; i < tickArrayIndexes.length; i++) {
    instructions.push(
      getInitializeTickArrayInstruction({
        whirlpool: poolAddress,
        funder,
        tickArray: tickArrayAddresses[i],
        startTickIndex: tickArrayIndexes[i]
      })
    );
    nonRefundableRent += calculateMinimumBalanceForRentExemption(
      rent,
      getTickArraySize()
    );
  }
  return {
    instructions,
    poolAddress,
    initializationCost: lamports2(nonRefundableRent)
  };
}
var createSplashPool = wrapFunctionWithExecution(
  createSplashPoolInstructions
);
var createConcentratedLiquidityPool = wrapFunctionWithExecution(
  createConcentratedLiquidityPoolInstructions
);

// src/decreaseLiquidity.ts
import {
  fetchAllTickArray,
  fetchPosition,
  fetchWhirlpool,
  getClosePositionInstruction,
  getClosePositionWithTokenExtensionsInstruction,
  getCollectFeesV2Instruction,
  getCollectRewardV2Instruction,
  getDecreaseLiquidityV2Instruction,
  getPositionAddress,
  getTickArrayAddress as getTickArrayAddress2
} from "@orca-so/whirlpools-client";
import {
  getTickArrayStartTickIndex as getTickArrayStartTickIndex2,
  decreaseLiquidityQuote,
  decreaseLiquidityQuoteA,
  decreaseLiquidityQuoteB,
  collectFeesQuote,
  collectRewardsQuote,
  getTickIndexInArray
} from "@orca-so/whirlpools-core";
import {
  findAssociatedTokenPda as findAssociatedTokenPda2,
  TOKEN_PROGRAM_ADDRESS as TOKEN_PROGRAM_ADDRESS2
} from "@solana-program/token";
import {
  fetchAllMint as fetchAllMint3,
  fetchAllMaybeMint,
  TOKEN_2022_PROGRAM_ADDRESS
} from "@solana-program/token-2022";
import { MEMO_PROGRAM_ADDRESS } from "@solana-program/memo";
import assert3 from "assert";
function getDecreaseLiquidityQuote(param, pool, tickRange, slippageToleranceBps, transferFeeA, transferFeeB) {
  if ("liquidity" in param) {
    return decreaseLiquidityQuote(
      param.liquidity,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickRange.tickLowerIndex,
      tickRange.tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  } else if ("tokenA" in param) {
    return decreaseLiquidityQuoteA(
      param.tokenA,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickRange.tickLowerIndex,
      tickRange.tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  } else {
    return decreaseLiquidityQuoteB(
      param.tokenB,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickRange.tickLowerIndex,
      tickRange.tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  }
}
async function decreaseLiquidityInstructions(rpc, positionMintAddress, param, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, authority = FUNDER) {
  assert3(
    authority.address !== DEFAULT_ADDRESS,
    "Either supply the authority or set the default funder"
  );
  const positionAddress = await getPositionAddress(positionMintAddress);
  const position = await fetchPosition(rpc, positionAddress[0]);
  const whirlpool = await fetchWhirlpool(rpc, position.data.whirlpool);
  const currentEpoch = await rpc.getEpochInfo().send();
  const [mintA, mintB, positionMint] = await fetchAllMint3(rpc, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB,
    positionMintAddress
  ]);
  const transferFeeA = getCurrentTransferFee(mintA, currentEpoch.epoch);
  const transferFeeB = getCurrentTransferFee(mintB, currentEpoch.epoch);
  const quote = getDecreaseLiquidityQuote(
    param,
    whirlpool.data,
    position.data,
    slippageToleranceBps,
    transferFeeA,
    transferFeeB
  );
  const instructions = [];
  const lowerTickArrayStartIndex = getTickArrayStartTickIndex2(
    position.data.tickLowerIndex,
    whirlpool.data.tickSpacing
  );
  const upperTickArrayStartIndex = getTickArrayStartTickIndex2(
    position.data.tickUpperIndex,
    whirlpool.data.tickSpacing
  );
  const [positionTokenAccount, tickArrayLower, tickArrayUpper] = await Promise.all([
    findAssociatedTokenPda2({
      owner: authority.address,
      mint: positionMintAddress,
      tokenProgram: positionMint.programAddress
    }).then((x) => x[0]),
    getTickArrayAddress2(whirlpool.address, lowerTickArrayStartIndex).then(
      (x) => x[0]
    ),
    getTickArrayAddress2(whirlpool.address, upperTickArrayStartIndex).then(
      (x) => x[0]
    )
  ]);
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(rpc, authority, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB
  ]);
  instructions.push(...createInstructions);
  instructions.push(
    getDecreaseLiquidityV2Instruction({
      whirlpool: whirlpool.address,
      positionAuthority: authority,
      position: position.address,
      positionTokenAccount,
      tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
      tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
      tokenVaultA: whirlpool.data.tokenVaultA,
      tokenVaultB: whirlpool.data.tokenVaultB,
      tokenMintA: whirlpool.data.tokenMintA,
      tokenMintB: whirlpool.data.tokenMintB,
      tokenProgramA: mintA.programAddress,
      tokenProgramB: mintB.programAddress,
      memoProgram: MEMO_PROGRAM_ADDRESS,
      tickArrayLower,
      tickArrayUpper,
      liquidityAmount: quote.liquidityDelta,
      tokenMinA: quote.tokenMinA,
      tokenMinB: quote.tokenMinB,
      remainingAccountsInfo: null
    })
  );
  instructions.push(...cleanupInstructions);
  return { quote, instructions };
}
async function closePositionInstructions(rpc, positionMintAddress, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, authority = FUNDER) {
  assert3(
    authority.address !== DEFAULT_ADDRESS,
    "Either supply an authority or set the default funder"
  );
  const positionAddress = await getPositionAddress(positionMintAddress);
  const position = await fetchPosition(rpc, positionAddress[0]);
  const whirlpool = await fetchWhirlpool(rpc, position.data.whirlpool);
  const currentEpoch = await rpc.getEpochInfo().send();
  const [mintA, mintB, positionMint, ...rewardMints] = await fetchAllMaybeMint(
    rpc,
    [
      whirlpool.data.tokenMintA,
      whirlpool.data.tokenMintB,
      positionMintAddress,
      ...whirlpool.data.rewardInfos.map((x) => x.mint).filter((x) => x !== DEFAULT_ADDRESS)
    ]
  );
  assert3(mintA.exists, "Token A not found");
  assert3(mintB.exists, "Token B not found");
  assert3(positionMint.exists, "Position mint not found");
  const transferFeeA = getCurrentTransferFee(mintA, currentEpoch.epoch);
  const transferFeeB = getCurrentTransferFee(mintB, currentEpoch.epoch);
  const quote = getDecreaseLiquidityQuote(
    { liquidity: position.data.liquidity },
    whirlpool.data,
    position.data,
    slippageToleranceBps,
    transferFeeA,
    transferFeeB
  );
  const lowerTickArrayStartIndex = getTickArrayStartTickIndex2(
    position.data.tickLowerIndex,
    whirlpool.data.tickSpacing
  );
  const upperTickArrayStartIndex = getTickArrayStartTickIndex2(
    position.data.tickUpperIndex,
    whirlpool.data.tickSpacing
  );
  const [positionTokenAccount, lowerTickArrayAddress, upperTickArrayAddress] = await Promise.all([
    findAssociatedTokenPda2({
      owner: authority.address,
      mint: positionMintAddress,
      tokenProgram: positionMint.programAddress
    }).then((x) => x[0]),
    getTickArrayAddress2(whirlpool.address, lowerTickArrayStartIndex).then(
      (x) => x[0]
    ),
    getTickArrayAddress2(whirlpool.address, upperTickArrayStartIndex).then(
      (x) => x[0]
    )
  ]);
  const [lowerTickArray, upperTickArray] = await fetchAllTickArray(rpc, [
    lowerTickArrayAddress,
    upperTickArrayAddress
  ]);
  const lowerTick = lowerTickArray.data.ticks[getTickIndexInArray(
    position.data.tickLowerIndex,
    lowerTickArrayStartIndex,
    whirlpool.data.tickSpacing
  )];
  const upperTick = upperTickArray.data.ticks[getTickIndexInArray(
    position.data.tickUpperIndex,
    upperTickArrayStartIndex,
    whirlpool.data.tickSpacing
  )];
  const feesQuote = collectFeesQuote(
    whirlpool.data,
    position.data,
    lowerTick,
    upperTick,
    transferFeeA,
    transferFeeB
  );
  const currentUnixTimestamp = BigInt(Math.floor(Date.now() / 1e3));
  const rewardsQuote = collectRewardsQuote(
    whirlpool.data,
    position.data,
    lowerTick,
    upperTick,
    currentUnixTimestamp,
    getCurrentTransferFee(rewardMints[0], currentEpoch.epoch),
    getCurrentTransferFee(rewardMints[1], currentEpoch.epoch),
    getCurrentTransferFee(rewardMints[2], currentEpoch.epoch)
  );
  const requiredMints = /* @__PURE__ */ new Set();
  if (quote.liquidityDelta > 0n || feesQuote.feeOwedA > 0n || feesQuote.feeOwedB > 0n) {
    requiredMints.add(whirlpool.data.tokenMintA);
    requiredMints.add(whirlpool.data.tokenMintB);
  }
  for (let i = 0; i < rewardsQuote.rewards.length; i++) {
    if (rewardsQuote.rewards[i].rewardsOwed > 0n) {
      requiredMints.add(whirlpool.data.rewardInfos[i].mint);
    }
  }
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(
    rpc,
    authority,
    Array.from(requiredMints)
  );
  const instructions = [];
  instructions.push(...createInstructions);
  if (quote.liquidityDelta > 0n) {
    instructions.push(
      getDecreaseLiquidityV2Instruction({
        whirlpool: whirlpool.address,
        positionAuthority: authority,
        position: positionAddress[0],
        positionTokenAccount,
        tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
        tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
        tokenVaultA: whirlpool.data.tokenVaultA,
        tokenVaultB: whirlpool.data.tokenVaultB,
        tickArrayLower: lowerTickArrayAddress,
        tickArrayUpper: upperTickArrayAddress,
        liquidityAmount: quote.liquidityDelta,
        tokenMinA: quote.tokenMinA,
        tokenMinB: quote.tokenMinB,
        tokenMintA: whirlpool.data.tokenMintA,
        tokenMintB: whirlpool.data.tokenMintB,
        tokenProgramA: mintA.programAddress,
        tokenProgramB: mintB.programAddress,
        memoProgram: MEMO_PROGRAM_ADDRESS,
        remainingAccountsInfo: null
      })
    );
  }
  if (feesQuote.feeOwedA > 0n || feesQuote.feeOwedB > 0n) {
    instructions.push(
      getCollectFeesV2Instruction({
        whirlpool: whirlpool.address,
        positionAuthority: authority,
        position: positionAddress[0],
        positionTokenAccount,
        tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
        tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
        tokenVaultA: whirlpool.data.tokenVaultA,
        tokenVaultB: whirlpool.data.tokenVaultB,
        tokenMintA: whirlpool.data.tokenMintA,
        tokenMintB: whirlpool.data.tokenMintB,
        tokenProgramA: mintA.programAddress,
        tokenProgramB: mintB.programAddress,
        memoProgram: MEMO_PROGRAM_ADDRESS,
        remainingAccountsInfo: null
      })
    );
  }
  for (let i = 0; i < rewardsQuote.rewards.length; i++) {
    if (rewardsQuote.rewards[i].rewardsOwed === 0n) {
      continue;
    }
    const rewardMint = rewardMints[i];
    assert3(rewardMint.exists, `Reward mint ${i} not found`);
    instructions.push(
      getCollectRewardV2Instruction({
        whirlpool: whirlpool.address,
        positionAuthority: authority,
        position: positionAddress[0],
        positionTokenAccount,
        rewardOwnerAccount: tokenAccountAddresses[rewardMint.address],
        rewardVault: whirlpool.data.rewardInfos[i].vault,
        rewardIndex: i,
        rewardMint: rewardMint.address,
        rewardTokenProgram: rewardMint.programAddress,
        memoProgram: MEMO_PROGRAM_ADDRESS,
        remainingAccountsInfo: null
      })
    );
  }
  switch (positionMint.programAddress) {
    case TOKEN_PROGRAM_ADDRESS2:
      instructions.push(
        getClosePositionInstruction({
          positionAuthority: authority,
          position: positionAddress[0],
          positionTokenAccount,
          positionMint: positionMintAddress,
          receiver: authority.address
        })
      );
      break;
    case TOKEN_2022_PROGRAM_ADDRESS:
      instructions.push(
        getClosePositionWithTokenExtensionsInstruction({
          positionAuthority: authority,
          position: positionAddress[0],
          positionTokenAccount,
          positionMint: positionMintAddress,
          receiver: authority.address,
          token2022Program: TOKEN_2022_PROGRAM_ADDRESS
        })
      );
      break;
    default:
      throw new Error("Invalid token program");
  }
  instructions.push(...cleanupInstructions);
  return {
    instructions,
    quote,
    feesQuote,
    rewardsQuote
  };
}
var closePosition = wrapFunctionWithExecution(
  closePositionInstructions
);
var decreaseLiquidity = wrapFunctionWithExecution(
  decreaseLiquidityInstructions
);

// src/harvest.ts
import {
  collectFeesQuote as collectFeesQuote2,
  collectRewardsQuote as collectRewardsQuote2,
  getTickArrayStartTickIndex as getTickArrayStartTickIndex3,
  getTickIndexInArray as getTickIndexInArray2
} from "@orca-so/whirlpools-core";
import {
  fetchAllTickArray as fetchAllTickArray2,
  fetchPosition as fetchPosition2,
  fetchWhirlpool as fetchWhirlpool2,
  getCollectFeesV2Instruction as getCollectFeesV2Instruction2,
  getCollectRewardV2Instruction as getCollectRewardV2Instruction2,
  getPositionAddress as getPositionAddress3,
  getTickArrayAddress as getTickArrayAddress3,
  getUpdateFeesAndRewardsInstruction
} from "@orca-so/whirlpools-client";
import { findAssociatedTokenPda as findAssociatedTokenPda3 } from "@solana-program/token";
import { fetchAllMaybeMint as fetchAllMaybeMint2 } from "@solana-program/token-2022";
import { MEMO_PROGRAM_ADDRESS as MEMO_PROGRAM_ADDRESS2 } from "@solana-program/memo";
import assert4 from "assert";
import { rpcFromUrl as rpcFromUrl2, buildAndSendTransaction as buildAndSendTransaction2 } from "@orca-so/tx-sender";

// src/position.ts
import {
  decodePosition,
  decodePositionBundle,
  fetchAllPositionWithFilter,
  getBundledPositionAddress,
  getPositionAddress as getPositionAddress2,
  getPositionBundleAddress,
  positionWhirlpoolFilter
} from "@orca-so/whirlpools-client";
import { _POSITION_BUNDLE_SIZE } from "@orca-so/whirlpools-core";
import { getTokenDecoder, TOKEN_PROGRAM_ADDRESS as TOKEN_PROGRAM_ADDRESS3 } from "@solana-program/token";
import { TOKEN_2022_PROGRAM_ADDRESS as TOKEN_2022_PROGRAM_ADDRESS2 } from "@solana-program/token-2022";
import { assertAccountExists, getBase64Encoder } from "@solana/kit";

// src/utils.ts
import {
  fetchEncodedAccounts
} from "@solana/kit";
var MAX_CHUNK_SIZE = 100;
async function fetchMultipleAccountsBatched(rpc, addresses, decoder) {
  const numChunks = Math.ceil(addresses.length / MAX_CHUNK_SIZE);
  const chunks = [...Array(numChunks).keys()].map(
    (i) => addresses.slice(i * MAX_CHUNK_SIZE, (i + 1) * MAX_CHUNK_SIZE)
  );
  const results = [];
  for (const chunk of chunks) {
    const chunkResult = await fetchEncodedAccounts(rpc, chunk);
    chunkResult.forEach((account, _) => {
      const data = decoder(account);
      results.push(data);
    });
  }
  return results;
}

// src/position.ts
function getPositionInBundleAddresses(positionBundle) {
  const buffer = Buffer.from(positionBundle.positionBitmap);
  const positions = [];
  for (let i = 0; i < _POSITION_BUNDLE_SIZE(); i++) {
    const byteIndex = Math.floor(i / 8);
    const bitIndex = i % 8;
    if (buffer[byteIndex] & 1 << bitIndex) {
      positions.push(
        getBundledPositionAddress(positionBundle.positionBundleMint, i).then(
          (x) => x[0]
        )
      );
    }
  }
  return positions;
}
async function fetchPositionsForOwner(rpc, owner) {
  const [tokenAccounts, token2022Accounts] = await Promise.all([
    rpc.getTokenAccountsByOwner(
      owner,
      { programId: TOKEN_PROGRAM_ADDRESS3 },
      { encoding: "base64" }
    ).send(),
    rpc.getTokenAccountsByOwner(
      owner,
      { programId: TOKEN_2022_PROGRAM_ADDRESS2 },
      { encoding: "base64" }
    ).send()
  ]);
  const encoder = getBase64Encoder();
  const decoder = getTokenDecoder();
  const potentialTokens = [...tokenAccounts.value, ...token2022Accounts.value].map((x) => ({
    ...decoder.decode(encoder.encode(x.account.data[0])),
    tokenProgram: x.account.owner
  })).filter((x) => x.amount === 1n);
  const positionAddresses = await Promise.all(
    potentialTokens.map((x) => getPositionAddress2(x.mint).then((x2) => x2[0]))
  );
  const positionBundleAddresses = await Promise.all(
    potentialTokens.map(
      (x) => getPositionBundleAddress(x.mint).then((x2) => x2[0])
    )
  );
  const positions = await fetchMultipleAccountsBatched(
    rpc,
    positionAddresses,
    decodePosition
  );
  const positionBundles = await fetchMultipleAccountsBatched(
    rpc,
    positionBundleAddresses,
    decodePositionBundle
  );
  const bundledPositionAddresses = await Promise.all(
    positionBundles.filter((x) => x.exists).flatMap((x) => getPositionInBundleAddresses(x.data))
  );
  const bundledPositions = (await fetchMultipleAccountsBatched(
    rpc,
    bundledPositionAddresses,
    decodePosition
  )).filter((x) => x.exists).map((x) => {
    assertAccountExists(x);
    return x;
  });
  const bundledPositionMap = bundledPositions.reduce((acc, x) => {
    const current = acc.get(x.data.positionMint) ?? [];
    return acc.set(x.data.positionMint, [...current, x]);
  }, /* @__PURE__ */ new Map());
  const positionsOrBundles = [];
  for (let i = 0; i < potentialTokens.length; i++) {
    const position = positions[i];
    const positionBundle = positionBundles[i];
    const token = potentialTokens[i];
    if (position.exists) {
      positionsOrBundles.push({
        ...position,
        tokenProgram: token.tokenProgram,
        isPositionBundle: false
      });
    }
    if (positionBundle.exists) {
      const positions2 = bundledPositionMap.get(positionBundle.data.positionBundleMint) ?? [];
      positionsOrBundles.push({
        ...positionBundle,
        positions: positions2,
        tokenProgram: token.tokenProgram,
        isPositionBundle: true
      });
    }
  }
  return positionsOrBundles;
}
async function fetchPositionsInWhirlpool(rpc, whirlpool) {
  const positions = await fetchAllPositionWithFilter(
    rpc,
    positionWhirlpoolFilter(whirlpool)
  );
  return positions.map((x) => ({
    ...x,
    isPositionBundle: false
  }));
}

// src/harvest.ts
async function harvestPositionInstructions(rpc, positionMintAddress, authority = FUNDER) {
  assert4(
    authority.address !== DEFAULT_ADDRESS,
    "Either supply an authority or set the default funder"
  );
  const currentEpoch = await rpc.getEpochInfo().send();
  const positionAddress = await getPositionAddress3(positionMintAddress);
  const position = await fetchPosition2(rpc, positionAddress[0]);
  const whirlpool = await fetchWhirlpool2(rpc, position.data.whirlpool);
  const [mintA, mintB, positionMint, ...rewardMints] = await fetchAllMaybeMint2(
    rpc,
    [
      whirlpool.data.tokenMintA,
      whirlpool.data.tokenMintB,
      positionMintAddress,
      ...whirlpool.data.rewardInfos.map((x) => x.mint).filter((x) => x !== DEFAULT_ADDRESS)
    ]
  );
  assert4(mintA.exists, "Token A not found");
  assert4(mintB.exists, "Token B not found");
  assert4(positionMint.exists, "Position mint not found");
  const lowerTickArrayStartIndex = getTickArrayStartTickIndex3(
    position.data.tickLowerIndex,
    whirlpool.data.tickSpacing
  );
  const upperTickArrayStartIndex = getTickArrayStartTickIndex3(
    position.data.tickUpperIndex,
    whirlpool.data.tickSpacing
  );
  const [positionTokenAccount, lowerTickArrayAddress, upperTickArrayAddress] = await Promise.all([
    findAssociatedTokenPda3({
      owner: authority.address,
      mint: positionMintAddress,
      tokenProgram: positionMint.programAddress
    }).then((x) => x[0]),
    getTickArrayAddress3(whirlpool.address, lowerTickArrayStartIndex).then(
      (x) => x[0]
    ),
    getTickArrayAddress3(whirlpool.address, upperTickArrayStartIndex).then(
      (x) => x[0]
    )
  ]);
  const [lowerTickArray, upperTickArray] = await fetchAllTickArray2(rpc, [
    lowerTickArrayAddress,
    upperTickArrayAddress
  ]);
  const lowerTick = lowerTickArray.data.ticks[getTickIndexInArray2(
    position.data.tickLowerIndex,
    lowerTickArrayStartIndex,
    whirlpool.data.tickSpacing
  )];
  const upperTick = upperTickArray.data.ticks[getTickIndexInArray2(
    position.data.tickUpperIndex,
    upperTickArrayStartIndex,
    whirlpool.data.tickSpacing
  )];
  const feesQuote = collectFeesQuote2(
    whirlpool.data,
    position.data,
    lowerTick,
    upperTick,
    getCurrentTransferFee(mintA, currentEpoch.epoch),
    getCurrentTransferFee(mintB, currentEpoch.epoch)
  );
  const currentUnixTimestamp = BigInt(Math.floor(Date.now() / 1e3));
  const rewardsQuote = collectRewardsQuote2(
    whirlpool.data,
    position.data,
    lowerTick,
    upperTick,
    currentUnixTimestamp,
    getCurrentTransferFee(rewardMints[0], currentEpoch.epoch),
    getCurrentTransferFee(rewardMints[1], currentEpoch.epoch),
    getCurrentTransferFee(rewardMints[2], currentEpoch.epoch)
  );
  const requiredMints = /* @__PURE__ */ new Set();
  if (feesQuote.feeOwedA > 0n || feesQuote.feeOwedB > 0n) {
    requiredMints.add(whirlpool.data.tokenMintA);
    requiredMints.add(whirlpool.data.tokenMintB);
  }
  for (let i = 0; i < rewardsQuote.rewards.length; i++) {
    if (rewardsQuote.rewards[i].rewardsOwed > 0n) {
      requiredMints.add(whirlpool.data.rewardInfos[i].mint);
    }
  }
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(
    rpc,
    authority,
    Array.from(requiredMints)
  );
  const instructions = [];
  instructions.push(...createInstructions);
  if (position.data.liquidity > 0n) {
    instructions.push(
      getUpdateFeesAndRewardsInstruction({
        whirlpool: whirlpool.address,
        position: positionAddress[0],
        tickArrayLower: lowerTickArrayAddress,
        tickArrayUpper: upperTickArrayAddress
      })
    );
  }
  if (feesQuote.feeOwedA > 0n || feesQuote.feeOwedB > 0n) {
    instructions.push(
      getCollectFeesV2Instruction2({
        whirlpool: whirlpool.address,
        positionAuthority: authority,
        position: positionAddress[0],
        positionTokenAccount,
        tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
        tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
        tokenVaultA: whirlpool.data.tokenVaultA,
        tokenVaultB: whirlpool.data.tokenVaultB,
        tokenMintA: whirlpool.data.tokenMintA,
        tokenMintB: whirlpool.data.tokenMintB,
        tokenProgramA: mintA.programAddress,
        tokenProgramB: mintB.programAddress,
        memoProgram: MEMO_PROGRAM_ADDRESS2,
        remainingAccountsInfo: null
      })
    );
  }
  for (let i = 0; i < rewardsQuote.rewards.length; i++) {
    if (rewardsQuote.rewards[i].rewardsOwed === 0n) {
      continue;
    }
    const rewardMint = rewardMints[i];
    assert4(rewardMint.exists, `Reward mint ${i} not found`);
    instructions.push(
      getCollectRewardV2Instruction2({
        whirlpool: whirlpool.address,
        positionAuthority: authority,
        position: positionAddress[0],
        positionTokenAccount,
        rewardOwnerAccount: tokenAccountAddresses[rewardMint.address],
        rewardVault: whirlpool.data.rewardInfos[i].vault,
        rewardIndex: i,
        rewardMint: rewardMint.address,
        rewardTokenProgram: rewardMint.programAddress,
        memoProgram: MEMO_PROGRAM_ADDRESS2,
        remainingAccountsInfo: null
      })
    );
  }
  instructions.push(...cleanupInstructions);
  return {
    feesQuote,
    rewardsQuote,
    instructions
  };
}
var harvestPosition = wrapFunctionWithExecution(
  harvestPositionInstructions
);
async function harvestAllPositionFees() {
  const { rpcUrl } = getRpcConfig();
  const rpc = rpcFromUrl2(rpcUrl);
  const owner = getPayer();
  const positions = await fetchPositionsForOwner(rpc, owner.address);
  const instructionSets = [];
  let currentInstructions = [];
  for (const position of positions) {
    if ("positionMint" in position.data) {
      const { instructions } = await harvestPositionInstructions(
        rpc,
        position.data.positionMint,
        owner
      );
      if (await wouldExceedTransactionSize(currentInstructions, instructions)) {
        instructionSets.push(currentInstructions);
        currentInstructions = [...instructions];
      } else {
        currentInstructions.push(...instructions);
      }
    }
  }
  return Promise.all(
    instructionSets.map(async (instructions) => {
      let txHash = await buildAndSendTransaction2(instructions, owner);
      return txHash;
    })
  );
}

// src/increaseLiquidity.ts
import {
  fetchAllMaybeTickArray,
  fetchPosition as fetchPosition3,
  fetchWhirlpool as fetchWhirlpool3,
  getIncreaseLiquidityV2Instruction,
  getInitializeTickArrayInstruction as getInitializeTickArrayInstruction2,
  getOpenPositionWithTokenExtensionsInstruction,
  getPositionAddress as getPositionAddress4,
  getTickArrayAddress as getTickArrayAddress4,
  getTickArraySize as getTickArraySize2
} from "@orca-so/whirlpools-client";
import {
  getFullRangeTickIndexes as getFullRangeTickIndexes2,
  getTickArrayStartTickIndex as getTickArrayStartTickIndex4,
  increaseLiquidityQuote,
  increaseLiquidityQuoteA,
  increaseLiquidityQuoteB,
  priceToTickIndex,
  getInitializableTickIndex,
  orderTickIndexes
} from "@orca-so/whirlpools-core";
import { address as address4, generateKeyPairSigner as generateKeyPairSigner3, lamports as lamports3 } from "@solana/kit";
import { fetchSysvarRent as fetchSysvarRent2 } from "@solana/sysvars";
import {
  ASSOCIATED_TOKEN_PROGRAM_ADDRESS,
  findAssociatedTokenPda as findAssociatedTokenPda4
} from "@solana-program/token";
import {
  fetchAllMint as fetchAllMint4,
  TOKEN_2022_PROGRAM_ADDRESS as TOKEN_2022_PROGRAM_ADDRESS3
} from "@solana-program/token-2022";
import { MEMO_PROGRAM_ADDRESS as MEMO_PROGRAM_ADDRESS3 } from "@solana-program/memo";
import assert5 from "assert";
function getIncreaseLiquidityQuote(param, pool, tickLowerIndex, tickUpperIndex, slippageToleranceBps, transferFeeA, transferFeeB) {
  if ("liquidity" in param) {
    return increaseLiquidityQuote(
      param.liquidity,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickLowerIndex,
      tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  } else if ("tokenA" in param) {
    return increaseLiquidityQuoteA(
      param.tokenA,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickLowerIndex,
      tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  } else {
    return increaseLiquidityQuoteB(
      param.tokenB,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickLowerIndex,
      tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  }
}
async function increaseLiquidityInstructions(rpc, positionMintAddress, param, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, authority = FUNDER) {
  assert5(
    authority.address !== DEFAULT_ADDRESS,
    "Either supply the authority or set the default funder"
  );
  const positionAddress = await getPositionAddress4(positionMintAddress);
  const position = await fetchPosition3(rpc, positionAddress[0]);
  const whirlpool = await fetchWhirlpool3(rpc, position.data.whirlpool);
  const currentEpoch = await rpc.getEpochInfo().send();
  const [mintA, mintB, positionMint] = await fetchAllMint4(rpc, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB,
    positionMintAddress
  ]);
  const transferFeeA = getCurrentTransferFee(mintA, currentEpoch.epoch);
  const transferFeeB = getCurrentTransferFee(mintB, currentEpoch.epoch);
  const quote = getIncreaseLiquidityQuote(
    param,
    whirlpool.data,
    position.data.tickLowerIndex,
    position.data.tickUpperIndex,
    slippageToleranceBps,
    transferFeeA,
    transferFeeB
  );
  const instructions = [];
  const lowerTickArrayStartIndex = getTickArrayStartTickIndex4(
    position.data.tickLowerIndex,
    whirlpool.data.tickSpacing
  );
  const upperTickArrayStartIndex = getTickArrayStartTickIndex4(
    position.data.tickUpperIndex,
    whirlpool.data.tickSpacing
  );
  const [positionTokenAccount, tickArrayLower, tickArrayUpper] = await Promise.all([
    findAssociatedTokenPda4({
      owner: authority.address,
      mint: positionMintAddress,
      tokenProgram: positionMint.programAddress
    }).then((x) => x[0]),
    getTickArrayAddress4(whirlpool.address, lowerTickArrayStartIndex).then(
      (x) => x[0]
    ),
    getTickArrayAddress4(whirlpool.address, upperTickArrayStartIndex).then(
      (x) => x[0]
    )
  ]);
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(rpc, authority, {
    [whirlpool.data.tokenMintA]: quote.tokenMaxA,
    [whirlpool.data.tokenMintB]: quote.tokenMaxB
  });
  instructions.push(...createInstructions);
  instructions.push(
    getIncreaseLiquidityV2Instruction({
      whirlpool: whirlpool.address,
      positionAuthority: authority,
      position: position.address,
      positionTokenAccount,
      tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
      tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
      tokenVaultA: whirlpool.data.tokenVaultA,
      tokenVaultB: whirlpool.data.tokenVaultB,
      tokenMintA: whirlpool.data.tokenMintA,
      tokenMintB: whirlpool.data.tokenMintB,
      tokenProgramA: mintA.programAddress,
      tokenProgramB: mintB.programAddress,
      tickArrayLower,
      tickArrayUpper,
      liquidityAmount: quote.liquidityDelta,
      tokenMaxA: quote.tokenMaxA,
      tokenMaxB: quote.tokenMaxB,
      memoProgram: MEMO_PROGRAM_ADDRESS3,
      remainingAccountsInfo: null
    })
  );
  instructions.push(...cleanupInstructions);
  return {
    quote,
    instructions
  };
}
async function internalOpenPositionInstructions(rpc, whirlpool, param, lowerTickIndex, upperTickIndex, mintA, mintB, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, funder = FUNDER) {
  assert5(
    funder.address !== DEFAULT_ADDRESS,
    "Either supply a funder or set the default funder"
  );
  const instructions = [];
  const rent = await fetchSysvarRent2(rpc);
  let nonRefundableRent = 0n;
  const tickRange = orderTickIndexes(lowerTickIndex, upperTickIndex);
  const initializableLowerTickIndex = getInitializableTickIndex(
    tickRange.tickLowerIndex,
    whirlpool.data.tickSpacing,
    false
  );
  const initializableUpperTickIndex = getInitializableTickIndex(
    tickRange.tickUpperIndex,
    whirlpool.data.tickSpacing,
    true
  );
  const currentEpoch = await rpc.getEpochInfo().send();
  const transferFeeA = getCurrentTransferFee(mintA, currentEpoch.epoch);
  const transferFeeB = getCurrentTransferFee(mintB, currentEpoch.epoch);
  const quote = getIncreaseLiquidityQuote(
    param,
    whirlpool.data,
    initializableLowerTickIndex,
    initializableUpperTickIndex,
    slippageToleranceBps,
    transferFeeA,
    transferFeeB
  );
  const positionMint = await generateKeyPairSigner3();
  const lowerTickArrayIndex = getTickArrayStartTickIndex4(
    initializableLowerTickIndex,
    whirlpool.data.tickSpacing
  );
  const upperTickArrayIndex = getTickArrayStartTickIndex4(
    initializableUpperTickIndex,
    whirlpool.data.tickSpacing
  );
  const [
    positionAddress,
    positionTokenAccount,
    lowerTickArrayAddress,
    upperTickArrayAddress
  ] = await Promise.all([
    getPositionAddress4(positionMint.address),
    findAssociatedTokenPda4({
      owner: funder.address,
      mint: positionMint.address,
      tokenProgram: TOKEN_2022_PROGRAM_ADDRESS3
    }).then((x) => x[0]),
    getTickArrayAddress4(whirlpool.address, lowerTickArrayIndex).then(
      (x) => x[0]
    ),
    getTickArrayAddress4(whirlpool.address, upperTickArrayIndex).then(
      (x) => x[0]
    )
  ]);
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(rpc, funder, {
    [whirlpool.data.tokenMintA]: quote.tokenMaxA,
    [whirlpool.data.tokenMintB]: quote.tokenMaxB
  });
  instructions.push(...createInstructions);
  const [lowerTickArray, upperTickArray] = await fetchAllMaybeTickArray(rpc, [
    lowerTickArrayAddress,
    upperTickArrayAddress
  ]);
  if (!lowerTickArray.exists) {
    instructions.push(
      getInitializeTickArrayInstruction2({
        whirlpool: whirlpool.address,
        funder,
        tickArray: lowerTickArrayAddress,
        startTickIndex: lowerTickArrayIndex
      })
    );
    nonRefundableRent += calculateMinimumBalanceForRentExemption(
      rent,
      getTickArraySize2()
    );
  }
  if (!upperTickArray.exists && lowerTickArrayIndex !== upperTickArrayIndex) {
    instructions.push(
      getInitializeTickArrayInstruction2({
        whirlpool: whirlpool.address,
        funder,
        tickArray: upperTickArrayAddress,
        startTickIndex: upperTickArrayIndex
      })
    );
    nonRefundableRent += calculateMinimumBalanceForRentExemption(
      rent,
      getTickArraySize2()
    );
  }
  instructions.push(
    getOpenPositionWithTokenExtensionsInstruction({
      funder,
      owner: funder.address,
      position: positionAddress[0],
      positionMint,
      positionTokenAccount,
      whirlpool: whirlpool.address,
      associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ADDRESS,
      tickLowerIndex: initializableLowerTickIndex,
      tickUpperIndex: initializableUpperTickIndex,
      token2022Program: TOKEN_2022_PROGRAM_ADDRESS3,
      metadataUpdateAuth: address4(
        "3axbTs2z5GBy6usVbNVoqEgZMng3vZvMnAoX29BFfwhr"
      ),
      withTokenMetadataExtension: true
    })
  );
  instructions.push(
    getIncreaseLiquidityV2Instruction({
      whirlpool: whirlpool.address,
      positionAuthority: funder,
      position: positionAddress[0],
      positionTokenAccount,
      tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
      tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
      tokenVaultA: whirlpool.data.tokenVaultA,
      tokenVaultB: whirlpool.data.tokenVaultB,
      tokenMintA: whirlpool.data.tokenMintA,
      tokenMintB: whirlpool.data.tokenMintB,
      tokenProgramA: mintA.programAddress,
      tokenProgramB: mintB.programAddress,
      tickArrayLower: lowerTickArrayAddress,
      tickArrayUpper: upperTickArrayAddress,
      liquidityAmount: quote.liquidityDelta,
      tokenMaxA: quote.tokenMaxA,
      tokenMaxB: quote.tokenMaxB,
      memoProgram: MEMO_PROGRAM_ADDRESS3,
      remainingAccountsInfo: null
    })
  );
  instructions.push(...cleanupInstructions);
  return {
    instructions,
    quote,
    positionMint: positionMint.address,
    initializationCost: lamports3(nonRefundableRent)
  };
}
async function openFullRangePositionInstructions(rpc, poolAddress, param, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, funder = FUNDER) {
  const whirlpool = await fetchWhirlpool3(rpc, poolAddress);
  const tickRange = getFullRangeTickIndexes2(whirlpool.data.tickSpacing);
  const [mintA, mintB] = await fetchAllMint4(rpc, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB
  ]);
  return internalOpenPositionInstructions(
    rpc,
    whirlpool,
    param,
    tickRange.tickLowerIndex,
    tickRange.tickUpperIndex,
    mintA,
    mintB,
    slippageToleranceBps,
    funder
  );
}
async function openPositionInstructions(rpc, poolAddress, param, lowerPrice, upperPrice, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, funder = FUNDER) {
  const whirlpool = await fetchWhirlpool3(rpc, poolAddress);
  assert5(
    whirlpool.data.tickSpacing !== SPLASH_POOL_TICK_SPACING,
    "Splash pools only support full range positions"
  );
  const [mintA, mintB] = await fetchAllMint4(rpc, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB
  ]);
  const decimalsA = mintA.data.decimals;
  const decimalsB = mintB.data.decimals;
  const lowerTickIndex = priceToTickIndex(lowerPrice, decimalsA, decimalsB);
  const upperTickIndex = priceToTickIndex(upperPrice, decimalsA, decimalsB);
  return internalOpenPositionInstructions(
    rpc,
    whirlpool,
    param,
    lowerTickIndex,
    upperTickIndex,
    mintA,
    mintB,
    slippageToleranceBps,
    funder
  );
}
var increasePosLiquidity = wrapFunctionWithExecution(
  increaseLiquidityInstructions
);
var openFullRangePosition = wrapFunctionWithExecution(
  openFullRangePositionInstructions
);
var openConcentratedPosition = wrapFunctionWithExecution(
  openPositionInstructions
);

// src/pool.ts
import {
  getFeeTierAddress as getFeeTierAddress2,
  getWhirlpoolAddress as getWhirlpoolAddress2,
  fetchWhirlpoolsConfig,
  fetchFeeTier,
  fetchMaybeWhirlpool,
  fetchAllMaybeWhirlpool,
  fetchAllFeeTierWithFilter,
  feeTierWhirlpoolsConfigFilter
} from "@orca-so/whirlpools-client";
import { sqrtPriceToPrice } from "@orca-so/whirlpools-core";
import { fetchAllMint as fetchAllMint5 } from "@solana-program/token";
async function fetchSplashPool(rpc, tokenMintOne, tokenMintTwo) {
  return fetchConcentratedLiquidityPool(
    rpc,
    tokenMintOne,
    tokenMintTwo,
    SPLASH_POOL_TICK_SPACING
  );
}
async function fetchConcentratedLiquidityPool(rpc, tokenMintOne, tokenMintTwo, tickSpacing) {
  const [tokenMintA, tokenMintB] = orderMints(tokenMintOne, tokenMintTwo);
  const feeTierAddress = await getFeeTierAddress2(
    WHIRLPOOLS_CONFIG_ADDRESS,
    tickSpacing
  ).then((x) => x[0]);
  const poolAddress = await getWhirlpoolAddress2(
    WHIRLPOOLS_CONFIG_ADDRESS,
    tokenMintA,
    tokenMintB,
    tickSpacing
  ).then((x) => x[0]);
  const [configAccount, feeTierAccount, poolAccount] = await Promise.all([
    fetchWhirlpoolsConfig(rpc, WHIRLPOOLS_CONFIG_ADDRESS),
    fetchFeeTier(rpc, feeTierAddress),
    fetchMaybeWhirlpool(rpc, poolAddress)
  ]);
  const [mintA, mintB] = await fetchAllMint5(rpc, [tokenMintA, tokenMintB]);
  if (poolAccount.exists) {
    const poolPrice = sqrtPriceToPrice(
      poolAccount.data.sqrtPrice,
      mintA.data.decimals,
      mintB.data.decimals
    );
    return {
      initialized: true,
      address: poolAddress,
      price: poolPrice,
      ...poolAccount.data
    };
  } else {
    return {
      initialized: false,
      address: poolAddress,
      whirlpoolsConfig: WHIRLPOOLS_CONFIG_ADDRESS,
      tickSpacing,
      feeRate: feeTierAccount.data.defaultFeeRate,
      protocolFeeRate: configAccount.data.defaultProtocolFeeRate,
      tokenMintA,
      tokenMintB
    };
  }
}
async function fetchWhirlpoolsByTokenPair(rpc, tokenMintOne, tokenMintTwo) {
  const [tokenMintA, tokenMintB] = orderMints(tokenMintOne, tokenMintTwo);
  const feeTierAccounts = await fetchAllFeeTierWithFilter(
    rpc,
    feeTierWhirlpoolsConfigFilter(WHIRLPOOLS_CONFIG_ADDRESS)
  );
  const supportedTickSpacings = feeTierAccounts.map((x) => x.data.tickSpacing);
  const poolAddresses = await Promise.all(
    supportedTickSpacings.map(
      (x) => getWhirlpoolAddress2(
        WHIRLPOOLS_CONFIG_ADDRESS,
        tokenMintA,
        tokenMintB,
        x
      ).then((x2) => x2[0])
    )
  );
  const [configAccount, poolAccounts] = await Promise.all([
    fetchWhirlpoolsConfig(rpc, WHIRLPOOLS_CONFIG_ADDRESS),
    fetchAllMaybeWhirlpool(rpc, poolAddresses)
  ]);
  const [mintA, mintB] = await fetchAllMint5(rpc, [tokenMintA, tokenMintB]);
  const pools = [];
  for (let i = 0; i < supportedTickSpacings.length; i++) {
    const tickSpacing = supportedTickSpacings[i];
    const feeTierAccount = feeTierAccounts[i];
    const poolAccount = poolAccounts[i];
    const poolAddress = poolAddresses[i];
    if (poolAccount.exists) {
      const poolPrice = sqrtPriceToPrice(
        poolAccount.data.sqrtPrice,
        mintA.data.decimals,
        mintB.data.decimals
      );
      pools.push({
        initialized: true,
        address: poolAddress,
        price: poolPrice,
        ...poolAccount.data
      });
    } else {
      pools.push({
        initialized: false,
        address: poolAddress,
        whirlpoolsConfig: WHIRLPOOLS_CONFIG_ADDRESS,
        tickSpacing,
        feeRate: feeTierAccount.data.defaultFeeRate,
        protocolFeeRate: configAccount.data.defaultProtocolFeeRate,
        tokenMintA,
        tokenMintB
      });
    }
  }
  return pools;
}

// src/swap.ts
import { AccountRole, lamports as lamports4 } from "@solana/kit";
import {
  _TICK_ARRAY_SIZE,
  getTickArrayStartTickIndex as getTickArrayStartTickIndex5,
  swapQuoteByInputToken,
  swapQuoteByOutputToken
} from "@orca-so/whirlpools-core";
import {
  AccountsType,
  fetchAllMaybeTickArray as fetchAllMaybeTickArray2,
  fetchWhirlpool as fetchWhirlpool4,
  fetchOracle,
  getOracleAddress,
  getSwapV2Instruction,
  getTickArrayAddress as getTickArrayAddress5
} from "@orca-so/whirlpools-client";
import { MEMO_PROGRAM_ADDRESS as MEMO_PROGRAM_ADDRESS4 } from "@solana-program/memo";
import { fetchAllMint as fetchAllMint6 } from "@solana-program/token-2022";
function createUninitializedTickArray(address5, startTickIndex, programAddress) {
  return {
    address: address5,
    data: {
      startTickIndex,
      ticks: Array(_TICK_ARRAY_SIZE()).fill({
        initialized: false,
        liquidityNet: 0n,
        liquidityGross: 0n,
        feeGrowthOutsideA: 0n,
        feeGrowthOutsideB: 0n,
        rewardGrowthsOutside: [0n, 0n, 0n]
      })
    },
    space: 0n,
    executable: false,
    lamports: lamports4(0n),
    programAddress
  };
}
async function fetchTickArrayOrDefault(rpc, whirlpool) {
  const tickArrayStartIndex = getTickArrayStartTickIndex5(
    whirlpool.data.tickCurrentIndex,
    whirlpool.data.tickSpacing
  );
  const offset = whirlpool.data.tickSpacing * _TICK_ARRAY_SIZE();
  const tickArrayIndexes = [
    tickArrayStartIndex,
    tickArrayStartIndex + offset,
    tickArrayStartIndex + offset * 2,
    tickArrayStartIndex - offset,
    tickArrayStartIndex - offset * 2
  ];
  const tickArrayAddresses = await Promise.all(
    tickArrayIndexes.map(
      (startIndex) => getTickArrayAddress5(whirlpool.address, startIndex).then((x) => x[0])
    )
  );
  const maybeTickArrays = await fetchAllMaybeTickArray2(rpc, tickArrayAddresses);
  const tickArrays = [];
  for (let i = 0; i < maybeTickArrays.length; i++) {
    const maybeTickArray = maybeTickArrays[i];
    if (maybeTickArray.exists) {
      tickArrays.push(maybeTickArray);
    } else {
      tickArrays.push(
        createUninitializedTickArray(
          tickArrayAddresses[i],
          tickArrayIndexes[i],
          whirlpool.programAddress
        )
      );
    }
  }
  return tickArrays;
}
async function getOracle(rpc, oracleAddress, whirlpool) {
  const feeTierIndex = whirlpool.feeTierIndexSeed[0] + whirlpool.feeTierIndexSeed[1] * 256;
  if (whirlpool.tickSpacing == feeTierIndex) {
    return void 0;
  }
  return (await fetchOracle(rpc, oracleAddress)).data;
}
function getSwapQuote(params, whirlpool, transferFeeA, transferFeeB, tickArrays, oracle, specifiedTokenA, slippageToleranceBps, timestamp) {
  if ("inputAmount" in params) {
    return swapQuoteByInputToken(
      params.inputAmount,
      specifiedTokenA,
      slippageToleranceBps,
      whirlpool,
      oracle,
      tickArrays,
      timestamp,
      transferFeeA,
      transferFeeB
    );
  }
  return swapQuoteByOutputToken(
    params.outputAmount,
    specifiedTokenA,
    slippageToleranceBps,
    whirlpool,
    oracle,
    tickArrays,
    timestamp,
    transferFeeA,
    transferFeeB
  );
}
async function swapInstructions(rpc, params, poolAddress, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, signer = FUNDER) {
  const whirlpool = await fetchWhirlpool4(rpc, poolAddress);
  const [tokenA, tokenB] = await fetchAllMint6(rpc, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB
  ]);
  const specifiedTokenA = params.mint === whirlpool.data.tokenMintA;
  const specifiedInput = "inputAmount" in params;
  const tickArrays = await fetchTickArrayOrDefault(rpc, whirlpool);
  const oracleAddress = await getOracleAddress(whirlpool.address).then(
    (x) => x[0]
  );
  const oracle = await getOracle(rpc, oracleAddress, whirlpool.data);
  const currentEpoch = await rpc.getEpochInfo().send();
  const transferFeeA = getCurrentTransferFee(tokenA, currentEpoch.epoch);
  const transferFeeB = getCurrentTransferFee(tokenB, currentEpoch.epoch);
  const timestamp = BigInt(Math.floor(Date.now() / 1e3));
  const tradeEnableTimestamp = oracle?.tradeEnableTimestamp ?? 0n;
  const quote = getSwapQuote(
    params,
    whirlpool.data,
    transferFeeA,
    transferFeeB,
    tickArrays.map((x) => x.data),
    oracle,
    specifiedTokenA,
    slippageToleranceBps,
    timestamp
  );
  const maxInAmount = "tokenIn" in quote ? quote.tokenIn : quote.tokenMaxIn;
  const aToB = specifiedTokenA === specifiedInput;
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(rpc, signer, {
    [whirlpool.data.tokenMintA]: aToB ? maxInAmount : 0n,
    [whirlpool.data.tokenMintB]: aToB ? 0n : maxInAmount
  });
  const instructions = [];
  instructions.push(...createInstructions);
  const specifiedAmount = "inputAmount" in params ? params.inputAmount : params.outputAmount;
  const otherAmountThreshold = "tokenMaxIn" in quote ? quote.tokenMaxIn : quote.tokenMinOut;
  const swapInstruction = getSwapV2Instruction({
    tokenProgramA: tokenA.programAddress,
    tokenProgramB: tokenB.programAddress,
    memoProgram: MEMO_PROGRAM_ADDRESS4,
    tokenAuthority: signer,
    whirlpool: whirlpool.address,
    tokenMintA: whirlpool.data.tokenMintA,
    tokenMintB: whirlpool.data.tokenMintB,
    tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
    tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
    tokenVaultA: whirlpool.data.tokenVaultA,
    tokenVaultB: whirlpool.data.tokenVaultB,
    tickArray0: tickArrays[0].address,
    tickArray1: tickArrays[1].address,
    tickArray2: tickArrays[2].address,
    amount: specifiedAmount,
    otherAmountThreshold,
    sqrtPriceLimit: 0,
    amountSpecifiedIsInput: specifiedInput,
    aToB,
    oracle: oracleAddress,
    remainingAccountsInfo: {
      slices: [
        { accountsType: AccountsType.SupplementalTickArrays, length: 2 }
      ]
    }
  });
  swapInstruction.accounts.push(
    { address: tickArrays[3].address, role: AccountRole.WRITABLE },
    { address: tickArrays[4].address, role: AccountRole.WRITABLE }
  );
  instructions.push(swapInstruction);
  instructions.push(...cleanupInstructions);
  return {
    quote,
    instructions,
    tradeEnableTimestamp
  };
}
var swap = wrapFunctionWithExecution(swapInstructions);
export {
  DEFAULT_ADDRESS,
  DEFAULT_ENFORCE_TOKEN_BALANCE_CHECK,
  DEFAULT_FUNDER,
  DEFAULT_NATIVE_MINT_WRAPPING_STRATEGY,
  DEFAULT_SLIPPAGE_TOLERANCE_BPS,
  DEFAULT_WHIRLPOOLS_CONFIG_ADDRESSES,
  DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS,
  ENFORCE_TOKEN_BALANCE_CHECK,
  FUNDER,
  NATIVE_MINT_WRAPPING_STRATEGY,
  SLIPPAGE_TOLERANCE_BPS,
  SPLASH_POOL_TICK_SPACING,
  WHIRLPOOLS_CONFIG_ADDRESS,
  WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS,
  closePosition,
  closePositionInstructions,
  createConcentratedLiquidityPool,
  createConcentratedLiquidityPoolInstructions,
  createSplashPool,
  createSplashPoolInstructions,
  decreaseLiquidity,
  decreaseLiquidityInstructions,
  fetchConcentratedLiquidityPool,
  fetchPositionsForOwner,
  fetchPositionsInWhirlpool,
  fetchSplashPool,
  fetchWhirlpoolsByTokenPair,
  getPayer,
  getRpcConfig,
  harvestAllPositionFees,
  harvestPosition,
  harvestPositionInstructions,
  increaseLiquidityInstructions,
  increasePosLiquidity,
  openConcentratedPosition,
  openFullRangePosition,
  openFullRangePositionInstructions,
  openPositionInstructions,
  orderMints,
  resetConfiguration,
  setComputeUnitMarginMultiplier,
  setDefaultFunder,
  setDefaultSlippageToleranceBps,
  setEnforceTokenBalanceCheck,
  setJitoBlockEngineUrl,
  setJitoFeePercentile,
  setJitoTipSetting,
  setNativeMintWrappingStrategy,
  setPayerFromBytes,
  setPriorityFeePercentile,
  setPriorityFeeSetting,
  setRpc,
  setWhirlpoolsConfig,
  swap,
  swapInstructions
};
//# sourceMappingURL=index.js.map
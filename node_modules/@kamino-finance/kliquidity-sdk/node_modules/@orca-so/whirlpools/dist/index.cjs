"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  DEFAULT_ADDRESS: () => DEFAULT_ADDRESS,
  DEFAULT_ENFORCE_TOKEN_BALANCE_CHECK: () => DEFAULT_ENFORCE_TOKEN_BALANCE_CHECK,
  DEFAULT_FUNDER: () => DEFAULT_FUNDER,
  DEFAULT_NATIVE_MINT_WRAPPING_STRATEGY: () => DEFAULT_NATIVE_MINT_WRAPPING_STRATEGY,
  DEFAULT_SLIPPAGE_TOLERANCE_BPS: () => DEFAULT_SLIPPAGE_TOLERANCE_BPS,
  DEFAULT_WHIRLPOOLS_CONFIG_ADDRESSES: () => DEFAULT_WHIRLPOOLS_CONFIG_ADDRESSES,
  DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS: () => DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS,
  ENFORCE_TOKEN_BALANCE_CHECK: () => ENFORCE_TOKEN_BALANCE_CHECK,
  FUNDER: () => FUNDER,
  NATIVE_MINT_WRAPPING_STRATEGY: () => NATIVE_MINT_WRAPPING_STRATEGY,
  SLIPPAGE_TOLERANCE_BPS: () => SLIPPAGE_TOLERANCE_BPS,
  SPLASH_POOL_TICK_SPACING: () => SPLASH_POOL_TICK_SPACING,
  WHIRLPOOLS_CONFIG_ADDRESS: () => WHIRLPOOLS_CONFIG_ADDRESS,
  WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS: () => WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS,
  closePosition: () => closePosition,
  closePositionInstructions: () => closePositionInstructions,
  createConcentratedLiquidityPool: () => createConcentratedLiquidityPool,
  createConcentratedLiquidityPoolInstructions: () => createConcentratedLiquidityPoolInstructions,
  createSplashPool: () => createSplashPool,
  createSplashPoolInstructions: () => createSplashPoolInstructions,
  decreaseLiquidity: () => decreaseLiquidity,
  decreaseLiquidityInstructions: () => decreaseLiquidityInstructions,
  fetchConcentratedLiquidityPool: () => fetchConcentratedLiquidityPool,
  fetchPositionsForOwner: () => fetchPositionsForOwner,
  fetchPositionsInWhirlpool: () => fetchPositionsInWhirlpool,
  fetchSplashPool: () => fetchSplashPool,
  fetchWhirlpoolsByTokenPair: () => fetchWhirlpoolsByTokenPair,
  getPayer: () => getPayer,
  getRpcConfig: () => import_tx_sender.getRpcConfig,
  harvestAllPositionFees: () => harvestAllPositionFees,
  harvestPosition: () => harvestPosition,
  harvestPositionInstructions: () => harvestPositionInstructions,
  increaseLiquidityInstructions: () => increaseLiquidityInstructions,
  increasePosLiquidity: () => increasePosLiquidity,
  openConcentratedPosition: () => openConcentratedPosition,
  openFullRangePosition: () => openFullRangePosition,
  openFullRangePositionInstructions: () => openFullRangePositionInstructions,
  openPositionInstructions: () => openPositionInstructions,
  orderMints: () => orderMints,
  resetConfiguration: () => resetConfiguration,
  setComputeUnitMarginMultiplier: () => import_tx_sender.setComputeUnitMarginMultiplier,
  setDefaultFunder: () => setDefaultFunder,
  setDefaultSlippageToleranceBps: () => setDefaultSlippageToleranceBps,
  setEnforceTokenBalanceCheck: () => setEnforceTokenBalanceCheck,
  setJitoBlockEngineUrl: () => import_tx_sender.setJitoBlockEngineUrl,
  setJitoFeePercentile: () => import_tx_sender.setJitoFeePercentile,
  setJitoTipSetting: () => import_tx_sender.setJitoTipSetting,
  setNativeMintWrappingStrategy: () => setNativeMintWrappingStrategy,
  setPayerFromBytes: () => setPayerFromBytes,
  setPriorityFeePercentile: () => import_tx_sender.setPriorityFeePercentile,
  setPriorityFeeSetting: () => import_tx_sender.setPriorityFeeSetting,
  setRpc: () => import_tx_sender.setRpc,
  setWhirlpoolsConfig: () => setWhirlpoolsConfig,
  swap: () => swap,
  swapInstructions: () => swapInstructions
});
module.exports = __toCommonJS(index_exports);

// src/config.ts
var import_whirlpools_client = require("@orca-so/whirlpools-client");
var import_kit = require("@solana/kit");
var import_tx_sender = require("@orca-so/tx-sender");
var DEFAULT_ADDRESS = (0, import_kit.address)("11111111111111111111111111111111");
var DEFAULT_WHIRLPOOLS_CONFIG_ADDRESSES = {
  solanaMainnet: (0, import_kit.address)("2LecshUwdy9xi7meFgHtFJQNSKk4KdTrcpvaB56dP2NQ"),
  solanaDevnet: (0, import_kit.address)("FcrweFY1G9HJAHG5inkGB6pKg1HZ6x9UC2WioAfWrGkR"),
  eclipseMainnet: (0, import_kit.address)("FVG4oDbGv16hqTUbovjyGmtYikn6UBEnazz6RVDMEFwv"),
  eclipseTestnet: (0, import_kit.address)("FPydDjRdZu9sT7HVd6ANhfjh85KLq21Pefr5YWWMRPFp")
};
var DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS = (0, import_kit.address)(
  "777H5H3Tp9U11uRVRzFwM8BinfiakbaLT8vQpeuhvEiH"
);
var WHIRLPOOLS_CONFIG_ADDRESS = DEFAULT_WHIRLPOOLS_CONFIG_ADDRESSES.solanaMainnet;
var WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS = DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS;
async function setWhirlpoolsConfig(config) {
  if ((0, import_kit.isAddress)(config)) {
    WHIRLPOOLS_CONFIG_ADDRESS = config;
  } else {
    WHIRLPOOLS_CONFIG_ADDRESS = DEFAULT_WHIRLPOOLS_CONFIG_ADDRESSES[config];
  }
  WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS = await (0, import_whirlpools_client.getWhirlpoolsConfigExtensionAddress)(WHIRLPOOLS_CONFIG_ADDRESS).then(
    (x) => x[0]
  );
}
var SPLASH_POOL_TICK_SPACING = 32896;
var DEFAULT_FUNDER = (0, import_kit.createNoopSigner)(DEFAULT_ADDRESS);
var FUNDER = DEFAULT_FUNDER;
function setDefaultFunder(funder) {
  if (typeof funder === "string") {
    FUNDER = (0, import_kit.createNoopSigner)(funder);
  } else {
    FUNDER = funder ?? (0, import_kit.createNoopSigner)(DEFAULT_ADDRESS);
  }
}
var DEFAULT_SLIPPAGE_TOLERANCE_BPS = 100;
var SLIPPAGE_TOLERANCE_BPS = DEFAULT_SLIPPAGE_TOLERANCE_BPS;
function setDefaultSlippageToleranceBps(slippageToleranceBps) {
  SLIPPAGE_TOLERANCE_BPS = Math.floor(slippageToleranceBps);
}
var DEFAULT_NATIVE_MINT_WRAPPING_STRATEGY = "keypair";
var NATIVE_MINT_WRAPPING_STRATEGY = DEFAULT_NATIVE_MINT_WRAPPING_STRATEGY;
function setNativeMintWrappingStrategy(strategy) {
  NATIVE_MINT_WRAPPING_STRATEGY = strategy;
}
var DEFAULT_ENFORCE_TOKEN_BALANCE_CHECK = false;
var ENFORCE_TOKEN_BALANCE_CHECK = DEFAULT_ENFORCE_TOKEN_BALANCE_CHECK;
function setEnforceTokenBalanceCheck(enforceBalanceCheck) {
  ENFORCE_TOKEN_BALANCE_CHECK = enforceBalanceCheck;
}
function resetConfiguration() {
  WHIRLPOOLS_CONFIG_ADDRESS = DEFAULT_WHIRLPOOLS_CONFIG_ADDRESSES.solanaMainnet;
  WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS = DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS;
  FUNDER = DEFAULT_FUNDER;
  SLIPPAGE_TOLERANCE_BPS = DEFAULT_SLIPPAGE_TOLERANCE_BPS;
  NATIVE_MINT_WRAPPING_STRATEGY = DEFAULT_NATIVE_MINT_WRAPPING_STRATEGY;
  ENFORCE_TOKEN_BALANCE_CHECK = DEFAULT_ENFORCE_TOKEN_BALANCE_CHECK;
}
var _payer;
async function setPayerFromBytes(pkBytes) {
  const kp = await (0, import_kit.createKeyPairFromBytes)(pkBytes);
  const signer = await (0, import_kit.createSignerFromKeyPair)(kp);
  _payer = signer;
  return signer;
}
function getPayer() {
  if (!_payer) {
    throw new Error("Payer not set. Call setPayer() first.");
  }
  return _payer;
}

// src/createPool.ts
var import_whirlpools_client2 = require("@orca-so/whirlpools-client");
var import_kit4 = require("@solana/kit");
var import_sysvars = require("@solana/sysvars");
var import_whirlpools_core = require("@orca-so/whirlpools-core");
var import_token_20222 = require("@solana-program/token-2022");
var import_assert2 = __toESM(require("assert"), 1);

// src/token.ts
var import_token = require("@solana-program/token");
var import_kit2 = require("@solana/kit");
var import_system = require("@solana-program/system");
var import_token2 = require("@solana-program/token");
var import_token_2022 = require("@solana-program/token-2022");
var import_assert = __toESM(require("assert"), 1);
var NATIVE_MINT = (0, import_kit2.address)(
  "So11111111111111111111111111111111111111112"
);
function mintFilter(x) {
  if (NATIVE_MINT_WRAPPING_STRATEGY === "none" || NATIVE_MINT_WRAPPING_STRATEGY === "ata") {
    return true;
  }
  return x != NATIVE_MINT;
}
async function prepareTokenAccountsInstructions(rpc, owner, spec) {
  const mintAddresses = Array.isArray(spec) ? spec : Object.keys(spec);
  const nativeMintIndex = mintAddresses.indexOf(NATIVE_MINT);
  const hasNativeMint = nativeMintIndex !== -1;
  const mints = await (0, import_token.fetchAllMint)(rpc, mintAddresses.filter(mintFilter));
  const tokenAddresses = await Promise.all(
    mints.map(
      (mint) => (0, import_token.findAssociatedTokenPda)({
        owner: owner.address,
        mint: mint.address,
        tokenProgram: mint.programAddress
      }).then((x) => x[0])
    )
  );
  const tokenAccounts = await (0, import_token.fetchAllMaybeToken)(rpc, tokenAddresses);
  const tokenAccountAddresses = {};
  const createInstructions = [];
  const cleanupInstructions = [];
  for (let i = 0; i < mints.length; i++) {
    const mint = mints[i];
    const tokenAccount = tokenAccounts[i];
    tokenAccountAddresses[mint.address] = tokenAccount.address;
    if (tokenAccount.exists) {
      continue;
    }
    createInstructions.push(
      (0, import_token.getCreateAssociatedTokenInstruction)({
        payer: owner,
        owner: owner.address,
        ata: tokenAccount.address,
        mint: mint.address,
        tokenProgram: mint.programAddress
      })
    );
  }
  if (!Array.isArray(spec)) {
    for (let i = 0; i < mints.length; i++) {
      const mint = mints[i];
      if (mint.address === NATIVE_MINT && NATIVE_MINT_WRAPPING_STRATEGY !== "none") {
        continue;
      }
      const tokenAccount = tokenAccounts[i];
      const existingBalance = tokenAccount.exists ? tokenAccount.data.amount : 0n;
      if (ENFORCE_TOKEN_BALANCE_CHECK) {
        (0, import_assert.default)(
          BigInt(spec[mint.address]) <= existingBalance,
          `Token account for ${mint.address} does not have the required balance`
        );
      }
    }
  }
  if (hasNativeMint && NATIVE_MINT_WRAPPING_STRATEGY === "keypair") {
    const keypair = await (0, import_kit2.generateKeyPairSigner)();
    const space = (0, import_token2.getTokenSize)();
    let amount = await rpc.getMinimumBalanceForRentExemption(BigInt(space)).send();
    if (!Array.isArray(spec)) {
      amount = (0, import_kit2.lamports)(amount + BigInt(spec[NATIVE_MINT]));
    }
    createInstructions.push(
      (0, import_system.getCreateAccountInstruction)({
        payer: owner,
        newAccount: keypair,
        lamports: amount,
        space,
        programAddress: import_token.TOKEN_PROGRAM_ADDRESS
      }),
      (0, import_token.getInitializeAccount3Instruction)({
        account: keypair.address,
        mint: NATIVE_MINT,
        owner: owner.address
      })
    );
    cleanupInstructions.push(
      (0, import_token.getCloseAccountInstruction)({
        account: keypair.address,
        owner,
        destination: owner.address
      })
    );
    tokenAccountAddresses[NATIVE_MINT] = keypair.address;
  }
  if (hasNativeMint && NATIVE_MINT_WRAPPING_STRATEGY === "seed") {
    const space = (0, import_token2.getTokenSize)();
    let amount = await rpc.getMinimumBalanceForRentExemption(BigInt(space)).send();
    if (!Array.isArray(spec)) {
      amount = (0, import_kit2.lamports)(amount + BigInt(spec[NATIVE_MINT]));
    }
    const seed = Date.now().toString();
    const buffer = await crypto.subtle.digest(
      "SHA-256",
      Buffer.concat([
        Buffer.from((0, import_kit2.getAddressEncoder)().encode(owner.address)),
        Buffer.from(seed),
        Buffer.from((0, import_kit2.getAddressEncoder)().encode(import_token.TOKEN_PROGRAM_ADDRESS))
      ])
    );
    tokenAccountAddresses[NATIVE_MINT] = (0, import_kit2.getAddressDecoder)().decode(
      new Uint8Array(buffer)
    );
    createInstructions.push(
      (0, import_system.getCreateAccountWithSeedInstruction)({
        payer: owner,
        newAccount: tokenAccountAddresses[NATIVE_MINT],
        base: owner.address,
        baseAccount: owner,
        seed,
        space,
        amount,
        programAddress: import_token.TOKEN_PROGRAM_ADDRESS
      }),
      (0, import_token.getInitializeAccount3Instruction)({
        account: tokenAccountAddresses[NATIVE_MINT],
        mint: NATIVE_MINT,
        owner: owner.address
      })
    );
    cleanupInstructions.push(
      (0, import_token.getCloseAccountInstruction)({
        account: tokenAccountAddresses[NATIVE_MINT],
        owner,
        destination: owner.address
      })
    );
  }
  if (hasNativeMint && NATIVE_MINT_WRAPPING_STRATEGY === "ata") {
    const account = tokenAccounts[nativeMintIndex];
    const existingBalance = account.exists ? account.data.amount : 0n;
    if (!Array.isArray(spec) && existingBalance < BigInt(spec[NATIVE_MINT])) {
      createInstructions.push(
        (0, import_system.getTransferSolInstruction)({
          source: owner,
          destination: tokenAccountAddresses[NATIVE_MINT],
          amount: BigInt(spec[NATIVE_MINT]) - existingBalance
        }),
        (0, import_token.getSyncNativeInstruction)({
          account: tokenAccountAddresses[NATIVE_MINT]
        })
      );
    }
    if (!account.exists) {
      cleanupInstructions.push(
        (0, import_token.getCloseAccountInstruction)({
          account: account.address,
          owner,
          destination: owner.address
        })
      );
    }
  }
  return {
    createInstructions,
    cleanupInstructions,
    tokenAccountAddresses
  };
}
function getCurrentTransferFee(mint, currentEpoch) {
  if (mint == null || "exists" in mint && !mint.exists || mint.data.extensions.__option === "None") {
    return void 0;
  }
  const feeConfig = mint.data.extensions.value.find(
    (x) => x.__kind === "TransferFeeConfig"
  );
  if (feeConfig == null) {
    return void 0;
  }
  const transferFee = currentEpoch >= feeConfig.newerTransferFee.epoch ? feeConfig.newerTransferFee : feeConfig.olderTransferFee;
  return {
    feeBps: transferFee.transferFeeBasisPoints,
    maxFee: transferFee.maximumFee
  };
}
function getAccountExtensions(mint) {
  if (mint.extensions.__option === "None") {
    return [];
  }
  const extensions = [];
  for (const extension of mint.extensions.value) {
    switch (extension.__kind) {
      case "TransferFeeConfig":
        extensions.push({
          __kind: "TransferFeeAmount",
          withheldAmount: 0n
        });
        break;
      case "NonTransferable":
        extensions.push({
          __kind: "NonTransferableAccount"
        });
        break;
      case "TransferHook":
        extensions.push({
          __kind: "TransferHookAccount",
          transferring: false
        });
        break;
    }
  }
  return extensions;
}
function orderMints(mint1, mint2) {
  const encoder = (0, import_kit2.getAddressEncoder)();
  const mint1Bytes = new Uint8Array(encoder.encode(mint1));
  const mint2Bytes = new Uint8Array(encoder.encode(mint2));
  return Buffer.compare(mint1Bytes, mint2Bytes) < 0 ? [mint1, mint2] : [mint2, mint1];
}
function getTokenSizeForMint(mint) {
  const extensions = getAccountExtensions(mint.data);
  return extensions.length === 0 ? (0, import_token2.getTokenSize)() : (0, import_token_2022.getTokenSize)(extensions);
}

// src/sysvar.ts
var ACCOUNT_STORAGE_OVERHEAD = 128;
function calculateMinimumBalanceForRentExemption(rent, dataSize) {
  const dataSizeForRent = BigInt(dataSize + ACCOUNT_STORAGE_OVERHEAD);
  const rentLamportsPerYear = rent.lamportsPerByteYear * dataSizeForRent;
  const minimumBalance = rentLamportsPerYear * BigInt(rent.exemptionThreshold);
  return minimumBalance;
}

// src/actionHelpers.ts
var import_kit3 = require("@solana/kit");
var import_tx_sender2 = require("@orca-so/tx-sender");
function wrapFunctionWithExecution(instructionFn) {
  return async (...params) => {
    const { rpcUrl } = (0, import_tx_sender.getRpcConfig)();
    const rpc = (0, import_tx_sender2.rpcFromUrl)(rpcUrl);
    const owner = getPayer();
    const result = await instructionFn(rpc, ...params, owner);
    return {
      ...result,
      callback: () => (0, import_tx_sender2.buildAndSendTransaction)(result.instructions, owner)
    };
  };
}
async function wouldExceedTransactionSize(currentInstructions, instructionsToAdd) {
  const noopSginer = (0, import_kit3.createNoopSigner)(
    (0, import_kit3.address)("11111111111111111111111111111111")
  );
  const tx = await (0, import_tx_sender2.buildTransaction)(
    [...currentInstructions, ...instructionsToAdd],
    noopSginer
  );
  const encodedTransaction = (0, import_kit3.getBase64EncodedWireTransaction)(tx);
  const TX_BASE64_ENCODED_SIZE_LIMIT = 1644;
  return encodedTransaction.length >= TX_BASE64_ENCODED_SIZE_LIMIT;
}

// src/createPool.ts
function createSplashPoolInstructions(rpc, tokenMintA, tokenMintB, initialPrice = 1, funder = FUNDER) {
  return createConcentratedLiquidityPoolInstructions(
    rpc,
    tokenMintA,
    tokenMintB,
    SPLASH_POOL_TICK_SPACING,
    initialPrice,
    funder
  );
}
async function createConcentratedLiquidityPoolInstructions(rpc, tokenMintA, tokenMintB, tickSpacing, initialPrice = 1, funder = FUNDER) {
  (0, import_assert2.default)(
    funder.address !== DEFAULT_ADDRESS,
    "Either supply a funder or set the default funder"
  );
  (0, import_assert2.default)(
    orderMints(tokenMintA, tokenMintB)[0] === tokenMintA,
    "Token order needs to be flipped to match the canonical ordering (i.e. sorted on the byte repr. of the mint pubkeys)"
  );
  const instructions = [];
  const rent = await (0, import_sysvars.fetchSysvarRent)(rpc);
  let nonRefundableRent = 0n;
  const [mintA, mintB] = await (0, import_token_20222.fetchAllMint)(rpc, [tokenMintA, tokenMintB]);
  const decimalsA = mintA.data.decimals;
  const decimalsB = mintB.data.decimals;
  const tokenProgramA = mintA.programAddress;
  const tokenProgramB = mintB.programAddress;
  const initialSqrtPrice = (0, import_whirlpools_core.priceToSqrtPrice)(initialPrice, decimalsA, decimalsB);
  const [
    poolAddress,
    feeTier,
    tokenBadgeA,
    tokenBadgeB,
    tokenVaultA,
    tokenVaultB
  ] = await Promise.all([
    (0, import_whirlpools_client2.getWhirlpoolAddress)(
      WHIRLPOOLS_CONFIG_ADDRESS,
      tokenMintA,
      tokenMintB,
      tickSpacing
    ).then((x) => x[0]),
    (0, import_whirlpools_client2.getFeeTierAddress)(WHIRLPOOLS_CONFIG_ADDRESS, tickSpacing).then((x) => x[0]),
    (0, import_whirlpools_client2.getTokenBadgeAddress)(WHIRLPOOLS_CONFIG_ADDRESS, tokenMintA).then(
      (x) => x[0]
    ),
    (0, import_whirlpools_client2.getTokenBadgeAddress)(WHIRLPOOLS_CONFIG_ADDRESS, tokenMintB).then(
      (x) => x[0]
    ),
    (0, import_kit4.generateKeyPairSigner)(),
    (0, import_kit4.generateKeyPairSigner)()
  ]);
  instructions.push(
    (0, import_whirlpools_client2.getInitializePoolV2Instruction)({
      whirlpoolsConfig: WHIRLPOOLS_CONFIG_ADDRESS,
      tokenMintA,
      tokenMintB,
      tokenBadgeA,
      tokenBadgeB,
      funder,
      whirlpool: poolAddress,
      tokenVaultA,
      tokenVaultB,
      tokenProgramA,
      tokenProgramB,
      feeTier,
      tickSpacing,
      initialSqrtPrice
    })
  );
  nonRefundableRent += calculateMinimumBalanceForRentExemption(
    rent,
    getTokenSizeForMint(mintA)
  );
  nonRefundableRent += calculateMinimumBalanceForRentExemption(
    rent,
    getTokenSizeForMint(mintB)
  );
  nonRefundableRent += calculateMinimumBalanceForRentExemption(
    rent,
    (0, import_whirlpools_client2.getWhirlpoolSize)()
  );
  const fullRange = (0, import_whirlpools_core.getFullRangeTickIndexes)(tickSpacing);
  const lowerTickIndex = (0, import_whirlpools_core.getTickArrayStartTickIndex)(
    fullRange.tickLowerIndex,
    tickSpacing
  );
  const upperTickIndex = (0, import_whirlpools_core.getTickArrayStartTickIndex)(
    fullRange.tickUpperIndex,
    tickSpacing
  );
  const initialTickIndex = (0, import_whirlpools_core.sqrtPriceToTickIndex)(initialSqrtPrice);
  const currentTickIndex = (0, import_whirlpools_core.getTickArrayStartTickIndex)(
    initialTickIndex,
    tickSpacing
  );
  const tickArrayIndexes = Array.from(
    /* @__PURE__ */ new Set([lowerTickIndex, upperTickIndex, currentTickIndex])
  );
  const tickArrayAddresses = await Promise.all(
    tickArrayIndexes.map(
      (x) => (0, import_whirlpools_client2.getTickArrayAddress)(poolAddress, x).then((x2) => x2[0])
    )
  );
  for (let i = 0; i < tickArrayIndexes.length; i++) {
    instructions.push(
      (0, import_whirlpools_client2.getInitializeTickArrayInstruction)({
        whirlpool: poolAddress,
        funder,
        tickArray: tickArrayAddresses[i],
        startTickIndex: tickArrayIndexes[i]
      })
    );
    nonRefundableRent += calculateMinimumBalanceForRentExemption(
      rent,
      (0, import_whirlpools_client2.getTickArraySize)()
    );
  }
  return {
    instructions,
    poolAddress,
    initializationCost: (0, import_kit4.lamports)(nonRefundableRent)
  };
}
var createSplashPool = wrapFunctionWithExecution(
  createSplashPoolInstructions
);
var createConcentratedLiquidityPool = wrapFunctionWithExecution(
  createConcentratedLiquidityPoolInstructions
);

// src/decreaseLiquidity.ts
var import_whirlpools_client3 = require("@orca-so/whirlpools-client");
var import_whirlpools_core2 = require("@orca-so/whirlpools-core");
var import_token4 = require("@solana-program/token");
var import_token_20223 = require("@solana-program/token-2022");
var import_memo = require("@solana-program/memo");
var import_assert3 = __toESM(require("assert"), 1);
function getDecreaseLiquidityQuote(param, pool, tickRange, slippageToleranceBps, transferFeeA, transferFeeB) {
  if ("liquidity" in param) {
    return (0, import_whirlpools_core2.decreaseLiquidityQuote)(
      param.liquidity,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickRange.tickLowerIndex,
      tickRange.tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  } else if ("tokenA" in param) {
    return (0, import_whirlpools_core2.decreaseLiquidityQuoteA)(
      param.tokenA,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickRange.tickLowerIndex,
      tickRange.tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  } else {
    return (0, import_whirlpools_core2.decreaseLiquidityQuoteB)(
      param.tokenB,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickRange.tickLowerIndex,
      tickRange.tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  }
}
async function decreaseLiquidityInstructions(rpc, positionMintAddress, param, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, authority = FUNDER) {
  (0, import_assert3.default)(
    authority.address !== DEFAULT_ADDRESS,
    "Either supply the authority or set the default funder"
  );
  const positionAddress = await (0, import_whirlpools_client3.getPositionAddress)(positionMintAddress);
  const position = await (0, import_whirlpools_client3.fetchPosition)(rpc, positionAddress[0]);
  const whirlpool = await (0, import_whirlpools_client3.fetchWhirlpool)(rpc, position.data.whirlpool);
  const currentEpoch = await rpc.getEpochInfo().send();
  const [mintA, mintB, positionMint] = await (0, import_token_20223.fetchAllMint)(rpc, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB,
    positionMintAddress
  ]);
  const transferFeeA = getCurrentTransferFee(mintA, currentEpoch.epoch);
  const transferFeeB = getCurrentTransferFee(mintB, currentEpoch.epoch);
  const quote = getDecreaseLiquidityQuote(
    param,
    whirlpool.data,
    position.data,
    slippageToleranceBps,
    transferFeeA,
    transferFeeB
  );
  const instructions = [];
  const lowerTickArrayStartIndex = (0, import_whirlpools_core2.getTickArrayStartTickIndex)(
    position.data.tickLowerIndex,
    whirlpool.data.tickSpacing
  );
  const upperTickArrayStartIndex = (0, import_whirlpools_core2.getTickArrayStartTickIndex)(
    position.data.tickUpperIndex,
    whirlpool.data.tickSpacing
  );
  const [positionTokenAccount, tickArrayLower, tickArrayUpper] = await Promise.all([
    (0, import_token4.findAssociatedTokenPda)({
      owner: authority.address,
      mint: positionMintAddress,
      tokenProgram: positionMint.programAddress
    }).then((x) => x[0]),
    (0, import_whirlpools_client3.getTickArrayAddress)(whirlpool.address, lowerTickArrayStartIndex).then(
      (x) => x[0]
    ),
    (0, import_whirlpools_client3.getTickArrayAddress)(whirlpool.address, upperTickArrayStartIndex).then(
      (x) => x[0]
    )
  ]);
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(rpc, authority, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB
  ]);
  instructions.push(...createInstructions);
  instructions.push(
    (0, import_whirlpools_client3.getDecreaseLiquidityV2Instruction)({
      whirlpool: whirlpool.address,
      positionAuthority: authority,
      position: position.address,
      positionTokenAccount,
      tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
      tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
      tokenVaultA: whirlpool.data.tokenVaultA,
      tokenVaultB: whirlpool.data.tokenVaultB,
      tokenMintA: whirlpool.data.tokenMintA,
      tokenMintB: whirlpool.data.tokenMintB,
      tokenProgramA: mintA.programAddress,
      tokenProgramB: mintB.programAddress,
      memoProgram: import_memo.MEMO_PROGRAM_ADDRESS,
      tickArrayLower,
      tickArrayUpper,
      liquidityAmount: quote.liquidityDelta,
      tokenMinA: quote.tokenMinA,
      tokenMinB: quote.tokenMinB,
      remainingAccountsInfo: null
    })
  );
  instructions.push(...cleanupInstructions);
  return { quote, instructions };
}
async function closePositionInstructions(rpc, positionMintAddress, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, authority = FUNDER) {
  (0, import_assert3.default)(
    authority.address !== DEFAULT_ADDRESS,
    "Either supply an authority or set the default funder"
  );
  const positionAddress = await (0, import_whirlpools_client3.getPositionAddress)(positionMintAddress);
  const position = await (0, import_whirlpools_client3.fetchPosition)(rpc, positionAddress[0]);
  const whirlpool = await (0, import_whirlpools_client3.fetchWhirlpool)(rpc, position.data.whirlpool);
  const currentEpoch = await rpc.getEpochInfo().send();
  const [mintA, mintB, positionMint, ...rewardMints] = await (0, import_token_20223.fetchAllMaybeMint)(
    rpc,
    [
      whirlpool.data.tokenMintA,
      whirlpool.data.tokenMintB,
      positionMintAddress,
      ...whirlpool.data.rewardInfos.map((x) => x.mint).filter((x) => x !== DEFAULT_ADDRESS)
    ]
  );
  (0, import_assert3.default)(mintA.exists, "Token A not found");
  (0, import_assert3.default)(mintB.exists, "Token B not found");
  (0, import_assert3.default)(positionMint.exists, "Position mint not found");
  const transferFeeA = getCurrentTransferFee(mintA, currentEpoch.epoch);
  const transferFeeB = getCurrentTransferFee(mintB, currentEpoch.epoch);
  const quote = getDecreaseLiquidityQuote(
    { liquidity: position.data.liquidity },
    whirlpool.data,
    position.data,
    slippageToleranceBps,
    transferFeeA,
    transferFeeB
  );
  const lowerTickArrayStartIndex = (0, import_whirlpools_core2.getTickArrayStartTickIndex)(
    position.data.tickLowerIndex,
    whirlpool.data.tickSpacing
  );
  const upperTickArrayStartIndex = (0, import_whirlpools_core2.getTickArrayStartTickIndex)(
    position.data.tickUpperIndex,
    whirlpool.data.tickSpacing
  );
  const [positionTokenAccount, lowerTickArrayAddress, upperTickArrayAddress] = await Promise.all([
    (0, import_token4.findAssociatedTokenPda)({
      owner: authority.address,
      mint: positionMintAddress,
      tokenProgram: positionMint.programAddress
    }).then((x) => x[0]),
    (0, import_whirlpools_client3.getTickArrayAddress)(whirlpool.address, lowerTickArrayStartIndex).then(
      (x) => x[0]
    ),
    (0, import_whirlpools_client3.getTickArrayAddress)(whirlpool.address, upperTickArrayStartIndex).then(
      (x) => x[0]
    )
  ]);
  const [lowerTickArray, upperTickArray] = await (0, import_whirlpools_client3.fetchAllTickArray)(rpc, [
    lowerTickArrayAddress,
    upperTickArrayAddress
  ]);
  const lowerTick = lowerTickArray.data.ticks[(0, import_whirlpools_core2.getTickIndexInArray)(
    position.data.tickLowerIndex,
    lowerTickArrayStartIndex,
    whirlpool.data.tickSpacing
  )];
  const upperTick = upperTickArray.data.ticks[(0, import_whirlpools_core2.getTickIndexInArray)(
    position.data.tickUpperIndex,
    upperTickArrayStartIndex,
    whirlpool.data.tickSpacing
  )];
  const feesQuote = (0, import_whirlpools_core2.collectFeesQuote)(
    whirlpool.data,
    position.data,
    lowerTick,
    upperTick,
    transferFeeA,
    transferFeeB
  );
  const currentUnixTimestamp = BigInt(Math.floor(Date.now() / 1e3));
  const rewardsQuote = (0, import_whirlpools_core2.collectRewardsQuote)(
    whirlpool.data,
    position.data,
    lowerTick,
    upperTick,
    currentUnixTimestamp,
    getCurrentTransferFee(rewardMints[0], currentEpoch.epoch),
    getCurrentTransferFee(rewardMints[1], currentEpoch.epoch),
    getCurrentTransferFee(rewardMints[2], currentEpoch.epoch)
  );
  const requiredMints = /* @__PURE__ */ new Set();
  if (quote.liquidityDelta > 0n || feesQuote.feeOwedA > 0n || feesQuote.feeOwedB > 0n) {
    requiredMints.add(whirlpool.data.tokenMintA);
    requiredMints.add(whirlpool.data.tokenMintB);
  }
  for (let i = 0; i < rewardsQuote.rewards.length; i++) {
    if (rewardsQuote.rewards[i].rewardsOwed > 0n) {
      requiredMints.add(whirlpool.data.rewardInfos[i].mint);
    }
  }
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(
    rpc,
    authority,
    Array.from(requiredMints)
  );
  const instructions = [];
  instructions.push(...createInstructions);
  if (quote.liquidityDelta > 0n) {
    instructions.push(
      (0, import_whirlpools_client3.getDecreaseLiquidityV2Instruction)({
        whirlpool: whirlpool.address,
        positionAuthority: authority,
        position: positionAddress[0],
        positionTokenAccount,
        tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
        tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
        tokenVaultA: whirlpool.data.tokenVaultA,
        tokenVaultB: whirlpool.data.tokenVaultB,
        tickArrayLower: lowerTickArrayAddress,
        tickArrayUpper: upperTickArrayAddress,
        liquidityAmount: quote.liquidityDelta,
        tokenMinA: quote.tokenMinA,
        tokenMinB: quote.tokenMinB,
        tokenMintA: whirlpool.data.tokenMintA,
        tokenMintB: whirlpool.data.tokenMintB,
        tokenProgramA: mintA.programAddress,
        tokenProgramB: mintB.programAddress,
        memoProgram: import_memo.MEMO_PROGRAM_ADDRESS,
        remainingAccountsInfo: null
      })
    );
  }
  if (feesQuote.feeOwedA > 0n || feesQuote.feeOwedB > 0n) {
    instructions.push(
      (0, import_whirlpools_client3.getCollectFeesV2Instruction)({
        whirlpool: whirlpool.address,
        positionAuthority: authority,
        position: positionAddress[0],
        positionTokenAccount,
        tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
        tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
        tokenVaultA: whirlpool.data.tokenVaultA,
        tokenVaultB: whirlpool.data.tokenVaultB,
        tokenMintA: whirlpool.data.tokenMintA,
        tokenMintB: whirlpool.data.tokenMintB,
        tokenProgramA: mintA.programAddress,
        tokenProgramB: mintB.programAddress,
        memoProgram: import_memo.MEMO_PROGRAM_ADDRESS,
        remainingAccountsInfo: null
      })
    );
  }
  for (let i = 0; i < rewardsQuote.rewards.length; i++) {
    if (rewardsQuote.rewards[i].rewardsOwed === 0n) {
      continue;
    }
    const rewardMint = rewardMints[i];
    (0, import_assert3.default)(rewardMint.exists, `Reward mint ${i} not found`);
    instructions.push(
      (0, import_whirlpools_client3.getCollectRewardV2Instruction)({
        whirlpool: whirlpool.address,
        positionAuthority: authority,
        position: positionAddress[0],
        positionTokenAccount,
        rewardOwnerAccount: tokenAccountAddresses[rewardMint.address],
        rewardVault: whirlpool.data.rewardInfos[i].vault,
        rewardIndex: i,
        rewardMint: rewardMint.address,
        rewardTokenProgram: rewardMint.programAddress,
        memoProgram: import_memo.MEMO_PROGRAM_ADDRESS,
        remainingAccountsInfo: null
      })
    );
  }
  switch (positionMint.programAddress) {
    case import_token4.TOKEN_PROGRAM_ADDRESS:
      instructions.push(
        (0, import_whirlpools_client3.getClosePositionInstruction)({
          positionAuthority: authority,
          position: positionAddress[0],
          positionTokenAccount,
          positionMint: positionMintAddress,
          receiver: authority.address
        })
      );
      break;
    case import_token_20223.TOKEN_2022_PROGRAM_ADDRESS:
      instructions.push(
        (0, import_whirlpools_client3.getClosePositionWithTokenExtensionsInstruction)({
          positionAuthority: authority,
          position: positionAddress[0],
          positionTokenAccount,
          positionMint: positionMintAddress,
          receiver: authority.address,
          token2022Program: import_token_20223.TOKEN_2022_PROGRAM_ADDRESS
        })
      );
      break;
    default:
      throw new Error("Invalid token program");
  }
  instructions.push(...cleanupInstructions);
  return {
    instructions,
    quote,
    feesQuote,
    rewardsQuote
  };
}
var closePosition = wrapFunctionWithExecution(
  closePositionInstructions
);
var decreaseLiquidity = wrapFunctionWithExecution(
  decreaseLiquidityInstructions
);

// src/harvest.ts
var import_whirlpools_core4 = require("@orca-so/whirlpools-core");
var import_whirlpools_client5 = require("@orca-so/whirlpools-client");
var import_token7 = require("@solana-program/token");
var import_token_20225 = require("@solana-program/token-2022");
var import_memo2 = require("@solana-program/memo");
var import_assert4 = __toESM(require("assert"), 1);
var import_tx_sender3 = require("@orca-so/tx-sender");

// src/position.ts
var import_whirlpools_client4 = require("@orca-so/whirlpools-client");
var import_whirlpools_core3 = require("@orca-so/whirlpools-core");
var import_token6 = require("@solana-program/token");
var import_token_20224 = require("@solana-program/token-2022");
var import_kit6 = require("@solana/kit");

// src/utils.ts
var import_kit5 = require("@solana/kit");
var MAX_CHUNK_SIZE = 100;
async function fetchMultipleAccountsBatched(rpc, addresses, decoder) {
  const numChunks = Math.ceil(addresses.length / MAX_CHUNK_SIZE);
  const chunks = [...Array(numChunks).keys()].map(
    (i) => addresses.slice(i * MAX_CHUNK_SIZE, (i + 1) * MAX_CHUNK_SIZE)
  );
  const results = [];
  for (const chunk of chunks) {
    const chunkResult = await (0, import_kit5.fetchEncodedAccounts)(rpc, chunk);
    chunkResult.forEach((account, _) => {
      const data = decoder(account);
      results.push(data);
    });
  }
  return results;
}

// src/position.ts
function getPositionInBundleAddresses(positionBundle) {
  const buffer = Buffer.from(positionBundle.positionBitmap);
  const positions = [];
  for (let i = 0; i < (0, import_whirlpools_core3._POSITION_BUNDLE_SIZE)(); i++) {
    const byteIndex = Math.floor(i / 8);
    const bitIndex = i % 8;
    if (buffer[byteIndex] & 1 << bitIndex) {
      positions.push(
        (0, import_whirlpools_client4.getBundledPositionAddress)(positionBundle.positionBundleMint, i).then(
          (x) => x[0]
        )
      );
    }
  }
  return positions;
}
async function fetchPositionsForOwner(rpc, owner) {
  const [tokenAccounts, token2022Accounts] = await Promise.all([
    rpc.getTokenAccountsByOwner(
      owner,
      { programId: import_token6.TOKEN_PROGRAM_ADDRESS },
      { encoding: "base64" }
    ).send(),
    rpc.getTokenAccountsByOwner(
      owner,
      { programId: import_token_20224.TOKEN_2022_PROGRAM_ADDRESS },
      { encoding: "base64" }
    ).send()
  ]);
  const encoder = (0, import_kit6.getBase64Encoder)();
  const decoder = (0, import_token6.getTokenDecoder)();
  const potentialTokens = [...tokenAccounts.value, ...token2022Accounts.value].map((x) => ({
    ...decoder.decode(encoder.encode(x.account.data[0])),
    tokenProgram: x.account.owner
  })).filter((x) => x.amount === 1n);
  const positionAddresses = await Promise.all(
    potentialTokens.map((x) => (0, import_whirlpools_client4.getPositionAddress)(x.mint).then((x2) => x2[0]))
  );
  const positionBundleAddresses = await Promise.all(
    potentialTokens.map(
      (x) => (0, import_whirlpools_client4.getPositionBundleAddress)(x.mint).then((x2) => x2[0])
    )
  );
  const positions = await fetchMultipleAccountsBatched(
    rpc,
    positionAddresses,
    import_whirlpools_client4.decodePosition
  );
  const positionBundles = await fetchMultipleAccountsBatched(
    rpc,
    positionBundleAddresses,
    import_whirlpools_client4.decodePositionBundle
  );
  const bundledPositionAddresses = await Promise.all(
    positionBundles.filter((x) => x.exists).flatMap((x) => getPositionInBundleAddresses(x.data))
  );
  const bundledPositions = (await fetchMultipleAccountsBatched(
    rpc,
    bundledPositionAddresses,
    import_whirlpools_client4.decodePosition
  )).filter((x) => x.exists).map((x) => {
    (0, import_kit6.assertAccountExists)(x);
    return x;
  });
  const bundledPositionMap = bundledPositions.reduce((acc, x) => {
    const current = acc.get(x.data.positionMint) ?? [];
    return acc.set(x.data.positionMint, [...current, x]);
  }, /* @__PURE__ */ new Map());
  const positionsOrBundles = [];
  for (let i = 0; i < potentialTokens.length; i++) {
    const position = positions[i];
    const positionBundle = positionBundles[i];
    const token = potentialTokens[i];
    if (position.exists) {
      positionsOrBundles.push({
        ...position,
        tokenProgram: token.tokenProgram,
        isPositionBundle: false
      });
    }
    if (positionBundle.exists) {
      const positions2 = bundledPositionMap.get(positionBundle.data.positionBundleMint) ?? [];
      positionsOrBundles.push({
        ...positionBundle,
        positions: positions2,
        tokenProgram: token.tokenProgram,
        isPositionBundle: true
      });
    }
  }
  return positionsOrBundles;
}
async function fetchPositionsInWhirlpool(rpc, whirlpool) {
  const positions = await (0, import_whirlpools_client4.fetchAllPositionWithFilter)(
    rpc,
    (0, import_whirlpools_client4.positionWhirlpoolFilter)(whirlpool)
  );
  return positions.map((x) => ({
    ...x,
    isPositionBundle: false
  }));
}

// src/harvest.ts
async function harvestPositionInstructions(rpc, positionMintAddress, authority = FUNDER) {
  (0, import_assert4.default)(
    authority.address !== DEFAULT_ADDRESS,
    "Either supply an authority or set the default funder"
  );
  const currentEpoch = await rpc.getEpochInfo().send();
  const positionAddress = await (0, import_whirlpools_client5.getPositionAddress)(positionMintAddress);
  const position = await (0, import_whirlpools_client5.fetchPosition)(rpc, positionAddress[0]);
  const whirlpool = await (0, import_whirlpools_client5.fetchWhirlpool)(rpc, position.data.whirlpool);
  const [mintA, mintB, positionMint, ...rewardMints] = await (0, import_token_20225.fetchAllMaybeMint)(
    rpc,
    [
      whirlpool.data.tokenMintA,
      whirlpool.data.tokenMintB,
      positionMintAddress,
      ...whirlpool.data.rewardInfos.map((x) => x.mint).filter((x) => x !== DEFAULT_ADDRESS)
    ]
  );
  (0, import_assert4.default)(mintA.exists, "Token A not found");
  (0, import_assert4.default)(mintB.exists, "Token B not found");
  (0, import_assert4.default)(positionMint.exists, "Position mint not found");
  const lowerTickArrayStartIndex = (0, import_whirlpools_core4.getTickArrayStartTickIndex)(
    position.data.tickLowerIndex,
    whirlpool.data.tickSpacing
  );
  const upperTickArrayStartIndex = (0, import_whirlpools_core4.getTickArrayStartTickIndex)(
    position.data.tickUpperIndex,
    whirlpool.data.tickSpacing
  );
  const [positionTokenAccount, lowerTickArrayAddress, upperTickArrayAddress] = await Promise.all([
    (0, import_token7.findAssociatedTokenPda)({
      owner: authority.address,
      mint: positionMintAddress,
      tokenProgram: positionMint.programAddress
    }).then((x) => x[0]),
    (0, import_whirlpools_client5.getTickArrayAddress)(whirlpool.address, lowerTickArrayStartIndex).then(
      (x) => x[0]
    ),
    (0, import_whirlpools_client5.getTickArrayAddress)(whirlpool.address, upperTickArrayStartIndex).then(
      (x) => x[0]
    )
  ]);
  const [lowerTickArray, upperTickArray] = await (0, import_whirlpools_client5.fetchAllTickArray)(rpc, [
    lowerTickArrayAddress,
    upperTickArrayAddress
  ]);
  const lowerTick = lowerTickArray.data.ticks[(0, import_whirlpools_core4.getTickIndexInArray)(
    position.data.tickLowerIndex,
    lowerTickArrayStartIndex,
    whirlpool.data.tickSpacing
  )];
  const upperTick = upperTickArray.data.ticks[(0, import_whirlpools_core4.getTickIndexInArray)(
    position.data.tickUpperIndex,
    upperTickArrayStartIndex,
    whirlpool.data.tickSpacing
  )];
  const feesQuote = (0, import_whirlpools_core4.collectFeesQuote)(
    whirlpool.data,
    position.data,
    lowerTick,
    upperTick,
    getCurrentTransferFee(mintA, currentEpoch.epoch),
    getCurrentTransferFee(mintB, currentEpoch.epoch)
  );
  const currentUnixTimestamp = BigInt(Math.floor(Date.now() / 1e3));
  const rewardsQuote = (0, import_whirlpools_core4.collectRewardsQuote)(
    whirlpool.data,
    position.data,
    lowerTick,
    upperTick,
    currentUnixTimestamp,
    getCurrentTransferFee(rewardMints[0], currentEpoch.epoch),
    getCurrentTransferFee(rewardMints[1], currentEpoch.epoch),
    getCurrentTransferFee(rewardMints[2], currentEpoch.epoch)
  );
  const requiredMints = /* @__PURE__ */ new Set();
  if (feesQuote.feeOwedA > 0n || feesQuote.feeOwedB > 0n) {
    requiredMints.add(whirlpool.data.tokenMintA);
    requiredMints.add(whirlpool.data.tokenMintB);
  }
  for (let i = 0; i < rewardsQuote.rewards.length; i++) {
    if (rewardsQuote.rewards[i].rewardsOwed > 0n) {
      requiredMints.add(whirlpool.data.rewardInfos[i].mint);
    }
  }
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(
    rpc,
    authority,
    Array.from(requiredMints)
  );
  const instructions = [];
  instructions.push(...createInstructions);
  if (position.data.liquidity > 0n) {
    instructions.push(
      (0, import_whirlpools_client5.getUpdateFeesAndRewardsInstruction)({
        whirlpool: whirlpool.address,
        position: positionAddress[0],
        tickArrayLower: lowerTickArrayAddress,
        tickArrayUpper: upperTickArrayAddress
      })
    );
  }
  if (feesQuote.feeOwedA > 0n || feesQuote.feeOwedB > 0n) {
    instructions.push(
      (0, import_whirlpools_client5.getCollectFeesV2Instruction)({
        whirlpool: whirlpool.address,
        positionAuthority: authority,
        position: positionAddress[0],
        positionTokenAccount,
        tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
        tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
        tokenVaultA: whirlpool.data.tokenVaultA,
        tokenVaultB: whirlpool.data.tokenVaultB,
        tokenMintA: whirlpool.data.tokenMintA,
        tokenMintB: whirlpool.data.tokenMintB,
        tokenProgramA: mintA.programAddress,
        tokenProgramB: mintB.programAddress,
        memoProgram: import_memo2.MEMO_PROGRAM_ADDRESS,
        remainingAccountsInfo: null
      })
    );
  }
  for (let i = 0; i < rewardsQuote.rewards.length; i++) {
    if (rewardsQuote.rewards[i].rewardsOwed === 0n) {
      continue;
    }
    const rewardMint = rewardMints[i];
    (0, import_assert4.default)(rewardMint.exists, `Reward mint ${i} not found`);
    instructions.push(
      (0, import_whirlpools_client5.getCollectRewardV2Instruction)({
        whirlpool: whirlpool.address,
        positionAuthority: authority,
        position: positionAddress[0],
        positionTokenAccount,
        rewardOwnerAccount: tokenAccountAddresses[rewardMint.address],
        rewardVault: whirlpool.data.rewardInfos[i].vault,
        rewardIndex: i,
        rewardMint: rewardMint.address,
        rewardTokenProgram: rewardMint.programAddress,
        memoProgram: import_memo2.MEMO_PROGRAM_ADDRESS,
        remainingAccountsInfo: null
      })
    );
  }
  instructions.push(...cleanupInstructions);
  return {
    feesQuote,
    rewardsQuote,
    instructions
  };
}
var harvestPosition = wrapFunctionWithExecution(
  harvestPositionInstructions
);
async function harvestAllPositionFees() {
  const { rpcUrl } = (0, import_tx_sender.getRpcConfig)();
  const rpc = (0, import_tx_sender3.rpcFromUrl)(rpcUrl);
  const owner = getPayer();
  const positions = await fetchPositionsForOwner(rpc, owner.address);
  const instructionSets = [];
  let currentInstructions = [];
  for (const position of positions) {
    if ("positionMint" in position.data) {
      const { instructions } = await harvestPositionInstructions(
        rpc,
        position.data.positionMint,
        owner
      );
      if (await wouldExceedTransactionSize(currentInstructions, instructions)) {
        instructionSets.push(currentInstructions);
        currentInstructions = [...instructions];
      } else {
        currentInstructions.push(...instructions);
      }
    }
  }
  return Promise.all(
    instructionSets.map(async (instructions) => {
      let txHash = await (0, import_tx_sender3.buildAndSendTransaction)(instructions, owner);
      return txHash;
    })
  );
}

// src/increaseLiquidity.ts
var import_whirlpools_client6 = require("@orca-so/whirlpools-client");
var import_whirlpools_core5 = require("@orca-so/whirlpools-core");
var import_kit7 = require("@solana/kit");
var import_sysvars2 = require("@solana/sysvars");
var import_token9 = require("@solana-program/token");
var import_token_20226 = require("@solana-program/token-2022");
var import_memo3 = require("@solana-program/memo");
var import_assert5 = __toESM(require("assert"), 1);
function getIncreaseLiquidityQuote(param, pool, tickLowerIndex, tickUpperIndex, slippageToleranceBps, transferFeeA, transferFeeB) {
  if ("liquidity" in param) {
    return (0, import_whirlpools_core5.increaseLiquidityQuote)(
      param.liquidity,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickLowerIndex,
      tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  } else if ("tokenA" in param) {
    return (0, import_whirlpools_core5.increaseLiquidityQuoteA)(
      param.tokenA,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickLowerIndex,
      tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  } else {
    return (0, import_whirlpools_core5.increaseLiquidityQuoteB)(
      param.tokenB,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickLowerIndex,
      tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  }
}
async function increaseLiquidityInstructions(rpc, positionMintAddress, param, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, authority = FUNDER) {
  (0, import_assert5.default)(
    authority.address !== DEFAULT_ADDRESS,
    "Either supply the authority or set the default funder"
  );
  const positionAddress = await (0, import_whirlpools_client6.getPositionAddress)(positionMintAddress);
  const position = await (0, import_whirlpools_client6.fetchPosition)(rpc, positionAddress[0]);
  const whirlpool = await (0, import_whirlpools_client6.fetchWhirlpool)(rpc, position.data.whirlpool);
  const currentEpoch = await rpc.getEpochInfo().send();
  const [mintA, mintB, positionMint] = await (0, import_token_20226.fetchAllMint)(rpc, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB,
    positionMintAddress
  ]);
  const transferFeeA = getCurrentTransferFee(mintA, currentEpoch.epoch);
  const transferFeeB = getCurrentTransferFee(mintB, currentEpoch.epoch);
  const quote = getIncreaseLiquidityQuote(
    param,
    whirlpool.data,
    position.data.tickLowerIndex,
    position.data.tickUpperIndex,
    slippageToleranceBps,
    transferFeeA,
    transferFeeB
  );
  const instructions = [];
  const lowerTickArrayStartIndex = (0, import_whirlpools_core5.getTickArrayStartTickIndex)(
    position.data.tickLowerIndex,
    whirlpool.data.tickSpacing
  );
  const upperTickArrayStartIndex = (0, import_whirlpools_core5.getTickArrayStartTickIndex)(
    position.data.tickUpperIndex,
    whirlpool.data.tickSpacing
  );
  const [positionTokenAccount, tickArrayLower, tickArrayUpper] = await Promise.all([
    (0, import_token9.findAssociatedTokenPda)({
      owner: authority.address,
      mint: positionMintAddress,
      tokenProgram: positionMint.programAddress
    }).then((x) => x[0]),
    (0, import_whirlpools_client6.getTickArrayAddress)(whirlpool.address, lowerTickArrayStartIndex).then(
      (x) => x[0]
    ),
    (0, import_whirlpools_client6.getTickArrayAddress)(whirlpool.address, upperTickArrayStartIndex).then(
      (x) => x[0]
    )
  ]);
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(rpc, authority, {
    [whirlpool.data.tokenMintA]: quote.tokenMaxA,
    [whirlpool.data.tokenMintB]: quote.tokenMaxB
  });
  instructions.push(...createInstructions);
  instructions.push(
    (0, import_whirlpools_client6.getIncreaseLiquidityV2Instruction)({
      whirlpool: whirlpool.address,
      positionAuthority: authority,
      position: position.address,
      positionTokenAccount,
      tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
      tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
      tokenVaultA: whirlpool.data.tokenVaultA,
      tokenVaultB: whirlpool.data.tokenVaultB,
      tokenMintA: whirlpool.data.tokenMintA,
      tokenMintB: whirlpool.data.tokenMintB,
      tokenProgramA: mintA.programAddress,
      tokenProgramB: mintB.programAddress,
      tickArrayLower,
      tickArrayUpper,
      liquidityAmount: quote.liquidityDelta,
      tokenMaxA: quote.tokenMaxA,
      tokenMaxB: quote.tokenMaxB,
      memoProgram: import_memo3.MEMO_PROGRAM_ADDRESS,
      remainingAccountsInfo: null
    })
  );
  instructions.push(...cleanupInstructions);
  return {
    quote,
    instructions
  };
}
async function internalOpenPositionInstructions(rpc, whirlpool, param, lowerTickIndex, upperTickIndex, mintA, mintB, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, funder = FUNDER) {
  (0, import_assert5.default)(
    funder.address !== DEFAULT_ADDRESS,
    "Either supply a funder or set the default funder"
  );
  const instructions = [];
  const rent = await (0, import_sysvars2.fetchSysvarRent)(rpc);
  let nonRefundableRent = 0n;
  const tickRange = (0, import_whirlpools_core5.orderTickIndexes)(lowerTickIndex, upperTickIndex);
  const initializableLowerTickIndex = (0, import_whirlpools_core5.getInitializableTickIndex)(
    tickRange.tickLowerIndex,
    whirlpool.data.tickSpacing,
    false
  );
  const initializableUpperTickIndex = (0, import_whirlpools_core5.getInitializableTickIndex)(
    tickRange.tickUpperIndex,
    whirlpool.data.tickSpacing,
    true
  );
  const currentEpoch = await rpc.getEpochInfo().send();
  const transferFeeA = getCurrentTransferFee(mintA, currentEpoch.epoch);
  const transferFeeB = getCurrentTransferFee(mintB, currentEpoch.epoch);
  const quote = getIncreaseLiquidityQuote(
    param,
    whirlpool.data,
    initializableLowerTickIndex,
    initializableUpperTickIndex,
    slippageToleranceBps,
    transferFeeA,
    transferFeeB
  );
  const positionMint = await (0, import_kit7.generateKeyPairSigner)();
  const lowerTickArrayIndex = (0, import_whirlpools_core5.getTickArrayStartTickIndex)(
    initializableLowerTickIndex,
    whirlpool.data.tickSpacing
  );
  const upperTickArrayIndex = (0, import_whirlpools_core5.getTickArrayStartTickIndex)(
    initializableUpperTickIndex,
    whirlpool.data.tickSpacing
  );
  const [
    positionAddress,
    positionTokenAccount,
    lowerTickArrayAddress,
    upperTickArrayAddress
  ] = await Promise.all([
    (0, import_whirlpools_client6.getPositionAddress)(positionMint.address),
    (0, import_token9.findAssociatedTokenPda)({
      owner: funder.address,
      mint: positionMint.address,
      tokenProgram: import_token_20226.TOKEN_2022_PROGRAM_ADDRESS
    }).then((x) => x[0]),
    (0, import_whirlpools_client6.getTickArrayAddress)(whirlpool.address, lowerTickArrayIndex).then(
      (x) => x[0]
    ),
    (0, import_whirlpools_client6.getTickArrayAddress)(whirlpool.address, upperTickArrayIndex).then(
      (x) => x[0]
    )
  ]);
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(rpc, funder, {
    [whirlpool.data.tokenMintA]: quote.tokenMaxA,
    [whirlpool.data.tokenMintB]: quote.tokenMaxB
  });
  instructions.push(...createInstructions);
  const [lowerTickArray, upperTickArray] = await (0, import_whirlpools_client6.fetchAllMaybeTickArray)(rpc, [
    lowerTickArrayAddress,
    upperTickArrayAddress
  ]);
  if (!lowerTickArray.exists) {
    instructions.push(
      (0, import_whirlpools_client6.getInitializeTickArrayInstruction)({
        whirlpool: whirlpool.address,
        funder,
        tickArray: lowerTickArrayAddress,
        startTickIndex: lowerTickArrayIndex
      })
    );
    nonRefundableRent += calculateMinimumBalanceForRentExemption(
      rent,
      (0, import_whirlpools_client6.getTickArraySize)()
    );
  }
  if (!upperTickArray.exists && lowerTickArrayIndex !== upperTickArrayIndex) {
    instructions.push(
      (0, import_whirlpools_client6.getInitializeTickArrayInstruction)({
        whirlpool: whirlpool.address,
        funder,
        tickArray: upperTickArrayAddress,
        startTickIndex: upperTickArrayIndex
      })
    );
    nonRefundableRent += calculateMinimumBalanceForRentExemption(
      rent,
      (0, import_whirlpools_client6.getTickArraySize)()
    );
  }
  instructions.push(
    (0, import_whirlpools_client6.getOpenPositionWithTokenExtensionsInstruction)({
      funder,
      owner: funder.address,
      position: positionAddress[0],
      positionMint,
      positionTokenAccount,
      whirlpool: whirlpool.address,
      associatedTokenProgram: import_token9.ASSOCIATED_TOKEN_PROGRAM_ADDRESS,
      tickLowerIndex: initializableLowerTickIndex,
      tickUpperIndex: initializableUpperTickIndex,
      token2022Program: import_token_20226.TOKEN_2022_PROGRAM_ADDRESS,
      metadataUpdateAuth: (0, import_kit7.address)(
        "3axbTs2z5GBy6usVbNVoqEgZMng3vZvMnAoX29BFfwhr"
      ),
      withTokenMetadataExtension: true
    })
  );
  instructions.push(
    (0, import_whirlpools_client6.getIncreaseLiquidityV2Instruction)({
      whirlpool: whirlpool.address,
      positionAuthority: funder,
      position: positionAddress[0],
      positionTokenAccount,
      tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
      tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
      tokenVaultA: whirlpool.data.tokenVaultA,
      tokenVaultB: whirlpool.data.tokenVaultB,
      tokenMintA: whirlpool.data.tokenMintA,
      tokenMintB: whirlpool.data.tokenMintB,
      tokenProgramA: mintA.programAddress,
      tokenProgramB: mintB.programAddress,
      tickArrayLower: lowerTickArrayAddress,
      tickArrayUpper: upperTickArrayAddress,
      liquidityAmount: quote.liquidityDelta,
      tokenMaxA: quote.tokenMaxA,
      tokenMaxB: quote.tokenMaxB,
      memoProgram: import_memo3.MEMO_PROGRAM_ADDRESS,
      remainingAccountsInfo: null
    })
  );
  instructions.push(...cleanupInstructions);
  return {
    instructions,
    quote,
    positionMint: positionMint.address,
    initializationCost: (0, import_kit7.lamports)(nonRefundableRent)
  };
}
async function openFullRangePositionInstructions(rpc, poolAddress, param, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, funder = FUNDER) {
  const whirlpool = await (0, import_whirlpools_client6.fetchWhirlpool)(rpc, poolAddress);
  const tickRange = (0, import_whirlpools_core5.getFullRangeTickIndexes)(whirlpool.data.tickSpacing);
  const [mintA, mintB] = await (0, import_token_20226.fetchAllMint)(rpc, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB
  ]);
  return internalOpenPositionInstructions(
    rpc,
    whirlpool,
    param,
    tickRange.tickLowerIndex,
    tickRange.tickUpperIndex,
    mintA,
    mintB,
    slippageToleranceBps,
    funder
  );
}
async function openPositionInstructions(rpc, poolAddress, param, lowerPrice, upperPrice, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, funder = FUNDER) {
  const whirlpool = await (0, import_whirlpools_client6.fetchWhirlpool)(rpc, poolAddress);
  (0, import_assert5.default)(
    whirlpool.data.tickSpacing !== SPLASH_POOL_TICK_SPACING,
    "Splash pools only support full range positions"
  );
  const [mintA, mintB] = await (0, import_token_20226.fetchAllMint)(rpc, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB
  ]);
  const decimalsA = mintA.data.decimals;
  const decimalsB = mintB.data.decimals;
  const lowerTickIndex = (0, import_whirlpools_core5.priceToTickIndex)(lowerPrice, decimalsA, decimalsB);
  const upperTickIndex = (0, import_whirlpools_core5.priceToTickIndex)(upperPrice, decimalsA, decimalsB);
  return internalOpenPositionInstructions(
    rpc,
    whirlpool,
    param,
    lowerTickIndex,
    upperTickIndex,
    mintA,
    mintB,
    slippageToleranceBps,
    funder
  );
}
var increasePosLiquidity = wrapFunctionWithExecution(
  increaseLiquidityInstructions
);
var openFullRangePosition = wrapFunctionWithExecution(
  openFullRangePositionInstructions
);
var openConcentratedPosition = wrapFunctionWithExecution(
  openPositionInstructions
);

// src/pool.ts
var import_whirlpools_client7 = require("@orca-so/whirlpools-client");
var import_whirlpools_core6 = require("@orca-so/whirlpools-core");
var import_token12 = require("@solana-program/token");
async function fetchSplashPool(rpc, tokenMintOne, tokenMintTwo) {
  return fetchConcentratedLiquidityPool(
    rpc,
    tokenMintOne,
    tokenMintTwo,
    SPLASH_POOL_TICK_SPACING
  );
}
async function fetchConcentratedLiquidityPool(rpc, tokenMintOne, tokenMintTwo, tickSpacing) {
  const [tokenMintA, tokenMintB] = orderMints(tokenMintOne, tokenMintTwo);
  const feeTierAddress = await (0, import_whirlpools_client7.getFeeTierAddress)(
    WHIRLPOOLS_CONFIG_ADDRESS,
    tickSpacing
  ).then((x) => x[0]);
  const poolAddress = await (0, import_whirlpools_client7.getWhirlpoolAddress)(
    WHIRLPOOLS_CONFIG_ADDRESS,
    tokenMintA,
    tokenMintB,
    tickSpacing
  ).then((x) => x[0]);
  const [configAccount, feeTierAccount, poolAccount] = await Promise.all([
    (0, import_whirlpools_client7.fetchWhirlpoolsConfig)(rpc, WHIRLPOOLS_CONFIG_ADDRESS),
    (0, import_whirlpools_client7.fetchFeeTier)(rpc, feeTierAddress),
    (0, import_whirlpools_client7.fetchMaybeWhirlpool)(rpc, poolAddress)
  ]);
  const [mintA, mintB] = await (0, import_token12.fetchAllMint)(rpc, [tokenMintA, tokenMintB]);
  if (poolAccount.exists) {
    const poolPrice = (0, import_whirlpools_core6.sqrtPriceToPrice)(
      poolAccount.data.sqrtPrice,
      mintA.data.decimals,
      mintB.data.decimals
    );
    return {
      initialized: true,
      address: poolAddress,
      price: poolPrice,
      ...poolAccount.data
    };
  } else {
    return {
      initialized: false,
      address: poolAddress,
      whirlpoolsConfig: WHIRLPOOLS_CONFIG_ADDRESS,
      tickSpacing,
      feeRate: feeTierAccount.data.defaultFeeRate,
      protocolFeeRate: configAccount.data.defaultProtocolFeeRate,
      tokenMintA,
      tokenMintB
    };
  }
}
async function fetchWhirlpoolsByTokenPair(rpc, tokenMintOne, tokenMintTwo) {
  const [tokenMintA, tokenMintB] = orderMints(tokenMintOne, tokenMintTwo);
  const feeTierAccounts = await (0, import_whirlpools_client7.fetchAllFeeTierWithFilter)(
    rpc,
    (0, import_whirlpools_client7.feeTierWhirlpoolsConfigFilter)(WHIRLPOOLS_CONFIG_ADDRESS)
  );
  const supportedTickSpacings = feeTierAccounts.map((x) => x.data.tickSpacing);
  const poolAddresses = await Promise.all(
    supportedTickSpacings.map(
      (x) => (0, import_whirlpools_client7.getWhirlpoolAddress)(
        WHIRLPOOLS_CONFIG_ADDRESS,
        tokenMintA,
        tokenMintB,
        x
      ).then((x2) => x2[0])
    )
  );
  const [configAccount, poolAccounts] = await Promise.all([
    (0, import_whirlpools_client7.fetchWhirlpoolsConfig)(rpc, WHIRLPOOLS_CONFIG_ADDRESS),
    (0, import_whirlpools_client7.fetchAllMaybeWhirlpool)(rpc, poolAddresses)
  ]);
  const [mintA, mintB] = await (0, import_token12.fetchAllMint)(rpc, [tokenMintA, tokenMintB]);
  const pools = [];
  for (let i = 0; i < supportedTickSpacings.length; i++) {
    const tickSpacing = supportedTickSpacings[i];
    const feeTierAccount = feeTierAccounts[i];
    const poolAccount = poolAccounts[i];
    const poolAddress = poolAddresses[i];
    if (poolAccount.exists) {
      const poolPrice = (0, import_whirlpools_core6.sqrtPriceToPrice)(
        poolAccount.data.sqrtPrice,
        mintA.data.decimals,
        mintB.data.decimals
      );
      pools.push({
        initialized: true,
        address: poolAddress,
        price: poolPrice,
        ...poolAccount.data
      });
    } else {
      pools.push({
        initialized: false,
        address: poolAddress,
        whirlpoolsConfig: WHIRLPOOLS_CONFIG_ADDRESS,
        tickSpacing,
        feeRate: feeTierAccount.data.defaultFeeRate,
        protocolFeeRate: configAccount.data.defaultProtocolFeeRate,
        tokenMintA,
        tokenMintB
      });
    }
  }
  return pools;
}

// src/swap.ts
var import_kit8 = require("@solana/kit");
var import_whirlpools_core7 = require("@orca-so/whirlpools-core");
var import_whirlpools_client8 = require("@orca-so/whirlpools-client");
var import_memo4 = require("@solana-program/memo");
var import_token_20227 = require("@solana-program/token-2022");
function createUninitializedTickArray(address5, startTickIndex, programAddress) {
  return {
    address: address5,
    data: {
      startTickIndex,
      ticks: Array((0, import_whirlpools_core7._TICK_ARRAY_SIZE)()).fill({
        initialized: false,
        liquidityNet: 0n,
        liquidityGross: 0n,
        feeGrowthOutsideA: 0n,
        feeGrowthOutsideB: 0n,
        rewardGrowthsOutside: [0n, 0n, 0n]
      })
    },
    space: 0n,
    executable: false,
    lamports: (0, import_kit8.lamports)(0n),
    programAddress
  };
}
async function fetchTickArrayOrDefault(rpc, whirlpool) {
  const tickArrayStartIndex = (0, import_whirlpools_core7.getTickArrayStartTickIndex)(
    whirlpool.data.tickCurrentIndex,
    whirlpool.data.tickSpacing
  );
  const offset = whirlpool.data.tickSpacing * (0, import_whirlpools_core7._TICK_ARRAY_SIZE)();
  const tickArrayIndexes = [
    tickArrayStartIndex,
    tickArrayStartIndex + offset,
    tickArrayStartIndex + offset * 2,
    tickArrayStartIndex - offset,
    tickArrayStartIndex - offset * 2
  ];
  const tickArrayAddresses = await Promise.all(
    tickArrayIndexes.map(
      (startIndex) => (0, import_whirlpools_client8.getTickArrayAddress)(whirlpool.address, startIndex).then((x) => x[0])
    )
  );
  const maybeTickArrays = await (0, import_whirlpools_client8.fetchAllMaybeTickArray)(rpc, tickArrayAddresses);
  const tickArrays = [];
  for (let i = 0; i < maybeTickArrays.length; i++) {
    const maybeTickArray = maybeTickArrays[i];
    if (maybeTickArray.exists) {
      tickArrays.push(maybeTickArray);
    } else {
      tickArrays.push(
        createUninitializedTickArray(
          tickArrayAddresses[i],
          tickArrayIndexes[i],
          whirlpool.programAddress
        )
      );
    }
  }
  return tickArrays;
}
async function getOracle(rpc, oracleAddress, whirlpool) {
  const feeTierIndex = whirlpool.feeTierIndexSeed[0] + whirlpool.feeTierIndexSeed[1] * 256;
  if (whirlpool.tickSpacing == feeTierIndex) {
    return void 0;
  }
  return (await (0, import_whirlpools_client8.fetchOracle)(rpc, oracleAddress)).data;
}
function getSwapQuote(params, whirlpool, transferFeeA, transferFeeB, tickArrays, oracle, specifiedTokenA, slippageToleranceBps, timestamp) {
  if ("inputAmount" in params) {
    return (0, import_whirlpools_core7.swapQuoteByInputToken)(
      params.inputAmount,
      specifiedTokenA,
      slippageToleranceBps,
      whirlpool,
      oracle,
      tickArrays,
      timestamp,
      transferFeeA,
      transferFeeB
    );
  }
  return (0, import_whirlpools_core7.swapQuoteByOutputToken)(
    params.outputAmount,
    specifiedTokenA,
    slippageToleranceBps,
    whirlpool,
    oracle,
    tickArrays,
    timestamp,
    transferFeeA,
    transferFeeB
  );
}
async function swapInstructions(rpc, params, poolAddress, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, signer = FUNDER) {
  const whirlpool = await (0, import_whirlpools_client8.fetchWhirlpool)(rpc, poolAddress);
  const [tokenA, tokenB] = await (0, import_token_20227.fetchAllMint)(rpc, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB
  ]);
  const specifiedTokenA = params.mint === whirlpool.data.tokenMintA;
  const specifiedInput = "inputAmount" in params;
  const tickArrays = await fetchTickArrayOrDefault(rpc, whirlpool);
  const oracleAddress = await (0, import_whirlpools_client8.getOracleAddress)(whirlpool.address).then(
    (x) => x[0]
  );
  const oracle = await getOracle(rpc, oracleAddress, whirlpool.data);
  const currentEpoch = await rpc.getEpochInfo().send();
  const transferFeeA = getCurrentTransferFee(tokenA, currentEpoch.epoch);
  const transferFeeB = getCurrentTransferFee(tokenB, currentEpoch.epoch);
  const timestamp = BigInt(Math.floor(Date.now() / 1e3));
  const tradeEnableTimestamp = oracle?.tradeEnableTimestamp ?? 0n;
  const quote = getSwapQuote(
    params,
    whirlpool.data,
    transferFeeA,
    transferFeeB,
    tickArrays.map((x) => x.data),
    oracle,
    specifiedTokenA,
    slippageToleranceBps,
    timestamp
  );
  const maxInAmount = "tokenIn" in quote ? quote.tokenIn : quote.tokenMaxIn;
  const aToB = specifiedTokenA === specifiedInput;
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(rpc, signer, {
    [whirlpool.data.tokenMintA]: aToB ? maxInAmount : 0n,
    [whirlpool.data.tokenMintB]: aToB ? 0n : maxInAmount
  });
  const instructions = [];
  instructions.push(...createInstructions);
  const specifiedAmount = "inputAmount" in params ? params.inputAmount : params.outputAmount;
  const otherAmountThreshold = "tokenMaxIn" in quote ? quote.tokenMaxIn : quote.tokenMinOut;
  const swapInstruction = (0, import_whirlpools_client8.getSwapV2Instruction)({
    tokenProgramA: tokenA.programAddress,
    tokenProgramB: tokenB.programAddress,
    memoProgram: import_memo4.MEMO_PROGRAM_ADDRESS,
    tokenAuthority: signer,
    whirlpool: whirlpool.address,
    tokenMintA: whirlpool.data.tokenMintA,
    tokenMintB: whirlpool.data.tokenMintB,
    tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
    tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
    tokenVaultA: whirlpool.data.tokenVaultA,
    tokenVaultB: whirlpool.data.tokenVaultB,
    tickArray0: tickArrays[0].address,
    tickArray1: tickArrays[1].address,
    tickArray2: tickArrays[2].address,
    amount: specifiedAmount,
    otherAmountThreshold,
    sqrtPriceLimit: 0,
    amountSpecifiedIsInput: specifiedInput,
    aToB,
    oracle: oracleAddress,
    remainingAccountsInfo: {
      slices: [
        { accountsType: import_whirlpools_client8.AccountsType.SupplementalTickArrays, length: 2 }
      ]
    }
  });
  swapInstruction.accounts.push(
    { address: tickArrays[3].address, role: import_kit8.AccountRole.WRITABLE },
    { address: tickArrays[4].address, role: import_kit8.AccountRole.WRITABLE }
  );
  instructions.push(swapInstruction);
  instructions.push(...cleanupInstructions);
  return {
    quote,
    instructions,
    tradeEnableTimestamp
  };
}
var swap = wrapFunctionWithExecution(swapInstructions);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DEFAULT_ADDRESS,
  DEFAULT_ENFORCE_TOKEN_BALANCE_CHECK,
  DEFAULT_FUNDER,
  DEFAULT_NATIVE_MINT_WRAPPING_STRATEGY,
  DEFAULT_SLIPPAGE_TOLERANCE_BPS,
  DEFAULT_WHIRLPOOLS_CONFIG_ADDRESSES,
  DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS,
  ENFORCE_TOKEN_BALANCE_CHECK,
  FUNDER,
  NATIVE_MINT_WRAPPING_STRATEGY,
  SLIPPAGE_TOLERANCE_BPS,
  SPLASH_POOL_TICK_SPACING,
  WHIRLPOOLS_CONFIG_ADDRESS,
  WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS,
  closePosition,
  closePositionInstructions,
  createConcentratedLiquidityPool,
  createConcentratedLiquidityPoolInstructions,
  createSplashPool,
  createSplashPoolInstructions,
  decreaseLiquidity,
  decreaseLiquidityInstructions,
  fetchConcentratedLiquidityPool,
  fetchPositionsForOwner,
  fetchPositionsInWhirlpool,
  fetchSplashPool,
  fetchWhirlpoolsByTokenPair,
  getPayer,
  getRpcConfig,
  harvestAllPositionFees,
  harvestPosition,
  harvestPositionInstructions,
  increaseLiquidityInstructions,
  increasePosLiquidity,
  openConcentratedPosition,
  openFullRangePosition,
  openFullRangePositionInstructions,
  openPositionInstructions,
  orderMints,
  resetConfiguration,
  setComputeUnitMarginMultiplier,
  setDefaultFunder,
  setDefaultSlippageToleranceBps,
  setEnforceTokenBalanceCheck,
  setJitoBlockEngineUrl,
  setJitoFeePercentile,
  setJitoTipSetting,
  setNativeMintWrappingStrategy,
  setPayerFromBytes,
  setPriorityFeePercentile,
  setPriorityFeeSetting,
  setRpc,
  setWhirlpoolsConfig,
  swap,
  swapInstructions
});
//# sourceMappingURL=index.cjs.map
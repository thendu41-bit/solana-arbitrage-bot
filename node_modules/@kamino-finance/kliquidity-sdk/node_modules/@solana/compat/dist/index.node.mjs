import { AccountRole } from '@solana/instructions';
import { createKeyPairFromBytes } from '@solana/keys';
import { SolanaError, SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH } from '@solana/errors';

// src/address.ts
function fromLegacyPublicKey(publicKey) {
  return publicKey.toBase58();
}
function fromLegacyTransactionInstruction(legacyInstruction) {
  const data = legacyInstruction.data?.byteLength > 0 ? Uint8Array.from(legacyInstruction.data) : void 0;
  const accounts = legacyInstruction.keys.map(
    (accountMeta) => Object.freeze({
      address: fromLegacyPublicKey(accountMeta.pubkey),
      role: determineRole(accountMeta.isSigner, accountMeta.isWritable)
    })
  );
  const programAddress = fromLegacyPublicKey(legacyInstruction.programId);
  return Object.freeze({
    ...accounts.length ? { accounts: Object.freeze(accounts) } : null,
    ...data ? { data } : null,
    programAddress
  });
}
function determineRole(isSigner, isWritable) {
  if (isSigner && isWritable) return AccountRole.WRITABLE_SIGNER;
  if (isSigner) return AccountRole.READONLY_SIGNER;
  if (isWritable) return AccountRole.WRITABLE;
  return AccountRole.READONLY;
}
async function fromLegacyKeypair(keypair, extractable) {
  const bytes = new Uint8Array(64);
  bytes.set(keypair.secretKey);
  bytes.set(
    keypair.publicKey.toBytes(),
    /* offset */
    32
  );
  return await createKeyPairFromBytes(bytes, extractable);
}
function convertSignatures(transaction, staticAccountKeys) {
  return Object.fromEntries(
    transaction.signatures.map((sig, index) => {
      const address = staticAccountKeys[index];
      if (sig.every((b) => b === 0)) {
        return [address, null];
      } else {
        return [address, sig];
      }
    })
  );
}
function fromVersionedTransaction(transaction) {
  const { message } = transaction;
  const { staticAccountKeys } = message.getAccountKeys();
  const { numRequiredSignatures } = message.header;
  if (numRequiredSignatures !== transaction.signatures.length) {
    throw new SolanaError(SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH, {
      numRequiredSignatures: transaction.message.header.numRequiredSignatures,
      signaturesLength: transaction.signatures.length,
      signerAddresses: staticAccountKeys.slice(0, numRequiredSignatures).map((p) => p.toBase58())
    });
  }
  const messageBytes = message.serialize();
  const signatures = convertSignatures(transaction, staticAccountKeys);
  return {
    messageBytes,
    signatures: Object.freeze(signatures)
  };
}

export { fromLegacyKeypair, fromLegacyPublicKey, fromLegacyTransactionInstruction, fromVersionedTransaction };
//# sourceMappingURL=index.node.mjs.map
//# sourceMappingURL=index.node.mjs.map
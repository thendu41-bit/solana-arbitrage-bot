"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRebalanceTypeFromRebalanceFields = getRebalanceTypeFromRebalanceFields;
exports.rebalanceTypeToRebalanceMethod = rebalanceTypeToRebalanceMethod;
exports.getRebalanceMethodFromRebalanceFields = getRebalanceMethodFromRebalanceFields;
exports.upsertRebalanceFieldInfo = upsertRebalanceFieldInfo;
exports.upsertManyRebalanceFieldInfos = upsertManyRebalanceFieldInfos;
exports.extractPricesFromDeserializedState = extractPricesFromDeserializedState;
const decimal_js_1 = __importDefault(require("decimal.js"));
const RebalanceType_1 = require("../@codegen/kliquidity/types/RebalanceType");
const CreationParameters_1 = require("../utils/CreationParameters");
const autodriftRebalance_1 = require("./autodriftRebalance");
const driftRebalance_1 = require("./driftRebalance");
const expanderRebalance_1 = require("./expanderRebalance");
const manualRebalance_1 = require("./manualRebalance");
const periodicRebalance_1 = require("./periodicRebalance");
const pricePercentageRebalance_1 = require("./pricePercentageRebalance");
const pricePercentageWithResetRebalance_1 = require("./pricePercentageWithResetRebalance");
const takeProfitRebalance_1 = require("./takeProfitRebalance");
function getRebalanceTypeFromRebalanceFields(rebalanceFieldInfos) {
    const rebalanceTypeField = rebalanceFieldInfos.find((field) => field.label === 'rebalanceType');
    if (!rebalanceTypeField) {
        throw new Error('Rebalance type field not found');
    }
    switch (rebalanceTypeField.value) {
        case manualRebalance_1.ManualRebalanceTypeName:
            return new RebalanceType_1.Manual();
        case pricePercentageRebalance_1.PricePercentageRebalanceTypeName:
            return new RebalanceType_1.PricePercentage();
        case pricePercentageWithResetRebalance_1.PricePercentageWithResetRebalanceTypeName:
            return new RebalanceType_1.PricePercentageWithReset();
        case driftRebalance_1.DriftRebalanceTypeName:
            return new RebalanceType_1.Drift();
        case takeProfitRebalance_1.TakeProfitRebalanceTypeName:
            return new RebalanceType_1.TakeProfit();
        case periodicRebalance_1.PeriodicRebalanceTypeName:
            return new RebalanceType_1.PeriodicRebalance();
        case expanderRebalance_1.ExpanderRebalanceTypeName:
            return new RebalanceType_1.Expander();
        case autodriftRebalance_1.AutodriftRebalanceTypeName:
            return new RebalanceType_1.Autodrift();
        default:
            throw new Error(`Invalid rebalance type ${rebalanceTypeField.value}`);
    }
}
function rebalanceTypeToRebalanceMethod(rebalanceType) {
    switch (rebalanceType.kind) {
        case RebalanceType_1.Manual.kind:
            return CreationParameters_1.ManualRebalanceMethod;
        case RebalanceType_1.PricePercentage.kind:
            return CreationParameters_1.PricePercentageRebalanceMethod;
        case RebalanceType_1.PricePercentageWithReset.kind:
            return CreationParameters_1.PricePercentageWithResetRangeRebalanceMethod;
        case RebalanceType_1.Drift.kind:
            return CreationParameters_1.DriftRebalanceMethod;
        case RebalanceType_1.TakeProfit.kind:
            return CreationParameters_1.TakeProfitMethod;
        case RebalanceType_1.PeriodicRebalance.kind:
            return CreationParameters_1.PeriodicRebalanceMethod;
        case RebalanceType_1.Expander.kind:
            return CreationParameters_1.ExpanderMethod;
        case RebalanceType_1.Autodrift.kind:
            return CreationParameters_1.AutodriftMethod;
        default:
            throw new Error(`Invalid rebalance type ${rebalanceType}`);
    }
}
function getRebalanceMethodFromRebalanceFields(rebalanceFieldInfos) {
    const rebalanceType = getRebalanceTypeFromRebalanceFields(rebalanceFieldInfos);
    return rebalanceTypeToRebalanceMethod(rebalanceType);
}
function upsertRebalanceFieldInfo(rebalanceFieldInfos, newFieldInfo) {
    const newRebalanceFieldInfoIndex = rebalanceFieldInfos.findIndex((fieldInfo) => fieldInfo.label === newFieldInfo.label);
    // if the field is not found, add it
    if (newRebalanceFieldInfoIndex === -1) {
        return [...rebalanceFieldInfos, newFieldInfo];
    }
    else {
        // if the field is found, update it
        const newRebalanceFieldInfos = [...rebalanceFieldInfos];
        newRebalanceFieldInfos[newRebalanceFieldInfoIndex] = newFieldInfo;
        return newRebalanceFieldInfos;
    }
}
function upsertManyRebalanceFieldInfos(rebalanceFieldInfos, newFieldInfos) {
    let updatedFieldInfos = [...rebalanceFieldInfos];
    for (const newFieldInfo of newFieldInfos) {
        updatedFieldInfos = upsertRebalanceFieldInfo(updatedFieldInfos, newFieldInfo);
    }
    return updatedFieldInfos;
}
function extractPricesFromDeserializedState(state) {
    const resetPriceLower = state.find((param) => param.label == 'resetPriceLower');
    const resetPriceUpper = state.find((param) => param.label == 'resetPriceUpper');
    if (resetPriceLower === undefined || resetPriceUpper === undefined) {
        throw new Error('Expected strategy to have resetPriceLower and resetPriceUpper in the field infos');
    }
    return [new decimal_js_1.default(resetPriceLower.value.toString()), new decimal_js_1.default(resetPriceUpper.value.toString())];
}
//# sourceMappingURL=utils.js.map
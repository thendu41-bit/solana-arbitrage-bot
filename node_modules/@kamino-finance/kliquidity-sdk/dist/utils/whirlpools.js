"use strict";
// Source: https://raw.githubusercontent.com/orca-so/whirlpool-sdk/main/src/position/quotes/remove-liquidity.ts
/**
 * Added roundUp flag to accurately estimate token holdings for deposits
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRemoveLiquidityQuote = getRemoveLiquidityQuote;
const anchor_1 = require("@coral-xyz/anchor");
const whirlpools_core_1 = require("@orca-so/whirlpools-core");
const numericalValues_1 = require("../constants/numericalValues");
const orca_1 = require("./orca");
function getRemoveLiquidityQuote(param, roundUp = false) {
    const posStatus = (0, whirlpools_core_1.positionStatus)(BigInt(param.sqrtPrice.toString()), param.tickLowerIndex, param.tickUpperIndex);
    switch (posStatus) {
        case 'priceBelowRange':
            return getRemoveLiquidityQuoteWhenPositionIsBelowRange(param, roundUp);
        case 'priceInRange':
            return getRemoveLiquidityQuoteWhenPositionIsInRange(param, roundUp);
        case 'priceAboveRange':
            return getRemoveLiquidityQuoteWhenPositionIsAboveRange(param, roundUp);
        default:
            throw new Error(`type ${posStatus} is an unknown PositionStatus`);
    }
}
function getRemoveLiquidityQuoteWhenPositionIsBelowRange(param, roundUp = false) {
    const { positionAddress, tickLowerIndex, tickUpperIndex, liquidity, slippageTolerance } = param;
    const sqrtPriceLowerX64 = (0, whirlpools_core_1.tickIndexToSqrtPrice)(tickLowerIndex);
    const sqrtPriceUpperX64 = (0, whirlpools_core_1.tickIndexToSqrtPrice)(tickUpperIndex);
    const estTokenA = (0, orca_1.getTokenAFromLiquidity)(liquidity, new anchor_1.BN(sqrtPriceLowerX64.toString()), new anchor_1.BN(sqrtPriceUpperX64.toString()), roundUp);
    const minTokenA = (0, orca_1.adjustForSlippage)(estTokenA, slippageTolerance, roundUp);
    return {
        positionAddress,
        minTokenA,
        minTokenB: numericalValues_1.ZERO_BN,
        estTokenA,
        estTokenB: numericalValues_1.ZERO_BN,
        liquidity,
    };
}
function getRemoveLiquidityQuoteWhenPositionIsInRange(param, roundUp = false) {
    const { positionAddress, sqrtPrice, tickLowerIndex, tickUpperIndex, liquidity, slippageTolerance } = param;
    const sqrtPriceX64 = sqrtPrice;
    const sqrtPriceLowerX64 = (0, whirlpools_core_1.tickIndexToSqrtPrice)(tickLowerIndex);
    const sqrtPriceUpperX64 = (0, whirlpools_core_1.tickIndexToSqrtPrice)(tickUpperIndex);
    const estTokenA = (0, orca_1.getTokenAFromLiquidity)(liquidity, new anchor_1.BN(sqrtPriceX64.toString()), new anchor_1.BN(sqrtPriceUpperX64.toString()), roundUp);
    const minTokenA = (0, orca_1.adjustForSlippage)(estTokenA, slippageTolerance, roundUp);
    const estTokenB = (0, orca_1.getTokenBFromLiquidity)(liquidity, new anchor_1.BN(sqrtPriceLowerX64.toString()), new anchor_1.BN(sqrtPriceX64.toString()), roundUp);
    const minTokenB = (0, orca_1.adjustForSlippage)(estTokenB, slippageTolerance, roundUp);
    return {
        positionAddress,
        minTokenA,
        minTokenB,
        estTokenA,
        estTokenB,
        liquidity,
    };
}
function getRemoveLiquidityQuoteWhenPositionIsAboveRange(param, roundUp = false) {
    const { positionAddress, tickLowerIndex, tickUpperIndex, liquidity, slippageTolerance: slippageTolerance } = param;
    const sqrtPriceLowerX64 = (0, whirlpools_core_1.tickIndexToSqrtPrice)(tickLowerIndex);
    const sqrtPriceUpperX64 = (0, whirlpools_core_1.tickIndexToSqrtPrice)(tickUpperIndex);
    const estTokenB = (0, orca_1.getTokenBFromLiquidity)(liquidity, new anchor_1.BN(sqrtPriceLowerX64.toString()), new anchor_1.BN(sqrtPriceUpperX64.toString()), roundUp);
    const minTokenB = (0, orca_1.adjustForSlippage)(estTokenB, slippageTolerance, roundUp);
    return {
        positionAddress,
        minTokenA: numericalValues_1.ZERO_BN,
        minTokenB,
        estTokenA: numericalValues_1.ZERO_BN,
        estTokenB,
        liquidity,
    };
}
//# sourceMappingURL=whirlpools.js.map
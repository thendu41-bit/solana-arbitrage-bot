import { BN } from '@coral-xyz/anchor';
import { Address, Instruction, TransactionMessage, TransactionSigner } from '@solana/kit';
import { WhirlpoolStrategy } from '../@codegen/kliquidity/accounts';
import { Dex } from './utils';
import Decimal from 'decimal.js';
import { RebalanceTypeKind } from '../@codegen/kliquidity/types';
export declare const RAYDIUM_DEVNET_PROGRAM_ID: Address<"devi51mZmdwUJGU9hjN27vEz64Gps7uUefqxg27EAtH">;
export type StrategyType = 'NON_PEGGED' | 'PEGGED' | 'STABLE';
export type StrategyCreationStatus = 'IGNORED' | 'SHADOW' | 'LIVE' | 'DEPRECATED' | 'STAGING';
export type StrategiesFilters = {
    strategyType?: StrategyType;
    strategyCreationStatus?: StrategyCreationStatus;
    isCommunity?: boolean;
    owner?: Address;
};
export declare function strategyTypeToBase58(strategyType: StrategyType): string;
export declare function strategyTypeToNumber(strategyType: StrategyType): number;
export declare function getStrategyTypeFromStrategy(strategy: WhirlpoolStrategy): StrategyType;
export declare function strategyCreationStatusToBase58(strategyCreationStatus: StrategyCreationStatus): string;
export declare function strategyCreationStatusToNumber(strategyCreationStatus: StrategyCreationStatus): number;
export declare function getStrategyCreationStatusFromStrategy(strategy: WhirlpoolStrategy): StrategyCreationStatus;
export interface GenericPoolInfo {
    dex: Dex;
    address: Address;
    tokenMintA: Address;
    tokenMintB: Address;
    price: Decimal;
    feeRate: Decimal;
    volumeOnLast7d: Decimal | undefined;
    tvl: Decimal | undefined;
    tickSpacing: Decimal;
    positions: Decimal;
}
export interface GenericPositionRangeInfo {
    estimatedApy: Decimal;
    estimatedVolume: Decimal | undefined;
}
export interface VaultParameters {
    tokenMintA: Address;
    tokenMintB: Address;
    dex: Dex;
    feeTier: Decimal;
    rebalancingParameters: RebalanceFieldInfo[];
}
export interface LiquidityDistribution {
    currentPrice: Decimal;
    currentTickIndex: number;
    distribution: LiquidityForPrice[];
}
export interface LiquidityForPrice {
    price: Decimal;
    liquidity: Decimal;
    tickIndex: number;
}
export interface DepositAmountsForSwap {
    requiredAAmountToDeposit: Decimal;
    requiredBAmountToDeposit: Decimal;
    tokenAToSwapAmount: Decimal;
    tokenBToSwapAmount: Decimal;
}
export declare function depositAmountsForSwapToLamports(depositAmounts: DepositAmountsForSwap, tokenADecimals: number, tokenBDecimals: number): DepositAmountsForSwap;
export interface RebalanceParams {
    rebalanceType: RebalanceTypeKind;
    lowerRangeBps?: Decimal;
    upperRangeBps?: Decimal;
    resetRangeLowerBps?: Decimal;
    resetRangeUpperBps?: Decimal;
    startMidTick?: Decimal;
    ticksBelowMid?: Decimal;
    ticksAboveMid?: Decimal;
    secondsPerTick?: Decimal;
    driftDirection?: Decimal;
    period?: Decimal;
    lowerRangePrice?: Decimal;
    upperRangePrice?: Decimal;
    destinationToken?: Decimal;
}
export interface RebalanceParamsAsPrices {
    rebalanceType: RebalanceTypeKind;
    rangePriceLower: Decimal;
    rangePriceUpper: Decimal;
    resetPriceLower?: Decimal;
    resetPriceUpper?: Decimal;
}
export interface PositionRange {
    lowerPrice: Decimal;
    upperPrice: Decimal;
}
export interface MaybeTokensBalances {
    a?: Decimal;
    b?: Decimal;
}
export interface TokensBalances {
    a: Decimal;
    b: Decimal;
}
export interface SwapperIxBuilder {
    (input: DepositAmountsForSwap, tokenAMint: Address, tokenBMint: Address, owner: TransactionSigner, slippage: Decimal, allKeys: Address[]): Promise<[Instruction[], Address[]]>;
}
export interface ProfiledFunctionExecution {
    <T>(promise: Promise<T>, transactionName: string, tags: [string, string][]): Promise<T>;
}
export declare function noopProfiledFunctionExecution(promise: Promise<any>): Promise<any>;
export interface CreateAta {
    ata: Address;
    createIxns: Instruction[];
    closeIxns: Instruction[];
}
export interface DeserializedVersionedTransaction {
    txMessage: TransactionMessage[];
    lookupTablesAddresses: Address[];
}
export interface InstructionsWithLookupTables {
    instructions: Instruction[];
    lookupTablesAddresses: Address[];
}
export interface PerformanceFees {
    feesFeeBPS: Decimal;
    reward0FeeBPS: Decimal;
    reward1FeeBPS: Decimal;
    reward2FeeBPS: Decimal;
}
export interface RebalanceFieldInfo {
    label: string;
    type: string;
    value: Decimal | string;
    enabled: boolean;
}
export type RebalanceFieldsDict = {
    [key: string]: Decimal;
};
export interface PriceReferenceType {
    name: string;
    descriptionShort?: string;
    description?: string;
}
export interface InputRebalanceFieldInfo {
    label: string;
    value: Decimal;
}
export interface InitStrategyIxs {
    initStrategyIx: Instruction;
    updateStrategyParamsIxs: Instruction[];
    updateRebalanceParamsIx: Instruction;
    openPositionIxs: Instruction[];
}
export interface WithdrawShares {
    prerequisiteIxs: Instruction[];
    withdrawIx: Instruction;
    closeSharesAtaIx?: Instruction;
}
export interface MetadataProgramAddressesOrca {
    position: Address;
    positionBump: number;
    positionMetadata: Address;
    positionMetadataBump: number;
}
export interface MetadataProgramAddressesRaydium {
    position: Address;
    positionBump: number;
    protocolPosition: Address;
    protocolPositionBump: number;
    positionMetadata: Address;
    positionMetadataBump: number;
}
export interface LowerAndUpperTickPubkeys {
    lowerTick: Address;
    lowerTickBump: number;
    upperTick: Address;
    upperTickBump: number;
}
export interface WithdrawAllAndCloseIxns {
    withdrawIxns: Instruction[];
    closeIxn: Instruction;
}
export interface InitPoolTickIfNeeded {
    tick: Address;
    initTickIx: Instruction | undefined;
}
export type Percentage = {
    numerator: BN;
    denominator: BN;
};
//# sourceMappingURL=types.d.ts.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findAtaBalance = exports.isWsolInfoInvalid = exports.createWsolAtaIfMissing = exports.getAtasWithCreateIxnsIfMissing = exports.createAtaIfMissingIx = exports.getComputeBudgetAndPriorityFeeIxns = exports.MAX_ACCOUNTS_PER_TRANSACTION = void 0;
exports.checkIfAccountExists = checkIfAccountExists;
exports.removeBudgetAndAtaIxns = removeBudgetAndAtaIxns;
const decimal_js_1 = __importDefault(require("decimal.js"));
const tokenUtils_1 = require("./tokenUtils");
const utils_1 = require("./utils");
const pubkeys_1 = require("../constants/pubkeys");
const token_1 = require("@solana-program/token");
const compute_budget_1 = require("@solana-program/compute-budget");
const token_2022_1 = require("@solana-program/token-2022");
const system_1 = require("@solana-program/system");
exports.MAX_ACCOUNTS_PER_TRANSACTION = 64;
const getComputeBudgetAndPriorityFeeIxns = (units, priorityFeeLamports) => {
    const ixns = [];
    ixns.push((0, compute_budget_1.getSetComputeUnitLimitInstruction)({ units }));
    if (priorityFeeLamports && priorityFeeLamports.gt(0)) {
        const unitPrice = priorityFeeLamports.mul(10 ** 6).div(units);
        ixns.push((0, compute_budget_1.getSetComputeUnitPriceInstruction)({ microLamports: BigInt(unitPrice.floor().toString()) }));
    }
    return ixns;
};
exports.getComputeBudgetAndPriorityFeeIxns = getComputeBudgetAndPriorityFeeIxns;
const createAtaIfMissingIx = async (connection, mint, owner, programId) => {
    const ata = await (0, tokenUtils_1.getAssociatedTokenAddress)(mint, owner.address, programId);
    const doesAtaExist = Boolean(await checkIfAccountExists(connection, ata));
    const createIxn = !doesAtaExist
        ? (0, tokenUtils_1.createAssociatedTokenAccountInstruction)(owner, ata, owner.address, mint, programId)
        : undefined;
    return createIxn;
};
exports.createAtaIfMissingIx = createAtaIfMissingIx;
const getAtasWithCreateIxnsIfMissing = async (connection, mints, owner) => {
    const requests = mints.map(async ([mint, tokenProgram]) => {
        const createAtaIx = await (0, exports.createAtaIfMissingIx)(connection, mint, owner, tokenProgram);
        if (createAtaIx) {
            return createAtaIx;
        }
        return undefined;
    });
    const result = (await Promise.all(requests.filter((x) => x !== undefined))).filter((ix) => ix !== undefined);
    return result;
};
exports.getAtasWithCreateIxnsIfMissing = getAtasWithCreateIxnsIfMissing;
const createWsolAtaIfMissing = async (rpc, amount, owner, method = 'deposit') => {
    const createIxns = [];
    const closeIxns = [];
    const wsolAta = await (0, tokenUtils_1.getAssociatedTokenAddress)(pubkeys_1.WRAPPED_SOL_MINT, owner.address);
    const solDeposit = amount.toNumber();
    const wsolAtaTokenAccount = await (0, token_2022_1.fetchMaybeToken)(rpc, wsolAta);
    // This checks if we need to create it
    if (!wsolAtaTokenAccount.exists) {
        createIxns.push((0, tokenUtils_1.createAssociatedTokenAccountInstruction)(owner, wsolAta, owner.address, pubkeys_1.WRAPPED_SOL_MINT, token_1.TOKEN_PROGRAM_ADDRESS));
    }
    let uiAmount = 0;
    try {
        if (wsolAtaTokenAccount.exists) {
            const tokenBalance = await (0, exports.findAtaBalance)(rpc, wsolAta);
            uiAmount = tokenBalance === null ? 0 : tokenBalance;
        }
    }
    catch (err) {
        console.log('Err Token Balance', err);
    }
    if (solDeposit !== null && solDeposit > uiAmount && method === 'deposit') {
        createIxns.push((0, system_1.getTransferSolInstruction)({
            amount: BigInt((0, utils_1.collToLamportsDecimal)(new decimal_js_1.default(solDeposit - uiAmount), tokenUtils_1.DECIMALS_SOL)
                .floor()
                .toString()),
            source: owner,
            destination: wsolAta,
        }));
    }
    if (createIxns.length > 0) {
        createIxns.push((0, token_2022_1.getSyncNativeInstruction)({
            account: wsolAta,
        }, { programAddress: token_1.TOKEN_PROGRAM_ADDRESS }));
    }
    closeIxns.push((0, token_2022_1.getCloseAccountInstruction)({ account: wsolAta, owner: owner, destination: owner.address, multiSigners: [] }, { programAddress: token_1.TOKEN_PROGRAM_ADDRESS }));
    return {
        ata: wsolAta,
        createIxns,
        closeIxns,
    };
};
exports.createWsolAtaIfMissing = createWsolAtaIfMissing;
const isWsolInfoInvalid = (wsolAtaAccountInfo) => {
    const res = wsolAtaAccountInfo === null ||
        (wsolAtaAccountInfo !== null &&
            wsolAtaAccountInfo.data.length === 0 &&
            wsolAtaAccountInfo.owner === pubkeys_1.DEFAULT_PUBLIC_KEY);
    return res;
};
exports.isWsolInfoInvalid = isWsolInfoInvalid;
async function checkIfAccountExists(connection, account) {
    return (await connection.getAccountInfo(account, { encoding: 'base64' }).send()).value != null;
}
function removeBudgetAndAtaIxns(ixns, mints) {
    return ixns.filter((ixn) => {
        const { programAddress, accounts } = ixn;
        if (programAddress === compute_budget_1.COMPUTE_BUDGET_PROGRAM_ADDRESS) {
            return false;
        }
        if (programAddress === token_2022_1.ASSOCIATED_TOKEN_PROGRAM_ADDRESS) {
            if (!accounts || accounts.length < 2) {
                return true;
            }
            const mint = accounts[3];
            return !mints.includes(mint.address);
        }
        return true;
    });
}
const findAtaBalance = async (connection, ata) => {
    const res = await connection.getTokenAccountBalance(ata).send();
    if (res && res.value) {
        return res.value.uiAmount;
    }
    return null;
};
exports.findAtaBalance = findAtaBalance;
//# sourceMappingURL=transactions.js.map
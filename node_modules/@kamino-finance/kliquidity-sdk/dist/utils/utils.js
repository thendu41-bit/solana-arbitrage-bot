"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReferencePriceType = exports.Dex = exports.RebalanceParamOffset = exports.ProportionalMintingMethod = exports.DollarBasedMintingMethod = void 0;
exports.sleep = sleep;
exports.dexToNumber = dexToNumber;
exports.numberToDex = numberToDex;
exports.numberToReferencePriceType = numberToReferencePriceType;
exports.getStrategyConfigValue = getStrategyConfigValue;
exports.buildStrategyRebalanceParams = buildStrategyRebalanceParams;
exports.doesStrategyHaveResetRange = doesStrategyHaveResetRange;
exports.numberToDriftDirection = numberToDriftDirection;
exports.numberToStakingRateSource = numberToStakingRateSource;
exports.numberToAutodriftStep = numberToAutodriftStep;
exports.numberToRebalanceType = numberToRebalanceType;
exports.getUpdateStrategyConfigIx = getUpdateStrategyConfigIx;
exports.collToLamportsDecimal = collToLamportsDecimal;
exports.lamportsToNumberDecimal = lamportsToNumberDecimal;
exports.readBigUint128LE = readBigUint128LE;
exports.readPriceOption = readPriceOption;
exports.rebalanceFieldsDictToInfo = rebalanceFieldsDictToInfo;
exports.isVaultInitialized = isVaultInitialized;
exports.sqrtPriceToPrice = sqrtPriceToPrice;
exports.stripTwapZeros = stripTwapZeros;
exports.percentageToBPS = percentageToBPS;
exports.keyOrDefault = keyOrDefault;
exports.optionGetValue = optionGetValue;
exports.optionGetValueOrUndefined = optionGetValueOrUndefined;
exports.optionGetValueOrDefault = optionGetValueOrDefault;
const kit_1 = require("@solana/kit");
const decimal_js_1 = __importDefault(require("decimal.js"));
const types_1 = require("../@codegen/kliquidity/types");
const instructions_1 = require("../@codegen/kliquidity/instructions");
const bn_js_1 = __importDefault(require("bn.js"));
const priceReferenceTypes_1 = require("./priceReferenceTypes");
const numericalValues_1 = require("../constants/numericalValues");
const math_1 = require("@raydium-io/raydium-sdk-v2/lib/raydium/clmm/utils/math");
const pubkeys_1 = require("../constants/pubkeys");
const system_1 = require("@solana-program/system");
const whirlpools_core_1 = require("@orca-so/whirlpools-core");
exports.DollarBasedMintingMethod = new decimal_js_1.default(0);
exports.ProportionalMintingMethod = new decimal_js_1.default(1);
exports.RebalanceParamOffset = new decimal_js_1.default(256);
function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
exports.Dex = ['ORCA', 'RAYDIUM', 'METEORA'];
exports.ReferencePriceType = [priceReferenceTypes_1.PoolPriceReferenceType, priceReferenceTypes_1.TwapPriceReferenceType];
function dexToNumber(dex) {
    for (let i = 0; i < exports.Dex.length; i++) {
        if (exports.Dex[i] === dex) {
            return i;
        }
    }
    throw new Error(`Unknown DEX ${dex}`);
}
function numberToDex(num) {
    const dex = exports.Dex[num];
    if (!dex) {
        throw new Error(`Unknown DEX ${num}`);
    }
    return dex;
}
function numberToReferencePriceType(num) {
    const referencePriceType = exports.ReferencePriceType[num];
    if (!referencePriceType) {
        throw new Error(`Strategy has invalid reference price type set: ${num}`);
    }
    return referencePriceType;
}
function getStrategyConfigValue(value) {
    const buffer = Buffer.alloc(128);
    writeBNUint64LE(buffer, new bn_js_1.default(value.toString()), 0);
    return [...buffer];
}
function buildStrategyRebalanceParams(params, rebalance_type, tokenADecimals, tokenBDecimals) {
    const buffer = Buffer.alloc(128);
    if (rebalance_type.kind == types_1.RebalanceType.Manual.kind) {
        // Manual has no params
    }
    else if (rebalance_type.kind == types_1.RebalanceType.PricePercentage.kind) {
        buffer.writeUint16LE(params[0].toNumber());
        buffer.writeUint16LE(params[1].toNumber(), 2);
    }
    else if (rebalance_type.kind == types_1.RebalanceType.PricePercentageWithReset.kind) {
        buffer.writeUint16LE(params[0].toNumber());
        buffer.writeUint16LE(params[1].toNumber(), 2);
        buffer.writeUint16LE(params[2].toNumber(), 4);
        buffer.writeUint16LE(params[3].toNumber(), 6);
    }
    else if (rebalance_type.kind == types_1.RebalanceType.Drift.kind) {
        buffer.writeInt32LE(params[0].toNumber());
        buffer.writeInt32LE(params[1].toNumber(), 4);
        buffer.writeInt32LE(params[2].toNumber(), 8);
        writeBNUint64LE(buffer, new bn_js_1.default(params[3].toString()), 12);
        buffer.writeUint8(params[4].toNumber(), 20);
    }
    else if (rebalance_type.kind == types_1.RebalanceType.TakeProfit.kind) {
        // TODO: fix this for meteora
        const lowerPrice = math_1.SqrtPriceMath.priceToSqrtPriceX64(params[0], tokenADecimals, tokenBDecimals);
        const upperPrice = math_1.SqrtPriceMath.priceToSqrtPriceX64(params[1], tokenADecimals, tokenBDecimals);
        writeBN128LE(buffer, lowerPrice, 0);
        writeBN128LE(buffer, upperPrice, 16);
        buffer.writeUint8(params[2].toNumber(), 32);
    }
    else if (rebalance_type.kind == types_1.RebalanceType.PeriodicRebalance.kind) {
        writeBNUint64LE(buffer, new bn_js_1.default(params[0].toString()), 0);
        buffer.writeUInt16LE(params[1].toNumber(), 8);
        buffer.writeUInt16LE(params[2].toNumber(), 10);
    }
    else if (rebalance_type.kind == types_1.RebalanceType.Expander.kind) {
        buffer.writeUInt16LE(params[0].toNumber(), 0);
        buffer.writeUInt16LE(params[1].toNumber(), 2);
        buffer.writeUInt16LE(params[2].toNumber(), 4);
        buffer.writeUInt16LE(params[3].toNumber(), 6);
        buffer.writeUInt16LE(params[4].toNumber(), 8);
        buffer.writeUInt16LE(params[5].toNumber(), 10);
        buffer.writeUInt8(params[6].toNumber(), 12);
    }
    else if (rebalance_type.kind == types_1.RebalanceType.Autodrift.kind) {
        buffer.writeUInt32LE(params[0].toNumber(), 0);
        buffer.writeInt32LE(params[1].toNumber(), 4);
        buffer.writeInt32LE(params[2].toNumber(), 8);
        buffer.writeUInt16LE(params[3].toNumber(), 12);
        buffer.writeUInt8(params[4].toNumber(), 14);
        buffer.writeUInt8(params[5].toNumber(), 15);
        buffer.writeUInt8(params[6].toNumber(), 16);
    }
    else {
        throw 'Rebalance type not valid ' + rebalance_type;
    }
    return [...buffer];
}
function doesStrategyHaveResetRange(rebalanceTypeNumber) {
    const rebalanceType = numberToRebalanceType(rebalanceTypeNumber);
    return (rebalanceType.kind == types_1.RebalanceType.PricePercentageWithReset.kind ||
        rebalanceType.kind == types_1.RebalanceType.Expander.kind);
}
function numberToDriftDirection(value) {
    if (value == 0) {
        return new types_1.DriftDirection.Increasing();
    }
    else if (value == 1) {
        return new types_1.DriftDirection.Decreasing();
    }
    else {
        throw new Error(`Invalid drift direction ${value.toString()}`);
    }
}
function numberToStakingRateSource(value) {
    if (value == 0) {
        return new types_1.StakingRateSource.Constant();
    }
    else if (value == 1) {
        return new types_1.StakingRateSource.Scope();
    }
    else {
        throw new Error(`Invalid staking rate source ${value.toString()}`);
    }
}
function numberToAutodriftStep(value) {
    if (value == 0) {
        return new types_1.RebalanceAutodriftStep.Uninitialized();
    }
    else if (value == 1) {
        return new types_1.RebalanceAutodriftStep.Autodrifting();
    }
    else {
        throw new Error(`Invalid autodrift step ${value.toString()}`);
    }
}
function numberToRebalanceType(rebalance_type) {
    if (rebalance_type == 0) {
        return new types_1.RebalanceType.Manual();
    }
    else if (rebalance_type == 1) {
        return new types_1.RebalanceType.PricePercentage();
    }
    else if (rebalance_type == 2) {
        return new types_1.RebalanceType.PricePercentageWithReset();
    }
    else if (rebalance_type == 3) {
        return new types_1.RebalanceType.Drift();
    }
    else if (rebalance_type == 4) {
        return new types_1.RebalanceType.TakeProfit();
    }
    else if (rebalance_type == 5) {
        return new types_1.RebalanceType.PeriodicRebalance();
    }
    else if (rebalance_type == 6) {
        return new types_1.RebalanceType.Expander();
    }
    else if (rebalance_type == 7) {
        return new types_1.RebalanceType.Autodrift();
    }
    else {
        throw new Error(`Invalid rebalance type ${rebalance_type.toString()}`);
    }
}
async function getUpdateStrategyConfigIx(signer, globalConfig, strategy, mode, amount, programId, newAccount = pubkeys_1.DEFAULT_PUBLIC_KEY) {
    const args = {
        mode: mode.discriminator,
        value: getStrategyConfigValue(amount),
    };
    const accounts = {
        adminAuthority: signer,
        newAccount,
        globalConfig,
        strategy,
        systemProgram: system_1.SYSTEM_PROGRAM_ADDRESS,
    };
    return (0, instructions_1.updateStrategyConfig)(args, accounts, undefined, programId);
}
function collToLamportsDecimal(amount, decimals) {
    const factor = new decimal_js_1.default(10).pow(decimals);
    return amount.mul(factor);
}
function lamportsToNumberDecimal(amount, decimals) {
    const factor = new decimal_js_1.default(10).pow(decimals);
    return new decimal_js_1.default(amount).div(factor);
}
function readBigUint128LE(buffer, offset) {
    return buffer.readBigUInt64LE(offset) + (buffer.readBigUInt64LE(offset + 8) << BigInt(64));
}
function readPriceOption(buffer, offset) {
    if (buffer.readUint8(offset) == 0) {
        return [offset + 1, new decimal_js_1.default(0)];
    }
    const value = buffer.readBigUInt64LE(offset + 1);
    const exp = buffer.readBigUInt64LE(offset + 9);
    return [offset + 17, new decimal_js_1.default(value.toString()).div(new decimal_js_1.default(10).pow(exp.toString()))];
}
function writeBNUint64LE(buffer, value, offset) {
    const lower_half = value.maskn(64).toBuffer('le');
    buffer.set(lower_half, offset);
}
function writeBN128LE(buffer, value, offset) {
    const lower_half = value.maskn(64).toBuffer('le');
    const upper_half = value.shrn(64).toBuffer('le');
    buffer.set(lower_half, offset);
    buffer.set(upper_half, offset + 8);
}
function rebalanceFieldsDictToInfo(rebalanceFields) {
    const rebalanceFieldsInfo = [];
    for (const key in rebalanceFields) {
        const value = rebalanceFields[key];
        rebalanceFieldsInfo.push({
            label: key,
            type: 'number',
            value: value,
            enabled: false,
        });
    }
    return rebalanceFieldsInfo;
}
function isVaultInitialized(vault, decimals) {
    return vault !== pubkeys_1.DEFAULT_PUBLIC_KEY && decimals.toNumber() > 0;
}
function sqrtPriceToPrice(sqrtPrice, dexNo, decimalsA, decimalsB) {
    const dex = numberToDex(dexNo);
    if (dex == 'ORCA') {
        return new decimal_js_1.default((0, whirlpools_core_1.sqrtPriceToPrice)(BigInt(sqrtPrice.toString()), decimalsA, decimalsB));
    }
    if (dex == 'RAYDIUM') {
        return math_1.SqrtPriceMath.sqrtPriceX64ToPrice(sqrtPrice, decimalsA, decimalsB);
    }
    if (dex == 'METEORA') {
        const price = new decimal_js_1.default(sqrtPrice.toString());
        return price.div(new decimal_js_1.default(numericalValues_1.U64_MAX));
    }
    throw new Error(`Got invalid dex number ${dex}`);
}
// Zero is not a valid TWAP component as that indicates the SOL price
function stripTwapZeros(chain) {
    return chain.filter((component) => component > 0);
}
function percentageToBPS(pct) {
    return pct * 100;
}
function keyOrDefault(key, defaultKey) {
    if (key === pubkeys_1.DEFAULT_PUBLIC_KEY) {
        return defaultKey;
    }
    return key;
}
// Extract value from Option if Some, otherwise return null
function optionGetValue(option) {
    return (0, kit_1.isSome)(option) ? option.value : null;
}
// Extract value from Option if Some, otherwise return undefined
function optionGetValueOrUndefined(option) {
    return (0, kit_1.isSome)(option) ? option.value : undefined;
}
// Extract value from Option if Some, otherwise return provided default
function optionGetValueOrDefault(option, defaultValue) {
    return (0, kit_1.isSome)(option) ? option.value : defaultValue;
}
//# sourceMappingURL=utils.js.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPriceOfBinByBinId = getPriceOfBinByBinId;
exports.getBinIdFromPrice = getBinIdFromPrice;
exports.getPriceOfBinByBinIdWithDecimals = getPriceOfBinByBinIdWithDecimals;
exports.getBinIdFromPriceWithDecimals = getBinIdFromPriceWithDecimals;
exports.getPriceFromQ64Price = getPriceFromQ64Price;
exports.getBinArrayLowerUpperBinId = getBinArrayLowerUpperBinId;
exports.getBinFromBinArray = getBinFromBinArray;
exports.getBinFromBinArrays = getBinFromBinArrays;
exports.binIdToBinArrayIndex = binIdToBinArrayIndex;
exports.deriveBinArray = deriveBinArray;
const kit_1 = require("@solana/kit");
const decimal_js_1 = __importDefault(require("decimal.js"));
const numericalValues_1 = require("../constants/numericalValues");
const anchor_1 = require("@coral-xyz/anchor");
const BASIS_POINT_MAX = 10000;
const MAX_BIN_ARRAY_SIZE = 70;
const addressEncoder = (0, kit_1.getAddressEncoder)();
function getPriceOfBinByBinId(binId, tickSpacing) {
    const binStepNum = new decimal_js_1.default(tickSpacing).div(new decimal_js_1.default(BASIS_POINT_MAX));
    return new decimal_js_1.default(1).add(new decimal_js_1.default(binStepNum)).pow(new decimal_js_1.default(binId));
}
function getBinIdFromPrice(price, tickSpacing, min) {
    const binStepNum = new decimal_js_1.default(tickSpacing).div(new decimal_js_1.default(BASIS_POINT_MAX));
    const binId = price.log().dividedBy(new decimal_js_1.default(1).add(binStepNum).log());
    return (min ? binId.floor() : binId.ceil()).toNumber();
}
function getPriceOfBinByBinIdWithDecimals(binId, tickSpacing, decimalsA, decimalsB) {
    return getPriceOfBinByBinId(binId, tickSpacing)
        .mul(new decimal_js_1.default(10).pow(decimalsA))
        .div(new decimal_js_1.default(10).pow(decimalsB));
}
function getBinIdFromPriceWithDecimals(price, tickSpacing, min, decimalsA, decimalsB) {
    const scaledPrice = price.mul(new decimal_js_1.default(10).pow(decimalsB)).div(new decimal_js_1.default(10).pow(decimalsA));
    return getBinIdFromPrice(scaledPrice, tickSpacing, min);
}
function getPriceFromQ64Price(price, decimalsA, decimalsB) {
    const scaledPrice = price.mul(new decimal_js_1.default(10).pow(decimalsA)).div(new decimal_js_1.default(10).pow(decimalsB));
    return scaledPrice.div(new decimal_js_1.default(numericalValues_1.U64_MAX));
}
function getBinArrayLowerUpperBinId(binArrayIndex) {
    const lowerBinId = binArrayIndex * MAX_BIN_ARRAY_SIZE;
    const upperBinId = lowerBinId + MAX_BIN_ARRAY_SIZE - 1;
    return [lowerBinId, upperBinId];
}
function getBinFromBinArray(binIndex, binArray) {
    const [lowerBinId] = getBinArrayLowerUpperBinId(binArray.index.toNumber());
    const offset = binIndex - lowerBinId;
    if (offset >= 0 && offset < binArray.bins.length) {
        return binArray.bins[offset];
    }
    return null;
}
function getBinFromBinArrays(binIndex, binArrays) {
    for (let i = 0; i < binArrays.length; i++) {
        const bin = getBinFromBinArray(binIndex, binArrays[i]);
        if (bin) {
            return bin;
        }
    }
    return null;
}
function binIdToBinArrayIndex(binId) {
    const { div: idx, mod } = binId.divmod(new anchor_1.BN(MAX_BIN_ARRAY_SIZE));
    return binId.isNeg() && !mod.isZero() ? idx.sub(new anchor_1.BN(1)) : idx;
}
async function deriveBinArray(lbPair, index, programId) {
    let binArrayBytes;
    if (index.isNeg()) {
        binArrayBytes = new Uint8Array(index.toTwos(64).toBuffer('le', 8));
    }
    else {
        binArrayBytes = new Uint8Array(index.toBuffer('le', 8));
    }
    const pda = await (0, kit_1.getProgramDerivedAddress)({
        seeds: [Buffer.from('bin_array'), addressEncoder.encode(lbPair), binArrayBytes],
        programAddress: programId,
    });
    return pda;
}
//# sourceMappingURL=meteora.js.map
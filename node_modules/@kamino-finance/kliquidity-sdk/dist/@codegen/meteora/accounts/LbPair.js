"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LbPair = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars */
const kit_1 = require("@solana/kit");
/* eslint-enable @typescript-eslint/no-unused-vars */
const bn_js_1 = __importDefault(require("bn.js")); // eslint-disable-line @typescript-eslint/no-unused-vars
const borsh = __importStar(require("@coral-xyz/borsh")); // eslint-disable-line @typescript-eslint/no-unused-vars
const utils_1 = require("../utils"); // eslint-disable-line @typescript-eslint/no-unused-vars
const types = __importStar(require("../types")); // eslint-disable-line @typescript-eslint/no-unused-vars
const programId_1 = require("../programId");
class LbPair {
    parameters;
    vParameters;
    bumpSeed;
    /** Bin step signer seed */
    binStepSeed;
    /** Type of the pair */
    pairType;
    /** Active bin id */
    activeId;
    /** Bin step. Represent the price increment / decrement. */
    binStep;
    /** Status of the pair. Check PairStatus enum. */
    status;
    requireBaseFactorSeed;
    baseFactorSeed;
    padding1;
    /** Token X mint */
    tokenXMint;
    /** Token Y mint */
    tokenYMint;
    /** LB token X vault */
    reserveX;
    /** LB token Y vault */
    reserveY;
    /** Uncollected protocol fee */
    protocolFee;
    /** Protocol fee owner, */
    feeOwner;
    /** Farming reward information */
    rewardInfos;
    /** Oracle pubkey */
    oracle;
    /** Packed initialized bin array state */
    binArrayBitmap;
    /** Last time the pool fee parameter was updated */
    lastUpdatedAt;
    /** Whitelisted wallet */
    whitelistedWallet;
    /** Address allowed to swap when the current slot is greater than or equal to the pre-activation slot. The pre-activation slot is calculated as `activation_slot - pre_activation_slot_duration`. */
    preActivationSwapAddress;
    /** Base keypair. Only required for permission pair */
    baseKey;
    /** Slot to enable the pair. Only applicable for permission pair. */
    activationSlot;
    /** Number of slot before activation slot. Used to calculate pre-activation slot for pre_activation_swap_address */
    preActivationSlotDuration;
    /** _padding2 is reclaimed free space from swap_cap_deactivate_slot and swap_cap_amount before, BE CAREFUL FOR TOMBSTONE WHEN REUSE !! */
    padding2;
    /** Liquidity lock duration for positions which created before activate. Only applicable for permission pair. */
    lockDurationsInSlot;
    /** Pool creator */
    creator;
    /** Reserved space for future use */
    reserved;
    static discriminator = Buffer.from([
        33, 11, 49, 98, 181, 101, 177, 13,
    ]);
    static layout = borsh.struct([
        types.StaticParameters.layout("parameters"),
        types.VariableParameters.layout("vParameters"),
        borsh.array(borsh.u8(), 1, "bumpSeed"),
        borsh.array(borsh.u8(), 2, "binStepSeed"),
        borsh.u8("pairType"),
        borsh.i32("activeId"),
        borsh.u16("binStep"),
        borsh.u8("status"),
        borsh.u8("requireBaseFactorSeed"),
        borsh.array(borsh.u8(), 2, "baseFactorSeed"),
        borsh.array(borsh.u8(), 2, "padding1"),
        (0, utils_1.borshAddress)("tokenXMint"),
        (0, utils_1.borshAddress)("tokenYMint"),
        (0, utils_1.borshAddress)("reserveX"),
        (0, utils_1.borshAddress)("reserveY"),
        types.ProtocolFee.layout("protocolFee"),
        (0, utils_1.borshAddress)("feeOwner"),
        borsh.array(types.RewardInfo.layout(), 2, "rewardInfos"),
        (0, utils_1.borshAddress)("oracle"),
        borsh.array(borsh.u64(), 16, "binArrayBitmap"),
        borsh.i64("lastUpdatedAt"),
        (0, utils_1.borshAddress)("whitelistedWallet"),
        (0, utils_1.borshAddress)("preActivationSwapAddress"),
        (0, utils_1.borshAddress)("baseKey"),
        borsh.u64("activationSlot"),
        borsh.u64("preActivationSlotDuration"),
        borsh.array(borsh.u8(), 8, "padding2"),
        borsh.u64("lockDurationsInSlot"),
        (0, utils_1.borshAddress)("creator"),
        borsh.array(borsh.u8(), 24, "reserved"),
    ]);
    constructor(fields) {
        this.parameters = new types.StaticParameters({ ...fields.parameters });
        this.vParameters = new types.VariableParameters({ ...fields.vParameters });
        this.bumpSeed = fields.bumpSeed;
        this.binStepSeed = fields.binStepSeed;
        this.pairType = fields.pairType;
        this.activeId = fields.activeId;
        this.binStep = fields.binStep;
        this.status = fields.status;
        this.requireBaseFactorSeed = fields.requireBaseFactorSeed;
        this.baseFactorSeed = fields.baseFactorSeed;
        this.padding1 = fields.padding1;
        this.tokenXMint = fields.tokenXMint;
        this.tokenYMint = fields.tokenYMint;
        this.reserveX = fields.reserveX;
        this.reserveY = fields.reserveY;
        this.protocolFee = new types.ProtocolFee({ ...fields.protocolFee });
        this.feeOwner = fields.feeOwner;
        this.rewardInfos = fields.rewardInfos.map((item) => new types.RewardInfo({ ...item }));
        this.oracle = fields.oracle;
        this.binArrayBitmap = fields.binArrayBitmap;
        this.lastUpdatedAt = fields.lastUpdatedAt;
        this.whitelistedWallet = fields.whitelistedWallet;
        this.preActivationSwapAddress = fields.preActivationSwapAddress;
        this.baseKey = fields.baseKey;
        this.activationSlot = fields.activationSlot;
        this.preActivationSlotDuration = fields.preActivationSlotDuration;
        this.padding2 = fields.padding2;
        this.lockDurationsInSlot = fields.lockDurationsInSlot;
        this.creator = fields.creator;
        this.reserved = fields.reserved;
    }
    static async fetch(rpc, address, programId = programId_1.PROGRAM_ID) {
        const info = await (0, kit_1.fetchEncodedAccount)(rpc, address);
        if (!info.exists) {
            return null;
        }
        if (info.programAddress !== programId) {
            throw new Error(`LbPairFields account ${address} belongs to wrong program ${info.programAddress}, expected ${programId}`);
        }
        return this.decode(Buffer.from(info.data));
    }
    static async fetchMultiple(rpc, addresses, programId = programId_1.PROGRAM_ID) {
        const infos = await (0, kit_1.fetchEncodedAccounts)(rpc, addresses);
        return infos.map((info) => {
            if (!info.exists) {
                return null;
            }
            if (info.programAddress !== programId) {
                throw new Error(`LbPairFields account ${info.address} belongs to wrong program ${info.programAddress}, expected ${programId}`);
            }
            return this.decode(Buffer.from(info.data));
        });
    }
    static decode(data) {
        if (!data.slice(0, 8).equals(LbPair.discriminator)) {
            throw new Error("invalid account discriminator");
        }
        const dec = LbPair.layout.decode(data.slice(8));
        return new LbPair({
            parameters: types.StaticParameters.fromDecoded(dec.parameters),
            vParameters: types.VariableParameters.fromDecoded(dec.vParameters),
            bumpSeed: dec.bumpSeed,
            binStepSeed: dec.binStepSeed,
            pairType: dec.pairType,
            activeId: dec.activeId,
            binStep: dec.binStep,
            status: dec.status,
            requireBaseFactorSeed: dec.requireBaseFactorSeed,
            baseFactorSeed: dec.baseFactorSeed,
            padding1: dec.padding1,
            tokenXMint: dec.tokenXMint,
            tokenYMint: dec.tokenYMint,
            reserveX: dec.reserveX,
            reserveY: dec.reserveY,
            protocolFee: types.ProtocolFee.fromDecoded(dec.protocolFee),
            feeOwner: dec.feeOwner,
            rewardInfos: dec.rewardInfos.map((item /* eslint-disable-line @typescript-eslint/no-explicit-any */) => types.RewardInfo.fromDecoded(item)),
            oracle: dec.oracle,
            binArrayBitmap: dec.binArrayBitmap,
            lastUpdatedAt: dec.lastUpdatedAt,
            whitelistedWallet: dec.whitelistedWallet,
            preActivationSwapAddress: dec.preActivationSwapAddress,
            baseKey: dec.baseKey,
            activationSlot: dec.activationSlot,
            preActivationSlotDuration: dec.preActivationSlotDuration,
            padding2: dec.padding2,
            lockDurationsInSlot: dec.lockDurationsInSlot,
            creator: dec.creator,
            reserved: dec.reserved,
        });
    }
    toJSON() {
        return {
            parameters: this.parameters.toJSON(),
            vParameters: this.vParameters.toJSON(),
            bumpSeed: this.bumpSeed,
            binStepSeed: this.binStepSeed,
            pairType: this.pairType,
            activeId: this.activeId,
            binStep: this.binStep,
            status: this.status,
            requireBaseFactorSeed: this.requireBaseFactorSeed,
            baseFactorSeed: this.baseFactorSeed,
            padding1: this.padding1,
            tokenXMint: this.tokenXMint,
            tokenYMint: this.tokenYMint,
            reserveX: this.reserveX,
            reserveY: this.reserveY,
            protocolFee: this.protocolFee.toJSON(),
            feeOwner: this.feeOwner,
            rewardInfos: this.rewardInfos.map((item) => item.toJSON()),
            oracle: this.oracle,
            binArrayBitmap: this.binArrayBitmap.map((item) => item.toString()),
            lastUpdatedAt: this.lastUpdatedAt.toString(),
            whitelistedWallet: this.whitelistedWallet,
            preActivationSwapAddress: this.preActivationSwapAddress,
            baseKey: this.baseKey,
            activationSlot: this.activationSlot.toString(),
            preActivationSlotDuration: this.preActivationSlotDuration.toString(),
            padding2: this.padding2,
            lockDurationsInSlot: this.lockDurationsInSlot.toString(),
            creator: this.creator,
            reserved: this.reserved,
        };
    }
    static fromJSON(obj) {
        return new LbPair({
            parameters: types.StaticParameters.fromJSON(obj.parameters),
            vParameters: types.VariableParameters.fromJSON(obj.vParameters),
            bumpSeed: obj.bumpSeed,
            binStepSeed: obj.binStepSeed,
            pairType: obj.pairType,
            activeId: obj.activeId,
            binStep: obj.binStep,
            status: obj.status,
            requireBaseFactorSeed: obj.requireBaseFactorSeed,
            baseFactorSeed: obj.baseFactorSeed,
            padding1: obj.padding1,
            tokenXMint: (0, kit_1.address)(obj.tokenXMint),
            tokenYMint: (0, kit_1.address)(obj.tokenYMint),
            reserveX: (0, kit_1.address)(obj.reserveX),
            reserveY: (0, kit_1.address)(obj.reserveY),
            protocolFee: types.ProtocolFee.fromJSON(obj.protocolFee),
            feeOwner: (0, kit_1.address)(obj.feeOwner),
            rewardInfos: obj.rewardInfos.map((item) => types.RewardInfo.fromJSON(item)),
            oracle: (0, kit_1.address)(obj.oracle),
            binArrayBitmap: obj.binArrayBitmap.map((item) => new bn_js_1.default(item)),
            lastUpdatedAt: new bn_js_1.default(obj.lastUpdatedAt),
            whitelistedWallet: (0, kit_1.address)(obj.whitelistedWallet),
            preActivationSwapAddress: (0, kit_1.address)(obj.preActivationSwapAddress),
            baseKey: (0, kit_1.address)(obj.baseKey),
            activationSlot: new bn_js_1.default(obj.activationSlot),
            preActivationSlotDuration: new bn_js_1.default(obj.preActivationSlotDuration),
            padding2: obj.padding2,
            lockDurationsInSlot: new bn_js_1.default(obj.lockDurationsInSlot),
            creator: (0, kit_1.address)(obj.creator),
            reserved: obj.reserved,
        });
    }
}
exports.LbPair = LbPair;
//# sourceMappingURL=LbPair.js.map
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PositionV2 = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars */
const kit_1 = require("@solana/kit");
/* eslint-enable @typescript-eslint/no-unused-vars */
const bn_js_1 = __importDefault(require("bn.js")); // eslint-disable-line @typescript-eslint/no-unused-vars
const borsh = __importStar(require("@coral-xyz/borsh")); // eslint-disable-line @typescript-eslint/no-unused-vars
const utils_1 = require("../utils"); // eslint-disable-line @typescript-eslint/no-unused-vars
const types = __importStar(require("../types")); // eslint-disable-line @typescript-eslint/no-unused-vars
const programId_1 = require("../programId");
class PositionV2 {
    /** The LB pair of this position */
    lbPair;
    /** Owner of the position. Client rely on this to to fetch their positions. */
    owner;
    /** Liquidity shares of this position in bins (lower_bin_id <-> upper_bin_id). This is the same as LP concept. */
    liquidityShares;
    /** Farming reward information */
    rewardInfos;
    /** Swap fee to claim information */
    feeInfos;
    /** Lower bin ID */
    lowerBinId;
    /** Upper bin ID */
    upperBinId;
    /** Last updated timestamp */
    lastUpdatedAt;
    /** Total claimed token fee X */
    totalClaimedFeeXAmount;
    /** Total claimed token fee Y */
    totalClaimedFeeYAmount;
    /** Total claimed rewards */
    totalClaimedRewards;
    /** Operator of position */
    operator;
    /** Slot which the locked liquidity can be withdraw */
    lockReleaseSlot;
    /** Is the position subjected to liquidity locking for the launch pool. */
    subjectedToBootstrapLiquidityLocking;
    /** Address is able to claim fee in this position, only valid for bootstrap_liquidity_position */
    feeOwner;
    /** Reserved space for future use */
    reserved;
    static discriminator = Buffer.from([
        117, 176, 212, 199, 245, 180, 133, 182,
    ]);
    static layout = borsh.struct([
        (0, utils_1.borshAddress)("lbPair"),
        (0, utils_1.borshAddress)("owner"),
        borsh.array(borsh.u128(), 70, "liquidityShares"),
        borsh.array(types.UserRewardInfo.layout(), 70, "rewardInfos"),
        borsh.array(types.FeeInfo.layout(), 70, "feeInfos"),
        borsh.i32("lowerBinId"),
        borsh.i32("upperBinId"),
        borsh.i64("lastUpdatedAt"),
        borsh.u64("totalClaimedFeeXAmount"),
        borsh.u64("totalClaimedFeeYAmount"),
        borsh.array(borsh.u64(), 2, "totalClaimedRewards"),
        (0, utils_1.borshAddress)("operator"),
        borsh.u64("lockReleaseSlot"),
        borsh.u8("subjectedToBootstrapLiquidityLocking"),
        (0, utils_1.borshAddress)("feeOwner"),
        borsh.array(borsh.u8(), 87, "reserved"),
    ]);
    constructor(fields) {
        this.lbPair = fields.lbPair;
        this.owner = fields.owner;
        this.liquidityShares = fields.liquidityShares;
        this.rewardInfos = fields.rewardInfos.map((item) => new types.UserRewardInfo({ ...item }));
        this.feeInfos = fields.feeInfos.map((item) => new types.FeeInfo({ ...item }));
        this.lowerBinId = fields.lowerBinId;
        this.upperBinId = fields.upperBinId;
        this.lastUpdatedAt = fields.lastUpdatedAt;
        this.totalClaimedFeeXAmount = fields.totalClaimedFeeXAmount;
        this.totalClaimedFeeYAmount = fields.totalClaimedFeeYAmount;
        this.totalClaimedRewards = fields.totalClaimedRewards;
        this.operator = fields.operator;
        this.lockReleaseSlot = fields.lockReleaseSlot;
        this.subjectedToBootstrapLiquidityLocking =
            fields.subjectedToBootstrapLiquidityLocking;
        this.feeOwner = fields.feeOwner;
        this.reserved = fields.reserved;
    }
    static async fetch(rpc, address, programId = programId_1.PROGRAM_ID) {
        const info = await (0, kit_1.fetchEncodedAccount)(rpc, address);
        if (!info.exists) {
            return null;
        }
        if (info.programAddress !== programId) {
            throw new Error(`PositionV2Fields account ${address} belongs to wrong program ${info.programAddress}, expected ${programId}`);
        }
        return this.decode(Buffer.from(info.data));
    }
    static async fetchMultiple(rpc, addresses, programId = programId_1.PROGRAM_ID) {
        const infos = await (0, kit_1.fetchEncodedAccounts)(rpc, addresses);
        return infos.map((info) => {
            if (!info.exists) {
                return null;
            }
            if (info.programAddress !== programId) {
                throw new Error(`PositionV2Fields account ${info.address} belongs to wrong program ${info.programAddress}, expected ${programId}`);
            }
            return this.decode(Buffer.from(info.data));
        });
    }
    static decode(data) {
        if (!data.slice(0, 8).equals(PositionV2.discriminator)) {
            throw new Error("invalid account discriminator");
        }
        const dec = PositionV2.layout.decode(data.slice(8));
        return new PositionV2({
            lbPair: dec.lbPair,
            owner: dec.owner,
            liquidityShares: dec.liquidityShares,
            rewardInfos: dec.rewardInfos.map((item /* eslint-disable-line @typescript-eslint/no-explicit-any */) => types.UserRewardInfo.fromDecoded(item)),
            feeInfos: dec.feeInfos.map((item /* eslint-disable-line @typescript-eslint/no-explicit-any */) => types.FeeInfo.fromDecoded(item)),
            lowerBinId: dec.lowerBinId,
            upperBinId: dec.upperBinId,
            lastUpdatedAt: dec.lastUpdatedAt,
            totalClaimedFeeXAmount: dec.totalClaimedFeeXAmount,
            totalClaimedFeeYAmount: dec.totalClaimedFeeYAmount,
            totalClaimedRewards: dec.totalClaimedRewards,
            operator: dec.operator,
            lockReleaseSlot: dec.lockReleaseSlot,
            subjectedToBootstrapLiquidityLocking: dec.subjectedToBootstrapLiquidityLocking,
            feeOwner: dec.feeOwner,
            reserved: dec.reserved,
        });
    }
    toJSON() {
        return {
            lbPair: this.lbPair,
            owner: this.owner,
            liquidityShares: this.liquidityShares.map((item) => item.toString()),
            rewardInfos: this.rewardInfos.map((item) => item.toJSON()),
            feeInfos: this.feeInfos.map((item) => item.toJSON()),
            lowerBinId: this.lowerBinId,
            upperBinId: this.upperBinId,
            lastUpdatedAt: this.lastUpdatedAt.toString(),
            totalClaimedFeeXAmount: this.totalClaimedFeeXAmount.toString(),
            totalClaimedFeeYAmount: this.totalClaimedFeeYAmount.toString(),
            totalClaimedRewards: this.totalClaimedRewards.map((item) => item.toString()),
            operator: this.operator,
            lockReleaseSlot: this.lockReleaseSlot.toString(),
            subjectedToBootstrapLiquidityLocking: this.subjectedToBootstrapLiquidityLocking,
            feeOwner: this.feeOwner,
            reserved: this.reserved,
        };
    }
    static fromJSON(obj) {
        return new PositionV2({
            lbPair: (0, kit_1.address)(obj.lbPair),
            owner: (0, kit_1.address)(obj.owner),
            liquidityShares: obj.liquidityShares.map((item) => new bn_js_1.default(item)),
            rewardInfos: obj.rewardInfos.map((item) => types.UserRewardInfo.fromJSON(item)),
            feeInfos: obj.feeInfos.map((item) => types.FeeInfo.fromJSON(item)),
            lowerBinId: obj.lowerBinId,
            upperBinId: obj.upperBinId,
            lastUpdatedAt: new bn_js_1.default(obj.lastUpdatedAt),
            totalClaimedFeeXAmount: new bn_js_1.default(obj.totalClaimedFeeXAmount),
            totalClaimedFeeYAmount: new bn_js_1.default(obj.totalClaimedFeeYAmount),
            totalClaimedRewards: obj.totalClaimedRewards.map((item) => new bn_js_1.default(item)),
            operator: (0, kit_1.address)(obj.operator),
            lockReleaseSlot: new bn_js_1.default(obj.lockReleaseSlot),
            subjectedToBootstrapLiquidityLocking: obj.subjectedToBootstrapLiquidityLocking,
            feeOwner: (0, kit_1.address)(obj.feeOwner),
            reserved: obj.reserved,
        });
    }
}
exports.PositionV2 = PositionV2;
//# sourceMappingURL=PositionV2.js.map
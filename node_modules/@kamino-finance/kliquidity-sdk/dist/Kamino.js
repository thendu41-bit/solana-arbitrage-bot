"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Kamino = exports.KAMINO_SCOPE_FEED_ID = exports.HUBBLE_SCOPE_FEED_ID = void 0;
const hubble_config_1 = require("@hubbleprotocol/hubble-config");
const kit_1 = require("@solana/kit");
const bs58_1 = __importDefault(require("bs58"));
const accounts_1 = require("./@codegen/kliquidity/accounts");
const decimal_js_1 = __importDefault(require("decimal.js"));
const instructions_1 = require("./@codegen/whirlpools/instructions");
const accounts_2 = require("./@codegen/whirlpools/accounts");
const whirlpools_core_1 = require("@orca-so/whirlpools-core");
const models_1 = require("./models");
const scope_sdk_1 = require("@kamino-finance/scope-sdk");
const utils_1 = require("./utils");
const instructions_2 = require("./@codegen/kliquidity/instructions");
const bn_js_1 = __importDefault(require("bn.js"));
const StrategyStatus_1 = require("./@codegen/kliquidity/types/StrategyStatus");
const constants_1 = require("./constants");
const types_1 = require("./@codegen/kliquidity/types");
const accounts_3 = require("./@codegen/raydium/accounts");
const services_1 = require("./services");
const StrategyConfigOption_1 = require("./@codegen/kliquidity/types/StrategyConfigOption");
const DefaultStrategyConfig_1 = require("./constants/DefaultStrategyConfig");
const pubkeys_1 = require("./constants/pubkeys");
const CreationParameters_1 = require("./utils/CreationParameters");
const deposit_method_1 = require("./constants/deposit_method");
const JupService_1 = require("./services/JupService");
const PoolSimulationService_1 = require("./services/PoolSimulationService");
const RebalanceType_1 = require("./@codegen/kliquidity/types/RebalanceType");
const transactions_1 = require("./utils/transactions");
const rebalance_methods_1 = require("./rebalance_methods");
const priceReferenceTypes_1 = require("./utils/priceReferenceTypes");
const utils_2 = require("./rebalance_methods/utils");
const consts_1 = require("./rebalance_methods/consts");
const autodriftRebalance_1 = require("./rebalance_methods/autodriftRebalance");
const whirlpools_1 = require("./utils/whirlpools");
const MeteoraService_1 = require("./services/MeteoraService");
const meteora_1 = require("./utils/meteora");
const accounts_4 = require("./@codegen/meteora/accounts");
const instructions_3 = require("./@codegen/meteora/instructions");
const lib_1 = require("@raydium-io/raydium-sdk-v2/lib");
const token_2022_1 = require("@solana-program/token-2022");
const token_1 = require("@solana-program/token");
const system_1 = require("@solana-program/system");
const sysvars_1 = require("@solana/sysvars");
const compat_1 = require("@solana/compat");
const address_lookup_table_1 = require("@solana-program/address-lookup-table");
const lookupTable_1 = require("./utils/lookupTable");
const compat_2 = require("./utils/compat");
const addressEncoder = (0, kit_1.getAddressEncoder)();
exports.HUBBLE_SCOPE_FEED_ID = (0, kit_1.address)('3NJYftD5sjVfxSnUdZ1wVML8f3aC6mp1CXCL6L7TnU8C');
exports.KAMINO_SCOPE_FEED_ID = (0, kit_1.address)('3t4JZcueEzTbVP6kLxXrL3VpWx45jDer4eqysweBchNH');
class Kamino {
    _cluster;
    _rpc;
    _config;
    _globalConfig;
    _scope;
    _kliquidityProgramId;
    _orcaService;
    _raydiumService;
    _meteoraService;
    _jupBaseAPI = JupService_1.DEFAULT_JUP_API_ENDPOINT;
    /**
     * Create a new instance of the Kamino SDK class.
     * @param cluster Name of the Solana cluster
     * @param rpc Connection to the Solana cluster
     * @param globalConfig override kamino global config
     * @param programId override kamino program id
     * @param whirlpoolProgramId override whirlpool program id
     * @param raydiumProgramId override raydium program id
     * @param meteoraProgramId
     * @param jupBaseAPI
     */
    constructor(cluster, rpc, globalConfig, programId, whirlpoolProgramId, raydiumProgramId, meteoraProgramId, jupBaseAPI) {
        this._cluster = cluster;
        this._rpc = rpc;
        this._config = (0, hubble_config_1.getConfigByCluster)(cluster);
        if (programId && programId === pubkeys_1.STAGING_KAMINO_PROGRAM_ID) {
            this._kliquidityProgramId = programId;
            this._globalConfig = pubkeys_1.STAGING_GLOBAL_CONFIG;
        }
        else {
            this._kliquidityProgramId = programId ? programId : (0, compat_1.fromLegacyPublicKey)(this._config.kamino.programId);
            this._globalConfig = globalConfig ? globalConfig : (0, compat_1.fromLegacyPublicKey)(this._config.kamino.globalConfig);
        }
        this._scope = new scope_sdk_1.Scope(cluster, rpc);
        this._orcaService = new services_1.OrcaService(rpc, whirlpoolProgramId);
        this._raydiumService = new services_1.RaydiumService(rpc, raydiumProgramId);
        this._meteoraService = new MeteoraService_1.MeteoraService(rpc, meteoraProgramId);
        if (jupBaseAPI) {
            this._jupBaseAPI = jupBaseAPI;
        }
    }
    getConnection = () => this._rpc;
    getProgramID = () => this._kliquidityProgramId;
    setGlobalConfig = (globalConfig) => {
        this._globalConfig = globalConfig;
    };
    getGlobalConfig = () => this._globalConfig;
    getDepositableTokens = async () => {
        const collateralInfos = await this.getCollateralInfos();
        return collateralInfos.filter((x) => x.mint !== pubkeys_1.DEFAULT_PUBLIC_KEY);
    };
    getCollateralInfos = async () => {
        const config = await this.getGlobalConfigState(this._globalConfig);
        if (!config) {
            throw Error(`Could not fetch globalConfig with pubkey ${this.getGlobalConfig().toString()}`);
        }
        return this.getCollateralInfo(config.tokenInfos);
    };
    getDisabledTokensPrices = async (collateralInfos) => {
        const collInfos = collateralInfos ? collateralInfos : await this.getCollateralInfos();
        const disabledTokens = collInfos.filter((x) => x.disabled && x.mint !== pubkeys_1.DEFAULT_PUBLIC_KEY);
        return JupService_1.JupService.getDollarPrices(disabledTokens.map((x) => x.mint), this._jupBaseAPI);
    };
    getSupportedDexes = () => ['ORCA', 'RAYDIUM', 'METEORA'];
    // todo: see if we can read this dynamically
    getFeeTiersForDex = (dex) => {
        if (dex === 'ORCA') {
            return [new decimal_js_1.default(0.0001), new decimal_js_1.default(0.0005), new decimal_js_1.default(0.003), new decimal_js_1.default(0.01)];
        }
        else if (dex === 'RAYDIUM') {
            return [new decimal_js_1.default(0.0001), new decimal_js_1.default(0.0005), new decimal_js_1.default(0.0025), new decimal_js_1.default(0.01)];
        }
        else if (dex === 'METEORA') {
            return [new decimal_js_1.default(0.0001), new decimal_js_1.default(0.0005), new decimal_js_1.default(0.0025), new decimal_js_1.default(0.01)];
        }
        else {
            throw new Error(`Dex ${dex} is not supported`);
        }
    };
    getRebalanceMethods = () => {
        return [
            CreationParameters_1.ManualRebalanceMethod,
            CreationParameters_1.PricePercentageRebalanceMethod,
            CreationParameters_1.PricePercentageWithResetRangeRebalanceMethod,
            CreationParameters_1.DriftRebalanceMethod,
            CreationParameters_1.TakeProfitMethod,
            CreationParameters_1.PeriodicRebalanceMethod,
            CreationParameters_1.ExpanderMethod,
            CreationParameters_1.AutodriftMethod,
        ];
    };
    getEnabledRebalanceMethods = () => {
        return this.getRebalanceMethods().filter((x) => x.enabled);
    };
    getPriceReferenceTypes = () => {
        return [priceReferenceTypes_1.PoolPriceReferenceType, priceReferenceTypes_1.TwapPriceReferenceType];
    };
    getDefaultRebalanceMethod = () => CreationParameters_1.PricePercentageRebalanceMethod;
    getDefaultParametersForNewVault = async () => {
        const dex = CreationParameters_1.DefaultDex;
        const tokenMintA = CreationParameters_1.DefaultMintTokenA;
        const tokenMintB = CreationParameters_1.DefaultMintTokenB;
        const rebalanceMethod = this.getDefaultRebalanceMethod();
        const feeTier = CreationParameters_1.DefaultFeeTierOrca;
        const tickSpacing = CreationParameters_1.DefaultTickSpacing;
        const rebalancingParameters = await this.getDefaultRebalanceFields(dex, tokenMintA, tokenMintB, tickSpacing, rebalanceMethod);
        const defaultParameters = {
            dex,
            tokenMintA,
            tokenMintB,
            feeTier,
            rebalancingParameters,
        };
        return defaultParameters;
    };
    /**
     * Retunrs what type of rebalance method the fields represent
     */
    getRebalanceTypeFromRebalanceFields = (rebalanceFields) => {
        return (0, utils_2.getRebalanceTypeFromRebalanceFields)(rebalanceFields);
    };
    /**
     * Retunrs the rebalance method the fields represent with more details (description, enabled, etc)
     */
    getRebalanceMethodFromRebalanceFields = (rebalanceFields) => {
        return (0, utils_2.getRebalanceMethodFromRebalanceFields)(rebalanceFields);
    };
    getReferencePriceTypeForStrategy = async (strategy) => {
        const strategyWithAddress = await this.getStrategyStateIfNotFetched(strategy);
        return (0, utils_1.numberToReferencePriceType)(strategyWithAddress.strategy.rebalanceRaw.referencePriceType);
    };
    getFieldsForRebalanceMethod = (rebalanceMethod, dex, fieldOverrides, tokenAMint, tokenBMint, tickSpacing, poolPrice) => {
        switch (rebalanceMethod) {
            case CreationParameters_1.ManualRebalanceMethod:
                return this.getFieldsForManualRebalanceMethod(dex, fieldOverrides, tokenAMint, tokenBMint, poolPrice);
            case CreationParameters_1.PricePercentageRebalanceMethod:
                return this.getFieldsForPricePercentageMethod(dex, fieldOverrides, tokenAMint, tokenBMint, poolPrice);
            case CreationParameters_1.PricePercentageWithResetRangeRebalanceMethod:
                return this.getFieldsForPricePercentageWithResetMethod(dex, fieldOverrides, tokenAMint, tokenBMint, poolPrice);
            case CreationParameters_1.DriftRebalanceMethod:
                return this.getFieldsForDriftRebalanceMethod(dex, fieldOverrides, tickSpacing, tokenAMint, tokenBMint, poolPrice);
            case CreationParameters_1.TakeProfitMethod:
                return this.getFieldsForTakeProfitRebalanceMethod(dex, fieldOverrides, tokenAMint, tokenBMint, poolPrice);
            case CreationParameters_1.PeriodicRebalanceMethod:
                return this.getFieldsForPeriodicRebalanceMethod(dex, fieldOverrides, tokenAMint, tokenBMint, poolPrice);
            case CreationParameters_1.ExpanderMethod:
                return this.getFieldsForExpanderRebalanceMethod(dex, fieldOverrides, tokenAMint, tokenBMint, poolPrice);
            case CreationParameters_1.AutodriftMethod:
                return this.getFieldsForAutodriftRebalanceMethod(dex, fieldOverrides, tokenAMint, tokenBMint, tickSpacing, poolPrice);
            default:
                throw new Error(`Rebalance method ${rebalanceMethod} is not supported`);
        }
    };
    getFieldsForManualRebalanceMethod = async (dex, fieldOverrides, tokenAMint, tokenBMint, poolPrice) => {
        const price = poolPrice ? poolPrice : new decimal_js_1.default(await this.getPriceForPair(dex, tokenAMint, tokenBMint));
        const defaultFields = (0, rebalance_methods_1.getDefaultManualRebalanceFieldInfos)(price);
        let lowerPrice = defaultFields.find((x) => x.label === 'rangePriceLower').value;
        const lowerPriceInput = fieldOverrides.find((x) => x.label === 'rangePriceLower');
        if (lowerPriceInput) {
            lowerPrice = lowerPriceInput.value;
        }
        let upperPrice = defaultFields.find((x) => x.label === 'rangePriceUpper').value;
        const upperPriceInput = fieldOverrides.find((x) => x.label === 'rangePriceUpper');
        if (upperPriceInput) {
            upperPrice = upperPriceInput.value;
        }
        return (0, rebalance_methods_1.getManualRebalanceFieldInfos)(new decimal_js_1.default(lowerPrice), new decimal_js_1.default(upperPrice));
    };
    getFieldsForPricePercentageMethod = async (dex, fieldOverrides, tokenAMint, tokenBMint, poolPrice) => {
        const price = poolPrice ? poolPrice : new decimal_js_1.default(await this.getPriceForPair(dex, tokenAMint, tokenBMint));
        const defaultFields = (0, rebalance_methods_1.getDefaultPricePercentageRebalanceFieldInfos)(price);
        let lowerPriceDifferenceBPS = defaultFields.find((x) => x.label === 'lowerRangeBps').value;
        const lowerPriceDifferenceBPSInput = fieldOverrides.find((x) => x.label === 'lowerRangeBps');
        if (lowerPriceDifferenceBPSInput) {
            lowerPriceDifferenceBPS = lowerPriceDifferenceBPSInput.value;
        }
        let upperPriceDifferenceBPS = defaultFields.find((x) => x.label === 'upperRangeBps').value;
        const upperPriceDifferenceBPSInput = fieldOverrides.find((x) => x.label === 'upperRangeBps');
        if (upperPriceDifferenceBPSInput) {
            upperPriceDifferenceBPS = upperPriceDifferenceBPSInput.value;
        }
        return (0, rebalance_methods_1.getPricePercentageRebalanceFieldInfos)(price, new decimal_js_1.default(lowerPriceDifferenceBPS), new decimal_js_1.default(upperPriceDifferenceBPS));
    };
    getFieldsForPricePercentageWithResetMethod = async (dex, fieldOverrides, tokenAMint, tokenBMint, poolPrice) => {
        const price = poolPrice ? poolPrice : new decimal_js_1.default(await this.getPriceForPair(dex, tokenAMint, tokenBMint));
        const defaultFields = (0, rebalance_methods_1.getDefaultPricePercentageWithResetRebalanceFieldInfos)(price);
        let lowerPriceDifferenceBPS = defaultFields.find((x) => x.label === 'lowerRangeBps').value;
        const lowerPriceDifferenceBPSInput = fieldOverrides.find((x) => x.label === 'lowerRangeBps');
        if (lowerPriceDifferenceBPSInput) {
            lowerPriceDifferenceBPS = lowerPriceDifferenceBPSInput.value;
        }
        let upperPriceDifferenceBPS = defaultFields.find((x) => x.label === 'upperRangeBps').value;
        const upperPriceDifferenceBPSInput = fieldOverrides.find((x) => x.label === 'upperRangeBps');
        if (upperPriceDifferenceBPSInput) {
            upperPriceDifferenceBPS = upperPriceDifferenceBPSInput.value;
        }
        let lowerResetPriceDifferenceBPS = defaultFields.find((x) => x.label === 'resetLowerRangeBps').value;
        const lowerResetPriceDifferenceBPSInput = fieldOverrides.find((x) => x.label === 'resetLowerRangeBps');
        if (lowerResetPriceDifferenceBPSInput) {
            lowerResetPriceDifferenceBPS = lowerResetPriceDifferenceBPSInput.value;
        }
        let upperResetPriceDifferenceBPS = defaultFields.find((x) => x.label === 'resetUpperRangeBps').value;
        const upperResetPriceDifferenceBPSInput = fieldOverrides.find((x) => x.label === 'resetUpperRangeBps');
        if (upperResetPriceDifferenceBPSInput) {
            upperResetPriceDifferenceBPS = upperResetPriceDifferenceBPSInput.value;
        }
        return (0, rebalance_methods_1.getPricePercentageWithResetRebalanceFieldInfos)(price, new decimal_js_1.default(lowerPriceDifferenceBPS), new decimal_js_1.default(upperPriceDifferenceBPS), new decimal_js_1.default(lowerResetPriceDifferenceBPS), new decimal_js_1.default(upperResetPriceDifferenceBPS));
    };
    getFieldsForDriftRebalanceMethod = async (dex, fieldOverrides, tickSpacing, tokenAMint, tokenBMint, poolPrice) => {
        const tokenADecimals = await (0, utils_1.getMintDecimals)(this._rpc, tokenAMint);
        const tokenBDecimals = await (0, utils_1.getMintDecimals)(this._rpc, tokenBMint);
        const price = poolPrice ? poolPrice : new decimal_js_1.default(await this.getPriceForPair(dex, tokenAMint, tokenBMint));
        const defaultFields = (0, rebalance_methods_1.getDefaultDriftRebalanceFieldInfos)(dex, tickSpacing, price, tokenADecimals, tokenBDecimals);
        let startMidTick = defaultFields.find((x) => x.label === 'startMidTick').value;
        const startMidTickInput = fieldOverrides.find((x) => x.label === 'startMidTick');
        if (startMidTickInput) {
            startMidTick = startMidTickInput.value;
        }
        let ticksBelowMid = defaultFields.find((x) => x.label === 'ticksBelowMid').value;
        const ticksBelowMidInput = fieldOverrides.find((x) => x.label === 'ticksBelowMid');
        if (ticksBelowMidInput) {
            ticksBelowMid = ticksBelowMidInput.value;
        }
        let ticksAboveMid = defaultFields.find((x) => x.label === 'ticksAboveMid').value;
        const ticksAboveMidInput = fieldOverrides.find((x) => x.label === 'ticksAboveMid');
        if (ticksAboveMidInput) {
            ticksAboveMid = ticksAboveMidInput.value;
        }
        let secondsPerTick = defaultFields.find((x) => x.label === 'secondsPerTick').value;
        const secondsPerTickInput = fieldOverrides.find((x) => x.label === 'secondsPerTick');
        if (secondsPerTickInput) {
            secondsPerTick = secondsPerTickInput.value;
        }
        let direction = defaultFields.find((x) => x.label === 'direction').value;
        const directionInput = fieldOverrides.find((x) => x.label === 'direction');
        if (directionInput) {
            direction = directionInput.value;
        }
        const fieldInfos = (0, rebalance_methods_1.getDriftRebalanceFieldInfos)(dex, tokenADecimals, tokenBDecimals, tickSpacing, new decimal_js_1.default(startMidTick), new decimal_js_1.default(ticksBelowMid), new decimal_js_1.default(ticksAboveMid), new decimal_js_1.default(secondsPerTick), new decimal_js_1.default(direction));
        return fieldInfos;
    };
    getFieldsForTakeProfitRebalanceMethod = async (dex, fieldOverrides, tokenAMint, tokenBMint, poolPrice) => {
        const price = poolPrice ? poolPrice : new decimal_js_1.default(await this.getPriceForPair(dex, tokenAMint, tokenBMint));
        const defaultFields = (0, rebalance_methods_1.getDefaultTakeProfitRebalanceFieldsInfos)(price);
        let lowerRangePrice = defaultFields.find((x) => x.label === 'rangePriceLower').value;
        const lowerRangePriceInput = fieldOverrides.find((x) => x.label === 'rangePriceLower');
        if (lowerRangePriceInput) {
            lowerRangePrice = lowerRangePriceInput.value;
        }
        let upperRangePrice = defaultFields.find((x) => x.label === 'rangePriceUpper').value;
        const upperRangePriceInput = fieldOverrides.find((x) => x.label === 'rangePriceUpper');
        if (upperRangePriceInput) {
            upperRangePrice = upperRangePriceInput.value;
        }
        let destinationToken = defaultFields.find((x) => x.label === 'destinationToken').value;
        const destinationTokenInput = fieldOverrides.find((x) => x.label === 'destinationToken');
        if (destinationTokenInput) {
            destinationToken = destinationTokenInput.value;
        }
        return (0, rebalance_methods_1.getTakeProfitRebalanceFieldsInfos)(new decimal_js_1.default(lowerRangePrice), new decimal_js_1.default(upperRangePrice), new decimal_js_1.default(destinationToken), true);
    };
    getFieldsForPeriodicRebalanceMethod = async (dex, fieldOverrides, tokenAMint, tokenBMint, poolPrice) => {
        const price = poolPrice ? poolPrice : new decimal_js_1.default(await this.getPriceForPair(dex, tokenAMint, tokenBMint));
        const defaultFields = (0, rebalance_methods_1.getDefaultPeriodicRebalanceFieldInfos)(price);
        let period = new decimal_js_1.default(defaultFields.find((x) => x.label === 'period').value);
        const periodInput = fieldOverrides.find((x) => x.label === 'period');
        if (periodInput) {
            period = new decimal_js_1.default(periodInput.value);
        }
        let lowerPriceDifferenceBPS = defaultFields.find((x) => x.label === 'lowerRangeBps').value;
        const lowerPriceDifferenceBPSInput = fieldOverrides.find((x) => x.label === 'lowerRangeBps');
        if (lowerPriceDifferenceBPSInput) {
            lowerPriceDifferenceBPS = lowerPriceDifferenceBPSInput.value;
        }
        let upperPriceDifferenceBPS = defaultFields.find((x) => x.label === 'upperRangeBps').value;
        const upperPriceDifferenceBPSInput = fieldOverrides.find((x) => x.label === 'upperRangeBps');
        if (upperPriceDifferenceBPSInput) {
            upperPriceDifferenceBPS = upperPriceDifferenceBPSInput.value;
        }
        return (0, rebalance_methods_1.getPeriodicRebalanceRebalanceFieldInfos)(price, period, new decimal_js_1.default(lowerPriceDifferenceBPS), new decimal_js_1.default(upperPriceDifferenceBPS));
    };
    getFieldsForExpanderRebalanceMethod = async (dex, fieldOverrides, tokenAMint, tokenBMint, poolPrice) => {
        const price = poolPrice ? poolPrice : new decimal_js_1.default(await this.getPriceForPair(dex, tokenAMint, tokenBMint));
        const defaultFields = (0, rebalance_methods_1.getDefaultExpanderRebalanceFieldInfos)(price);
        let lowerPriceDifferenceBPS = defaultFields.find((x) => x.label === 'lowerRangeBps').value;
        const lowerPriceDifferenceBPSInput = fieldOverrides.find((x) => x.label === 'lowerRangeBps');
        if (lowerPriceDifferenceBPSInput) {
            lowerPriceDifferenceBPS = lowerPriceDifferenceBPSInput.value;
        }
        let upperPriceDifferenceBPS = defaultFields.find((x) => x.label === 'upperRangeBps').value;
        const upperPriceDifferenceBPSInput = fieldOverrides.find((x) => x.label === 'upperRangeBps');
        if (upperPriceDifferenceBPSInput) {
            upperPriceDifferenceBPS = upperPriceDifferenceBPSInput.value;
        }
        let lowerResetPriceDifferenceBPS = defaultFields.find((x) => x.label === 'resetLowerRangeBps').value;
        const lowerResetPriceDifferenceBPSInput = fieldOverrides.find((x) => x.label === 'resetLowerRangeBps');
        if (lowerResetPriceDifferenceBPSInput) {
            lowerResetPriceDifferenceBPS = lowerResetPriceDifferenceBPSInput.value;
        }
        let upperResetPriceDifferenceBPS = defaultFields.find((x) => x.label === 'resetUpperRangeBps').value;
        const upperResetPriceDifferenceBPSInput = fieldOverrides.find((x) => x.label === 'resetUpperRangeBps');
        if (upperResetPriceDifferenceBPSInput) {
            upperResetPriceDifferenceBPS = upperResetPriceDifferenceBPSInput.value;
        }
        let expansionBPS = defaultFields.find((x) => x.label === 'expansionBps').value;
        const expansionBPSInput = fieldOverrides.find((x) => x.label === 'expansionBps');
        if (expansionBPSInput) {
            expansionBPS = expansionBPSInput.value;
        }
        let maxNumberOfExpansions = defaultFields.find((x) => x.label === 'maxNumberOfExpansions').value;
        const maxNumberOfExpansionsInput = fieldOverrides.find((x) => x.label === 'maxNumberOfExpansions');
        if (maxNumberOfExpansionsInput) {
            maxNumberOfExpansions = maxNumberOfExpansionsInput.value;
        }
        let swapUnevenAllowed = defaultFields.find((x) => x.label === 'swapUnevenAllowed').value;
        const swapUnevenAllowedInput = fieldOverrides.find((x) => x.label === 'swapUnevenAllowed');
        if (swapUnevenAllowedInput) {
            swapUnevenAllowed = swapUnevenAllowedInput.value;
        }
        return (0, rebalance_methods_1.getExpanderRebalanceFieldInfos)(price, new decimal_js_1.default(lowerPriceDifferenceBPS), new decimal_js_1.default(upperPriceDifferenceBPS), new decimal_js_1.default(lowerResetPriceDifferenceBPS), new decimal_js_1.default(upperResetPriceDifferenceBPS), new decimal_js_1.default(expansionBPS), new decimal_js_1.default(maxNumberOfExpansions), new decimal_js_1.default(swapUnevenAllowed));
    };
    getFieldsForAutodriftRebalanceMethod = async (dex, fieldOverrides, tokenAMint, tokenBMint, tickSpacing, poolPrice) => {
        const tokenADecimals = await (0, utils_1.getMintDecimals)(this._rpc, tokenAMint);
        const tokenBDecimals = await (0, utils_1.getMintDecimals)(this._rpc, tokenBMint);
        const price = poolPrice ? poolPrice : new decimal_js_1.default(await this.getPriceForPair(dex, tokenAMint, tokenBMint));
        // TODO: maybe we will need to get real staking price instead of pool price for this to be accurate.
        const defaultFields = (0, autodriftRebalance_1.getDefaultAutodriftRebalanceFieldInfos)(dex, price, tokenADecimals, tokenBDecimals, tickSpacing);
        const lastMidTick = defaultFields.find((x) => x.label === 'lastMidTick').value;
        let initDriftTicksPerEpoch = defaultFields.find((x) => x.label === 'initDriftTicksPerEpoch').value;
        const initDriftTicksPerEpochInput = fieldOverrides.find((x) => x.label === 'initDriftTicksPerEpoch');
        if (initDriftTicksPerEpochInput) {
            initDriftTicksPerEpoch = initDriftTicksPerEpochInput.value;
        }
        let ticksBelowMid = defaultFields.find((x) => x.label === 'ticksBelowMid').value;
        const ticksBelowMidInput = fieldOverrides.find((x) => x.label === 'ticksBelowMid');
        if (ticksBelowMidInput) {
            ticksBelowMid = ticksBelowMidInput.value;
        }
        let ticksAboveMid = defaultFields.find((x) => x.label === 'ticksAboveMid').value;
        const ticksAboveMidInput = fieldOverrides.find((x) => x.label === 'ticksAboveMid');
        if (ticksAboveMidInput) {
            ticksAboveMid = ticksAboveMidInput.value;
        }
        let frontrunMultiplierBps = defaultFields.find((x) => x.label === 'frontrunMultiplierBps').value;
        const frontrunMultiplierBpsInput = fieldOverrides.find((x) => x.label === 'frontrunMultiplierBps');
        if (frontrunMultiplierBpsInput) {
            frontrunMultiplierBps = frontrunMultiplierBpsInput.value;
        }
        let stakingRateASource = defaultFields.find((x) => x.label === 'stakingRateASource').value;
        const stakingRateASourceInput = fieldOverrides.find((x) => x.label === 'stakingRateASource');
        if (stakingRateASourceInput) {
            stakingRateASource = stakingRateASourceInput.value;
        }
        let stakingRateBSource = defaultFields.find((x) => x.label === 'stakingRateBSource').value;
        const stakingRateBSourceInput = fieldOverrides.find((x) => x.label === 'stakingRateBSource');
        if (stakingRateBSourceInput) {
            stakingRateBSource = stakingRateBSourceInput.value;
        }
        let initialDriftDirection = defaultFields.find((x) => x.label === 'initialDriftDirection').value;
        const initialDriftDirectionInput = fieldOverrides.find((x) => x.label === 'initialDriftDirection');
        if (initialDriftDirectionInput) {
            initialDriftDirection = initialDriftDirectionInput.value;
        }
        const fieldInfos = (0, autodriftRebalance_1.getAutodriftRebalanceFieldInfos)(dex, tokenADecimals, tokenBDecimals, tickSpacing, new decimal_js_1.default(lastMidTick), new decimal_js_1.default(initDriftTicksPerEpoch), new decimal_js_1.default(ticksBelowMid), new decimal_js_1.default(ticksAboveMid), new decimal_js_1.default(frontrunMultiplierBps), new decimal_js_1.default(stakingRateASource), new decimal_js_1.default(stakingRateBSource), new decimal_js_1.default(initialDriftDirection));
        return fieldInfos;
    };
    /**
     * Get the price for a given pair of tokens in a given dex; The price comes from any pool having those tokens, not a specific one, so the price may not be exactly the same between different pools with the same tokens. For a specific pool price use getPoolPrice
     * @param strategy
     * @param amountA
     */
    getPriceForPair = async (dex, poolTokenA, poolTokenB) => {
        if (dex === 'ORCA') {
            const pools = await this.getOrcaPoolsForTokens(poolTokenA, poolTokenB);
            if (pools.length === 0) {
                throw new Error(`No pool found for ${poolTokenA.toString()} and ${poolTokenB.toString()}`);
            }
            return Number(pools[0].price);
        }
        else if (dex === 'RAYDIUM') {
            const pools = await this.getRaydiumPoolsForTokens(poolTokenA, poolTokenB);
            if (pools.length === 0) {
                throw new Error(`No pool found for ${poolTokenA.toString()} and ${poolTokenB.toString()}`);
            }
            return pools[0].price;
        }
        else if (dex === 'METEORA') {
            const pools = await this.getMeteoraPoolsForTokens(poolTokenA, poolTokenB);
            if (pools.length === 0) {
                throw new Error(`No pool found for ${poolTokenA.toString()} and ${poolTokenB.toString()}`);
            }
            const decimalsX = await (0, utils_1.getMintDecimals)(this._rpc, poolTokenA);
            const decimalsY = await (0, utils_1.getMintDecimals)(this._rpc, poolTokenB);
            return (0, meteora_1.getPriceOfBinByBinIdWithDecimals)(pools[0].pool.activeId, pools[0].pool.binStep, decimalsX, decimalsY).toNumber();
        }
        else {
            throw new Error(`Dex ${dex} is not supported`);
        }
    };
    getDefaultRebalanceFields = async (dex, poolTokenA, poolTokenB, tickSpacing, rebalanceMethod) => {
        const price = new decimal_js_1.default(await this.getPriceForPair(dex, poolTokenA, poolTokenB));
        const tokenADecimals = await (0, utils_1.getMintDecimals)(this._rpc, poolTokenA);
        const tokenBDecimals = await (0, utils_1.getMintDecimals)(this._rpc, poolTokenB);
        switch (rebalanceMethod) {
            case CreationParameters_1.ManualRebalanceMethod:
                return (0, rebalance_methods_1.getDefaultManualRebalanceFieldInfos)(price);
            case CreationParameters_1.PricePercentageRebalanceMethod:
                return (0, rebalance_methods_1.getDefaultPricePercentageRebalanceFieldInfos)(price);
            case CreationParameters_1.PricePercentageWithResetRangeRebalanceMethod:
                return (0, rebalance_methods_1.getDefaultPricePercentageWithResetRebalanceFieldInfos)(price);
            case CreationParameters_1.DriftRebalanceMethod:
                return (0, rebalance_methods_1.getDefaultDriftRebalanceFieldInfos)(dex, tickSpacing, price, tokenADecimals, tokenBDecimals);
            case CreationParameters_1.TakeProfitMethod:
                return (0, rebalance_methods_1.getDefaultTakeProfitRebalanceFieldsInfos)(price);
            case CreationParameters_1.PeriodicRebalanceMethod:
                return (0, rebalance_methods_1.getDefaultPeriodicRebalanceFieldInfos)(price);
            case CreationParameters_1.ExpanderMethod:
                return (0, rebalance_methods_1.getDefaultExpanderRebalanceFieldInfos)(price);
            case CreationParameters_1.AutodriftMethod:
                return (0, autodriftRebalance_1.getDefaultAutodriftRebalanceFieldInfos)(dex, price, tokenADecimals, tokenBDecimals, tickSpacing);
            default:
                throw new Error(`Rebalance method ${rebalanceMethod} is not supported`);
        }
    };
    /**
     * Return a the pubkey of the pool in a given dex, for given mints and fee tier; if that pool doesn't exist, return default pubkey
     */
    getPoolInitializedForDexPairTier = async (dex, poolTokenA, poolTokenB, feeBPS) => {
        if (dex === 'ORCA') {
            let pool = pubkeys_1.DEFAULT_PUBLIC_KEY;
            const orcaPools = await this.getOrcaPoolsForTokens(poolTokenA, poolTokenB);
            orcaPools.forEach((element) => {
                if (element.feeRate * CreationParameters_1.FullBPS === feeBPS.toNumber()) {
                    pool = (0, kit_1.address)(element.address);
                }
            });
            return pool;
        }
        else if (dex === 'RAYDIUM') {
            const pools = [];
            const raydiumPools = await this.getRaydiumPoolsForTokens(poolTokenA, poolTokenB);
            raydiumPools.forEach((element) => {
                if (new decimal_js_1.default(element.ammConfig.tradeFeeRate).div(CreationParameters_1.FullBPS).div(CreationParameters_1.FullPercentage).equals(feeBPS.div(CreationParameters_1.FullBPS))) {
                    pools.push(element);
                }
            });
            if (pools.length === 0) {
                return pubkeys_1.DEFAULT_PUBLIC_KEY;
            }
            let pool = pubkeys_1.DEFAULT_PUBLIC_KEY;
            let tickSpacing = Number.MAX_VALUE;
            pools.forEach((element) => {
                if (element.ammConfig.tickSpacing < tickSpacing) {
                    pool = (0, kit_1.address)(element.id);
                    tickSpacing = element.ammConfig.tickSpacing;
                }
            });
            return pool;
        }
        else if (dex === 'METEORA') {
            let pool = pubkeys_1.DEFAULT_PUBLIC_KEY;
            const pools = await this.getMeteoraPoolsForTokens(poolTokenA, poolTokenB);
            pools.forEach((element) => {
                const feeRateBps = element.pool.parameters.baseFactor * element.pool.binStep;
                if (feeRateBps === feeBPS.toNumber()) {
                    pool = (0, kit_1.address)(element.key);
                }
            });
            return pool;
        }
        else {
            throw new Error(`Dex ${dex} is not supported`);
        }
    };
    /**
     * Return generic information for all pools in a given dex, for given mints and fee tier
     */
    async getExistentPoolsForPair(dex, tokenMintA, tokenMintB) {
        if (dex === 'ORCA') {
            const pools = await this.getOrcaPoolsForTokens(tokenMintA, tokenMintB);
            const genericPoolInfos = await Promise.all(pools.map(async (pool) => {
                const positionsCount = new decimal_js_1.default(await this.getPositionsCountForPool(dex, (0, kit_1.address)(pool.address)));
                // read price from pool
                const poolData = await this._orcaService.getOrcaWhirlpool((0, kit_1.address)(pool.address));
                if (!poolData) {
                    throw new Error(`Pool ${pool.address} not found`);
                }
                const poolInfo = {
                    dex,
                    address: (0, kit_1.address)(pool.address),
                    price: new decimal_js_1.default((0, whirlpools_core_1.sqrtPriceToPrice)(BigInt(poolData.sqrtPrice), pool.tokenA.decimals, pool.tokenB.decimals)),
                    tokenMintA: (0, kit_1.address)(pool.tokenMintA),
                    tokenMintB: (0, kit_1.address)(pool.tokenMintB),
                    tvl: pool.tvlUsdc ? new decimal_js_1.default(pool.tvlUsdc) : undefined,
                    feeRate: new decimal_js_1.default(pool.feeRate).mul(CreationParameters_1.FullBPS),
                    volumeOnLast7d: pool.stats['7d'] ? new decimal_js_1.default(pool.stats['7d'].volume) : undefined,
                    tickSpacing: new decimal_js_1.default(pool.tickSpacing),
                    positions: positionsCount,
                };
                return poolInfo;
            }));
            return genericPoolInfos;
        }
        else if (dex === 'RAYDIUM') {
            const pools = await this.getRaydiumPoolsForTokens(tokenMintA, tokenMintB);
            const genericPoolInfos = await Promise.all(pools.map(async (pool) => {
                const positionsCount = new decimal_js_1.default(await this.getPositionsCountForPool(dex, (0, kit_1.address)(pool.id)));
                const poolInfo = {
                    dex,
                    address: (0, kit_1.address)(pool.id),
                    price: new decimal_js_1.default(pool.price),
                    tokenMintA: (0, kit_1.address)(pool.mintA),
                    tokenMintB: (0, kit_1.address)(pool.mintB),
                    tvl: new decimal_js_1.default(pool.tvl),
                    feeRate: new decimal_js_1.default(pool.ammConfig.tradeFeeRate).div(new decimal_js_1.default(CreationParameters_1.FullPercentage)),
                    volumeOnLast7d: new decimal_js_1.default(pool.week.volume),
                    tickSpacing: new decimal_js_1.default(pool.ammConfig.tickSpacing),
                    positions: positionsCount,
                };
                return poolInfo;
            }));
            return genericPoolInfos;
        }
        else if (dex === 'METEORA') {
            const pools = await this.getMeteoraPoolsForTokens(tokenMintA, tokenMintB);
            const genericPoolInfos = await Promise.all(pools.map(async (pool) => {
                const positionsCount = new decimal_js_1.default(await this.getPositionsCountForPool(dex, pool.key));
                const decimalsX = await (0, utils_1.getMintDecimals)(this._rpc, pool.pool.tokenXMint);
                const decimalsY = await (0, utils_1.getMintDecimals)(this._rpc, pool.pool.tokenYMint);
                const price = (0, meteora_1.getPriceOfBinByBinIdWithDecimals)(pool.pool.activeId, pool.pool.binStep, decimalsX, decimalsY);
                const poolInfo = {
                    dex,
                    address: pool.key,
                    price,
                    tokenMintA: pool.pool.tokenXMint,
                    tokenMintB: pool.pool.tokenYMint,
                    tvl: new decimal_js_1.default(0),
                    feeRate: (0, MeteoraService_1.computeMeteoraFee)(pool.pool).div(1e2), // Transform it to rate
                    volumeOnLast7d: new decimal_js_1.default(0),
                    tickSpacing: new decimal_js_1.default(pool.pool.binStep),
                    positions: positionsCount,
                };
                return poolInfo;
            }));
            return genericPoolInfos;
        }
        else {
            throw new Error(`Dex ${dex} is not supported`);
        }
    }
    getOrcaPoolsForTokens = async (poolTokenA, poolTokenB) => {
        const pools = [];
        const poolTokenAString = poolTokenA.toString();
        const poolTokenBString = poolTokenB.toString();
        const whirlpools = await this._orcaService.getOrcaWhirlpools();
        whirlpools.forEach((element) => {
            if ((element.tokenMintA === poolTokenAString && element.tokenMintB === poolTokenBString) ||
                (element.tokenMintA === poolTokenBString && element.tokenMintB === poolTokenAString))
                pools.push(element);
        });
        return pools;
    };
    getRaydiumPoolsForTokens = async (poolTokenA, poolTokenB) => {
        const pools = [];
        const poolTokenAString = poolTokenA.toString();
        const poolTokenBString = poolTokenB.toString();
        const raydiumPools = await this._raydiumService.getRaydiumWhirlpools();
        raydiumPools.data.forEach((element) => {
            if ((element.mintA === poolTokenAString && element.mintB === poolTokenBString) ||
                (element.mintA === poolTokenBString && element.mintB === poolTokenAString)) {
                pools.push(element);
            }
        });
        return pools;
    };
    getMeteoraPoolsForTokens = async (poolTokenA, poolTokenB) => {
        const pools = [];
        const meteoraPools = await this._meteoraService.getMeteoraPools();
        meteoraPools.forEach((element) => {
            if ((element.pool.tokenXMint === poolTokenA && element.pool.tokenYMint === poolTokenB) ||
                (element.pool.tokenXMint === poolTokenB && element.pool.tokenYMint === poolTokenA)) {
                pools.push(element);
            }
        });
        return pools;
    };
    /**
     * Return a list of all Kamino whirlpool strategies
     * @param strategies Limit results to these strategy addresses
     */
    getStrategies = async (strategies) => {
        if (!strategies) {
            strategies = (await this.getAllStrategiesWithFilters({})).map((x) => x.address);
        }
        return await (0, utils_1.batchFetch)(strategies, (chunk) => this.getWhirlpoolStrategies(chunk));
    };
    /**
     * Return a list of all Kamino whirlpool strategies with their addresses
     * @param strategies Limit results to these strategy addresses
     */
    getStrategiesWithAddresses = async (strategies) => {
        if (!strategies) {
            return this.getAllStrategiesWithFilters({});
        }
        const result = [];
        const states = await (0, utils_1.batchFetch)(strategies, (chunk) => this.getWhirlpoolStrategies(chunk));
        for (let i = 0; i < strategies.length; i++) {
            if (states[i]) {
                result.push({ address: strategies[i], strategy: states[i] });
            }
            else {
                throw Error(`Could not fetch strategy state for ${strategies[i].toString()}`);
            }
        }
        return result;
    };
    getAllStrategiesWithFilters = async (strategyFilters) => {
        const filters = [];
        filters.push({
            dataSize: BigInt(accounts_1.WhirlpoolStrategy.layout.span + 8),
        });
        filters.push({
            memcmp: {
                offset: 0n,
                bytes: bs58_1.default.encode(accounts_1.WhirlpoolStrategy.discriminator),
                encoding: 'base58',
            },
        });
        if (strategyFilters.owner) {
            filters.push({
                memcmp: {
                    offset: 8n,
                    bytes: strategyFilters.owner.toString(),
                    encoding: 'base58',
                },
            });
        }
        if (strategyFilters.strategyCreationStatus) {
            filters.push({
                memcmp: {
                    offset: 1625n,
                    bytes: (0, utils_1.strategyCreationStatusToBase58)(strategyFilters.strategyCreationStatus),
                    encoding: 'base58',
                },
            });
        }
        if (strategyFilters.strategyType) {
            filters.push({
                memcmp: {
                    offset: 1120n,
                    bytes: (0, utils_1.strategyTypeToBase58)(strategyFilters.strategyType).toString(),
                    encoding: 'base58',
                },
            });
        }
        if (strategyFilters.isCommunity !== undefined && strategyFilters.isCommunity !== null) {
            const value = !strategyFilters.isCommunity ? '1' : '2';
            filters.push({
                memcmp: {
                    offset: 1664n,
                    bytes: value,
                    encoding: 'base58',
                },
            });
        }
        return (await this._rpc
            .getProgramAccounts(this.getProgramID(), {
            filters,
            encoding: 'base64',
        })
            .send()).map((x) => {
            const res = {
                strategy: accounts_1.WhirlpoolStrategy.decode(Buffer.from(x.account.data[0], 'base64')),
                address: x.pubkey,
            };
            return res;
        });
    };
    /**
     * Get a Kamino whirlpool strategy by its public key address
     * @param address
     */
    getStrategyByAddress = (address) => this.getWhirlpoolStrategy(address);
    /**
     * Get a Kamino whirlpool strategy by its kToken mint address
     * @param kTokenMint - mint address of the kToken
     */
    getStrategyByKTokenMint = async (kTokenMint) => {
        const filters = [
            {
                dataSize: BigInt(accounts_1.WhirlpoolStrategy.layout.span + 8),
            },
            {
                memcmp: {
                    offset: 0n,
                    bytes: bs58_1.default.encode(accounts_1.WhirlpoolStrategy.discriminator),
                    encoding: 'base58',
                },
            },
            {
                memcmp: {
                    bytes: kTokenMint.toString(),
                    offset: 720n,
                    encoding: 'base58',
                },
            },
        ];
        const matchingStrategies = await this._rpc
            .getProgramAccounts(this.getProgramID(), {
            filters,
            encoding: 'base64',
        })
            .send();
        if (matchingStrategies.length === 0) {
            return null;
        }
        if (matchingStrategies.length > 1) {
            throw new Error(`Multiple strategies found for kToken mint: ${kTokenMint}. Strategies found: ${matchingStrategies.map((x) => x.pubkey)}`);
        }
        const decodedStrategy = accounts_1.WhirlpoolStrategy.decode(Buffer.from(matchingStrategies[0].account.data[0], 'base64'));
        return {
            address: matchingStrategies[0].pubkey,
            strategy: decodedStrategy,
        };
    };
    /**
     * Get the strategy share data (price + balances) of the specified Kamino whirlpool strategy
     * @param strategy
     * @param scopePrices
     */
    getStrategyShareData = async (strategy, scopePrices) => {
        const strategyState = await this.getStrategyStateIfNotFetched(strategy);
        const sharesFactor = decimal_js_1.default.pow(10, strategyState.strategy.sharesMintDecimals.toString());
        const sharesIssued = new decimal_js_1.default(strategyState.strategy.sharesIssued.toString());
        const balances = await this.getStrategyBalances(strategyState.strategy, scopePrices);
        if (sharesIssued.isZero()) {
            return { price: new decimal_js_1.default(1), balance: balances };
        }
        else {
            return { price: balances.computedHoldings.totalSum.div(sharesIssued).mul(sharesFactor), balance: balances };
        }
    };
    /**
     * Get the token A and B per share for the specified Kamino whirlpool strategy
     * @param strategy
     */
    getTokenAAndBPerShare = async (strategy) => {
        const strategyState = await this.getStrategyStateIfNotFetched(strategy);
        const sharesIssued = new decimal_js_1.default(strategyState.strategy.sharesIssued.toString());
        const balances = await this.getStrategyBalances(strategyState.strategy);
        if (sharesIssued.isZero()) {
            return { a: new decimal_js_1.default(0), b: new decimal_js_1.default(0) };
        }
        return { a: balances.tokenAAmounts.div(sharesIssued), b: balances.tokenBAmounts.div(sharesIssued) };
    };
    /**
     * Batch fetch share data for all or a filtered list of strategies
     * @param strategyFilters strategy filters or a list of strategy public keys
     */
    getStrategiesShareData = async (strategyFilters, stratsWithAddresses, collateralInfos, disabledTokensPrices) => {
        const result = [];
        const strategiesWithAddresses = stratsWithAddresses
            ? stratsWithAddresses
            : Array.isArray(strategyFilters)
                ? await this.getStrategiesWithAddresses(strategyFilters)
                : await this.getAllStrategiesWithFilters(strategyFilters);
        const fetchBalances = [];
        const allScopePrices = strategiesWithAddresses.map((x) => x.strategy.scopePrices);
        const scopePrices = await this._scope.getMultipleOraclePrices(allScopePrices);
        const scopePricesMap = scopePrices.reduce((map, [address, price]) => {
            map[address] = price;
            return map;
        }, {});
        const raydiumStrategies = strategiesWithAddresses.filter((x) => x.strategy.strategyDex.toNumber() === (0, utils_1.dexToNumber)('RAYDIUM') && x.strategy.position !== pubkeys_1.DEFAULT_PUBLIC_KEY);
        const raydiumPoolsPromise = this.getRaydiumPools(raydiumStrategies.map((x) => x.strategy.pool));
        const raydiumPositionsPromise = this.getRaydiumPositions(raydiumStrategies.map((x) => x.strategy.position));
        const orcaStrategies = strategiesWithAddresses.filter((x) => x.strategy.strategyDex.toNumber() === (0, utils_1.dexToNumber)('ORCA') && x.strategy.position !== pubkeys_1.DEFAULT_PUBLIC_KEY);
        const orcaPoolsPromise = this.getWhirlpools(orcaStrategies.map((x) => x.strategy.pool));
        const orcaPositionsPromise = this.getOrcaPositions(orcaStrategies.map((x) => x.strategy.position));
        const meteoraStrategies = strategiesWithAddresses.filter((x) => x.strategy.strategyDex.toNumber() === (0, utils_1.dexToNumber)('METEORA') && x.strategy.position !== pubkeys_1.DEFAULT_PUBLIC_KEY);
        const meteoraPoolsPromise = this.getMeteoraPools(meteoraStrategies.map((x) => x.strategy.pool));
        const meteoraPositionsPromise = this.getMeteoraPositions(meteoraStrategies.map((x) => x.strategy.position));
        const [raydiumPools, raydiumPositions, orcaPools, orcaPositions, meteoraPools, meteoraPositions] = await Promise.all([
            raydiumPoolsPromise,
            raydiumPositionsPromise,
            orcaPoolsPromise,
            orcaPositionsPromise,
            meteoraPoolsPromise,
            meteoraPositionsPromise,
        ]);
        const inactiveStrategies = strategiesWithAddresses.filter((x) => x.strategy.position === pubkeys_1.DEFAULT_PUBLIC_KEY);
        const collInfos = collateralInfos ? collateralInfos : await this.getCollateralInfos();
        const disabledPrices = disabledTokensPrices ? disabledTokensPrices : await this.getDisabledTokensPrices(collInfos);
        for (const { strategy, address } of inactiveStrategies) {
            const strategyPrices = await this.getStrategyPrices(strategy, collInfos, scopePricesMap[strategy.scopePrices], disabledPrices);
            result.push({
                address,
                strategy,
                shareData: (0, models_1.getEmptyShareData)({
                    ...strategyPrices,
                    poolPrice: utils_1.ZERO,
                    upperPrice: utils_1.ZERO,
                    lowerPrice: utils_1.ZERO,
                    twapPrice: utils_1.ZERO,
                    lowerResetPrice: utils_1.ZERO,
                    upperResetPrice: utils_1.ZERO,
                }),
            });
        }
        fetchBalances.push(...this.getBalance(raydiumStrategies, raydiumPools, raydiumPositions, this.getRaydiumBalances, collInfos, scopePricesMap, disabledPrices));
        fetchBalances.push(...this.getBalance(orcaStrategies, orcaPools, orcaPositions, this.getOrcaBalances, collInfos, scopePricesMap, disabledPrices));
        fetchBalances.push(...this.getBalance(meteoraStrategies, meteoraPools, meteoraPositions, this.getMeteoraBalances, collInfos, scopePricesMap, disabledPrices));
        const strategyBalances = await Promise.all(fetchBalances);
        for (const { balance, strategyWithAddress } of strategyBalances) {
            const sharesFactor = decimal_js_1.default.pow(10, strategyWithAddress.strategy.sharesMintDecimals.toString());
            const sharesIssued = new decimal_js_1.default(strategyWithAddress.strategy.sharesIssued.toString());
            if (sharesIssued.isZero()) {
                result.push({
                    address: strategyWithAddress.address,
                    strategy: strategyWithAddress.strategy,
                    shareData: { price: new decimal_js_1.default(1), balance },
                });
            }
            else {
                result.push({
                    address: strategyWithAddress.address,
                    strategy: strategyWithAddress.strategy,
                    shareData: { price: balance.computedHoldings.totalSum.div(sharesIssued).mul(sharesFactor), balance },
                });
            }
        }
        return result;
    };
    getBalance = (strategies, pools, positions, fetchBalance, collateralInfos, prices, disabledTokensPrices) => {
        const fetchBalances = [];
        for (let i = 0; i < strategies.length; i++) {
            const { strategy, address } = strategies[i];
            const retrievedPool = { ...pools.get(strategy.pool) };
            const pool = { ...retrievedPool };
            const position = positions[i];
            if (!pool) {
                throw new Error(`Pool ${strategy.pool.toString()} could not be found.`);
            }
            if (!position) {
                throw new Error(`Position ${strategy.position.toString()} could not be found.`);
            }
            fetchBalances.push(fetchBalance(strategy, pool, position, collateralInfos, prices ? prices[strategy.scopePrices] : undefined, disabledTokensPrices).then((balance) => {
                return { balance, strategyWithAddress: { strategy, address } };
            }));
        }
        return fetchBalances;
    };
    getRaydiumBalances = async (strategy, pool, position, collateralInfos, prices, disabledTokensPrices) => {
        const strategyPrices = await this.getStrategyPrices(strategy, collateralInfos, prices, disabledTokensPrices);
        const rebalanceKind = (0, utils_1.numberToRebalanceType)(strategy.rebalanceType);
        const tokenHoldings = this.getRaydiumTokensBalances(strategy, pool, position);
        const computedHoldings = this.getStrategyHoldingsUsd(tokenHoldings.available.a, tokenHoldings.available.b, tokenHoldings.invested.a, tokenHoldings.invested.b, new decimal_js_1.default(strategy.tokenAMintDecimals.toString()), new decimal_js_1.default(strategy.tokenBMintDecimals.toString()), strategyPrices.aPrice, strategyPrices.bPrice);
        const decimalsA = strategy.tokenAMintDecimals.toNumber();
        const decimalsB = strategy.tokenBMintDecimals.toNumber();
        const poolPrice = lib_1.SqrtPriceMath.sqrtPriceX64ToPrice(pool.sqrtPriceX64, decimalsA, decimalsB);
        const twapPrice = strategyPrices.aTwapPrice !== null && strategyPrices.bTwapPrice !== null
            ? strategyPrices.aTwapPrice.div(strategyPrices.bTwapPrice)
            : null;
        const upperPrice = lib_1.SqrtPriceMath.sqrtPriceX64ToPrice(lib_1.SqrtPriceMath.getSqrtPriceX64FromTick(position.tickUpperIndex), decimalsA, decimalsB);
        const lowerPrice = lib_1.SqrtPriceMath.sqrtPriceX64ToPrice(lib_1.SqrtPriceMath.getSqrtPriceX64FromTick(position.tickLowerIndex), decimalsA, decimalsB);
        let lowerResetPrice = null;
        let upperResetPrice = null;
        const dex = (0, utils_1.numberToDex)(strategy.strategyDex.toNumber());
        if (rebalanceKind.kind === RebalanceType_1.PricePercentageWithReset.kind) {
            const state = (0, rebalance_methods_1.deserializePricePercentageWithResetRebalanceWithStateOverride)(dex, decimalsA, decimalsB, poolPrice, strategy.rebalanceRaw);
            [lowerResetPrice, upperResetPrice] = (0, utils_2.extractPricesFromDeserializedState)(state);
        }
        else if (rebalanceKind.kind === RebalanceType_1.Expander.kind) {
            const state = (0, rebalance_methods_1.deserializeExpanderRebalanceWithStateOverride)(dex, decimalsA, decimalsB, poolPrice, strategy.rebalanceRaw);
            [lowerResetPrice, upperResetPrice] = (0, utils_2.extractPricesFromDeserializedState)(state);
        }
        const balance = {
            computedHoldings,
            prices: { ...strategyPrices, poolPrice, lowerPrice, upperPrice, twapPrice, lowerResetPrice, upperResetPrice },
            tokenAAmounts: tokenHoldings.available.a.plus(tokenHoldings.invested.a),
            tokenBAmounts: tokenHoldings.available.b.plus(tokenHoldings.invested.b),
        };
        return balance;
    };
    getMeteoraBalances = async (strategy, pool, position, // the undefined is for scenarios where the position is not initialised yet
    collateralInfos, prices, disabledTokensPrices) => {
        const strategyPricesPromise = this.getStrategyPrices(strategy, collateralInfos, prices, disabledTokensPrices);
        const rebalanceKind = (0, utils_1.numberToRebalanceType)(strategy.rebalanceType);
        const tokenHoldingsPromise = this.getMeteoraTokensBalances(strategy);
        const [strategyPrices, tokenHoldings] = await Promise.all([strategyPricesPromise, tokenHoldingsPromise]);
        const computedHoldings = this.getStrategyHoldingsUsd(tokenHoldings.available.a, tokenHoldings.available.b, tokenHoldings.invested.a, tokenHoldings.invested.b, new decimal_js_1.default(strategy.tokenAMintDecimals.toString()), new decimal_js_1.default(strategy.tokenBMintDecimals.toString()), strategyPrices.aPrice, strategyPrices.bPrice);
        const decimalsA = strategy.tokenAMintDecimals.toNumber();
        const decimalsB = strategy.tokenBMintDecimals.toNumber();
        const twapPrice = strategyPrices.aTwapPrice !== null && strategyPrices.bTwapPrice !== null
            ? strategyPrices.aTwapPrice.div(strategyPrices.bTwapPrice)
            : null;
        const poolPrice = (0, meteora_1.getPriceOfBinByBinIdWithDecimals)(pool.activeId, pool.binStep, decimalsA, decimalsB);
        let lowerPrice = utils_1.ZERO;
        let upperPrice = utils_1.ZERO;
        if (position && position.lowerBinId && position.upperBinId) {
            lowerPrice = (0, meteora_1.getPriceOfBinByBinIdWithDecimals)(position.lowerBinId, pool.binStep, decimalsA, decimalsB);
            upperPrice = (0, meteora_1.getPriceOfBinByBinIdWithDecimals)(position.upperBinId, pool.binStep, decimalsA, decimalsB);
        }
        let lowerResetPrice = null;
        let upperResetPrice = null;
        const dex = (0, utils_1.numberToDex)(strategy.strategyDex.toNumber());
        if (rebalanceKind.kind === RebalanceType_1.PricePercentageWithReset.kind) {
            const state = (0, rebalance_methods_1.deserializePricePercentageWithResetRebalanceWithStateOverride)(dex, decimalsA, decimalsB, poolPrice, strategy.rebalanceRaw);
            [lowerResetPrice, upperResetPrice] = (0, utils_2.extractPricesFromDeserializedState)(state);
        }
        else if (rebalanceKind.kind === RebalanceType_1.Expander.kind) {
            const state = (0, rebalance_methods_1.deserializeExpanderRebalanceWithStateOverride)(dex, decimalsA, decimalsB, poolPrice, strategy.rebalanceRaw);
            [lowerResetPrice, upperResetPrice] = (0, utils_2.extractPricesFromDeserializedState)(state);
        }
        const balance = {
            computedHoldings,
            prices: { ...strategyPrices, poolPrice, lowerPrice, upperPrice, twapPrice, lowerResetPrice, upperResetPrice },
            tokenAAmounts: tokenHoldings.available.a.plus(tokenHoldings.invested.a),
            tokenBAmounts: tokenHoldings.available.b.plus(tokenHoldings.invested.b),
        };
        return balance;
    };
    getRaydiumTokensBalances = (strategy, pool, position, mode = 'WITHDRAW') => {
        const lowerSqrtPriceX64 = lib_1.SqrtPriceMath.getSqrtPriceX64FromTick(position.tickLowerIndex);
        const upperSqrtPriceX64 = lib_1.SqrtPriceMath.getSqrtPriceX64FromTick(position.tickUpperIndex);
        const { amountA, amountB } = lib_1.LiquidityMath.getAmountsFromLiquidity(pool.sqrtPriceX64, new bn_js_1.default(lowerSqrtPriceX64), new bn_js_1.default(upperSqrtPriceX64), position.liquidity, mode === 'DEPOSIT');
        const aAvailable = new decimal_js_1.default(strategy.tokenAAmounts.toString());
        const bAvailable = new decimal_js_1.default(strategy.tokenBAmounts.toString());
        const aInvested = new decimal_js_1.default(amountA.toString());
        const bInvested = new decimal_js_1.default(amountB.toString());
        const holdings = {
            available: {
                a: aAvailable,
                b: bAvailable,
            },
            invested: {
                a: aInvested,
                b: bInvested,
            },
        };
        return holdings;
    };
    getMeteoraTokensBalances = async (strategy) => {
        let aInvested = utils_1.ZERO;
        let bInvested = utils_1.ZERO;
        try {
            const userPosition = await this.readMeteoraPosition(strategy.pool, strategy.position);
            if (!userPosition?.amountX.isNaN() && !userPosition?.amountY.isNaN()) {
                aInvested = userPosition.amountX;
                bInvested = userPosition.amountY;
            }
        }
        catch (e) {
            // @tslint:disable-next-line no-empty
        }
        const aAvailable = new decimal_js_1.default(strategy.tokenAAmounts.toString());
        const bAvailable = new decimal_js_1.default(strategy.tokenBAmounts.toString());
        const holdings = {
            available: {
                a: aAvailable,
                b: bAvailable,
            },
            invested: {
                a: new decimal_js_1.default(aInvested),
                b: new decimal_js_1.default(bInvested),
            },
        };
        return holdings;
    };
    getOrcaBalances = async (strategy, pool, position, collateralInfos, prices, disabledTokensPrices, mode = 'WITHDRAW') => {
        const strategyPrices = await this.getStrategyPrices(strategy, collateralInfos, prices, disabledTokensPrices);
        const rebalanceKind = (0, utils_1.numberToRebalanceType)(strategy.rebalanceType);
        const tokenHoldings = this.getOrcaTokensBalances(strategy, pool, position, mode);
        const computedHoldings = this.getStrategyHoldingsUsd(tokenHoldings.available.a, tokenHoldings.available.b, tokenHoldings.invested.a, tokenHoldings.invested.b, new decimal_js_1.default(strategy.tokenAMintDecimals.toString()), new decimal_js_1.default(strategy.tokenBMintDecimals.toString()), strategyPrices.aPrice, strategyPrices.bPrice);
        const decimalsA = strategy.tokenAMintDecimals.toNumber();
        const decimalsB = strategy.tokenBMintDecimals.toNumber();
        const poolPrice = new decimal_js_1.default((0, whirlpools_core_1.sqrtPriceToPrice)(BigInt(pool.sqrtPrice.toString()), decimalsA, decimalsB));
        const twapPrice = strategyPrices.aTwapPrice !== null && strategyPrices.bTwapPrice !== null
            ? strategyPrices.aTwapPrice.div(strategyPrices.bTwapPrice)
            : null;
        const upperPrice = new decimal_js_1.default((0, whirlpools_core_1.tickIndexToPrice)(position.tickUpperIndex, decimalsA, decimalsB));
        const lowerPrice = new decimal_js_1.default((0, whirlpools_core_1.tickIndexToPrice)(position.tickLowerIndex, decimalsA, decimalsB));
        let lowerResetPrice = null;
        let upperResetPrice = null;
        const dex = (0, utils_1.numberToDex)(strategy.strategyDex.toNumber());
        if (rebalanceKind.kind === RebalanceType_1.PricePercentageWithReset.kind) {
            const state = (0, rebalance_methods_1.deserializePricePercentageWithResetRebalanceWithStateOverride)(dex, decimalsA, decimalsB, poolPrice, strategy.rebalanceRaw);
            [lowerResetPrice, upperResetPrice] = (0, utils_2.extractPricesFromDeserializedState)(state);
        }
        else if (rebalanceKind.kind === RebalanceType_1.Expander.kind) {
            const state = (0, rebalance_methods_1.deserializeExpanderRebalanceWithStateOverride)(dex, decimalsA, decimalsB, poolPrice, strategy.rebalanceRaw);
            [lowerResetPrice, upperResetPrice] = (0, utils_2.extractPricesFromDeserializedState)(state);
        }
        const balance = {
            computedHoldings,
            prices: { ...strategyPrices, poolPrice, lowerPrice, upperPrice, twapPrice, lowerResetPrice, upperResetPrice },
            tokenAAmounts: tokenHoldings.available.a.plus(tokenHoldings.invested.a),
            tokenBAmounts: tokenHoldings.available.b.plus(tokenHoldings.invested.b),
        };
        return balance;
    };
    getOrcaTokensBalances = (strategy, pool, position, mode = 'WITHDRAW') => {
        const quote = (0, whirlpools_1.getRemoveLiquidityQuote)({
            positionAddress: strategy.position,
            liquidity: position.liquidity,
            slippageTolerance: { numerator: constants_1.ZERO_BN, denominator: new bn_js_1.default(1000) },
            sqrtPrice: pool.sqrtPrice,
            tickLowerIndex: position.tickLowerIndex,
            tickUpperIndex: position.tickUpperIndex,
            tickCurrentIndex: pool.tickCurrentIndex,
        }, mode === 'DEPOSIT');
        const aAvailable = new decimal_js_1.default(strategy.tokenAAmounts.toString());
        const bAvailable = new decimal_js_1.default(strategy.tokenBAmounts.toString());
        const aInvested = new decimal_js_1.default(quote.estTokenA.toString());
        const bInvested = new decimal_js_1.default(quote.estTokenB.toString());
        const holdings = {
            available: {
                a: aAvailable,
                b: bAvailable,
            },
            invested: {
                a: aInvested,
                b: bInvested,
            },
        };
        return holdings;
    };
    /**
     * Get the strategies share data (price + balances) of the Kamino whirlpool strategies that match the filters
     * @param strategyFilters
     */
    getStrategyShareDataForStrategies = async (strategyFilters) => {
        // weird name of method, but want to keep this method backwards compatible and not rename it
        return this.getStrategiesShareData(strategyFilters);
    };
    /**
     * Get the strategy share price of the specified Kamino whirlpool strategy
     * @param strategy
     */
    getStrategySharePrice = async (strategy) => {
        const strategyState = await this.getStrategyStateIfNotFetched(strategy);
        const sharesFactor = decimal_js_1.default.pow(10, strategyState.strategy.sharesMintDecimals.toString());
        const sharesIssued = new decimal_js_1.default(strategyState.strategy.sharesIssued.toString());
        const balances = await this.getStrategyBalances(strategyState.strategy);
        if (sharesIssued.isZero()) {
            return new decimal_js_1.default(1);
        }
        else {
            return balances.computedHoldings.totalSum.div(sharesIssued).mul(sharesFactor);
        }
    };
    getTokenAccountBalance = async (tokenAccount) => {
        const tokenAccountBalance = await this._rpc.getTokenAccountBalance(tokenAccount).send();
        if (!tokenAccountBalance.value) {
            throw new Error(`Could not get token account balance for ${tokenAccount.toString()}.`);
        }
        return new decimal_js_1.default(tokenAccountBalance.value.uiAmountString);
    };
    /**
     * Get the balance of a token account or 0 if it doesn't exist
     * @param tokenAccount
     */
    getTokenAccountBalanceOrZero = async (tokenAccount) => {
        const tokenAccountExists = await (0, transactions_1.checkIfAccountExists)(this._rpc, tokenAccount);
        if (tokenAccountExists) {
            return await this.getTokenAccountBalance(tokenAccount);
        }
        else {
            return new decimal_js_1.default(0);
        }
    };
    getStrategyBalances = async (strategy, scopePrices, disabledTokensPrices) => {
        const collateralInfos = await this.getCollateralInfos();
        let disabledPrices = disabledTokensPrices;
        if (!disabledPrices) {
            disabledPrices = await this.getDisabledTokensPrices(collateralInfos);
        }
        if (strategy.strategyDex.toNumber() === (0, utils_1.dexToNumber)('ORCA')) {
            return this.getStrategyBalancesOrca(strategy, collateralInfos, scopePrices, disabledPrices);
        }
        else if (strategy.strategyDex.toNumber() === (0, utils_1.dexToNumber)('RAYDIUM')) {
            return this.getStrategyBalancesRaydium(strategy, collateralInfos, scopePrices, disabledPrices);
        }
        else if (strategy.strategyDex.toNumber() === (0, utils_1.dexToNumber)('METEORA')) {
            return this.getStrategyBalancesMeteora(strategy, collateralInfos, scopePrices, disabledPrices);
        }
        else {
            throw new Error(`Invalid dex ${strategy.strategyDex.toString()}`);
        }
    };
    getStrategyTokensBalances = async (strategy, mode = 'WITHDRAW') => {
        if (strategy.strategyDex.toNumber() === (0, utils_1.dexToNumber)('ORCA')) {
            const [whirlpoolAcc, positionAcc] = (await this.getConnection().getMultipleAccounts([strategy.pool, strategy.position]).send()).value;
            if (!whirlpoolAcc) {
                throw Error(`Could not fetch Orca whirlpool state with pubkey ${strategy.pool.toString()}`);
            }
            if (!positionAcc) {
                throw Error(`Could not fetch Orca whirlpool position state with pubkey ${strategy.position.toString()}`);
            }
            const whirlpool = accounts_2.Whirlpool.decode(Buffer.from(whirlpoolAcc.data[0], 'base64'));
            const position = accounts_2.Position.decode(Buffer.from(positionAcc.data[0], 'base64'));
            return this.getOrcaTokensBalances(strategy, whirlpool, position, mode);
        }
        else if (strategy.strategyDex.toNumber() === (0, utils_1.dexToNumber)('RAYDIUM')) {
            const [poolStateAcc, positionAcc] = (await this.getConnection().getMultipleAccounts([strategy.pool, strategy.position]).send()).value;
            if (!poolStateAcc) {
                throw Error(`Could not fetch Raydium pool state with pubkey ${strategy.pool.toString()}`);
            }
            if (!positionAcc) {
                throw Error(`Could not fetch Raydium position state with pubkey ${strategy.position.toString()}`);
            }
            const poolState = accounts_3.PoolState.decode(Buffer.from(poolStateAcc.data[0], 'base64'));
            const position = accounts_3.PersonalPositionState.decode(Buffer.from(positionAcc.data[0], 'base64'));
            return this.getRaydiumTokensBalances(strategy, poolState, position, mode);
        }
        else if (strategy.strategyDex.toNumber() === (0, utils_1.dexToNumber)('METEORA')) {
            return this.getMeteoraTokensBalances(strategy);
        }
        else {
            throw new Error(`Invalid dex ${strategy.strategyDex.toString()}`);
        }
    };
    /**
     * Get amount of specified token in all Kamino live strategies
     * @param tokenMint token mint pubkey
     */
    getTotalTokensInStrategies = async (tokenMint) => {
        const strategies = await this.getStrategiesShareData({ strategyCreationStatus: 'LIVE' });
        let totalTokenAmount = new decimal_js_1.default(0);
        const vaults = [];
        for (const { strategy, address: ad, shareData } of strategies) {
            const aTotal = shareData.balance.computedHoldings.invested.a.plus(shareData.balance.computedHoldings.available.a);
            const bTotal = shareData.balance.computedHoldings.invested.b.plus(shareData.balance.computedHoldings.available.b);
            let amount = new decimal_js_1.default(0);
            if (strategy.tokenAMint === (0, kit_1.address)(tokenMint) && aTotal.greaterThan(0)) {
                amount = aTotal;
            }
            else if (strategy.tokenBMint === (0, kit_1.address)(tokenMint) && bTotal.greaterThan(0)) {
                amount = bTotal;
            }
            if (amount.greaterThan(0)) {
                totalTokenAmount = totalTokenAmount.plus(amount);
                vaults.push({
                    address: ad,
                    frontendUrl: `${constants_1.FRONTEND_KAMINO_STRATEGY_URL}/${ad}`,
                    amount,
                });
            }
        }
        return { totalTokenAmount, vaults, timestamp: new Date() };
    };
    getAccountOwner = async (pk) => {
        const acc = await this.getConnection().getAccountInfo(pk).send();
        if (acc.value === null) {
            throw Error(`Could not fetch mint ${pk}`);
        }
        return acc.value.owner;
    };
    getStrategyBalancesOrca = async (strategy, collateralInfos, scopePrices, disabledTokensPrices) => {
        const res = await this.getConnection().getMultipleAccounts([strategy.pool, strategy.position]).send();
        const [whirlpoolAcc, positionAcc] = res.value;
        if (!whirlpoolAcc) {
            throw Error(`Could not fetch Orca whirlpool state with pubkey ${strategy.pool.toString()}`);
        }
        if (!positionAcc) {
            throw Error(`Could not fetch Orca whirlpool position state with pubkey ${strategy.position.toString()}`);
        }
        const whirlpool = accounts_2.Whirlpool.decode(Buffer.from(whirlpoolAcc.data[0], 'base64'));
        const position = accounts_2.Position.decode(Buffer.from(positionAcc.data[0], 'base64'));
        return this.getOrcaBalances(strategy, whirlpool, position, collateralInfos, scopePrices, disabledTokensPrices, undefined);
    };
    getStrategyBalancesRaydium = async (strategy, collateralInfos, scopePrices, disabledTokensPrices) => {
        const res = await (0, kit_1.fetchEncodedAccounts)(this.getConnection(), [strategy.pool, strategy.position]);
        const [poolStateAcc, positionAcc] = res;
        if (!poolStateAcc.exists) {
            throw Error(`Could not fetch Raydium pool state with pubkey ${strategy.pool}`);
        }
        if (!positionAcc.exists) {
            throw Error(`Could not fetch Raydium position state with pubkey ${strategy.position}`);
        }
        const poolState = accounts_3.PoolState.decode(Buffer.from(poolStateAcc.data));
        const position = accounts_3.PersonalPositionState.decode(Buffer.from(positionAcc.data));
        return this.getRaydiumBalances(strategy, poolState, position, collateralInfos, scopePrices, disabledTokensPrices);
    };
    getStrategyBalancesMeteora = async (strategy, collateralInfos, scopePrices, disabledTokensPrices) => {
        const res = await this.getConnection().getMultipleAccounts([strategy.pool, strategy.position]).send();
        const [poolStateAcc, positionAcc] = res.value;
        if (!poolStateAcc) {
            throw Error(`Could not fetch Meteora pool state with pubkey ${strategy.pool}`);
        }
        if (!positionAcc) {
            throw Error(`Could not fetch Meteora position state with pubkey ${strategy.position}`);
        }
        const poolState = accounts_4.LbPair.decode(Buffer.from(poolStateAcc.data[0], 'base64'));
        try {
            const position = accounts_4.PositionV2.decode(Buffer.from(positionAcc.data[0], 'base64'));
            return this.getMeteoraBalances(strategy, poolState, position, collateralInfos, scopePrices, disabledTokensPrices);
        }
        catch (e) {
            return this.getMeteoraBalances(strategy, poolState, undefined, collateralInfos, scopePrices, disabledTokensPrices);
        }
    };
    getStrategyHoldingsUsd = (aAvailable, bAvailable, aInvested, bInvested, decimalsA, decimalsB, aPrice, bPrice) => {
        const aAvailableScaled = aAvailable.div(decimal_js_1.default.pow(10, decimalsA));
        const bAvailableScaled = bAvailable.div(decimal_js_1.default.pow(10, decimalsB));
        const aInvestedScaled = aInvested.div(decimal_js_1.default.pow(10, decimalsA));
        const bInvestedScaled = bInvested.div(decimal_js_1.default.pow(10, decimalsB));
        const availableUsd = aPrice && bPrice ? aAvailableScaled.mul(aPrice).add(bAvailableScaled.mul(bPrice)) : new decimal_js_1.default(0);
        const investedUsd = aPrice && bPrice ? aInvestedScaled.mul(aPrice).add(bInvestedScaled.mul(bPrice)) : new decimal_js_1.default(0);
        return {
            available: {
                a: aAvailableScaled,
                b: bAvailableScaled,
            },
            availableUsd: availableUsd,
            invested: {
                a: aInvestedScaled,
                b: bInvestedScaled,
            },
            investedUsd: investedUsd,
            totalSum: availableUsd.add(investedUsd),
        };
    };
    getAllOraclePrices = (prices) => this._scope.getOraclePrices(prices);
    /**
     * Get all Kamino token spot and twap prices
     * @param oraclePrices (optional) Scope Oracle prices
     * @param collateralInfos (optional) Kamino Collateral Infos
     */
    getAllPrices = async (oraclePrices, collateralInfos, disabledTokensPrices) => {
        // todo: make MintToPriceMap have Pubkey as key
        const spotPrices = {};
        const twaps = {};
        const disabledTokens = [];
        const oraclePricesAndCollateralInfos = await this.getOraclePricesAndCollateralInfos(oraclePrices ? [[exports.HUBBLE_SCOPE_FEED_ID, oraclePrices]] : undefined, collateralInfos, true);
        const { oraclePrices: allOraclePrices, collateralInfos: hubbleCollateralInfos } = oraclePricesAndCollateralInfos;
        for (const collateralInfo of hubbleCollateralInfos) {
            if (collateralInfo.scopePriceChain &&
                scope_sdk_1.Scope.isScopeChainValid(collateralInfo.scopePriceChain) &&
                collateralInfo.disabled === 0) {
                const collInfoMintString = collateralInfo.mint.toString();
                const hubbleOraclePrices = allOraclePrices?.find((x) => x[0] === exports.HUBBLE_SCOPE_FEED_ID)?.[1];
                const spotPrice = await this._scope.getPriceFromChain(collateralInfo.scopePriceChain, hubbleOraclePrices);
                spotPrices[collInfoMintString] = {
                    price: spotPrice.price,
                    name: (0, utils_1.getTokenNameFromCollateralInfo)(collateralInfo),
                };
                const filteredTwapChain = collateralInfo?.scopeTwapPriceChain?.filter((x) => x > 0);
                if (filteredTwapChain && scope_sdk_1.Scope.isScopeChainValid(filteredTwapChain)) {
                    const twap = await this._scope.getPriceFromChain(filteredTwapChain, hubbleOraclePrices);
                    twaps[collInfoMintString] = {
                        price: twap.price,
                        name: (0, utils_1.getTokenNameFromCollateralInfo)(collateralInfo),
                    };
                }
            }
            else {
                if (collateralInfo.mint === pubkeys_1.DEFAULT_PUBLIC_KEY) {
                    continue;
                }
                disabledTokens.push(collateralInfo.mint);
            }
        }
        try {
            const tokensPrices = disabledTokensPrices
                ? disabledTokensPrices
                : await JupService_1.JupService.getDollarPrices(disabledTokens, this._jupBaseAPI);
            for (const [token, price] of tokensPrices) {
                const collInfo = hubbleCollateralInfos.find((x) => x.mint === token);
                if (!collInfo) {
                    console.log(`Could not find collateral info for token ${token.toString()}`);
                    continue;
                }
                // if there already is a spot price for this token, skip it
                if (spotPrices[token.toString()]) {
                    continue;
                }
                spotPrices[token.toString()] = {
                    price: new decimal_js_1.default(price),
                    name: (0, utils_1.getTokenNameFromCollateralInfo)(collInfo),
                };
            }
        }
        catch (e) {
            console.error('Failed to get prices for disabled tokens from Jup', e);
        }
        return { spot: spotPrices, twap: twaps };
    };
    async getOraclePricesAndCollateralInfos(oraclePrices, collateralInfos, readAllFeeds = false) {
        if (!oraclePrices) {
            const allFeeds = readAllFeeds ? [exports.HUBBLE_SCOPE_FEED_ID, exports.KAMINO_SCOPE_FEED_ID] : [exports.HUBBLE_SCOPE_FEED_ID];
            oraclePrices = await this.getAllOraclePrices(allFeeds);
        }
        if (!collateralInfos) {
            collateralInfos = await this.getCollateralInfos();
        }
        return { oraclePrices, collateralInfos };
    }
    /**
     * Get the prices of all tokens in the specified strategy, or null if the reward token does not exist
     * @param strategy
     * @param collateralInfos
     * @param scopePrices
     */
    getStrategyPrices = async (strategy, collateralInfos, scopePrices, disabledTokensPrices) => {
        const tokenA = collateralInfos[strategy.tokenACollateralId.toNumber()];
        const tokenB = collateralInfos[strategy.tokenBCollateralId.toNumber()];
        const rewardToken0 = collateralInfos[strategy.reward0CollateralId.toNumber()];
        const rewardToken1 = collateralInfos[strategy.reward1CollateralId.toNumber()];
        const rewardToken2 = collateralInfos[strategy.reward2CollateralId.toNumber()];
        let prices;
        if (scopePrices) {
            prices = scopePrices;
        }
        else {
            prices = await this._scope.getSingleOraclePrices({ prices: strategy.scopePrices });
        }
        let jupPrices;
        if (disabledTokensPrices) {
            jupPrices = disabledTokensPrices;
        }
        else {
            jupPrices = await this.getDisabledTokensPrices(collateralInfos);
        }
        const fallbackTokenAPrice = jupPrices.get(tokenA.mint) ?? new decimal_js_1.default(0);
        const fallbackTokenBPrice = jupPrices.get(tokenB.mint) ?? new decimal_js_1.default(0);
        const fallbackReward0Price = jupPrices.get(rewardToken0.mint) ?? new decimal_js_1.default(0);
        const fallbackReward1Price = jupPrices.get(rewardToken1.mint) ?? new decimal_js_1.default(0);
        const fallbackReward2Price = jupPrices.get(rewardToken2.mint) ?? new decimal_js_1.default(0);
        const aPrice = scope_sdk_1.Scope.isScopeChainValid(tokenA.scopePriceChain)
            ? (await this._scope.getPriceFromChain(tokenA.scopePriceChain, prices)).price
            : fallbackTokenAPrice;
        const bPrice = scope_sdk_1.Scope.isScopeChainValid(tokenB.scopePriceChain)
            ? (await this._scope.getPriceFromChain(tokenB.scopePriceChain, prices)).price
            : fallbackTokenBPrice;
        const tokenATwap = (0, utils_1.stripTwapZeros)(tokenA.scopeTwapPriceChain);
        const tokenBTwap = (0, utils_1.stripTwapZeros)(tokenB.scopeTwapPriceChain);
        const aTwapPrice = scope_sdk_1.Scope.isScopeChainValid(tokenATwap)
            ? await this._scope.getPriceFromChain(tokenATwap, prices)
            : null;
        const bTwapPrice = scope_sdk_1.Scope.isScopeChainValid(tokenBTwap)
            ? await this._scope.getPriceFromChain(tokenBTwap, prices)
            : null;
        let reward0Price = null;
        if (strategy.reward0Decimals.toNumber() !== 0) {
            reward0Price = scope_sdk_1.Scope.isScopeChainValid(rewardToken0.scopePriceChain)
                ? (await this._scope.getPriceFromChain(rewardToken0.scopePriceChain, prices)).price
                : fallbackReward0Price;
        }
        let reward1Price = null;
        if (strategy.reward1Decimals.toNumber() !== 0) {
            reward1Price = scope_sdk_1.Scope.isScopeChainValid(rewardToken1.scopePriceChain)
                ? (await this._scope.getPriceFromChain(rewardToken1.scopePriceChain, prices)).price
                : fallbackReward1Price;
        }
        let reward2Price = null;
        if (strategy.reward2Decimals.toNumber() !== 0) {
            reward2Price = scope_sdk_1.Scope.isScopeChainValid(rewardToken2.scopePriceChain)
                ? (await this._scope.getPriceFromChain(rewardToken2.scopePriceChain, prices)).price
                : fallbackReward2Price;
        }
        return {
            aPrice: aPrice ?? null,
            bPrice: bPrice ?? null,
            aTwapPrice: aTwapPrice?.price ?? null,
            bTwapPrice: bTwapPrice?.price ?? null,
            reward0Price: reward0Price ?? null,
            reward1Price: reward1Price ?? null,
            reward2Price: reward2Price ?? null,
        };
    };
    /**
     * Get all token accounts for the specified share mint
     */
    getShareTokenAccounts = async (shareMint) => {
        //how to get all token accounts for specific mint: https://spl.solana.com/token#finding-all-token-accounts-for-a-specific-mint
        //get it from the hardcoded token program and create a filter with the actual mint address
        //datasize:165 filter selects all token accounts, memcmp filter selects based on the mint address withing each token account
        return this._rpc
            .getProgramAccounts(token_1.TOKEN_PROGRAM_ADDRESS, {
            filters: [
                { dataSize: 165n },
                { memcmp: { offset: 0n, bytes: shareMint.toString(), encoding: 'base58' } },
            ],
            encoding: 'jsonParsed',
        })
            .send();
    };
    /**
     * Get all token accounts for the specified wallet
     */
    getAllTokenAccounts = async (wallet) => {
        //how to get all token accounts for specific wallet: https://spl.solana.com/token#finding-all-token-accounts-for-a-wallet
        return this._rpc
            .getProgramAccounts(token_1.TOKEN_PROGRAM_ADDRESS, {
            filters: [
                { dataSize: 165n },
                { memcmp: { offset: 32n, bytes: wallet.toString(), encoding: 'base58' } },
            ],
            encoding: 'jsonParsed',
        })
            .send();
    };
    /**
     * Get all token accounts that are holding a specific Kamino whirlpool strategy
     */
    getStrategyTokenAccounts = async (strategy) => {
        const strategyState = await this.getStrategyStateIfNotFetched(strategy);
        return this.getShareTokenAccounts(strategyState.strategy.sharesMint);
    };
    /**
     * Get strategy range in which liquidity is deposited
     */
    getStrategyRange = async (strategy) => {
        const stratWithAddress = await this.getStrategyStateIfNotFetched(strategy);
        if (stratWithAddress.strategy.strategyDex.toNumber() === (0, utils_1.dexToNumber)('ORCA')) {
            return this.getStrategyRangeOrca(strategy);
        }
        else if (stratWithAddress.strategy.strategyDex.toNumber() === (0, utils_1.dexToNumber)('RAYDIUM')) {
            return this.getStrategyRangeRaydium(strategy);
        }
        else if (stratWithAddress.strategy.strategyDex.toNumber() === (0, utils_1.dexToNumber)('METEORA')) {
            return this.getStrategyRangeMeteora(strategy);
        }
        else {
            throw Error(`Dex {stratWithAddress.strategy.strategyDex.toNumber()} not supported`);
        }
    };
    getStrategyRangeOrca = async (strategy) => {
        const { strategy: strategyState } = await this.getStrategyStateIfNotFetched(strategy);
        if (strategyState.position === pubkeys_1.DEFAULT_PUBLIC_KEY) {
            return { lowerPrice: utils_1.ZERO, upperPrice: utils_1.ZERO };
        }
        else {
            return this.getPositionRangeOrca(strategyState.position, strategyState.tokenAMintDecimals.toNumber(), strategyState.tokenBMintDecimals.toNumber());
        }
    };
    getStrategyRangeRaydium = async (strategy) => {
        const { strategy: strategyState } = await this.getStrategyStateIfNotFetched(strategy);
        if (strategyState.position === pubkeys_1.DEFAULT_PUBLIC_KEY) {
            return { lowerPrice: utils_1.ZERO, upperPrice: utils_1.ZERO };
        }
        else {
            return this.getPositionRangeRaydium(strategyState.position, strategyState.tokenAMintDecimals.toNumber(), strategyState.tokenBMintDecimals.toNumber());
        }
    };
    getStrategyRangeMeteora = async (strategy) => {
        const { strategy: strategyState } = await this.getStrategyStateIfNotFetched(strategy);
        if (strategyState.position === pubkeys_1.DEFAULT_PUBLIC_KEY) {
            return { lowerPrice: utils_1.ZERO, upperPrice: utils_1.ZERO };
        }
        else {
            return this.getPositionRangeMeteora(strategyState.position, strategyState.tokenAMintDecimals.toNumber(), strategyState.tokenBMintDecimals.toNumber());
        }
    };
    getPositionRange = async (dex, position, decimalsA, decimalsB) => {
        if (dex === 'ORCA') {
            return this.getPositionRangeOrca(position, decimalsA, decimalsB);
        }
        else if (dex === 'RAYDIUM') {
            return this.getPositionRangeRaydium(position, decimalsA, decimalsB);
        }
        else if (dex === 'METEORA') {
            return this.getPositionRangeMeteora(position, decimalsA, decimalsB);
        }
        else {
            throw Error(`Unsupported dex ${dex}`);
        }
    };
    getPositionRangeOrca = async (positionPk, decimalsA, decimalsB) => {
        if (positionPk === pubkeys_1.DEFAULT_PUBLIC_KEY) {
            return { lowerPrice: utils_1.ZERO, upperPrice: utils_1.ZERO };
        }
        const position = await accounts_2.Position.fetch(this._rpc, positionPk, this._orcaService.getWhirlpoolProgramId());
        if (!position) {
            return { lowerPrice: utils_1.ZERO, upperPrice: utils_1.ZERO };
        }
        const lowerPrice = new decimal_js_1.default((0, whirlpools_core_1.tickIndexToPrice)(position.tickLowerIndex, decimalsA, decimalsB));
        const upperPrice = new decimal_js_1.default((0, whirlpools_core_1.tickIndexToPrice)(position.tickUpperIndex, decimalsA, decimalsB));
        const positionRange = { lowerPrice, upperPrice };
        return positionRange;
    };
    getPositionRangeRaydium = async (positionPk, decimalsA, decimalsB) => {
        if (positionPk === pubkeys_1.DEFAULT_PUBLIC_KEY) {
            return { lowerPrice: utils_1.ZERO, upperPrice: utils_1.ZERO };
        }
        const position = await accounts_3.PersonalPositionState.fetch(this._rpc, positionPk, this._raydiumService.getRaydiumProgramId());
        if (!position) {
            return { lowerPrice: utils_1.ZERO, upperPrice: utils_1.ZERO };
        }
        const lowerPrice = lib_1.SqrtPriceMath.sqrtPriceX64ToPrice(lib_1.SqrtPriceMath.getSqrtPriceX64FromTick(position.tickLowerIndex), decimalsA, decimalsB);
        const upperPrice = lib_1.SqrtPriceMath.sqrtPriceX64ToPrice(lib_1.SqrtPriceMath.getSqrtPriceX64FromTick(position.tickUpperIndex), decimalsA, decimalsB);
        const positionRange = { lowerPrice, upperPrice };
        return positionRange;
    };
    getPositionRangeMeteora = async (positionPk, decimalsA, decimalsB) => {
        if (positionPk === pubkeys_1.DEFAULT_PUBLIC_KEY) {
            return { lowerPrice: utils_1.ZERO, upperPrice: utils_1.ZERO };
        }
        const position = await accounts_4.PositionV2.fetch(this._rpc, positionPk, this._meteoraService.getMeteoraProgramId());
        if (!position) {
            return { lowerPrice: utils_1.ZERO, upperPrice: utils_1.ZERO };
        }
        const pool = await accounts_4.LbPair.fetch(this._rpc, position.lbPair);
        if (!pool) {
            return { lowerPrice: utils_1.ZERO, upperPrice: utils_1.ZERO };
        }
        const lowerPrice = (0, meteora_1.getPriceOfBinByBinIdWithDecimals)(position.lowerBinId, pool.binStep, decimalsA, decimalsB);
        const upperPrice = (0, meteora_1.getPriceOfBinByBinIdWithDecimals)(position.upperBinId, pool.binStep, decimalsA, decimalsB);
        const positionRange = { lowerPrice, upperPrice };
        return positionRange;
    };
    /**
     * Get all strategy token holders
     * @param strategy
     */
    getStrategyHolders = async (strategy) => {
        const strategyState = await this.getStrategyStateIfNotFetched(strategy);
        const tokenAccounts = await this.getStrategyTokenAccounts(strategyState);
        const result = [];
        for (const tokenAccount of tokenAccounts) {
            const accountData = tokenAccount.account.data;
            if ('parsed' in accountData) {
                result.push({
                    // @ts-ignore
                    holderPubkey: (0, kit_1.address)(accountData.parsed.info.owner),
                    // @ts-ignore
                    amount: new decimal_js_1.default(accountData.parsed.info.tokenAmount.uiAmountString),
                });
            }
        }
        return result;
    };
    /**
     * Get a list of Orca whirlpools from public keys
     * @param whirlpools
     */
    getWhirlpools = async (whirlpools) => {
        // todo: make this map have Pubkey as key
        const whirlpoolMap = new Map();
        const uniqueWhirlpools = [...new Set(whirlpools)];
        if (uniqueWhirlpools.length === 1) {
            const whirlpool = await this.getWhirlpoolByAddress(whirlpools[0]);
            whirlpoolMap.set(whirlpools[0], whirlpool);
            return whirlpoolMap;
        }
        const fetched = await (0, utils_1.batchFetch)(uniqueWhirlpools, (chunk) => accounts_2.Whirlpool.fetchMultiple(this._rpc, chunk, this._orcaService.getWhirlpoolProgramId()));
        fetched.reduce((map, whirlpool, i) => {
            whirlpoolMap.set(uniqueWhirlpools[i], whirlpool);
            map[uniqueWhirlpools[i]] = whirlpool;
            return map;
        }, {});
        return whirlpoolMap;
    };
    getAllWhirlpoolsFromAPI = async (tokens = []) => {
        return await this._orcaService.getOrcaWhirlpools(tokens);
    };
    /**
     * Get a list of Orca positions from public keys
     * @param positions
     */
    getOrcaPositions = async (positions) => {
        const nonDefaults = positions.filter((value) => value !== pubkeys_1.DEFAULT_PUBLIC_KEY);
        const fetched = await (0, utils_1.batchFetch)(nonDefaults, (chunk) => accounts_2.Position.fetchMultiple(this._rpc, chunk, this._orcaService.getWhirlpoolProgramId()));
        const fetchedMap = fetched.reduce((map, position, i) => {
            map[nonDefaults[i]] = position;
            return map;
        }, {});
        return positions.map((position) => fetchedMap[position] || null);
    };
    /**
     * Get a list of Raydium positions from public keys
     * @param positions
     */
    getRaydiumPositions = async (positions) => {
        const nonDefaults = positions.filter((value) => value !== pubkeys_1.DEFAULT_PUBLIC_KEY);
        const fetched = await (0, utils_1.batchFetch)(nonDefaults, (chunk) => accounts_3.PersonalPositionState.fetchMultiple(this._rpc, chunk, this._raydiumService.getRaydiumProgramId()));
        const fetchedMap = fetched.reduce((map, position, i) => {
            map[nonDefaults[i]] = position;
            return map;
        }, {});
        return positions.map((position) => fetchedMap[position] || null);
    };
    getMeteoraPositions = async (positions) => {
        const nonDefaults = positions.filter((value) => value !== pubkeys_1.DEFAULT_PUBLIC_KEY);
        const fetched = await (0, utils_1.batchFetch)(nonDefaults, (chunk) => accounts_4.PositionV2.fetchMultiple(this._rpc, chunk, this._meteoraService.getMeteoraProgramId()));
        const fetchedMap = fetched.reduce((map, position, i) => {
            map[nonDefaults[i]] = position;
            return map;
        }, {});
        return positions.map((position) => fetchedMap[position] || null);
    };
    /**
     * Get whirlpool from public key
     * @param whirlpool pubkey of the orca whirlpool
     */
    getWhirlpoolByAddress = (whirlpool) => accounts_2.Whirlpool.fetch(this._rpc, whirlpool, this._orcaService.getWhirlpoolProgramId());
    /**
     * Get a list of Raydium pools from public keys
     * @param pools
     */
    getRaydiumPools = async (pools) => {
        // todo: make this map have Pubkey as key
        const poolsMap = new Map();
        const uniquePools = [...new Set(pools)];
        if (uniquePools.length === 1) {
            const pool = await this.getRaydiumPoolByAddress(pools[0]);
            poolsMap.set(pools[0], pool);
        }
        const fetched = await (0, utils_1.batchFetch)(uniquePools, (chunk) => accounts_3.PoolState.fetchMultiple(this._rpc, chunk, this._raydiumService.getRaydiumProgramId()));
        fetched.reduce((map, whirlpool, i) => {
            poolsMap.set(uniquePools[i], whirlpool);
            return map;
        }, {});
        return poolsMap;
    };
    getMeteoraPools = async (pools) => {
        // todo: make this map have Pubkey as key
        const poolsMap = new Map();
        const uniquePools = [...new Set(pools)];
        if (uniquePools.length === 1) {
            const pool = await this.getMeteoraPoolByAddress(pools[0]);
            poolsMap.set(pools[0], pool);
        }
        const fetched = await (0, utils_1.batchFetch)(uniquePools, (chunk) => accounts_4.LbPair.fetchMultiple(this._rpc, chunk, this._meteoraService.getMeteoraProgramId()));
        fetched.reduce((map, whirlpool, i) => {
            poolsMap.set(uniquePools[i], whirlpool);
            return map;
        }, {});
        return poolsMap;
    };
    getRaydiumAmmConfig = (config) => accounts_3.AmmConfig.fetch(this._rpc, config, this._raydiumService.getRaydiumProgramId());
    /**
     * Get Raydium pool from public key
     * @param pool pubkey of the orca whirlpool
     */
    getRaydiumPoolByAddress = (pool) => accounts_3.PoolState.fetch(this._rpc, pool, this._raydiumService.getRaydiumProgramId());
    getMeteoraPoolByAddress = (pool) => accounts_4.LbPair.fetch(this._rpc, pool, this._meteoraService.getMeteoraProgramId());
    getEventAuthorityPDA = async (dex) => {
        if (dex.toNumber() === (0, utils_1.dexToNumber)('ORCA') || dex.toNumber() === (0, utils_1.dexToNumber)('RAYDIUM')) {
            return (0, kit_1.none)();
        }
        if (dex.toNumber() === (0, utils_1.dexToNumber)('METEORA')) {
            const [key] = await (0, kit_1.getProgramDerivedAddress)({
                seeds: [Buffer.from('__event_authority')],
                programAddress: this._meteoraService.getMeteoraProgramId(),
            });
            return (0, kit_1.some)(key);
        }
        throw new Error('Invalid dex');
    };
    /**
     * Return transaction instruction to withdraw shares from a strategy owner (wallet) and get back token A and token B
     * @param strategy strategy public key
     * @param sharesAmount amount of shares (decimal representation), NOT in lamports
     * @param owner shares owner (wallet with shares)
     * @returns transaction instruction
     */
    withdrawShares = async (strategy, sharesAmount, owner, sharesAtaBalance) => {
        if (sharesAmount.lessThanOrEqualTo(0)) {
            throw Error('Shares amount cant be lower than or equal to 0.');
        }
        const strategyState = await this.getStrategyStateIfNotFetched(strategy);
        const eventAuthority = await this.getEventAuthorityPDA(strategyState.strategy.strategyDex);
        const { treasuryFeeTokenAVault, treasuryFeeTokenBVault } = await this.getTreasuryFeeVaultPDAs(strategyState.strategy.tokenAMint, strategyState.strategy.tokenBMint);
        const [sharesAta, tokenAAta, tokenBAta] = await Promise.all([
            (0, utils_1.getAssociatedTokenAddress)(strategyState.strategy.sharesMint, owner.address),
            (0, utils_1.getAssociatedTokenAddress)(strategyState.strategy.tokenAMint, owner.address, (0, utils_1.keyOrDefault)(strategyState.strategy.tokenATokenProgram, token_1.TOKEN_PROGRAM_ADDRESS)),
            (0, utils_1.getAssociatedTokenAddress)(strategyState.strategy.tokenBMint, owner.address, (0, utils_1.keyOrDefault)(strategyState.strategy.tokenBTokenProgram, token_1.TOKEN_PROGRAM_ADDRESS)),
        ]);
        console.log('Shares ATA in withdraw: ', sharesAta.toString());
        const sharesAmountInLamports = sharesAmount.mul(new decimal_js_1.default(10).pow(strategyState.strategy.sharesMintDecimals.toString()));
        const programId = this.getDexProgramId(strategyState.strategy);
        const args = { sharesAmount: new bn_js_1.default(sharesAmountInLamports.floor().toString()) };
        const accounts = {
            user: owner,
            strategy: strategyState.address,
            globalConfig: strategyState.strategy.globalConfig,
            pool: strategyState.strategy.pool,
            position: strategyState.strategy.position,
            tickArrayLower: strategyState.strategy.tickArrayLower,
            tickArrayUpper: strategyState.strategy.tickArrayUpper,
            tokenAVault: strategyState.strategy.tokenAVault,
            tokenBVault: strategyState.strategy.tokenBVault,
            baseVaultAuthority: strategyState.strategy.baseVaultAuthority,
            poolTokenVaultA: strategyState.strategy.poolTokenVaultA,
            poolTokenVaultB: strategyState.strategy.poolTokenVaultB,
            tokenAAta: tokenAAta,
            tokenBAta: tokenBAta,
            userSharesAta: sharesAta,
            sharesMint: strategyState.strategy.sharesMint,
            treasuryFeeTokenAVault,
            treasuryFeeTokenBVault,
            tokenProgram: token_1.TOKEN_PROGRAM_ADDRESS,
            tokenProgram2022: token_2022_1.TOKEN_2022_PROGRAM_ADDRESS,
            positionTokenAccount: strategyState.strategy.positionTokenAccount,
            poolProgram: programId,
            instructionSysvarAccount: sysvars_1.SYSVAR_INSTRUCTIONS_ADDRESS,
            tokenAMint: strategyState.strategy.tokenAMint,
            tokenBMint: strategyState.strategy.tokenBMint,
            eventAuthority,
            tokenATokenProgram: (0, utils_1.keyOrDefault)(strategyState.strategy.tokenATokenProgram, token_1.TOKEN_PROGRAM_ADDRESS),
            tokenBTokenProgram: (0, utils_1.keyOrDefault)(strategyState.strategy.tokenBTokenProgram, token_1.TOKEN_PROGRAM_ADDRESS),
            memoProgram: pubkeys_1.MEMO_PROGRAM_ID,
        };
        let withdrawIx = (0, instructions_2.withdraw)(args, accounts, undefined, this.getProgramID());
        let collectFeesAndRewardsIxns = [];
        //  for Raydium strats we need to collect fees and rewards before withdrawal
        //  add rewards vaults accounts to withdraw
        const isRaydium = strategyState.strategy.strategyDex.toNumber() === (0, utils_1.dexToNumber)('RAYDIUM');
        if (isRaydium) {
            const raydiumPosition = await accounts_3.PersonalPositionState.fetch(this._rpc, strategyState.strategy.position, this._raydiumService.getRaydiumProgramId());
            if (!raydiumPosition) {
                throw new Error('Position is not found');
            }
            collectFeesAndRewardsIxns = new decimal_js_1.default(raydiumPosition.liquidity.toString()).gt(utils_1.ZERO)
                ? [await this.collectFeesAndRewards(strategy, owner)]
                : [];
            const poolState = await this.getRaydiumPoolByAddress(strategyState.strategy.pool);
            if (!poolState) {
                throw new Error('Pool is not found');
            }
            withdrawIx = {
                ...withdrawIx,
                accounts: withdrawIx.accounts?.concat([
                    {
                        address: strategyState.strategy.raydiumProtocolPositionOrBaseVaultAuthority,
                        role: kit_1.AccountRole.WRITABLE,
                    },
                ]),
            };
            if (strategyState.strategy.reward0Decimals.toNumber() > 0) {
                withdrawIx = {
                    ...withdrawIx,
                    accounts: withdrawIx.accounts?.concat([
                        {
                            address: poolState.rewardInfos[0].tokenVault,
                            role: kit_1.AccountRole.WRITABLE,
                        },
                        {
                            address: strategyState.strategy.reward0Vault,
                            role: kit_1.AccountRole.WRITABLE,
                        },
                        {
                            address: poolState.rewardInfos[0].tokenMint,
                            role: kit_1.AccountRole.WRITABLE,
                        },
                    ]),
                };
            }
            if (strategyState.strategy.reward1Decimals.toNumber() > 0) {
                withdrawIx = {
                    ...withdrawIx,
                    accounts: withdrawIx.accounts?.concat([
                        {
                            address: poolState.rewardInfos[1].tokenVault,
                            role: kit_1.AccountRole.WRITABLE,
                        },
                        {
                            address: strategyState.strategy.reward1Vault,
                            role: kit_1.AccountRole.WRITABLE,
                        },
                        {
                            address: poolState.rewardInfos[1].tokenMint,
                            role: kit_1.AccountRole.WRITABLE,
                        },
                    ]),
                };
            }
            if (strategyState.strategy.reward2Decimals.toNumber() > 0) {
                withdrawIx = {
                    ...withdrawIx,
                    accounts: withdrawIx.accounts?.concat([
                        {
                            address: poolState.rewardInfos[2].tokenVault,
                            role: kit_1.AccountRole.WRITABLE,
                        },
                        {
                            address: strategyState.strategy.reward2Vault,
                            role: kit_1.AccountRole.WRITABLE,
                        },
                        {
                            address: poolState.rewardInfos[2].tokenMint,
                            role: kit_1.AccountRole.WRITABLE,
                        },
                    ]),
                };
            }
            const [poolTickArrayBitmap, _poolTickArrayBitmapBump] = await (0, kit_1.getProgramDerivedAddress)({
                seeds: [Buffer.from('pool_tick_array_bitmap_extension'), addressEncoder.encode(strategyState.strategy.pool)],
                programAddress: this._raydiumService.getRaydiumProgramId(),
            });
            withdrawIx = {
                ...withdrawIx,
                accounts: withdrawIx.accounts?.concat([
                    {
                        address: poolTickArrayBitmap,
                        role: kit_1.AccountRole.WRITABLE,
                    },
                ]),
            };
        }
        const res = { prerequisiteIxs: collectFeesAndRewardsIxns, withdrawIx };
        // if we withdraw everything also close the shares ATA
        if (sharesAtaBalance && sharesAtaBalance.lte(sharesAmount)) {
            res.closeSharesAtaIx = (0, token_2022_1.getCloseAccountInstruction)({
                owner,
                account: sharesAta,
                destination: owner.address,
            }, { programAddress: token_1.TOKEN_PROGRAM_ADDRESS });
        }
        return res;
    };
    /**
     * Get transaction instructions that create associated token accounts if they don't exist (token A, B and share)
     * @param owner wallet owner (shareholder)
     * @param strategyState kamino strategy state
     * @param tokenAData token A data of the owner's wallet
     * @param tokenAAta associated token account for token B
     * @param tokenBData token B data of the owner's wallet
     * @param tokenBAta associated token account for token B
     * @param sharesMintData shares data of the owner's wallet
     * @param sharesAta associated token account for shares
     * @returns list of transaction instructions (empty if all accounts already exist)
     */
    getCreateAssociatedTokenAccountInstructionsIfNotExist = async (owner, strategyState, tokenAData, tokenAAta, tokenBData, tokenBAta, sharesMintData, sharesAta) => {
        const instructions = [];
        if (!tokenAData) {
            const tokenProgramA = strategyState.strategy.tokenATokenProgram === pubkeys_1.DEFAULT_PUBLIC_KEY
                ? token_1.TOKEN_PROGRAM_ADDRESS
                : strategyState.strategy.tokenATokenProgram;
            instructions.push((0, utils_1.createAssociatedTokenAccountInstruction)(owner, tokenAAta, owner.address, strategyState.strategy.tokenAMint, tokenProgramA));
        }
        if (!tokenBData) {
            const tokenProgramB = strategyState.strategy.tokenBTokenProgram === pubkeys_1.DEFAULT_PUBLIC_KEY
                ? token_1.TOKEN_PROGRAM_ADDRESS
                : strategyState.strategy.tokenBTokenProgram;
            instructions.push((0, utils_1.createAssociatedTokenAccountInstruction)(owner, tokenBAta, owner.address, strategyState.strategy.tokenBMint, tokenProgramB));
        }
        if (!sharesMintData) {
            instructions.push((0, utils_1.createAssociatedTokenAccountInstruction)(owner, sharesAta, owner.address, strategyState.strategy.sharesMint));
        }
        return instructions;
    };
    /**
     * Check if strategy has already been fetched (is StrategyWithAddress type) and return that,
     * otherwise fetch it first from Address and return it
     * @param strategy
     * @private
     */
    getStrategyStateIfNotFetched = async (strategy) => {
        const hasStrategyBeenFetched = (object) => {
            return !(typeof object === 'string' && (0, kit_1.isAddress)(object));
        };
        if (hasStrategyBeenFetched(strategy)) {
            return strategy;
        }
        else {
            const strategyState = await this.getStrategyByAddress(strategy);
            if (!strategyState) {
                throw Error(`Could not fetch strategy state with pubkey ${strategy.toString()}`);
            }
            return { strategy: strategyState, address: strategy };
        }
    };
    getWhirlpoolStateIfNotFetched = async (whirlpool) => {
        const hasWhirlpoolBeenFetched = (object) => {
            return typeof object !== 'string' && 'whirlpool' in object;
        };
        if (hasWhirlpoolBeenFetched(whirlpool)) {
            return whirlpool;
        }
        else {
            const whirlpoolState = await this.getWhirlpoolByAddress(whirlpool);
            if (!whirlpoolState) {
                throw Error(`Could not fetch whirlpool state with pubkey ${whirlpool.toString()}`);
            }
            return { whirlpool: whirlpoolState, address: whirlpool };
        }
    };
    getMeteoraStateIfNotFetched = async (lbPair) => {
        const hasLbPairBeenFetched = (object) => {
            return typeof object !== 'string' && 'pool' in object;
        };
        if (hasLbPairBeenFetched(lbPair)) {
            return lbPair;
        }
        else {
            const lbPairState = await this.getMeteoraPoolByAddress(lbPair);
            if (!lbPairState) {
                throw Error(`Could not fetch meteora lb pair state with pubkey ${lbPair.toString()}`);
            }
            return { pool: lbPairState, address: lbPair };
        }
    };
    /**
     * Get treasury fee vault program addresses from for token A and B mints
     * @param tokenAMint
     * @param tokenBMint
     * @private
     */
    getTreasuryFeeVaultPDAs = async (tokenAMint, tokenBMint) => {
        const [[treasuryFeeTokenAVault], [treasuryFeeTokenBVault], [treasuryFeeVaultAuthority]] = await Promise.all([
            (0, kit_1.getProgramDerivedAddress)({
                seeds: [Buffer.from('treasury_fee_vault'), addressEncoder.encode(tokenAMint)],
                programAddress: this.getProgramID(),
            }),
            (0, kit_1.getProgramDerivedAddress)({
                seeds: [Buffer.from('treasury_fee_vault'), addressEncoder.encode(tokenBMint)],
                programAddress: this.getProgramID(),
            }),
            (0, kit_1.getProgramDerivedAddress)({
                seeds: [Buffer.from('treasury_fee_vault_authority')],
                programAddress: this.getProgramID(),
            }),
        ]);
        return { treasuryFeeTokenAVault, treasuryFeeTokenBVault, treasuryFeeVaultAuthority };
    };
    /**
     * Get a transaction instruction to withdraw all strategy shares from a specific wallet into token A and B
     * @param strategy public key of the strategy
     * @param owner public key of the owner (shareholder)
     * @returns transaction instruction or null if no shares or no sharesMint ATA present in the wallet
     */
    withdrawAllShares = async (strategy, owner) => {
        const strategyState = await this.getStrategyStateIfNotFetched(strategy);
        const [, sharesData] = await (0, utils_1.getAssociatedTokenAddressAndAccount)(this._rpc, strategyState.strategy.sharesMint, owner.address);
        if (!sharesData || sharesData.data.amount === 0n) {
            return null;
        }
        const amount = new decimal_js_1.default(sharesData.data.amount.toString()).div(new decimal_js_1.default(10).pow(strategyState.strategy.sharesMintDecimals.toString()));
        return this.withdrawShares(strategyState, amount, owner);
    };
    /**
     * Get all the accounts needed by the deposit tx, without the swap.
     * @param strategy Kamino strategy public key or on-chain object
     * @param owner Owner (wallet, shareholder) public key
     * @returns list of pubkeys needed for the deposit transaction
     */
    getAllDepositAccounts = async (strategy, owner) => {
        const strategyState = await this.getStrategyStateIfNotFetched(strategy);
        const globalConfig = await accounts_1.GlobalConfig.fetch(this._rpc, strategyState.strategy.globalConfig, this.getProgramID());
        if (!globalConfig) {
            throw Error(`Could not fetch global config with pubkey ${strategyState.strategy.globalConfig.toString()}`);
        }
        const [sharesAta, tokenAAta, tokenBAta] = await Promise.all([
            (0, utils_1.getAssociatedTokenAddress)(strategyState.strategy.sharesMint, owner),
            (0, utils_1.getAssociatedTokenAddress)(strategyState.strategy.tokenAMint, owner, (0, utils_1.keyOrDefault)(strategyState.strategy.tokenATokenProgram, token_1.TOKEN_PROGRAM_ADDRESS)),
            (0, utils_1.getAssociatedTokenAddress)(strategyState.strategy.tokenBMint, owner, (0, utils_1.keyOrDefault)(strategyState.strategy.tokenBTokenProgram, token_1.TOKEN_PROGRAM_ADDRESS)),
        ]);
        const accounts = [
            owner,
            strategyState.address,
            strategyState.strategy.globalConfig,
            strategyState.strategy.pool,
            strategyState.strategy.position,
            strategyState.strategy.tokenAVault,
            strategyState.strategy.tokenBVault,
            strategyState.strategy.baseVaultAuthority,
            strategyState.strategy.tokenAMint,
            strategyState.strategy.tokenBMint,
            sharesAta,
            tokenAAta,
            tokenBAta,
            strategyState.strategy.sharesMint,
            strategyState.strategy.sharesMintAuthority,
            strategyState.strategy.scopePrices,
            globalConfig.tokenInfos,
            token_1.TOKEN_PROGRAM_ADDRESS,
            (0, utils_1.keyOrDefault)(strategyState.strategy.tokenATokenProgram, token_1.TOKEN_PROGRAM_ADDRESS),
            (0, utils_1.keyOrDefault)(strategyState.strategy.tokenBTokenProgram, token_1.TOKEN_PROGRAM_ADDRESS),
            sysvars_1.SYSVAR_INSTRUCTIONS_ADDRESS,
            strategyState.strategy.tickArrayLower,
            strategyState.strategy.tickArrayUpper,
        ];
        return accounts;
    };
    /**
     * Get transaction instruction to deposit token A and B into a strategy.
     * @param strategy Kamino strategy public key or on-chain object
     * @param amountA Amount of token A to deposit into strategy
     * @param amountB Amount of token B to deposit into strategy
     * @param owner Owner (wallet, shareholder) public key
     * @returns transaction instruction for depositing tokens into a strategy
     */
    deposit = async (strategy, amountA, amountB, owner) => {
        if (amountA.lessThanOrEqualTo(0) && amountB.lessThanOrEqualTo(0)) {
            throw Error('Token A and B amount cant be lower than or equal to 0.');
        }
        const strategyState = await this.getStrategyStateIfNotFetched(strategy);
        const globalConfig = await this.getGlobalConfigState(strategyState.strategy.globalConfig);
        if (!globalConfig) {
            throw Error(`Could not fetch global config with pubkey ${strategyState.strategy.globalConfig.toString()}`);
        }
        const [sharesAta, tokenAAta, tokenBAta] = await Promise.all([
            (0, utils_1.getAssociatedTokenAddress)(strategyState.strategy.sharesMint, owner.address),
            (0, utils_1.getAssociatedTokenAddress)(strategyState.strategy.tokenAMint, owner.address, (0, utils_1.keyOrDefault)(strategyState.strategy.tokenATokenProgram, token_1.TOKEN_PROGRAM_ADDRESS)),
            (0, utils_1.getAssociatedTokenAddress)(strategyState.strategy.tokenBMint, owner.address, (0, utils_1.keyOrDefault)(strategyState.strategy.tokenBTokenProgram, token_1.TOKEN_PROGRAM_ADDRESS)),
        ]);
        const lamportsA = amountA.mul(new decimal_js_1.default(10).pow(strategyState.strategy.tokenAMintDecimals.toString()));
        const lamportsB = amountB.mul(new decimal_js_1.default(10).pow(strategyState.strategy.tokenBMintDecimals.toString()));
        const depositArgs = {
            tokenMaxA: new bn_js_1.default(lamportsA.floor().toString()),
            tokenMaxB: new bn_js_1.default(lamportsB.floor().toString()),
        };
        const depositAccounts = {
            user: owner,
            strategy: strategyState.address,
            globalConfig: strategyState.strategy.globalConfig,
            pool: strategyState.strategy.pool,
            position: strategyState.strategy.position,
            tokenAVault: strategyState.strategy.tokenAVault,
            tokenBVault: strategyState.strategy.tokenBVault,
            baseVaultAuthority: strategyState.strategy.baseVaultAuthority,
            tokenAAta,
            tokenBAta,
            tokenAMint: strategyState.strategy.tokenAMint,
            tokenBMint: strategyState.strategy.tokenBMint,
            userSharesAta: sharesAta,
            sharesMint: strategyState.strategy.sharesMint,
            sharesMintAuthority: strategyState.strategy.sharesMintAuthority,
            scopePrices: strategyState.strategy.scopePrices,
            tokenInfos: globalConfig.tokenInfos,
            tokenProgram: token_1.TOKEN_PROGRAM_ADDRESS,
            instructionSysvarAccount: sysvars_1.SYSVAR_INSTRUCTIONS_ADDRESS,
            tickArrayLower: strategyState.strategy.tickArrayLower,
            tickArrayUpper: strategyState.strategy.tickArrayUpper,
            tokenATokenProgram: (0, utils_1.keyOrDefault)(strategyState.strategy.tokenATokenProgram, token_1.TOKEN_PROGRAM_ADDRESS),
            tokenBTokenProgram: (0, utils_1.keyOrDefault)(strategyState.strategy.tokenBTokenProgram, token_1.TOKEN_PROGRAM_ADDRESS),
        };
        return (0, instructions_2.deposit)(depositArgs, depositAccounts, undefined, this.getProgramID());
    };
    singleSidedDepositTokenA = async (strategy, amountToDeposit, owner, slippageBps, profiler = utils_1.noopProfiledFunctionExecution, swapIxsBuilder, initialUserTokenAtaBalances, priceAInB, includeAtaIxns = true, // if true it includes create and close wsol and token atas,
    onlyDirectRoutes) => {
        const strategyWithAddress = await this.getStrategyStateIfNotFetched(strategy);
        const userTokenBalances = await profiler(this.getInitialUserTokenBalances(owner.address, strategyWithAddress.strategy.tokenAMint, strategyWithAddress.strategy.tokenBMint, initialUserTokenAtaBalances), 'A-getInitialUserTokenBalances', []);
        const userTokenBalancesWithoutSolBalanace = {
            a: userTokenBalances.a,
            b: userTokenBalances.b,
        };
        // if any of the tokens is SOL, we need to read how much SOL the user has, not how much wSOL which is what getInitialUserTokenBalances returns
        if ((0, utils_1.isSOLMint)(strategyWithAddress.strategy.tokenAMint)) {
            userTokenBalances.a = userTokenBalances.a?.add((0, utils_1.lamportsToNumberDecimal)(new decimal_js_1.default((await this._rpc.getBalance(owner.address).send()).value.toString()), utils_1.DECIMALS_SOL));
        }
        if ((0, utils_1.isSOLMint)(strategyWithAddress.strategy.tokenBMint)) {
            userTokenBalances.b = userTokenBalances.b?.add((0, utils_1.lamportsToNumberDecimal)(new decimal_js_1.default((await this._rpc.getBalance(owner.address).send()).value.toString()), utils_1.DECIMALS_SOL));
        }
        if (!userTokenBalances.a || !userTokenBalances.b) {
            throw Error('Error reading user token balances');
        }
        const tokenAMinPostDepositBalance = userTokenBalances.a?.sub(amountToDeposit);
        const swapper = swapIxsBuilder
            ? swapIxsBuilder
            : (input, tokenAMint, tokenBMint, user, slippageBps, allAccounts) => this.getJupSwapIxsV6(input, tokenAMint, tokenBMint, user.address, slippageBps, false, allAccounts, profiler, onlyDirectRoutes);
        console.log('single sided deposit tokenA tokenAMinPostDepositBalance', tokenAMinPostDepositBalance);
        console.log('single sided deposit tokenA userTokenBalances.b', userTokenBalances.b);
        return await profiler(this.getSingleSidedDepositIxs(strategyWithAddress, (0, utils_1.collToLamportsDecimal)(tokenAMinPostDepositBalance, strategyWithAddress.strategy.tokenAMintDecimals.toNumber()), (0, utils_1.collToLamportsDecimal)(userTokenBalances.b, strategyWithAddress.strategy.tokenBMintDecimals.toNumber()), owner, slippageBps, swapper, profiler, userTokenBalancesWithoutSolBalanace, priceAInB, includeAtaIxns), 'A-getSingleSidedDepositIxs', []);
    };
    singleSidedDepositTokenB = async (strategy, amountToDeposit, owner, slippageBps, profiler = utils_1.noopProfiledFunctionExecution, swapIxsBuilder, initialUserTokenAtaBalances, priceAInB, includeAtaIxns = true, // if true it includes create and close wsol and token atas,
    onlyDirectRoutes) => {
        const strategyWithAddress = await this.getStrategyStateIfNotFetched(strategy);
        const userTokenBalances = await profiler(this.getInitialUserTokenBalances(owner.address, strategyWithAddress.strategy.tokenAMint, strategyWithAddress.strategy.tokenBMint, initialUserTokenAtaBalances), 'A-getInitialUserTokenBalances', []);
        const userTokenBalancesWithoutSolBalanace = {
            a: userTokenBalances.a,
            b: userTokenBalances.b,
        };
        // if any of the tokens is SOL, we need to read how much SOL the user has, not how much wSOL which is what getInitialUserTokenBalances returns
        if ((0, utils_1.isSOLMint)(strategyWithAddress.strategy.tokenAMint)) {
            userTokenBalances.a = userTokenBalances.a?.add((0, utils_1.lamportsToNumberDecimal)(new decimal_js_1.default((await this._rpc.getBalance(owner.address).send()).value.toString()), utils_1.DECIMALS_SOL));
        }
        if ((0, utils_1.isSOLMint)(strategyWithAddress.strategy.tokenBMint)) {
            userTokenBalances.b = userTokenBalances.b?.add((0, utils_1.lamportsToNumberDecimal)(new decimal_js_1.default((await this._rpc.getBalance(owner.address).send()).value.toString()), utils_1.DECIMALS_SOL));
        }
        if (!userTokenBalances.a || !userTokenBalances.b) {
            throw Error('Error reading user token balances');
        }
        const tokenBMinPostDepositBalance = userTokenBalances.b.sub(amountToDeposit);
        const swapper = swapIxsBuilder
            ? swapIxsBuilder
            : (input, tokenAMint, tokenBMint, user, slippageBps, allAccounts) => this.getJupSwapIxsV6(input, tokenAMint, tokenBMint, user.address, slippageBps, false, allAccounts, profiler, onlyDirectRoutes);
        return await profiler(this.getSingleSidedDepositIxs(strategyWithAddress, (0, utils_1.collToLamportsDecimal)(userTokenBalances.a, strategyWithAddress.strategy.tokenAMintDecimals.toNumber()), (0, utils_1.collToLamportsDecimal)(tokenBMinPostDepositBalance, strategyWithAddress.strategy.tokenBMintDecimals.toNumber()), owner, slippageBps, swapper, profiler, userTokenBalancesWithoutSolBalanace, priceAInB, includeAtaIxns), 'A-getSingleSidedDepositIxs', []);
    };
    getInitialUserTokenBalances = async (owner, tokenAMint, tokenBMint, initialUserTokenBalances) => {
        let initialUserTokenABalance = new decimal_js_1.default(0);
        let initialUserTokenBBalance = new decimal_js_1.default(0);
        if (initialUserTokenBalances?.a) {
            initialUserTokenABalance = initialUserTokenBalances.a;
        }
        else {
            const tokenATokenProgram = await this.getAccountOwner(tokenAMint);
            const tokenAAta = await (0, utils_1.getAssociatedTokenAddress)(tokenAMint, owner, (0, utils_1.keyOrDefault)(tokenATokenProgram, token_1.TOKEN_PROGRAM_ADDRESS));
            const ataExists = await (0, transactions_1.checkIfAccountExists)(this._rpc, tokenAAta);
            if (!ataExists) {
                initialUserTokenABalance = new decimal_js_1.default(0);
            }
            else {
                initialUserTokenABalance = await this.getTokenAccountBalance(tokenAAta);
            }
        }
        if (initialUserTokenBalances?.b) {
            initialUserTokenBBalance = initialUserTokenBalances.b;
        }
        else {
            const tokenBTokenProgram = await this.getAccountOwner(tokenBMint);
            const tokenBAta = await (0, utils_1.getAssociatedTokenAddress)(tokenBMint, owner, (0, utils_1.keyOrDefault)(tokenBTokenProgram, token_1.TOKEN_PROGRAM_ADDRESS));
            const ataExists = await (0, transactions_1.checkIfAccountExists)(this._rpc, tokenBAta);
            if (!ataExists) {
                initialUserTokenBBalance = new decimal_js_1.default(0);
            }
            else {
                initialUserTokenBBalance = await this.getTokenAccountBalance(tokenBAta);
            }
        }
        return { a: initialUserTokenABalance, b: initialUserTokenBBalance };
    };
    getSingleSidedDepositIxs = async (strategy, tokenAMinPostDepositBalanceLamports, tokenBMinPostDepositBalanceLamports, owner, swapSlippageBps, swapIxsBuilder, profiler, initialUserTokenAtaBalances, priceAInB, // not mandatory as it will be fetched from Jupyter
    includeAtaIxns = true // if true it includes create and close wsol and token atas,
    ) => {
        const strategyWithAddress = await this.getStrategyStateIfNotFetched(strategy);
        const strategyState = strategyWithAddress.strategy;
        let realTokenAMinPostDepositBalanceLamports = tokenAMinPostDepositBalanceLamports;
        let realTokenBMinPostDepositBalanceLamports = tokenBMinPostDepositBalanceLamports;
        if ((tokenAMinPostDepositBalanceLamports.lessThan(0) && !(0, utils_1.isSOLMint)(strategyState.tokenAMint)) ||
            (tokenBMinPostDepositBalanceLamports.lessThan(0) && !(0, utils_1.isSOLMint)(strategyState.tokenBMint))) {
            throw Error('Token A or B post deposit amount cant be lower than 0.');
        }
        const [sharesAta, tokenAAta, tokenBAta] = await Promise.all([
            (0, utils_1.getAssociatedTokenAddress)(strategyState.sharesMint, owner.address),
            (0, utils_1.getAssociatedTokenAddress)(strategyState.tokenAMint, owner.address, (0, utils_1.keyOrDefault)(strategyState.tokenATokenProgram, token_1.TOKEN_PROGRAM_ADDRESS)),
            (0, utils_1.getAssociatedTokenAddress)(strategyState.tokenBMint, owner.address, (0, utils_1.keyOrDefault)(strategyState.tokenBTokenProgram, token_1.TOKEN_PROGRAM_ADDRESS)),
        ]);
        let tokenAAtaBalance = initialUserTokenAtaBalances.a;
        let tokenBAtaBalance = initialUserTokenAtaBalances.b;
        let aToDeposit = (0, utils_1.collToLamportsDecimal)(tokenAAtaBalance, strategyState.tokenAMintDecimals.toNumber()).sub(tokenAMinPostDepositBalanceLamports);
        let bToDeposit = (0, utils_1.collToLamportsDecimal)(tokenBAtaBalance, strategyState.tokenBMintDecimals.toNumber()).sub(tokenBMinPostDepositBalanceLamports);
        const cleanupIxs = [];
        const createWsolAtasIxns = [];
        if ((0, utils_1.isSOLMint)(strategyState.tokenAMint)) {
            // read how much SOL the user has and calculate the amount to deposit and balance based on it
            const solBalance = new decimal_js_1.default((await this._rpc.getBalance(owner.address).send()).value.toString());
            const tokenAAtaBalanceLamports = (0, utils_1.collToLamportsDecimal)(tokenAAtaBalance, strategyState.tokenAMintDecimals.toNumber());
            const availableSol = solBalance.add(tokenAAtaBalanceLamports);
            const solToDeposit = availableSol.sub(tokenAMinPostDepositBalanceLamports);
            aToDeposit = solToDeposit;
            if (!aToDeposit.eq(utils_1.ZERO)) {
                if (tokenAAtaBalanceLamports.lessThan(aToDeposit)) {
                    tokenAAtaBalance = (0, utils_1.lamportsToNumberDecimal)(aToDeposit, utils_1.DECIMALS_SOL);
                }
            }
            const createWSolAtaIxns = await (0, transactions_1.createWsolAtaIfMissing)(this._rpc, new decimal_js_1.default((0, utils_1.lamportsToNumberDecimal)(solToDeposit, utils_1.DECIMALS_SOL)), owner);
            // if the wSOL ata is not created, expect to have 0 remaining after the deposit
            const wSolAtaExists = await (0, transactions_1.checkIfAccountExists)(this._rpc, createWSolAtaIxns.ata);
            if (!wSolAtaExists) {
                realTokenAMinPostDepositBalanceLamports = new decimal_js_1.default(0);
            }
            else {
                if (solToDeposit.greaterThanOrEqualTo(tokenAAtaBalanceLamports)) {
                    realTokenAMinPostDepositBalanceLamports = utils_1.ZERO;
                }
                else {
                    realTokenAMinPostDepositBalanceLamports = tokenAAtaBalanceLamports.sub(solToDeposit);
                }
            }
            if (includeAtaIxns) {
                createWsolAtasIxns.push(...createWSolAtaIxns.createIxns);
                cleanupIxs.push(...createWSolAtaIxns.closeIxns);
            }
        }
        if ((0, utils_1.isSOLMint)(strategyState.tokenBMint)) {
            const solBalance = new decimal_js_1.default((await this._rpc.getBalance(owner.address).send()).value.toString());
            const tokenBAtaBalanceLamports = (0, utils_1.collToLamportsDecimal)(tokenBAtaBalance, strategyState.tokenBMintDecimals.toNumber());
            const availableSol = solBalance.add(tokenBAtaBalanceLamports);
            const solToDeposit = availableSol.sub(tokenBMinPostDepositBalanceLamports);
            availableSol;
            bToDeposit = solToDeposit;
            if (!bToDeposit.eq(utils_1.ZERO)) {
                if (tokenBAtaBalanceLamports.lessThan(bToDeposit)) {
                    tokenBAtaBalance = (0, utils_1.lamportsToNumberDecimal)(bToDeposit, utils_1.DECIMALS_SOL);
                }
            }
            const createWSolAtaIxns = await (0, transactions_1.createWsolAtaIfMissing)(this._rpc, new decimal_js_1.default((0, utils_1.lamportsToNumberDecimal)(solToDeposit, utils_1.DECIMALS_SOL)), owner);
            const wSolAtaExists = await (0, transactions_1.checkIfAccountExists)(this._rpc, createWSolAtaIxns.ata);
            if (!wSolAtaExists) {
                realTokenBMinPostDepositBalanceLamports = new decimal_js_1.default(0);
            }
            else {
                if (solToDeposit.greaterThanOrEqualTo(tokenBAtaBalanceLamports)) {
                    realTokenBMinPostDepositBalanceLamports = utils_1.ZERO;
                }
                else {
                    realTokenBMinPostDepositBalanceLamports = tokenBAtaBalanceLamports.sub(solToDeposit);
                }
            }
            if (includeAtaIxns) {
                createWsolAtasIxns.push(...createWSolAtaIxns.createIxns);
                cleanupIxs.push(...createWSolAtaIxns.closeIxns);
            }
        }
        const amountsToDepositWithSwapPromise = this.calculateAmountsToBeDepositedWithSwap(strategyWithAddress, aToDeposit, bToDeposit, profiler, priceAInB);
        if (aToDeposit.lessThan(0) || bToDeposit.lessThan(0)) {
            throw Error(`Token A or B to deposit amount cannot be lower than 0; aToDeposit=${aToDeposit.toString()} bToDeposit=${bToDeposit.toString()}`);
        }
        const createAtaList = [[strategyState.sharesMint, token_1.TOKEN_PROGRAM_ADDRESS]];
        if (!tokenAAtaBalance.greaterThan(0)) {
            createAtaList.push([
                strategyState.tokenAMint,
                (0, utils_1.keyOrDefault)(strategyState.tokenATokenProgram, token_1.TOKEN_PROGRAM_ADDRESS),
            ]);
        }
        if (!tokenBAtaBalance.greaterThan(0)) {
            createAtaList.push([
                strategyState.tokenBMint,
                (0, utils_1.keyOrDefault)(strategyState.tokenBTokenProgram, token_1.TOKEN_PROGRAM_ADDRESS),
            ]);
        }
        const createAtasIxnsPromise = (0, transactions_1.getAtasWithCreateIxnsIfMissing)(this._rpc, createAtaList.filter(([mint, _tokenProgram]) => !(0, utils_1.isSOLMint)(mint)), owner);
        const getGlobalConfigPromise = this.getGlobalConfigState(strategyState.globalConfig);
        const [createAtasIxns, amountsToDepositWithSwap, globalConfig] = await Promise.all([
            createAtasIxnsPromise,
            amountsToDepositWithSwapPromise,
            getGlobalConfigPromise,
        ]);
        const checkExpectedVaultsBalancesIx = await profiler(this.getCheckExpectedVaultsBalancesIx(strategyWithAddress, owner, tokenAAta, tokenBAta, {
            a: tokenAAtaBalance,
            b: tokenBAtaBalance,
        }), 'B-getCheckExpectedVaultsBalancesIx', []);
        const args = {
            tokenAMinPostDepositBalance: new bn_js_1.default(realTokenAMinPostDepositBalanceLamports.floor().toString()),
            tokenBMinPostDepositBalance: new bn_js_1.default(realTokenBMinPostDepositBalanceLamports.floor().toString()),
        };
        const accounts = {
            user: owner,
            strategy: strategyWithAddress.address,
            globalConfig: strategyState.globalConfig,
            pool: strategyState.pool,
            position: strategyState.position,
            tokenAVault: strategyState.tokenAVault,
            tokenBVault: strategyState.tokenBVault,
            baseVaultAuthority: strategyState.baseVaultAuthority,
            tokenAAta,
            tokenBAta,
            tokenAMint: strategyState.tokenAMint,
            tokenBMint: strategyState.tokenBMint,
            userSharesAta: sharesAta,
            sharesMint: strategyState.sharesMint,
            sharesMintAuthority: strategyState.sharesMintAuthority,
            scopePrices: strategyState.scopePrices,
            tokenInfos: globalConfig.tokenInfos,
            tokenProgram: token_1.TOKEN_PROGRAM_ADDRESS,
            instructionSysvarAccount: sysvars_1.SYSVAR_INSTRUCTIONS_ADDRESS,
            tickArrayLower: strategyWithAddress.strategy.tickArrayLower,
            tickArrayUpper: strategyWithAddress.strategy.tickArrayUpper,
            tokenATokenProgram: (0, utils_1.keyOrDefault)(strategyWithAddress.strategy.tokenATokenProgram, token_1.TOKEN_PROGRAM_ADDRESS),
            tokenBTokenProgram: (0, utils_1.keyOrDefault)(strategyWithAddress.strategy.tokenBTokenProgram, token_1.TOKEN_PROGRAM_ADDRESS),
        };
        const singleSidedDepositIx = (0, instructions_2.singleTokenDepositWithMin)(args, accounts, undefined, this.getProgramID());
        let result = [];
        if (includeAtaIxns) {
            result.push(...createAtasIxns, ...createWsolAtasIxns);
        }
        // get all unique accounts in the tx so we can use the remaining space (MAX_ACCOUNTS_PER_TRANSACTION - accounts_used) for the swap
        const extractKeys = (ixs) => ixs.flatMap((ix) => ix.accounts?.map((key) => key.address) || []);
        const allKeys = [
            ...extractKeys(result),
            ...extractKeys([checkExpectedVaultsBalancesIx]),
            ...extractKeys([singleSidedDepositIx]),
            ...extractKeys(cleanupIxs),
        ];
        // if we have no tokens to sell skip the jup tx
        if (amountsToDepositWithSwap.tokenAToSwapAmount.gte(utils_1.ZERO) &&
            amountsToDepositWithSwap.tokenBToSwapAmount.gte(utils_1.ZERO)) {
            result = result.concat([checkExpectedVaultsBalancesIx, singleSidedDepositIx, ...cleanupIxs]);
            return { instructions: result, lookupTablesAddresses: [] };
        }
        const [jupSwapIxs, lookupTablesAddresses] = await profiler(Kamino.retryAsync(async () => profiler(swapIxsBuilder(amountsToDepositWithSwap, strategyState.tokenAMint, strategyState.tokenBMint, owner, swapSlippageBps, allKeys), 'B-swapIxsBuilder', [
            // todo: not sure if we need to include these logs
            ['tokenAMint', strategyState.tokenAMint.toString()],
            ['tokenBMint', strategyState.tokenBMint.toString()],
        ])), 'B-retryAsync', []);
        result = result.concat([checkExpectedVaultsBalancesIx, ...jupSwapIxs, singleSidedDepositIx, ...cleanupIxs]);
        return { instructions: result, lookupTablesAddresses };
    };
    static async retryAsync(fn, retriesLeft = 5, interval = 2000) {
        try {
            return await fn();
        }
        catch (error) {
            if (retriesLeft) {
                await new Promise((resolve) => setTimeout(resolve, interval));
                return await Kamino.retryAsync(fn, retriesLeft - 1, interval);
            }
            throw error;
        }
    }
    /**
     * Get transaction instruction to deposit SOL into topup vault.
     * @param owner Owner (wallet, shareholder) public key
     * @param amountLamports Amount of SOL to deposit into topup vault
     * @returns transaction instruction for adding SOL to topup vault
     */
    upkeepTopupVault = async (owner, amountLamports) => {
        if (amountLamports.lessThanOrEqualTo(0)) {
            throw Error('Must deposit a positive amount of SOL.');
        }
        const topupVault = await this.getUserTopupVault(owner.address);
        const ix = (0, system_1.getTransferSolInstruction)({
            source: owner,
            destination: topupVault,
            amount: BigInt(amountLamports.floor().toString()),
        });
        return ix;
    };
    /**
     * Get the topup vault balance in SOL.
     * @param owner Owner (wallet, shareholder) public key
     * @returns SOL amount in topup vault
     */
    topupVaultBalance = async (owner) => {
        const topupVault = await this.getUserTopupVault(owner);
        return (0, utils_1.lamportsToNumberDecimal)(new decimal_js_1.default((await this._rpc.getBalance(topupVault).send()).value.toString()), utils_1.DECIMALS_SOL);
    };
    /**
     * Get transaction instruction to withdraw SOL from the topup vault.
     * @param owner Owner (wallet, shareholder) public key
     * @param amount Amount of SOL to withdraw from the topup vault
     * @returns transaction instruction for removing SOL from the topup vault
     */
    withdrawTopupVault = async (owner, amount) => {
        if (amount.lessThanOrEqualTo(0)) {
            throw Error('Must withdraw a positive amount of SOL.');
        }
        const topupVault = await this.getUserTopupVault(owner.address);
        let solToWithdraw;
        if (amount.eq(new decimal_js_1.default(constants_1.U64_MAX))) {
            solToWithdraw = new decimal_js_1.default((await this._rpc.getBalance(topupVault).send()).value.toString());
        }
        else {
            solToWithdraw = (0, utils_1.collToLamportsDecimal)(amount, utils_1.DECIMALS_SOL);
        }
        const args = {
            amount: new bn_js_1.default(solToWithdraw.toString()),
        };
        const accounts = {
            adminAuthority: owner,
            topupVault,
            system: system_1.SYSTEM_PROGRAM_ADDRESS,
        };
        const withdrawIxn = (0, instructions_2.withdrawFromTopup)(args, accounts, undefined, this.getProgramID());
        return withdrawIxn;
    };
    getJupSwapIxsWithMaxAccounts = async (input, tokenAMint, tokenBMint, owner, slippageBps, useOnlyLegacyTransaction, existingAccounts, maxAccounts, profiler = utils_1.noopProfiledFunctionExecution, onlyDirectRoutes) => {
        const jupiterQuote = input.tokenAToSwapAmount.lt(utils_1.ZERO)
            ? await profiler(JupService_1.JupService.getBestRouteV6(owner, input.tokenAToSwapAmount.abs(), tokenAMint, tokenBMint, slippageBps.toNumber(), useOnlyLegacyTransaction, maxAccounts, onlyDirectRoutes), 'C-getBestRouteV6', [])
            : await profiler(JupService_1.JupService.getBestRouteV6(owner, input.tokenBToSwapAmount.abs(), tokenBMint, tokenAMint, slippageBps.toNumber(), useOnlyLegacyTransaction, maxAccounts, onlyDirectRoutes), 'C-getBestRouteV6', []);
        const allJupIxs = [
            ...(jupiterQuote.tokenLedgerInstruction ? [jupiterQuote.tokenLedgerInstruction] : []),
            ...(0, transactions_1.removeBudgetAndAtaIxns)(jupiterQuote.setupInstructions, [tokenAMint, tokenBMint]),
            jupiterQuote.swapInstruction,
            ...(jupiterQuote.cleanupInstruction ? [jupiterQuote.cleanupInstruction] : []),
        ];
        const allJupAccounts = allJupIxs.flatMap((ix) => ix.accounts?.map((key) => key.address) || []);
        const allAccounts = new Set([...existingAccounts, ...allJupAccounts]);
        const prefix = 'getSingleSidedJupRoute:';
        console.log(`${prefix} All distinct existing accounts number ${new Set(existingAccounts).size}`);
        console.log(`${prefix} All distinct Jup accounts number ${new Set(allJupAccounts).size}`);
        console.log(`${prefix} All accounts number ${allAccounts.size}`);
        if (allAccounts.size < transactions_1.MAX_ACCOUNTS_PER_TRANSACTION) {
            return [allJupIxs, jupiterQuote.addressLookupTableAddresses];
        }
        // if none of the swap TXs returned by Jup have less than max allowed accounts throw error as the tx will fail because we lock too many accounts
        throw new Error('All Jupiter swap routes have too many accounts in the instructions');
    };
    getJupSwapIxsV6 = async (input, tokenAMint, tokenBMint, owner, slippageBps, useOnlyLegacyTransaction, existingAccounts, profiledFunctionExecution = utils_1.noopProfiledFunctionExecution, onlyDirectRoutes) => {
        console.log('getJupSwapIxsV6', JSON.stringify(input));
        let extraAccountsBuffer = 5;
        const currentAccounts = new Set(existingAccounts).size;
        const duplicatedAccounts = 1 + // tokenProgram
            1 + // systemProgram
            1 + // tokenAMint
            1 + // tokenBMint
            1 + // tokenAAta
            1; // tokenBAta
        while (extraAccountsBuffer < 30) {
            const maxAccounts = transactions_1.MAX_ACCOUNTS_PER_TRANSACTION - (currentAccounts - duplicatedAccounts) - extraAccountsBuffer;
            try {
                const result = await this.getJupSwapIxsWithMaxAccounts(input, tokenAMint, tokenBMint, owner, slippageBps, useOnlyLegacyTransaction, existingAccounts, maxAccounts, profiledFunctionExecution, onlyDirectRoutes);
                return result;
            }
            catch (error) {
                extraAccountsBuffer += 2;
                console.log(`getJupSwapIxs: ${error}`);
            }
        }
        console.log('getJupSwapIxs: Could not find a route with less than 64 total accounts');
        throw new Error(`Oops. Failed to find a route. Try again or unselect single-sided deposit.`);
    };
    getCheckExpectedVaultsBalancesIx = async (strategy, user, tokenAAta, tokenBAta, expectedTokensBalances) => {
        const { strategy: strategyState, address: _ } = strategy;
        let expectedABalance;
        if (expectedTokensBalances && expectedTokensBalances.a) {
            expectedABalance = expectedTokensBalances.a;
        }
        else {
            expectedABalance = await this.getTokenAccountBalanceOrZero(tokenAAta);
        }
        let expectedBBalance;
        if (expectedTokensBalances && expectedTokensBalances.b) {
            expectedBBalance = expectedTokensBalances.b;
        }
        else {
            expectedBBalance = await this.getTokenAccountBalanceOrZero(tokenBAta);
        }
        const expectedALamportsDecimal = (0, utils_1.collToLamportsDecimal)(expectedABalance, strategyState.tokenAMintDecimals.toNumber());
        const expectedBLamportsDecimal = (0, utils_1.collToLamportsDecimal)(expectedBBalance, strategyState.tokenBMintDecimals.toNumber());
        console.log('expectedALamportsDecimal ', expectedALamportsDecimal.toString());
        console.log('expectedBLamportsDecimal ', expectedBLamportsDecimal.toString());
        const expectedALamports = expectedALamportsDecimal.floor();
        const expectedBLamports = expectedBLamportsDecimal.floor();
        const args = {
            tokenAAtaBalance: new bn_js_1.default(expectedALamports.toString()),
            tokenBAtaBalance: new bn_js_1.default(expectedBLamports.toString()),
        };
        const accounts = {
            user,
            tokenAAta,
            tokenBAta,
        };
        return (0, instructions_2.checkExpectedVaultsBalances)(args, accounts, undefined, this.getProgramID());
    };
    /**
     * Get transaction instruction to create a new Kamino strategy.
     * Current limitations:
     *   - strategy can only be created by the owner (admin) of the global config, we will need to allow non-admins to bypass this check
     *   - after the strategy is created, only the owner (admin) can update the treasury fee vault with token A/B, we need to allow non-admins to be able to do (and require) this as well
     * @param strategy public key of the new strategy to create
     * @param pool public key of the CLMM pool (either Orca or Raydium)
     * @param owner public key of the strategy owner (admin authority)
     * @param dex decentralized exchange specifier
     * @returns transaction instruction for Kamino strategy creation
     */
    createStrategy = async (strategy, pool, owner, dex) => {
        let tokenAMint = pubkeys_1.DEFAULT_PUBLIC_KEY;
        let tokenBMint = pubkeys_1.DEFAULT_PUBLIC_KEY;
        if (dex === 'ORCA') {
            const whirlpoolState = await accounts_2.Whirlpool.fetch(this._rpc, pool, this._orcaService.getWhirlpoolProgramId());
            if (!whirlpoolState) {
                throw Error(`Could not fetch whirlpool state with pubkey ${pool.toString()}`);
            }
            tokenAMint = whirlpoolState.tokenMintA;
            tokenBMint = whirlpoolState.tokenMintB;
        }
        else if (dex === 'RAYDIUM') {
            const raydiumPoolState = await accounts_3.PoolState.fetch(this._rpc, pool, this._raydiumService.getRaydiumProgramId());
            if (!raydiumPoolState) {
                throw Error(`Could not fetch Raydium pool state with pubkey ${pool.toString()}`);
            }
            tokenAMint = raydiumPoolState.tokenMint0;
            tokenBMint = raydiumPoolState.tokenMint1;
        }
        else if (dex === 'METEORA') {
            const meteoraPoolState = await accounts_4.LbPair.fetch(this._rpc, pool, this._meteoraService.getMeteoraProgramId());
            if (!meteoraPoolState) {
                throw Error(`Could not fetch Meteora pool state with pubkey ${pool.toString()}`);
            }
            tokenAMint = meteoraPoolState.tokenXMint;
            tokenBMint = meteoraPoolState.tokenYMint;
        }
        const tokenATokenProgram = await this.getAccountOwner(tokenAMint);
        const tokenBTokenProgram = await this.getAccountOwner(tokenBMint);
        const config = await this.getGlobalConfigState(this._globalConfig);
        if (!config) {
            throw Error(`Could not fetch globalConfig  with pubkey ${this.getGlobalConfig().toString()}`);
        }
        const collateralInfos = await this.getCollateralInfo(config.tokenInfos);
        const tokenACollateralId = collateralInfos.findIndex((x) => x.mint === tokenAMint);
        if (tokenACollateralId === -1) {
            throw Error(`Could not find token A (mint ${tokenAMint}) in collateral infos`);
        }
        const tokenBCollateralId = collateralInfos.findIndex((x) => x.mint === tokenBMint);
        if (tokenBCollateralId === -1) {
            throw Error(`Could not find token A (mint ${tokenBMint}) in collateral infos`);
        }
        const programAddresses = await this.getStrategyProgramAddresses(strategy, tokenAMint, tokenBMint);
        const strategyArgs = {
            tokenACollateralId: new bn_js_1.default(tokenACollateralId),
            tokenBCollateralId: new bn_js_1.default(tokenBCollateralId),
            strategyType: new bn_js_1.default((0, utils_1.dexToNumber)(dex)),
        };
        const strategyAccounts = {
            adminAuthority: owner,
            strategy,
            globalConfig: this._globalConfig,
            pool,
            tokenAMint,
            tokenBMint,
            tokenAVault: programAddresses.tokenAVault,
            tokenBVault: programAddresses.tokenBVault,
            baseVaultAuthority: programAddresses.baseVaultAuthority,
            sharesMint: programAddresses.sharesMint,
            sharesMintAuthority: programAddresses.sharesMintAuthority,
            tokenInfos: config.tokenInfos,
            systemProgram: system_1.SYSTEM_PROGRAM_ADDRESS,
            rent: sysvars_1.SYSVAR_RENT_ADDRESS,
            tokenProgram: token_1.TOKEN_PROGRAM_ADDRESS,
            tokenATokenProgram,
            tokenBTokenProgram,
        };
        let ix = (0, instructions_2.initializeStrategy)(strategyArgs, strategyAccounts, undefined, this.getProgramID());
        ix = {
            ...ix,
            accounts: ix.accounts?.concat([
                { address: config.scopePriceId, role: kit_1.AccountRole.READONLY },
                { address: config.scopeProgramId, role: kit_1.AccountRole.READONLY },
            ]),
        };
        return ix;
    };
    /**
     * Get transaction instruction to close Kamino strategy, including its position if there is any
     * and strategy token accounts.
     * @param strategy public key of the strategy
     * @param admin signer to close the strategy
     * @returns instruction to close the strategy
     */
    withdrawAllAndCloseStrategy = async (admin, strategy) => {
        const strategyWithAddress = await this.getStrategyStateIfNotFetched(strategy);
        const withdrawIxns = await this.withdrawAllShares(strategyWithAddress, admin);
        if (withdrawIxns === null) {
            return null;
        }
        const closeIxn = await this.closeStrategy(admin, strategyWithAddress);
        return {
            withdrawIxns: [...withdrawIxns.prerequisiteIxs, withdrawIxns.withdrawIx],
            closeIxn,
        };
    };
    /**
     * Get transaction instruction to close Kamino strategy, including its position if there is any
     * and strategy token accounts.
     * @param admin signer to close the strategy
     * @param strategy public key of the strategy
     * @returns instruction to close the strategy
     */
    closeStrategy = async (admin, strategy) => {
        const { address: strategyPubkey, strategy: strategyState } = await this.getStrategyStateIfNotFetched(strategy);
        const collInfos = await this.getCollateralInfos();
        const eventAuthority = await this.getEventAuthorityPDA(strategyState.strategyDex);
        const poolProgram = this.getDexProgramId(strategyState);
        let oldPositionOrBaseVaultAuthority = strategyState.baseVaultAuthority;
        let oldPositionMintOrBaseVaultAuthority = strategyState.baseVaultAuthority;
        let oldPositionTokenAccountOrBaseVaultAuthority = strategyState.baseVaultAuthority;
        let oldTickArrayLowerOrBaseVaultAuthority = strategyState.baseVaultAuthority;
        let oldTickArrayUpperOrBaseVaultAuthority = strategyState.baseVaultAuthority;
        if (strategyState.position !== pubkeys_1.DEFAULT_PUBLIC_KEY) {
            oldPositionOrBaseVaultAuthority = strategyState.position;
            oldPositionMintOrBaseVaultAuthority = strategyState.positionMint;
            oldPositionTokenAccountOrBaseVaultAuthority = strategyState.positionTokenAccount;
            oldTickArrayLowerOrBaseVaultAuthority = strategyState.tickArrayLower;
            oldTickArrayUpperOrBaseVaultAuthority = strategyState.tickArrayUpper;
        }
        const [userTokenAAta, userTokenBAta] = await Promise.all([
            (0, utils_1.getAssociatedTokenAddress)(strategyState.tokenAMint, strategyState.adminAuthority, (0, utils_1.keyOrDefault)(strategyState.tokenATokenProgram, token_1.TOKEN_PROGRAM_ADDRESS)),
            (0, utils_1.getAssociatedTokenAddress)(strategyState.tokenBMint, strategyState.adminAuthority, (0, utils_1.keyOrDefault)(strategyState.tokenBTokenProgram, token_1.TOKEN_PROGRAM_ADDRESS)),
        ]);
        const rewardMints = Array(6).fill(strategyState.pool);
        const rewardTokenPrograms = Array(6).fill(token_1.TOKEN_PROGRAM_ADDRESS);
        let reward0Vault = strategyState.baseVaultAuthority;
        let userReward0Ata = strategyState.baseVaultAuthority;
        if ((0, utils_1.isVaultInitialized)(strategyState.reward0Vault, strategyState.reward0Decimals)) {
            reward0Vault = strategyState.reward0Vault;
            rewardMints[0] = collInfos[strategyState.reward0CollateralId.toNumber()].mint;
            rewardTokenPrograms[0] = await this.getAccountOwner(rewardMints[0]);
            userReward0Ata = await (0, utils_1.getAssociatedTokenAddress)(rewardMints[0], strategyState.adminAuthority, rewardTokenPrograms[0]);
        }
        let reward1Vault = strategyState.baseVaultAuthority;
        let userReward1Ata = strategyState.baseVaultAuthority;
        if ((0, utils_1.isVaultInitialized)(strategyState.reward1Vault, strategyState.reward1Decimals)) {
            reward1Vault = strategyState.reward1Vault;
            rewardMints[1] = collInfos[strategyState.reward1CollateralId.toNumber()].mint;
            rewardTokenPrograms[1] = await this.getAccountOwner(rewardMints[1]);
            userReward1Ata = await (0, utils_1.getAssociatedTokenAddress)(rewardMints[1], strategyState.adminAuthority, rewardTokenPrograms[1]);
        }
        let reward2Vault = strategyState.baseVaultAuthority;
        let userReward2Ata = strategyState.baseVaultAuthority;
        if ((0, utils_1.isVaultInitialized)(strategyState.reward2Vault, strategyState.reward2Decimals)) {
            reward2Vault = strategyState.reward2Vault;
            rewardMints[2] = collInfos[strategyState.reward2CollateralId.toNumber()].mint;
            rewardTokenPrograms[2] = await this.getAccountOwner(rewardMints[2]);
            userReward2Ata = await (0, utils_1.getAssociatedTokenAddress)(rewardMints[2], strategyState.adminAuthority, rewardTokenPrograms[2]);
        }
        let kaminoReward0Vault = strategyState.baseVaultAuthority;
        const userKaminoReward0Ata = strategyState.baseVaultAuthority;
        if ((0, utils_1.isVaultInitialized)(strategyState.kaminoRewards[0].rewardVault, strategyState.kaminoRewards[0].decimals)) {
            kaminoReward0Vault = strategyState.kaminoRewards[0].rewardVault;
            rewardMints[3] = strategyState.kaminoRewards[0].rewardVault;
            rewardTokenPrograms[3] = await this.getAccountOwner(rewardMints[3]);
            userReward0Ata = await (0, utils_1.getAssociatedTokenAddress)(rewardMints[3], strategyState.adminAuthority, rewardTokenPrograms[3]);
        }
        let kaminoReward1Vault = strategyState.baseVaultAuthority;
        const userKaminoReward1Ata = strategyState.baseVaultAuthority;
        if ((0, utils_1.isVaultInitialized)(strategyState.kaminoRewards[1].rewardVault, strategyState.kaminoRewards[1].decimals)) {
            kaminoReward1Vault = strategyState.kaminoRewards[1].rewardVault;
            rewardMints[4] = strategyState.kaminoRewards[1].rewardVault;
            rewardTokenPrograms[4] = await this.getAccountOwner(rewardMints[4]);
            userReward1Ata = await (0, utils_1.getAssociatedTokenAddress)(rewardMints[4], strategyState.adminAuthority, rewardTokenPrograms[4]);
        }
        let kaminoReward2Vault = strategyState.baseVaultAuthority;
        const userKaminoReward2Ata = strategyState.baseVaultAuthority;
        if ((0, utils_1.isVaultInitialized)(strategyState.kaminoRewards[2].rewardVault, strategyState.kaminoRewards[2].decimals)) {
            kaminoReward2Vault = strategyState.kaminoRewards[2].rewardVault;
            rewardMints[5] = strategyState.kaminoRewards[2].rewardVault;
            rewardTokenPrograms[5] = await this.getAccountOwner(rewardMints[5]);
            userReward2Ata = await (0, utils_1.getAssociatedTokenAddress)(rewardMints[5], admin.address, rewardTokenPrograms[5]);
        }
        const strategyAccounts = {
            adminAuthority: admin,
            strategy: strategyPubkey,
            oldPositionOrBaseVaultAuthority,
            oldPositionMintOrBaseVaultAuthority,
            oldPositionTokenAccountOrBaseVaultAuthority,
            tokenAVault: strategyState.tokenAVault,
            tokenBVault: strategyState.tokenBVault,
            baseVaultAuthority: strategyState.baseVaultAuthority,
            system: system_1.SYSTEM_PROGRAM_ADDRESS,
            tokenProgram: token_1.TOKEN_PROGRAM_ADDRESS,
            poolProgram: poolProgram,
            userTokenAAta,
            userTokenBAta,
            reward0Vault,
            reward1Vault,
            reward2Vault,
            kaminoReward0Vault,
            kaminoReward1Vault,
            kaminoReward2Vault,
            userReward0Ata,
            userReward1Ata,
            userReward2Ata,
            userKaminoReward0Ata,
            userKaminoReward1Ata,
            userKaminoReward2Ata,
            oldTickArrayLowerOrBaseVaultAuthority,
            oldTickArrayUpperOrBaseVaultAuthority,
            pool: strategyState.pool,
            eventAuthority,
            tokenATokenProgram: (0, utils_1.keyOrDefault)(strategyState.tokenATokenProgram, token_1.TOKEN_PROGRAM_ADDRESS),
            tokenBTokenProgram: (0, utils_1.keyOrDefault)(strategyState.tokenBTokenProgram, token_1.TOKEN_PROGRAM_ADDRESS),
            tokenAMint: strategyState.tokenAMint,
            tokenBMint: strategyState.tokenBMint,
        };
        let ix = (0, instructions_2.closeStrategy)(strategyAccounts, undefined, this.getProgramID());
        for (let i = 0; i < 6; i++) {
            ix = {
                ...ix,
                accounts: ix.accounts?.concat([
                    { address: rewardMints[i], role: kit_1.AccountRole.READONLY },
                    { address: rewardTokenPrograms[i], role: kit_1.AccountRole.READONLY },
                ]),
            };
        }
        return ix;
    };
    getUserTopupVault = async (user) => {
        const [topupVault] = await (0, kit_1.getProgramDerivedAddress)({
            seeds: [Buffer.from('topup_vault'), addressEncoder.encode(user)],
            programAddress: this.getProgramID(),
        });
        return topupVault;
    };
    /**
     * Find program adresses required for kamino strategy creation
     * @param strategy
     * @param tokenMintA
     * @param tokenMintB
     * @private
     * @returns object with program addresses for kamino strategy creation
     */
    getStrategyProgramAddresses = async (strategy, tokenMintA, tokenMintB) => {
        const [tokenAVault, tokenABump] = await (0, kit_1.getProgramDerivedAddress)({
            seeds: [Buffer.from('svault_a'), addressEncoder.encode(strategy)],
            programAddress: this.getProgramID(),
        });
        const [tokenBVault, tokenBBump] = await (0, kit_1.getProgramDerivedAddress)({
            seeds: [Buffer.from('svault_b'), addressEncoder.encode(strategy)],
            programAddress: this.getProgramID(),
        });
        const [baseVaultAuthority, baseVaultAuthorityBump] = await (0, kit_1.getProgramDerivedAddress)({
            seeds: [Buffer.from('authority'), addressEncoder.encode(tokenAVault), addressEncoder.encode(tokenBVault)],
            programAddress: this.getProgramID(),
        });
        const [sharesMint, sharesMintBump] = await (0, kit_1.getProgramDerivedAddress)({
            seeds: [
                Buffer.from('shares'),
                addressEncoder.encode(strategy),
                addressEncoder.encode(tokenMintA),
                addressEncoder.encode(tokenMintB),
            ],
            programAddress: this.getProgramID(),
        });
        const [sharesMintAuthority, sharesMintAuthorityBump] = await (0, kit_1.getProgramDerivedAddress)({
            seeds: [Buffer.from('authority'), addressEncoder.encode(sharesMint)],
            programAddress: this.getProgramID(),
        });
        return {
            sharesMintAuthority,
            tokenAVault,
            tokenBVault,
            baseVaultAuthority,
            baseVaultAuthorityBump,
            sharesMintAuthorityBump,
            sharesMintBump,
            tokenBBump,
            sharesMint,
            tokenABump,
        };
    };
    /**
     * Get transaction instruction to create a new rent exempt strategy account
     * @param payer transaction payer (signer) public key
     * @param newStrategy public key of the new strategy
     * @returns transaction instruction to create the account
     */
    createStrategyAccount = async (payer, newStrategy) => {
        const accountSize = BigInt(accounts_1.WhirlpoolStrategy.layout.span + 8);
        return this.createAccountRentExempt(payer, newStrategy, accountSize);
    };
    createAccountRentExempt = async (payer, newAccount, size) => {
        const lamports = await this._rpc.getMinimumBalanceForRentExemption(size).send();
        return (0, system_1.getCreateAccountInstruction)({
            newAccount,
            space: size,
            lamports,
            payer,
            programAddress: this.getProgramID(),
        });
    };
    /**
     * Get transaction instruction to collect strategy fees from the treasury fee
     * vaults and rewards from the reward vaults.
     * @param strategy strategy public key or already fetched object
     * @param owner signer of the tx
     * @returns transaction instruction to collect strategy fees and rewards
     */
    collectFeesAndRewards = async (strategy, owner) => {
        const { address: strategyPubkey, strategy: strategyState } = await this.getStrategyStateIfNotFetched(strategy);
        const eventAuthority = await this.getEventAuthorityPDA(strategyState.strategyDex);
        const { treasuryFeeTokenAVault, treasuryFeeTokenBVault, treasuryFeeVaultAuthority } = await this.getTreasuryFeeVaultPDAs(strategyState.tokenAMint, strategyState.tokenBMint);
        let programId = this._orcaService.getWhirlpoolProgramId();
        let poolRewardVault0 = pubkeys_1.DEFAULT_PUBLIC_KEY;
        let poolRewardVault1 = pubkeys_1.DEFAULT_PUBLIC_KEY;
        let poolRewardVault2 = pubkeys_1.DEFAULT_PUBLIC_KEY;
        let rewardMint0 = pubkeys_1.DEFAULT_PUBLIC_KEY;
        let rewardMint1 = pubkeys_1.DEFAULT_PUBLIC_KEY;
        let rewardMint2 = pubkeys_1.DEFAULT_PUBLIC_KEY;
        if (strategyState.strategyDex.toNumber() === (0, utils_1.dexToNumber)('ORCA')) {
            const whirlpool = await accounts_2.Whirlpool.fetch(this._rpc, strategyState.pool, this._orcaService.getWhirlpoolProgramId());
            if (!whirlpool) {
                throw Error(`Could not fetch whirlpool state with pubkey ${strategyState.pool.toString()}`);
            }
            poolRewardVault0 = whirlpool.rewardInfos[0].vault;
            poolRewardVault1 = whirlpool.rewardInfos[1].vault;
            poolRewardVault2 = whirlpool.rewardInfos[2].vault;
            rewardMint0 = whirlpool.rewardInfos[0].mint;
            rewardMint1 = whirlpool.rewardInfos[1].mint;
            rewardMint2 = whirlpool.rewardInfos[2].mint;
        }
        else if (strategyState.strategyDex.toNumber() === (0, utils_1.dexToNumber)('RAYDIUM')) {
            programId = this._raydiumService.getRaydiumProgramId();
            const poolState = await accounts_3.PoolState.fetch(this._rpc, strategyState.pool, this._raydiumService.getRaydiumProgramId());
            if (!poolState) {
                throw Error(`Could not fetch Raydium pool state with pubkey ${strategyState.pool.toString()}`);
            }
            poolRewardVault0 = poolState.rewardInfos[0].tokenVault;
            poolRewardVault1 = poolState.rewardInfos[1].tokenVault;
            poolRewardVault2 = poolState.rewardInfos[2].tokenVault;
            rewardMint0 = poolState.rewardInfos[0].tokenMint;
            rewardMint1 = poolState.rewardInfos[1].tokenMint;
            rewardMint2 = poolState.rewardInfos[2].tokenMint;
        }
        else if (strategyState.strategyDex.toNumber() === (0, utils_1.dexToNumber)('METEORA')) {
            programId = this._meteoraService.getMeteoraProgramId();
            const poolState = await accounts_4.LbPair.fetch(this._rpc, strategyState.pool, this._meteoraService.getMeteoraProgramId());
            if (!poolState) {
                throw Error(`Could not fetch Meteora pool state with pubkey ${strategyState.pool.toString()}`);
            }
            poolRewardVault0 = poolState.rewardInfos[0].vault;
            poolRewardVault1 = poolState.rewardInfos[1].vault;
            poolRewardVault2 = strategyPubkey;
            rewardMint0 = poolState.rewardInfos[0].mint;
            rewardMint1 = poolState.rewardInfos[1].mint;
            rewardMint2 = this.getProgramID();
        }
        const accounts = {
            user: owner || strategyState.adminAuthority,
            strategy: strategyPubkey,
            globalConfig: strategyState.globalConfig,
            pool: strategyState.pool,
            position: strategyState.position,
            positionTokenAccount: strategyState.positionTokenAccount,
            treasuryFeeTokenAVault,
            treasuryFeeTokenBVault,
            treasuryFeeVaultAuthority,
            tokenAMint: strategyState.tokenAMint,
            tokenBMint: strategyState.tokenBMint,
            tokenAVault: strategyState.tokenAVault,
            tokenBVault: strategyState.tokenBVault,
            poolTokenVaultA: strategyState.poolTokenVaultA,
            poolTokenVaultB: strategyState.poolTokenVaultB,
            baseVaultAuthority: strategyState.baseVaultAuthority,
            reward0Vault: strategyState.reward0Vault,
            reward1Vault: strategyState.reward1Vault,
            reward2Vault: strategyState.baseVaultAuthority,
            poolRewardVault0: strategyState.reward0Decimals.toNumber() > 0 ? poolRewardVault0 : strategyState.baseVaultAuthority,
            poolRewardVault1: strategyState.reward1Decimals.toNumber() > 0 ? poolRewardVault1 : strategyState.baseVaultAuthority,
            poolRewardVault2: strategyState.reward2Decimals.toNumber() > 0 ? poolRewardVault2 : strategyState.baseVaultAuthority,
            tickArrayLower: strategyState.tickArrayLower,
            tickArrayUpper: strategyState.tickArrayUpper,
            raydiumProtocolPositionOrBaseVaultAuthority: strategyState.raydiumProtocolPositionOrBaseVaultAuthority,
            poolProgram: programId,
            instructionSysvarAccount: sysvars_1.SYSVAR_INSTRUCTIONS_ADDRESS,
            eventAuthority,
            tokenATokenProgram: (0, utils_1.keyOrDefault)(strategyState.tokenATokenProgram, token_1.TOKEN_PROGRAM_ADDRESS),
            tokenBTokenProgram: (0, utils_1.keyOrDefault)(strategyState.tokenBTokenProgram, token_1.TOKEN_PROGRAM_ADDRESS),
            memoProgram: pubkeys_1.MEMO_PROGRAM_ID,
            tokenProgram: token_1.TOKEN_PROGRAM_ADDRESS,
            tokenProgram2022: token_2022_1.TOKEN_2022_PROGRAM_ADDRESS,
        };
        let ix = (0, instructions_2.collectFeesAndRewards)(accounts, undefined, this.getProgramID());
        const pairs = [
            [strategyState.reward0Decimals.toNumber(), rewardMint0],
            [strategyState.reward1Decimals.toNumber(), rewardMint1],
            [strategyState.reward2Decimals.toNumber(), rewardMint2],
        ];
        for (const [decimals, mint] of pairs) {
            if (decimals > 0) {
                const tokenProgram = await this.getAccountOwner(mint);
                ix = {
                    ...ix,
                    accounts: ix.accounts?.concat([
                        { address: mint, role: kit_1.AccountRole.READONLY },
                        { address: tokenProgram, role: kit_1.AccountRole.READONLY },
                    ]),
                };
            }
        }
        if (strategyState.strategyDex.toNumber() === (0, utils_1.dexToNumber)('RAYDIUM')) {
            const [poolTickArrayBitmap] = await (0, kit_1.getProgramDerivedAddress)({
                seeds: [Buffer.from('pool_tick_array_bitmap_extension'), addressEncoder.encode(strategyState.pool)],
                programAddress: this._raydiumService.getRaydiumProgramId(),
            });
            ix = {
                ...ix,
                accounts: ix.accounts?.concat([{ address: poolTickArrayBitmap, role: kit_1.AccountRole.READONLY }]),
            };
        }
        return ix;
    };
    /**
     * Get orca position metadata program addresses
     * @param positionMint mint account of the position
     */
    getMetadataProgramAddressesOrca = async (positionMint) => {
        const [position, positionBump] = await (0, kit_1.getProgramDerivedAddress)({
            seeds: [Buffer.from('position'), addressEncoder.encode(positionMint)],
            programAddress: this._orcaService.getWhirlpoolProgramId(),
        });
        const [positionMetadata, positionMetadataBump] = await (0, kit_1.getProgramDerivedAddress)({
            seeds: [Buffer.from('metadata'), addressEncoder.encode(constants_1.METADATA_PROGRAM_ID), addressEncoder.encode(positionMint)],
            programAddress: constants_1.METADATA_PROGRAM_ID,
        });
        return {
            position,
            positionBump,
            positionMetadata,
            positionMetadataBump,
        };
    };
    getMetadataProgramAddressesRaydium = async (positionMint, pool, tickLowerIndex, tickUpperIndex) => {
        const { publicKey: protocolPosition, nonce: protocolPositionBump } = (0, lib_1.getPdaProtocolPositionAddress)((0, compat_2.toLegacyPublicKey)(this._raydiumService.getRaydiumProgramId()), (0, compat_2.toLegacyPublicKey)(pool), tickLowerIndex, tickUpperIndex);
        const [position, positionBump] = await (0, kit_1.getProgramDerivedAddress)({
            seeds: [Buffer.from('position'), addressEncoder.encode(positionMint)],
            programAddress: this._raydiumService.getRaydiumProgramId(),
        });
        const [positionMetadata, positionMetadataBump] = await (0, kit_1.getProgramDerivedAddress)({
            seeds: [Buffer.from('metadata'), addressEncoder.encode(constants_1.METADATA_PROGRAM_ID), addressEncoder.encode(positionMint)],
            programAddress: constants_1.METADATA_PROGRAM_ID,
        });
        return {
            position,
            positionBump,
            protocolPosition: (0, compat_1.fromLegacyPublicKey)(protocolPosition),
            protocolPositionBump,
            positionMetadata,
            positionMetadataBump,
        };
    };
    getStartEndTickIndexProgramAddressesOrca = async (whirlpool, whirlpoolState, tickLowerIndex, tickUpperIndex) => {
        const startTickIndex = (0, whirlpools_core_1.getTickArrayStartTickIndex)(tickLowerIndex, whirlpoolState.tickSpacing);
        const endTickIndex = (0, whirlpools_core_1.getTickArrayStartTickIndex)(tickUpperIndex, whirlpoolState.tickSpacing);
        const [lowerTickPubkey, lowerTickBump] = await (0, kit_1.getProgramDerivedAddress)({
            seeds: [Buffer.from('tick_array'), addressEncoder.encode(whirlpool), Buffer.from(startTickIndex.toString())],
            programAddress: this._orcaService.getWhirlpoolProgramId(),
        });
        const [upperTickPubkey, upperTickBump] = await (0, kit_1.getProgramDerivedAddress)({
            seeds: [Buffer.from('tick_array'), addressEncoder.encode(whirlpool), Buffer.from(endTickIndex.toString())],
            programAddress: this._orcaService.getWhirlpoolProgramId(),
        });
        return {
            lowerTick: lowerTickPubkey,
            lowerTickBump,
            upperTick: upperTickPubkey,
            upperTickBump,
        };
    };
    getStartEndTicketIndexProgramAddressesRaydium = async (pool, poolState, tickLowerIndex, tickUpperIndex) => {
        const startTickIndex = lib_1.TickUtils.getTickArrayStartIndexByTick(tickLowerIndex, poolState.tickSpacing);
        const endTickIndex = lib_1.TickUtils.getTickArrayStartIndexByTick(tickUpperIndex, poolState.tickSpacing);
        const [lowerTickPubkey, lowerTickBump] = await (0, kit_1.getProgramDerivedAddress)({
            seeds: [Buffer.from('tick_array'), addressEncoder.encode(pool), (0, lib_1.i32ToBytes)(startTickIndex)],
            programAddress: this._raydiumService.getRaydiumProgramId(),
        });
        const [upperTickPubkey, upperTickBump] = await (0, kit_1.getProgramDerivedAddress)({
            seeds: [Buffer.from('tick_array'), addressEncoder.encode(pool), (0, lib_1.i32ToBytes)(endTickIndex)],
            programAddress: this._raydiumService.getRaydiumProgramId(),
        });
        return {
            lowerTick: lowerTickPubkey,
            lowerTickBump,
            upperTick: upperTickPubkey,
            upperTickBump,
        };
    };
    readMeteoraPosition = async (poolPk, positionPk) => {
        const pool = await accounts_4.LbPair.fetch(this._rpc, poolPk, this._meteoraService.getMeteoraProgramId());
        const position = await accounts_4.PositionV2.fetch(this._rpc, positionPk, this._meteoraService.getMeteoraProgramId());
        if (!pool || !position) {
            return {
                Address: positionPk,
                amountX: new decimal_js_1.default(0),
                amountY: new decimal_js_1.default(0),
            };
        }
        const { lowerTick: lowerTickPk, upperTick: upperTickPk } = await this.getStartEndTicketIndexProgramAddressesMeteora(poolPk, position.lowerBinId);
        const lowerBinArray = await accounts_4.BinArray.fetch(this._rpc, lowerTickPk, this._meteoraService.getMeteoraProgramId());
        const upperBinArray = await accounts_4.BinArray.fetch(this._rpc, upperTickPk, this._meteoraService.getMeteoraProgramId());
        if (!lowerBinArray || !upperBinArray) {
            return {
                Address: positionPk,
                amountX: new decimal_js_1.default(0),
                amountY: new decimal_js_1.default(0),
            };
        }
        const binArrays = [lowerBinArray, upperBinArray];
        let totalAmountX = new decimal_js_1.default(0);
        let totalAmountY = new decimal_js_1.default(0);
        for (let idx = position.lowerBinId; idx <= position.upperBinId; idx++) {
            const bin = (0, meteora_1.getBinFromBinArrays)(idx, binArrays);
            if (bin) {
                const binX = new decimal_js_1.default(bin.amountX.toString());
                const binY = new decimal_js_1.default(bin.amountY.toString());
                const binLiq = new decimal_js_1.default(bin.liquiditySupply.toString());
                if (!binX.isNaN() && !binY.isNaN() && !binLiq.isNaN() && binLiq.gt(utils_1.ZERO)) {
                    const positionLiqNumber = position.liquidityShares[idx - position.lowerBinId];
                    if (positionLiqNumber && !positionLiqNumber.isZero()) {
                        const positionLiq = new decimal_js_1.default(positionLiqNumber.toString());
                        totalAmountX = totalAmountX.add(binX.mul(positionLiq).div(binLiq));
                        totalAmountY = totalAmountY.add(binY.mul(positionLiq).div(binLiq));
                    }
                }
            }
        }
        return {
            Address: positionPk,
            amountX: totalAmountX,
            amountY: totalAmountY,
        };
    };
    getStartEndTicketIndexProgramAddressesMeteora = async (pool, tickLowerIndex) => {
        const meteoraProgramId = this._meteoraService.getMeteoraProgramId();
        const lowerBinArrayIndex = (0, meteora_1.binIdToBinArrayIndex)(new bn_js_1.default(tickLowerIndex));
        const [lowerTick, lowerTickBump] = await (0, meteora_1.deriveBinArray)(pool, lowerBinArrayIndex, meteoraProgramId);
        const upperBinArrayIndex = lowerBinArrayIndex.add(new bn_js_1.default(1));
        const [upperTick, upperTickBump] = await (0, meteora_1.deriveBinArray)(pool, upperBinArrayIndex, meteoraProgramId);
        return {
            lowerTick,
            lowerTickBump,
            upperTick,
            upperTickBump,
        };
    };
    /**
     * Get a transaction to open liquidity position for a Kamino strategy
     * @param admin strategy admin authority
     * @param strategy strategy you want to open liquidity position for
     * @param positionMint position mint keypair
     * @param priceLower new position's lower price of the range
     * @param priceUpper new position's upper price of the range
     * @param status strategy status
     */
    openPosition = async (admin, strategy, positionMint, priceLower, priceUpper, status = new StrategyStatus_1.Uninitialized()) => {
        const { strategy: strategyState, address: strategyAddress } = await this.getStrategyStateIfNotFetched(strategy);
        if (!strategyState) {
            throw Error(`Could not fetch strategy state with pubkey ${strategy.toString()}`);
        }
        const eventAuthority = await this.getEventAuthorityPDA(strategyState.strategyDex);
        if (strategyState.strategyDex.toNumber() === (0, utils_1.dexToNumber)('ORCA')) {
            return this.openPositionOrca(admin, strategyAddress, strategyState.baseVaultAuthority, strategyState.pool, positionMint, priceLower, priceUpper, strategyState.tokenAVault, strategyState.tokenBVault, strategyState.tokenAMint, strategyState.tokenBMint, strategyState.tokenATokenProgram, strategyState.tokenBTokenProgram, strategyState.position, strategyState.positionMint, strategyState.positionTokenAccount, strategyState.tickArrayLower, strategyState.tickArrayUpper, status);
        }
        else if (strategyState.strategyDex.toNumber() === (0, utils_1.dexToNumber)('RAYDIUM')) {
            let reward0Vault = undefined;
            let reward1Vault = undefined;
            let reward2Vault = undefined;
            if (strategyState.reward0Decimals.toNumber() > 0) {
                reward0Vault = strategyState.reward0Vault;
            }
            if (strategyState.reward1Decimals.toNumber() > 0) {
                reward1Vault = strategyState.reward1Vault;
            }
            if (strategyState.reward2Decimals.toNumber() > 0) {
                reward2Vault = strategyState.reward2Vault;
            }
            return this.openPositionRaydium(admin, strategyAddress, strategyState.baseVaultAuthority, strategyState.pool, positionMint, priceLower, priceUpper, strategyState.tokenAVault, strategyState.tokenBVault, strategyState.tokenAMint, strategyState.tokenBMint, strategyState.tokenATokenProgram, strategyState.tokenBTokenProgram, strategyState.tickArrayLower, strategyState.tickArrayUpper, strategyState.position, strategyState.positionMint, strategyState.positionTokenAccount, strategyState.raydiumProtocolPositionOrBaseVaultAuthority, eventAuthority, status, reward0Vault, reward1Vault, reward2Vault);
        }
        else if (strategyState.strategyDex.toNumber() === (0, utils_1.dexToNumber)('METEORA')) {
            return this.openPositionMeteora(admin, strategyAddress, strategyState.baseVaultAuthority, strategyState.pool, positionMint, priceLower, priceUpper, strategyState.tokenAVault, strategyState.tokenBVault, strategyState.tokenAMint, strategyState.tokenBMint, strategyState.tokenATokenProgram, strategyState.tokenBTokenProgram, strategyState.position, strategyState.positionMint, strategyState.positionTokenAccount, strategyState.tickArrayLower, strategyState.tickArrayUpper, eventAuthority, status);
        }
        else {
            throw new Error(`Invalid dex ${strategyState.strategyDex.toString()}`);
        }
    };
    /**
     * Get a transaction to open liquidity position for a Kamino strategy
     * @param strategy strategy you want to open liquidity position for
     * @param positionMint new liquidity position account pubkey
     * @param priceLower new position's lower price of the range
     * @param priceUpper new position's upper price of the range
     * @param status strategy status
     */
    openPositionOrca = async (adminAuthority, strategy, baseVaultAuthority, pool, positionMint, priceLower, priceUpper, tokenAVault, tokenBVault, tokenAMint, tokenBMint, tokenATokenProgram, tokenBTokenProgram, oldPositionOrBaseVaultAuthority, oldPositionMintOrBaseVaultAuthority, oldPositionTokenAccountOrBaseVaultAuthority, oldTickArrayLowerOrBaseVaultAuthority, oldTickArrayUpperOrBaseVaultAuthority, status = new StrategyStatus_1.Uninitialized()) => {
        const whirlpool = await accounts_2.Whirlpool.fetch(this._rpc, pool, this._orcaService.getWhirlpoolProgramId());
        if (!whirlpool) {
            throw Error(`Could not fetch whirlpool state with pubkey ${pool.toString()}`);
        }
        const isRebalancing = status.discriminator === StrategyStatus_1.Rebalancing.discriminator;
        const decimalsA = await (0, utils_1.getMintDecimals)(this._rpc, whirlpool.tokenMintA);
        const decimalsB = await (0, utils_1.getMintDecimals)(this._rpc, whirlpool.tokenMintB);
        const tickLowerIndex = (0, whirlpools_core_1.priceToTickIndex)(priceLower.toNumber(), decimalsA, decimalsB);
        const tickUpperIndex = (0, whirlpools_core_1.priceToTickIndex)(priceUpper.toNumber(), decimalsA, decimalsB);
        const { position, positionBump, positionMetadata } = await this.getMetadataProgramAddressesOrca(positionMint.address);
        const positionTokenAccount = await (0, utils_1.getAssociatedTokenAddress)(positionMint.address, baseVaultAuthority);
        const args = {
            tickLowerIndex: new bn_js_1.default(tickLowerIndex),
            tickUpperIndex: new bn_js_1.default(tickUpperIndex),
            bump: positionBump,
        };
        const { lowerTick: startTickIndex, upperTick: endTickIndex } = await this.getStartEndTickIndexProgramAddressesOrca(pool, whirlpool, tickLowerIndex, tickUpperIndex);
        const globalConfig = await this.getGlobalConfigState(this._globalConfig);
        if (!globalConfig) {
            throw Error(`Could not fetch global config with pubkey ${this._globalConfig.toString()}`);
        }
        const accounts = {
            adminAuthority: adminAuthority,
            strategy,
            pool: pool,
            tickArrayLower: startTickIndex,
            tickArrayUpper: endTickIndex,
            baseVaultAuthority: baseVaultAuthority,
            position,
            positionMint: positionMint.address,
            positionMetadataAccount: positionMetadata,
            positionTokenAccount,
            rent: sysvars_1.SYSVAR_RENT_ADDRESS,
            system: system_1.SYSTEM_PROGRAM_ADDRESS,
            tokenProgram: token_1.TOKEN_PROGRAM_ADDRESS,
            tokenProgram2022: token_2022_1.TOKEN_2022_PROGRAM_ADDRESS,
            associatedTokenProgram: token_2022_1.ASSOCIATED_TOKEN_PROGRAM_ADDRESS,
            poolProgram: this._orcaService.getWhirlpoolProgramId(),
            oldPositionOrBaseVaultAuthority: isRebalancing ? oldPositionOrBaseVaultAuthority : baseVaultAuthority,
            oldPositionMintOrBaseVaultAuthority: isRebalancing ? oldPositionMintOrBaseVaultAuthority : positionMint.address,
            oldPositionTokenAccountOrBaseVaultAuthority: isRebalancing
                ? oldPositionTokenAccountOrBaseVaultAuthority
                : positionTokenAccount,
            globalConfig: this._globalConfig,
            oldTickArrayLowerOrBaseVaultAuthority: isRebalancing ? oldTickArrayLowerOrBaseVaultAuthority : baseVaultAuthority,
            oldTickArrayUpperOrBaseVaultAuthority: isRebalancing ? oldTickArrayUpperOrBaseVaultAuthority : baseVaultAuthority,
            tokenAVault,
            tokenBVault,
            poolTokenVaultA: whirlpool.tokenVaultA,
            poolTokenVaultB: whirlpool.tokenVaultB,
            scopePrices: globalConfig.scopePriceId,
            tokenInfos: globalConfig.tokenInfos,
            tokenAMint,
            tokenBMint,
            eventAuthority: (0, kit_1.none)(),
            consensusAccount: pubkeys_1.CONSENSUS_ID,
            tokenATokenProgram: (0, utils_1.keyOrDefault)(tokenATokenProgram, token_1.TOKEN_PROGRAM_ADDRESS),
            tokenBTokenProgram: (0, utils_1.keyOrDefault)(tokenBTokenProgram, token_1.TOKEN_PROGRAM_ADDRESS),
            memoProgram: pubkeys_1.MEMO_PROGRAM_ID,
        };
        const ix = (0, instructions_2.openLiquidityPosition)(args, accounts, undefined, this.getProgramID());
        const accs = [...(ix.accounts || [])];
        const accountIndex = accs.findIndex((acc) => acc.address === positionMint.address);
        if (accountIndex >= 0) {
            accs[accountIndex] = {
                ...accs[accountIndex],
                role: kit_1.AccountRole.WRITABLE_SIGNER,
                // @ts-ignore
                signer: positionMint,
            };
        }
        return {
            ...ix,
            accounts: accs,
        };
    };
    /**
     * Get a transaction to open liquidity position for a Kamino strategy
     * @param strategy strategy you want to open liquidity position for
     * @param positionMint new liquidity position account pubkey
     * @param priceLower new position's lower price of the range
     * @param priceUpper new position's upper price of the range
     * @param status strategy status
     */
    openPositionRaydium = async (adminAuthority, strategy, baseVaultAuthority, pool, positionMint, priceLower, priceUpper, tokenAVault, tokenBVault, tokenAMint, tokenBMint, tokenATokenProgram, tokenBTokenProgram, oldTickArrayLowerOrBaseVaultAuthority, oldTickArrayUpperOrBaseVaultAuthority, oldPositionOrBaseVaultAuthority, oldPositionMintOrBaseVaultAuthority, oldPositionTokenAccountOrBaseVaultAuthority, oldProtocolPositionOrBaseVaultAuthority, eventAuthority, status = new StrategyStatus_1.Uninitialized(), strategyRewardOVault, strategyReward1Vault, strategyReward2Vault) => {
        const poolState = await accounts_3.PoolState.fetch(this._rpc, pool, this._raydiumService.getRaydiumProgramId());
        if (!poolState) {
            throw Error(`Could not fetch Raydium pool state with pubkey ${pool.toString()}`);
        }
        const isRebalancing = status.discriminator === StrategyStatus_1.Rebalancing.discriminator;
        const decimalsA = await (0, utils_1.getMintDecimals)(this._rpc, poolState.tokenMint0);
        const decimalsB = await (0, utils_1.getMintDecimals)(this._rpc, poolState.tokenMint1);
        const tickLowerIndex = lib_1.TickMath.getTickWithPriceAndTickspacing(lib_1.TickMath.roundPriceWithTickspacing(priceLower, poolState.tickSpacing, decimalsA, decimalsB), poolState.tickSpacing, decimalsA, decimalsB);
        const tickUpperIndex = lib_1.TickMath.getTickWithPriceAndTickspacing(lib_1.TickMath.roundPriceWithTickspacing(priceUpper, poolState.tickSpacing, decimalsA, decimalsB), poolState.tickSpacing, decimalsA, decimalsB);
        const { position, positionBump, protocolPosition, positionMetadata } = await this.getMetadataProgramAddressesRaydium(positionMint.address, pool, tickLowerIndex, tickUpperIndex);
        const positionTokenAccount = await (0, utils_1.getAssociatedTokenAddress)(positionMint.address, baseVaultAuthority);
        const args = {
            tickLowerIndex: new bn_js_1.default(tickLowerIndex),
            tickUpperIndex: new bn_js_1.default(tickUpperIndex),
            bump: positionBump,
        };
        const { lowerTick: startTickIndex, upperTick: endTickIndex } = await this.getStartEndTicketIndexProgramAddressesRaydium(pool, poolState, tickLowerIndex, tickUpperIndex);
        const globalConfig = await this.getGlobalConfigState(this._globalConfig);
        if (!globalConfig) {
            throw Error(`Could not fetch global config with pubkey ${this._globalConfig.toString()}`);
        }
        const accounts = {
            adminAuthority: adminAuthority,
            strategy,
            pool: pool,
            tickArrayLower: startTickIndex,
            tickArrayUpper: endTickIndex,
            baseVaultAuthority: baseVaultAuthority,
            position,
            positionMint: positionMint.address,
            positionMetadataAccount: positionMetadata,
            positionTokenAccount,
            rent: sysvars_1.SYSVAR_RENT_ADDRESS,
            system: system_1.SYSTEM_PROGRAM_ADDRESS,
            tokenProgram: token_1.TOKEN_PROGRAM_ADDRESS,
            tokenProgram2022: token_2022_1.TOKEN_2022_PROGRAM_ADDRESS,
            associatedTokenProgram: token_2022_1.ASSOCIATED_TOKEN_PROGRAM_ADDRESS,
            poolProgram: this._raydiumService.getRaydiumProgramId(),
            oldPositionOrBaseVaultAuthority: isRebalancing ? oldPositionOrBaseVaultAuthority : baseVaultAuthority,
            oldPositionMintOrBaseVaultAuthority: isRebalancing ? oldPositionMintOrBaseVaultAuthority : positionMint.address,
            oldPositionTokenAccountOrBaseVaultAuthority: isRebalancing
                ? oldPositionTokenAccountOrBaseVaultAuthority
                : positionTokenAccount,
            globalConfig: this._globalConfig,
            oldTickArrayLowerOrBaseVaultAuthority: isRebalancing ? oldTickArrayLowerOrBaseVaultAuthority : baseVaultAuthority,
            oldTickArrayUpperOrBaseVaultAuthority: isRebalancing ? oldTickArrayUpperOrBaseVaultAuthority : baseVaultAuthority,
            tokenAVault: tokenAVault,
            tokenBVault: tokenBVault,
            poolTokenVaultA: poolState.tokenVault0,
            poolTokenVaultB: poolState.tokenVault1,
            scopePrices: globalConfig.scopePriceId,
            tokenInfos: globalConfig.tokenInfos,
            tokenAMint,
            tokenBMint,
            eventAuthority,
            consensusAccount: pubkeys_1.CONSENSUS_ID,
            tokenATokenProgram: (0, utils_1.keyOrDefault)(tokenATokenProgram, token_1.TOKEN_PROGRAM_ADDRESS),
            tokenBTokenProgram: (0, utils_1.keyOrDefault)(tokenBTokenProgram, token_1.TOKEN_PROGRAM_ADDRESS),
            memoProgram: pubkeys_1.MEMO_PROGRAM_ID,
        };
        const [poolTickArrayBitmap] = await (0, kit_1.getProgramDerivedAddress)({
            seeds: [Buffer.from('pool_tick_array_bitmap_extension'), addressEncoder.encode(pool)],
            programAddress: this._raydiumService.getRaydiumProgramId(),
        });
        let ix = (0, instructions_2.openLiquidityPosition)(args, accounts, undefined, this.getProgramID());
        ix = {
            ...ix,
            accounts: ix.accounts?.concat([
                { address: protocolPosition, role: kit_1.AccountRole.WRITABLE },
                { address: oldProtocolPositionOrBaseVaultAuthority, role: kit_1.AccountRole.WRITABLE },
                { address: constants_1.METADATA_PROGRAM_ID, role: kit_1.AccountRole.READONLY },
                { address: poolTickArrayBitmap, role: kit_1.AccountRole.WRITABLE },
            ]),
        };
        if (strategyRewardOVault) {
            ix = {
                ...ix,
                accounts: ix.accounts?.concat([
                    { address: poolState.rewardInfos[0].tokenVault, role: kit_1.AccountRole.WRITABLE },
                    { address: strategyRewardOVault, role: kit_1.AccountRole.WRITABLE },
                    { address: poolState.rewardInfos[0].tokenMint, role: kit_1.AccountRole.READONLY },
                ]),
            };
        }
        if (strategyReward1Vault) {
            ix = {
                ...ix,
                accounts: ix.accounts?.concat([
                    { address: poolState.rewardInfos[1].tokenVault, role: kit_1.AccountRole.WRITABLE },
                    { address: strategyReward1Vault, role: kit_1.AccountRole.WRITABLE },
                    { address: poolState.rewardInfos[1].tokenMint, role: kit_1.AccountRole.READONLY },
                ]),
            };
        }
        if (strategyReward2Vault) {
            ix = {
                ...ix,
                accounts: ix.accounts?.concat([
                    { address: poolState.rewardInfos[2].tokenVault, role: kit_1.AccountRole.WRITABLE },
                    { address: strategyReward2Vault, role: kit_1.AccountRole.WRITABLE },
                    { address: poolState.rewardInfos[2].tokenMint, role: kit_1.AccountRole.READONLY },
                ]),
            };
        }
        const accs = [...(ix.accounts || [])];
        const accountIndex = accs.findIndex((acc) => acc.address === positionMint.address);
        if (accountIndex >= 0) {
            accs[accountIndex] = {
                ...accs[accountIndex],
                role: kit_1.AccountRole.WRITABLE_SIGNER,
                // @ts-ignore
                signer: positionMint,
            };
        }
        return {
            ...ix,
            accounts: accs,
        };
    };
    /**
     * Get a transaction to open liquidity position for a Kamino strategy
     * @param strategy strategy you want to open liquidity position for
     * @param positionMint new liquidity position account pubkey
     * @param priceLower new position's lower price of the range
     * @param priceUpper new position's upper price of the range
     * @param status strategy status
     */
    openPositionMeteora = async (adminAuthority, strategy, baseVaultAuthority, pool, position, priceLower, priceUpper, tokenAVault, tokenBVault, tokenAMint, tokenBMint, tokenATokenProgram, tokenBTokenProgram, oldPositionOrBaseVaultAuthority, oldPositionMintOrBaseVaultAuthority, oldPositionTokenAccountOrBaseVaultAuthority, oldTickArrayLowerOrBaseVaultAuthority, oldTickArrayUpperOrBaseVaultAuthority, eventAuthority, status = new StrategyStatus_1.Uninitialized()) => {
        const lbPair = await accounts_4.LbPair.fetch(this._rpc, pool, this._meteoraService.getMeteoraProgramId());
        if (!lbPair) {
            throw Error(`Could not fetch meteora lbpair state with pubkey ${pool.toString()}`);
        }
        const isRebalancing = status.discriminator === StrategyStatus_1.Rebalancing.discriminator;
        const decimalsA = await (0, utils_1.getMintDecimals)(this._rpc, lbPair.tokenXMint);
        const decimalsB = await (0, utils_1.getMintDecimals)(this._rpc, lbPair.tokenYMint);
        const tickLowerIndex = (0, meteora_1.getBinIdFromPriceWithDecimals)(priceLower, lbPair.binStep, true, decimalsA, decimalsB);
        const tickUpperIndex = (0, meteora_1.getBinIdFromPriceWithDecimals)(priceUpper, lbPair.binStep, true, decimalsA, decimalsB);
        const { position: positionMint, positionBump, positionMetadata, } = await this.getMetadataProgramAddressesOrca(position.address);
        const positionTokenAccount = await (0, utils_1.getAssociatedTokenAddress)(position.address, baseVaultAuthority);
        const args = {
            tickLowerIndex: new bn_js_1.default(tickLowerIndex),
            tickUpperIndex: new bn_js_1.default(tickUpperIndex),
            bump: positionBump,
        };
        const { lowerTick: startTickIndex, upperTick: endTickIndex } = await this.getStartEndTicketIndexProgramAddressesMeteora(pool, tickLowerIndex);
        const globalConfig = await this.getGlobalConfigState(this._globalConfig);
        if (!globalConfig) {
            throw Error(`Could not fetch global config with pubkey ${this._globalConfig.toString()}`);
        }
        const accounts = {
            adminAuthority: adminAuthority,
            strategy,
            pool: pool,
            tickArrayLower: startTickIndex,
            tickArrayUpper: endTickIndex,
            baseVaultAuthority: baseVaultAuthority,
            position: position.address,
            positionMint,
            positionMetadataAccount: positionMetadata,
            positionTokenAccount,
            rent: sysvars_1.SYSVAR_RENT_ADDRESS,
            system: system_1.SYSTEM_PROGRAM_ADDRESS,
            tokenProgram: token_1.TOKEN_PROGRAM_ADDRESS,
            tokenProgram2022: token_2022_1.TOKEN_2022_PROGRAM_ADDRESS,
            associatedTokenProgram: token_2022_1.ASSOCIATED_TOKEN_PROGRAM_ADDRESS,
            poolProgram: this._meteoraService.getMeteoraProgramId(),
            oldPositionOrBaseVaultAuthority: isRebalancing ? oldPositionOrBaseVaultAuthority : baseVaultAuthority,
            oldPositionMintOrBaseVaultAuthority: isRebalancing ? oldPositionMintOrBaseVaultAuthority : positionMint,
            oldPositionTokenAccountOrBaseVaultAuthority: isRebalancing
                ? oldPositionTokenAccountOrBaseVaultAuthority
                : positionTokenAccount,
            globalConfig: this._globalConfig,
            oldTickArrayLowerOrBaseVaultAuthority: isRebalancing ? oldTickArrayLowerOrBaseVaultAuthority : baseVaultAuthority,
            oldTickArrayUpperOrBaseVaultAuthority: isRebalancing ? oldTickArrayUpperOrBaseVaultAuthority : baseVaultAuthority,
            tokenAVault,
            tokenBVault,
            poolTokenVaultA: lbPair.reserveX,
            poolTokenVaultB: lbPair.reserveY,
            scopePrices: globalConfig.scopePriceId,
            tokenInfos: globalConfig.tokenInfos,
            tokenAMint,
            tokenBMint,
            eventAuthority,
            consensusAccount: pubkeys_1.CONSENSUS_ID,
            tokenATokenProgram: (0, utils_1.keyOrDefault)(tokenATokenProgram, token_1.TOKEN_PROGRAM_ADDRESS),
            tokenBTokenProgram: (0, utils_1.keyOrDefault)(tokenBTokenProgram, token_1.TOKEN_PROGRAM_ADDRESS),
            memoProgram: pubkeys_1.MEMO_PROGRAM_ID,
        };
        const ix = (0, instructions_2.openLiquidityPosition)(args, accounts, undefined, this.getProgramID());
        const accs = [...(ix.accounts || [])];
        const accountIndex = accs.findIndex((acc) => acc.address === position.address);
        if (accountIndex >= 0) {
            accs[accountIndex] = {
                ...accs[accountIndex],
                role: kit_1.AccountRole.WRITABLE_SIGNER,
                // @ts-ignore
                signer: position,
            };
        }
        return {
            ...ix,
            accounts: accs,
        };
    };
    /**
     * Get a transaction for executive withdrawal from a Kamino strategy.
     * @param strategy strategy pubkey or object
     * @param action withdrawal action
     * @returns transaction for executive withdrawal
     */
    executiveWithdraw = async (admin, strategy, action) => {
        const { address: strategyPubkey, strategy: strategyState } = await this.getStrategyStateIfNotFetched(strategy);
        const eventAuthority = await this.getEventAuthorityPDA(strategyState.strategyDex);
        const globalConfig = await this.getGlobalConfigState(strategyState.globalConfig);
        if (globalConfig === null) {
            throw new Error(`Unable to fetch GlobalConfig with Pubkey ${strategyState.globalConfig}`);
        }
        const args = {
            action: action.discriminator,
        };
        const programId = this.getDexProgramId(strategyState);
        const accounts = {
            adminAuthority: admin,
            strategy: strategyPubkey,
            globalConfig: strategyState.globalConfig,
            pool: strategyState.pool,
            position: strategyState.position,
            positionTokenAccount: strategyState.positionTokenAccount,
            baseVaultAuthority: strategyState.baseVaultAuthority,
            tickArrayLower: strategyState.tickArrayLower,
            tickArrayUpper: strategyState.tickArrayUpper,
            tokenAVault: strategyState.tokenAVault,
            tokenBVault: strategyState.tokenBVault,
            poolTokenVaultA: strategyState.poolTokenVaultA,
            poolTokenVaultB: strategyState.poolTokenVaultB,
            tokenAMint: strategyState.tokenAMint,
            tokenBMint: strategyState.tokenBMint,
            scopePrices: strategyState.scopePrices,
            raydiumProtocolPositionOrBaseVaultAuthority: strategyState.raydiumProtocolPositionOrBaseVaultAuthority,
            poolProgram: programId,
            tokenInfos: globalConfig.tokenInfos,
            eventAuthority,
            tokenATokenProgram: (0, utils_1.keyOrDefault)(strategyState.tokenATokenProgram, token_1.TOKEN_PROGRAM_ADDRESS),
            tokenBTokenProgram: (0, utils_1.keyOrDefault)(strategyState.tokenBTokenProgram, token_1.TOKEN_PROGRAM_ADDRESS),
            memoProgram: pubkeys_1.MEMO_PROGRAM_ID,
            tokenProgram: token_1.TOKEN_PROGRAM_ADDRESS,
            tokenProgram2022: token_2022_1.TOKEN_2022_PROGRAM_ADDRESS,
        };
        let executiveWithdrawIx = (0, instructions_2.executiveWithdraw)(args, accounts, undefined, this.getProgramID());
        //  for Raydium strats we need to collect fees and rewards before withdrawal
        //  add rewards vaults accounts to withdraw
        const isRaydium = strategyState.strategyDex.toNumber() === (0, utils_1.dexToNumber)('RAYDIUM');
        if (isRaydium) {
            const poolState = await this.getRaydiumPoolByAddress(strategyState.pool);
            if (!poolState) {
                throw new Error('Pool is not found');
            }
            if (strategyState.reward0Decimals.toNumber() > 0) {
                executiveWithdrawIx = {
                    ...executiveWithdrawIx,
                    accounts: executiveWithdrawIx.accounts?.concat([
                        { address: poolState.rewardInfos[0].tokenVault, role: kit_1.AccountRole.WRITABLE },
                        { address: strategyState.reward0Vault, role: kit_1.AccountRole.WRITABLE },
                    ]),
                };
            }
            if (strategyState.reward1Decimals.toNumber() > 0) {
                executiveWithdrawIx = {
                    ...executiveWithdrawIx,
                    accounts: executiveWithdrawIx.accounts?.concat([
                        { address: poolState.rewardInfos[1].tokenVault, role: kit_1.AccountRole.WRITABLE },
                        { address: strategyState.reward1Vault, role: kit_1.AccountRole.WRITABLE },
                    ]),
                };
            }
            if (strategyState.reward2Decimals.toNumber() > 0) {
                executiveWithdrawIx = {
                    ...executiveWithdrawIx,
                    accounts: executiveWithdrawIx.accounts?.concat([
                        { address: poolState.rewardInfos[2].tokenVault, role: kit_1.AccountRole.WRITABLE },
                        { address: strategyState.reward2Vault, role: kit_1.AccountRole.WRITABLE },
                    ]),
                };
            }
        }
        return executiveWithdrawIx;
    };
    /**
     * Get a an instruction to update the reference price type of a strategy
     * @param admin transaction signer
     * @param strategy strategy pubkey or object
     * @param referencePriceType new reference price type
     */
    getUpdateReferencePriceTypeIx = async (admin, strategy, referencePriceType) => {
        const { address } = await this.getStrategyStateIfNotFetched(strategy);
        return (0, utils_1.getUpdateStrategyConfigIx)(admin, this._globalConfig, address, new StrategyConfigOption_1.UpdateReferencePriceType(), new decimal_js_1.default(referencePriceType.discriminator), this.getProgramID());
    };
    /**
     * Get a transaction to invest funds from the Kamino vaults and put them into the DEX pool as liquidity.
     * @param strategy strategy pubkey or object
     * @param payer transaction payer
     */
    invest = async (strategy, payer) => {
        const strategyWithAddress = await this.getStrategyStateIfNotFetched(strategy);
        if (!strategyWithAddress || !strategyWithAddress.strategy) {
            throw Error(`Could not fetch strategy state with pubkey ${strategy.toString()}`);
        }
        const strategyState = strategyWithAddress.strategy;
        const globalConfig = await this.getGlobalConfigState(strategyState.globalConfig);
        if (!globalConfig) {
            throw Error(`Could not fetch global config with pubkey ${strategyState.globalConfig.toString()}`);
        }
        const programId = this.getDexProgramId(strategyState);
        const eventAuthority = await this.getEventAuthorityPDA(strategyState.strategyDex);
        const accounts = {
            position: strategyState.position,
            positionTokenAccount: strategyState.positionTokenAccount,
            pool: strategyState.pool,
            tokenAVault: strategyState.tokenAVault,
            tokenBVault: strategyState.tokenBVault,
            baseVaultAuthority: strategyState.baseVaultAuthority,
            payer,
            strategy: strategyWithAddress.address,
            globalConfig: strategyState.globalConfig,
            poolTokenVaultA: strategyState.poolTokenVaultA,
            poolTokenVaultB: strategyState.poolTokenVaultB,
            tickArrayLower: strategyState.tickArrayLower,
            tickArrayUpper: strategyState.tickArrayUpper,
            scopePrices: globalConfig.scopePriceId,
            raydiumProtocolPositionOrBaseVaultAuthority: strategyState.raydiumProtocolPositionOrBaseVaultAuthority,
            tokenInfos: globalConfig.tokenInfos,
            poolProgram: programId,
            instructionSysvarAccount: sysvars_1.SYSVAR_INSTRUCTIONS_ADDRESS,
            tokenAMint: strategyState.tokenAMint,
            tokenBMint: strategyState.tokenBMint,
            eventAuthority,
            tokenATokenProgram: (0, utils_1.keyOrDefault)(strategyState.tokenATokenProgram, token_1.TOKEN_PROGRAM_ADDRESS),
            tokenBTokenProgram: (0, utils_1.keyOrDefault)(strategyState.tokenBTokenProgram, token_1.TOKEN_PROGRAM_ADDRESS),
            memoProgram: pubkeys_1.MEMO_PROGRAM_ID,
            tokenProgram: token_1.TOKEN_PROGRAM_ADDRESS,
            tokenProgram2022: token_2022_1.TOKEN_2022_PROGRAM_ADDRESS,
        };
        return (0, instructions_2.invest)(accounts, undefined, this.getProgramID());
    };
    /**
     * Get a list of instructions to collect the pending fees and invest them into the Kamino strategy's position.
     * @param strategy strategy pubkey or object
     * @param payer transaction payer
     */
    compound = async (strategy, payer) => {
        // fetch here so the underlying instructions won't need to fetch
        const strategyWithAddress = await this.getStrategyStateIfNotFetched(strategy);
        if (!strategyWithAddress) {
            throw Error(`Could not fetch strategy state with pubkey ${strategy.toString()}`);
        }
        const collectFeesAndRewardsIx = this.collectFeesAndRewards(strategyWithAddress, payer);
        const investIx = this.invest(strategy, payer);
        return Promise.all([collectFeesAndRewardsIx, investIx]);
    };
    /**
     * Get a the pending fees in lamports of a strategy.
     * @param strategy strategy pubkey or object
     */
    getPendingFees = async (strategies) => {
        const strategiesWithAddresses = await this.getStrategiesWithAddresses(strategies);
        const raydiumStrategies = strategiesWithAddresses.filter((x) => x.strategy.strategyDex.toNumber() === (0, utils_1.dexToNumber)('RAYDIUM') && x.strategy.position !== pubkeys_1.DEFAULT_PUBLIC_KEY);
        const raydiumPositionsPromise = this.getRaydiumPositions(raydiumStrategies.map((x) => x.strategy.position));
        const orcaStrategies = strategiesWithAddresses.filter((x) => x.strategy.strategyDex.toNumber() === (0, utils_1.dexToNumber)('ORCA') && x.strategy.position !== pubkeys_1.DEFAULT_PUBLIC_KEY);
        const orcaPositionsPromise = this.getOrcaPositions(orcaStrategies.map((x) => x.strategy.position));
        const meteoraStrategies = strategiesWithAddresses.filter((x) => x.strategy.strategyDex.toNumber() === (0, utils_1.dexToNumber)('METEORA') && x.strategy.position !== pubkeys_1.DEFAULT_PUBLIC_KEY);
        const meteoraPositionsPromise = this.getMeteoraPositions(meteoraStrategies.map((x) => x.strategy.position));
        const [raydiumPositions, orcaPositions, meteoraPositions] = await Promise.all([
            raydiumPositionsPromise,
            orcaPositionsPromise,
            meteoraPositionsPromise,
        ]);
        const result = [];
        for (let index = 0; index < orcaStrategies.length; index++) {
            const orcaPosition = orcaPositions[index];
            if (!orcaPosition) {
                throw Error(`Could not fetch Orca position state with pubkey ${orcaStrategies[index].strategy.position.toString()}`);
            }
            const pendingFees = {
                a: new decimal_js_1.default(orcaPosition.feeOwedA.toString()),
                b: new decimal_js_1.default(orcaPosition.feeOwedB.toString()),
            };
            result.push({
                strategy: orcaStrategies[index],
                pendingFees,
            });
        }
        for (let index = 0; index < raydiumStrategies.length; index++) {
            const raydiumPosition = raydiumPositions[index];
            if (!raydiumPosition) {
                throw Error(`Could not fetch Raydium position state with pubkey ${raydiumStrategies[index].strategy.position.toString()}`);
            }
            const pendingFees = {
                a: new decimal_js_1.default(raydiumPosition.tokenFeesOwed0.toString()),
                b: new decimal_js_1.default(raydiumPosition.tokenFeesOwed1.toString()),
            };
            result.push({
                strategy: raydiumStrategies[index],
                pendingFees,
            });
        }
        for (let index = 0; index < meteoraStrategies.length; index++) {
            const meteoraPosition = meteoraPositions[index];
            if (!meteoraPosition) {
                throw Error(`Could not fetch Meteora position state with pubkey ${meteoraStrategies[index].strategy.position.toString()}`);
            }
            const pendingFees = {
                a: utils_1.ZERO,
                b: utils_1.ZERO,
            };
            for (const feeInfo of meteoraPosition.feeInfos) {
                pendingFees.a = pendingFees.a.add(feeInfo.feeXPending.toString());
                pendingFees.b = pendingFees.b.add(feeInfo.feeYPending.toString());
            }
            result.push({
                strategy: meteoraStrategies[index],
                pendingFees,
            });
        }
        return result;
    };
    getUpdateRebalancingParamsFromRebalanceFieldsIx = async (strategyAdmin, strategy, rebalanceFieldInfos) => {
        const rebalanceType = (0, utils_2.getRebalanceTypeFromRebalanceFields)(rebalanceFieldInfos);
        const strategyWithAddress = await this.getStrategyStateIfNotFetched(strategy);
        if (!strategyWithAddress || !strategyWithAddress.strategy) {
            throw Error(`Could not fetch strategy state with pubkey ${strategy.toString()}`);
        }
        const rebalanceParams = rebalanceFieldInfos
            .filter((x) => x.label != consts_1.RebalanceTypeLabelName && x.enabled)
            .map((f) => new decimal_js_1.default(f.value));
        return this.getUpdateRebalancingParamsIxns(strategyAdmin, strategyWithAddress.address, rebalanceParams, rebalanceType, strategyWithAddress.strategy.tokenAMintDecimals.toNumber(), strategyWithAddress.strategy.tokenBMintDecimals.toNumber());
    };
    processRebalanceParams = async (dex, pool, rebalanceType, rebalanceParams) => {
        const processedRebalanceParams = [...rebalanceParams];
        const rebalanceTypeKind = (0, utils_1.numberToRebalanceType)(rebalanceType.toNumber());
        if (dex === 'ORCA') {
            const { whirlpool: whilrpoolState } = await this.getWhirlpoolStateIfNotFetched(pool);
            if (rebalanceTypeKind.kind === types_1.RebalanceType.Drift.kind) {
                processedRebalanceParams[0] = new decimal_js_1.default((0, utils_1.getNearestValidTickIndexFromTickIndex)(rebalanceParams[0].toNumber(), whilrpoolState.tickSpacing));
            }
        }
        return processedRebalanceParams;
    };
    getUpdateRebalancingParamsIxns = async (strategyAdmin, strategy, rebalanceParams, rebalanceType, tokenADecimals, tokenBDecimals) => {
        const { address: strategyAddress, strategy: strategyState } = await this.getStrategyStateIfNotFetched(strategy);
        if (!rebalanceType) {
            rebalanceType = (0, utils_1.numberToRebalanceType)(strategyState.rebalanceType);
        }
        tokenADecimals = strategyState.tokenAMintDecimals.toNumber();
        tokenBDecimals = strategyState.tokenBMintDecimals.toNumber();
        const processedRebalanceParams = await this.processRebalanceParams((0, utils_1.numberToDex)(strategyState.strategyDex.toNumber()), strategyState.pool, new decimal_js_1.default(rebalanceType.discriminator), rebalanceParams);
        const value = (0, utils_1.buildStrategyRebalanceParams)(processedRebalanceParams, rebalanceType, tokenADecimals, tokenBDecimals);
        const args = {
            mode: types_1.StrategyConfigOption.UpdateRebalanceParams.discriminator,
            value,
        };
        const accounts = {
            adminAuthority: strategyAdmin,
            newAccount: pubkeys_1.DEFAULT_PUBLIC_KEY, // not used
            globalConfig: this._globalConfig,
            strategy: strategyAddress,
            systemProgram: system_1.SYSTEM_PROGRAM_ADDRESS,
        };
        return (0, instructions_2.updateStrategyConfig)(args, accounts, undefined, this.getProgramID());
    };
    getUpdateRebalancingParamsForUninitializedStratIx = async (strategyAdmin, strategy, rebalanceParams, rebalanceType, tokenADecimals, tokenBDecimals) => {
        const value = (0, utils_1.buildStrategyRebalanceParams)(rebalanceParams, rebalanceType, tokenADecimals, tokenBDecimals);
        const args = {
            mode: types_1.StrategyConfigOption.UpdateRebalanceParams.discriminator,
            value,
        };
        const accounts = {
            adminAuthority: strategyAdmin,
            newAccount: pubkeys_1.DEFAULT_PUBLIC_KEY, // not used
            globalConfig: this._globalConfig,
            strategy,
            systemProgram: system_1.SYSTEM_PROGRAM_ADDRESS,
        };
        return (0, instructions_2.updateStrategyConfig)(args, accounts, undefined, this.getProgramID());
    };
    buildStrategyRebalanceParams = async (strategy) => {
        const strategyState = await this.getStrategyStateIfNotFetched(strategy);
        const params = strategyState.strategy.rebalanceRaw.params.map((p) => new decimal_js_1.default(p.toString()));
        return (0, utils_1.buildStrategyRebalanceParams)(params, (0, utils_1.numberToRebalanceType)(strategyState.strategy.rebalanceType));
    };
    /**
     * Get a list of instructions to initialize and set up a strategy
     * @param dex the dex to use (Orca or Raydium)
     * @param feeTierBps which fee tier for that specific pair should be used (in BPS)
     * @param tokenAMint the mint of TokenA in the pool
     * @param tokenBMint the mint of TokenB in the pool
     * @param depositCap the maximum amount in USD in lamports (6 decimals) that can be deposited into the strategy
     * @param depositCapPerIx the maximum amount in USD in lamports (6 decimals) that can be deposited into the strategy per instruction
     */
    getBuildStrategyIxns = async (dex, feeTierBps, strategy, positionMint, strategyAdmin, rebalanceType, rebalanceParams, tokenAMint, tokenBMint, depositCap, depositCapPerIx, withdrawFeeBps, depositFeeBps, performanceFeeBps) => {
        const feeTier = feeTierBps.div(CreationParameters_1.FullBPS);
        // check both tokens exist in collateralInfo
        const config = await this.getGlobalConfigState(this._globalConfig);
        if (!config) {
            throw Error(`Could not fetch globalConfig  with pubkey ${this.getGlobalConfig().toString()}`);
        }
        const collateralInfos = await this.getCollateralInfo(config.tokenInfos);
        if (!this.mintIsSupported(collateralInfos, tokenAMint) || !this.mintIsSupported(collateralInfos, tokenBMint)) {
            throw Error(`Token mint ${tokenAMint.toString()} is not supported`);
        }
        const pool = await this.getPoolInitializedForDexPairTier(dex, tokenAMint, tokenBMint, feeTier.mul(CreationParameters_1.FullBPS));
        if (pool === pubkeys_1.DEFAULT_PUBLIC_KEY) {
            throw Error(`Pool for tokens ${tokenAMint.toString()} and ${tokenBMint.toString()} for feeTier ${feeTier.toString()} does not exist`);
        }
        const processedRebalanceParams = await this.processRebalanceParams(dex, pool, rebalanceType, rebalanceParams);
        const price = await this.getCurrentPriceFromPool(dex, pool);
        let tokenMintA;
        let tokenMintB;
        let tickSpacing;
        if (dex === 'ORCA') {
            const whirlpoolState = await accounts_2.Whirlpool.fetch(this._rpc, pool, this._orcaService.getWhirlpoolProgramId());
            if (!whirlpoolState) {
                throw Error(`Could not fetch whirlpool state with pubkey ${pool.toString()}`);
            }
            tokenMintA = whirlpoolState.tokenMintA;
            tokenMintB = whirlpoolState.tokenMintB;
            tickSpacing = whirlpoolState.tickSpacing;
        }
        else if (dex === 'RAYDIUM') {
            const raydiumPoolState = await accounts_3.PoolState.fetch(this._rpc, pool, this._raydiumService.getRaydiumProgramId());
            if (!raydiumPoolState) {
                throw Error(`Could not fetch Raydium pool state with pubkey ${pool.toString()}`);
            }
            tokenMintA = raydiumPoolState.tokenMint0;
            tokenMintB = raydiumPoolState.tokenMint1;
            tickSpacing = raydiumPoolState.tickSpacing;
        }
        else if (dex === 'METEORA') {
            const meteoraPoolState = await accounts_4.LbPair.fetch(this._rpc, pool, this._meteoraService.getMeteoraProgramId());
            if (!meteoraPoolState) {
                throw Error(`Could not fetch Meteora pool state with pubkey ${pool.toString()}`);
            }
            tokenMintA = meteoraPoolState.tokenXMint;
            tokenMintB = meteoraPoolState.tokenYMint;
            tickSpacing = meteoraPoolState.binStep;
        }
        else {
            throw new Error(`Dex ${dex} is not supported`);
        }
        const tokenATokenProgram = await this.getAccountOwner(tokenAMint);
        const tokenBTokenProgram = await this.getAccountOwner(tokenBMint);
        const initStrategyIx = await this.createStrategy(strategy, pool, strategyAdmin, dex);
        const tokenADecimals = await (0, utils_1.getMintDecimals)(this._rpc, tokenMintA);
        const tokenBDecimals = await (0, utils_1.getMintDecimals)(this._rpc, tokenMintB);
        const rebalanceKind = (0, utils_1.numberToRebalanceType)(rebalanceType.toNumber());
        const updateRebalanceParamsIx = await this.getUpdateRebalancingParamsForUninitializedStratIx(strategyAdmin, strategy, processedRebalanceParams, rebalanceKind, tokenADecimals, tokenBDecimals);
        const updateStrategyParamsIxs = await this.getUpdateStrategyParamsIxs(strategyAdmin, strategy, rebalanceType, withdrawFeeBps, performanceFeeBps);
        const programAddresses = await this.getStrategyProgramAddresses(strategy, tokenMintA, tokenMintB);
        const baseVaultAuthority = programAddresses.baseVaultAuthority;
        const tokenAVault = programAddresses.tokenAVault;
        const tokenBVault = programAddresses.tokenBVault;
        const { lowerPrice, upperPrice } = await this.getRebalancePositionRange(dex, price, tokenAMint, tokenBMint, tickSpacing, rebalanceKind, rebalanceParams);
        const openPositionIxs = [];
        const eventAuthority = await this.getEventAuthorityPDA(new bn_js_1.default((0, utils_1.dexToNumber)(dex)));
        if (dex === 'ORCA') {
            const whirlpoolWithAddress = await this.getWhirlpoolStateIfNotFetched(pool);
            if (!whirlpoolWithAddress) {
                throw Error(`Could not fetch whirlpool state with pubkey ${pool.toString()}`);
            }
            const initLowerTickIfNeeded = await this.initializeTickForOrcaPool(strategyAdmin, pool, lowerPrice);
            const initUpperTickIfNeeded = await this.initializeTickForOrcaPool(strategyAdmin, pool, upperPrice);
            const openPositionIx = await this.openPositionOrca(strategyAdmin, strategy, baseVaultAuthority, pool, positionMint, lowerPrice, upperPrice, tokenAVault, tokenBVault, tokenAMint, tokenBMint, tokenATokenProgram, tokenBTokenProgram, baseVaultAuthority, baseVaultAuthority, baseVaultAuthority, baseVaultAuthority, baseVaultAuthority);
            if (initLowerTickIfNeeded.initTickIx) {
                openPositionIxs.push(initLowerTickIfNeeded.initTickIx);
            }
            if (initUpperTickIfNeeded.initTickIx) {
                openPositionIxs.push(initUpperTickIfNeeded.initTickIx);
            }
            openPositionIxs.push(openPositionIx);
        }
        else if (dex === 'RAYDIUM') {
            const openPositionIx = await this.openPositionRaydium(strategyAdmin, strategy, baseVaultAuthority, pool, positionMint, lowerPrice, upperPrice, tokenAVault, tokenBVault, tokenAMint, tokenBMint, tokenATokenProgram, tokenBTokenProgram, baseVaultAuthority, baseVaultAuthority, baseVaultAuthority, baseVaultAuthority, baseVaultAuthority, baseVaultAuthority, eventAuthority);
            openPositionIxs.push(openPositionIx);
        }
        else if (dex === 'METEORA') {
            const lbPair = await this.getMeteoraStateIfNotFetched(pool);
            if (!lbPair) {
                throw Error(`Could not fetch whirlpool state with pubkey ${pool.toString()}`);
            }
            const initLowerTickIfNeeded = await this.initializeTickForMeteoraPool(strategyAdmin, pool, lowerPrice);
            const initUpperTickIfNeeded = await this.initializeTickForMeteoraPool(strategyAdmin, pool, upperPrice);
            const openPositionIx = await this.openPositionMeteora(strategyAdmin, strategy, baseVaultAuthority, pool, positionMint, lowerPrice, upperPrice, tokenAVault, tokenBVault, tokenAMint, tokenBMint, tokenATokenProgram, tokenBTokenProgram, baseVaultAuthority, baseVaultAuthority, baseVaultAuthority, baseVaultAuthority, baseVaultAuthority, eventAuthority);
            if (initLowerTickIfNeeded.initTickIx) {
                openPositionIxs.push(initLowerTickIfNeeded.initTickIx);
            }
            if (initUpperTickIfNeeded.initTickIx) {
                openPositionIxs.push(initUpperTickIfNeeded.initTickIx);
            }
            openPositionIxs.push(openPositionIx);
        }
        else {
            throw new Error(`Dex ${dex} is not supported`);
        }
        return {
            initStrategyIx,
            updateStrategyParamsIxs,
            updateRebalanceParamsIx,
            openPositionIxs,
        };
    };
    async getNewPositionRange(strategy, rebalanceKind, rebalanceParams) {
        const strategyState = await this.getStrategyStateIfNotFetched(strategy);
        const dex = (0, utils_1.numberToDex)(strategyState.strategy.strategyDex.toNumber());
        const tokenAMint = strategyState.strategy.tokenAMint;
        const tokenBMint = strategyState.strategy.tokenBMint;
        const price = await this.getCurrentPriceFromPool(dex, strategyState.strategy.pool);
        const tickSpacing = await this.getPoolTickSpacing(dex, strategyState.strategy.pool);
        return this.getRebalancePositionRange(dex, price, tokenAMint, tokenBMint, tickSpacing, rebalanceKind, rebalanceParams);
    }
    async getRebalancePositionRange(dex, price, tokenAMint, tokenBMint, tickSpacing, rebalanceKind, rebalanceParams) {
        const tokenADecimals = await (0, utils_1.getMintDecimals)(this._rpc, tokenAMint);
        const tokenBDecimals = await (0, utils_1.getMintDecimals)(this._rpc, tokenBMint);
        switch (rebalanceKind.kind) {
            case types_1.RebalanceType.Manual.kind:
                return { lowerPrice: rebalanceParams[0], upperPrice: rebalanceParams[1] };
            case types_1.RebalanceType.TakeProfit.kind:
                return { lowerPrice: rebalanceParams[0], upperPrice: rebalanceParams[1] };
            case types_1.RebalanceType.PricePercentage.kind:
                return (0, rebalance_methods_1.getPositionRangeFromPercentageRebalanceParams)(price, rebalanceParams[0], rebalanceParams[1]);
            case types_1.RebalanceType.PricePercentageWithReset.kind:
                return (0, rebalance_methods_1.getPositionRangeFromPricePercentageWithResetParams)(price, rebalanceParams[0], rebalanceParams[1]);
            case types_1.RebalanceType.Drift.kind:
                return (0, rebalance_methods_1.getPositionRangeFromDriftParams)(dex, tickSpacing, tokenADecimals, tokenBDecimals, rebalanceParams[0], rebalanceParams[1], rebalanceParams[2]);
            case types_1.RebalanceType.PeriodicRebalance.kind:
                return (0, rebalance_methods_1.getPositionRangeFromPeriodicRebalanceParams)(price, rebalanceParams[1], rebalanceParams[2]);
            case types_1.RebalanceType.Expander.kind:
                return (0, rebalance_methods_1.getPositionRangeFromExpanderParams)(price, rebalanceParams[0], rebalanceParams[1]);
            case types_1.RebalanceType.Autodrift.kind:
                const currentTickIndex = (0, whirlpools_core_1.priceToTickIndex)(price.toNumber(), tokenADecimals, tokenBDecimals);
                const startMidTick = new decimal_js_1.default(currentTickIndex);
                return (0, autodriftRebalance_1.getPositionRangeFromAutodriftParams)(dex, tokenADecimals, tokenBDecimals, startMidTick, rebalanceParams[1], rebalanceParams[2], tickSpacing);
            default:
                throw new Error(`Rebalance type ${rebalanceKind} is not supported`);
        }
    }
    async getCurrentPrice(strategy) {
        const strategyWithAddress = await this.getStrategyStateIfNotFetched(strategy);
        const pool = strategyWithAddress.strategy.pool;
        const dex = (0, utils_1.numberToDex)(strategyWithAddress.strategy.strategyDex.toNumber());
        return this.getCurrentPriceFromPool(dex, pool, strategyWithAddress.strategy.tokenAMintDecimals.toNumber(), strategyWithAddress.strategy.tokenBMintDecimals.toNumber());
    }
    async getCurrentPriceFromPool(dex, pool, tokenADecimals, tokenBDecimals) {
        if (dex === 'ORCA') {
            return this.getOrcaPoolPrice(pool, tokenADecimals, tokenBDecimals);
        }
        else if (dex === 'RAYDIUM') {
            return this.getRaydiumPoolPrice(pool);
        }
        else if (dex === 'METEORA') {
            return this.getMeteoraPoolPrice(pool);
        }
        else {
            throw new Error(`Dex ${dex} is not supported`);
        }
    }
    async getPoolTickSpacing(dex, pool) {
        if (dex === 'ORCA') {
            const whirlpoolState = await accounts_2.Whirlpool.fetch(this._rpc, pool, this._orcaService.getWhirlpoolProgramId());
            if (!whirlpoolState) {
                throw Error(`Could not fetch whirlpool state with pubkey ${pool.toString()}`);
            }
            return whirlpoolState.tickSpacing;
        }
        else if (dex === 'RAYDIUM') {
            const raydiumPoolState = await accounts_3.PoolState.fetch(this._rpc, pool, this._raydiumService.getRaydiumProgramId());
            if (!raydiumPoolState) {
                throw Error(`Could not fetch Raydium pool state with pubkey ${pool.toString()}`);
            }
            return raydiumPoolState.tickSpacing;
        }
        else if (dex === 'METEORA') {
            const meteoraPoolState = await accounts_4.LbPair.fetch(this._rpc, pool, this._meteoraService.getMeteoraProgramId());
            if (!meteoraPoolState) {
                throw Error(`Could not fetch Meteora pool state with pubkey ${pool.toString()}`);
            }
            return meteoraPoolState.binStep;
        }
        else {
            throw new Error(`Dex ${dex} is not supported`);
        }
    }
    async getPriceRangePercentageBasedFromPool(dex, pool, lowerPriceBpsDifference, upperPriceBpsDifference) {
        let poolPrice;
        if (dex === 'ORCA') {
            poolPrice = await this.getOrcaPoolPrice(pool);
        }
        else if (dex === 'RAYDIUM') {
            poolPrice = await this.getRaydiumPoolPrice(pool);
        }
        else if (dex === 'METEORA') {
            poolPrice = await this.getMeteoraPoolPrice(pool);
        }
        else {
            throw new Error(`Invalid dex ${dex}`);
        }
        return this.getPriceRangePercentageBasedFromPrice(poolPrice, lowerPriceBpsDifference, upperPriceBpsDifference);
    }
    /**
     * Get the raw rebalancing params given the strategy type
     */
    async readRebalancingParamsFromChain(strategy) {
        const strategyWithAddress = await this.getStrategyStateIfNotFetched(strategy);
        const rebalanceKind = (0, utils_1.numberToRebalanceType)(strategyWithAddress.strategy.rebalanceType);
        let rebalanceFields;
        if (rebalanceKind.kind === RebalanceType_1.Manual.kind) {
            rebalanceFields = [];
        }
        else if (rebalanceKind.kind === RebalanceType_1.PricePercentage.kind) {
            rebalanceFields = (0, rebalance_methods_1.readPricePercentageRebalanceParamsFromStrategy)(strategyWithAddress.strategy.rebalanceRaw);
        }
        else if (rebalanceKind.kind === RebalanceType_1.PricePercentageWithReset.kind) {
            rebalanceFields = (0, rebalance_methods_1.readPricePercentageWithResetRebalanceParamsFromStrategy)(strategyWithAddress.strategy.rebalanceRaw);
        }
        else if (rebalanceKind.kind === RebalanceType_1.Drift.kind) {
            rebalanceFields = (0, utils_1.rebalanceFieldsDictToInfo)((0, rebalance_methods_1.readDriftRebalanceParamsFromStrategy)(strategyWithAddress.strategy.rebalanceRaw));
        }
        else if (rebalanceKind.kind === RebalanceType_1.TakeProfit.kind) {
            const tokenADecimals = await (0, utils_1.getMintDecimals)(this._rpc, strategyWithAddress.strategy.tokenAMint);
            const tokenBDecimals = await (0, utils_1.getMintDecimals)(this._rpc, strategyWithAddress.strategy.tokenBMint);
            rebalanceFields = (0, utils_1.rebalanceFieldsDictToInfo)((0, rebalance_methods_1.readTakeProfitRebalanceParamsFromStrategy)(tokenADecimals, tokenBDecimals, strategyWithAddress.strategy.rebalanceRaw));
        }
        else if (rebalanceKind.kind === RebalanceType_1.PeriodicRebalance.kind) {
            rebalanceFields = (0, utils_1.rebalanceFieldsDictToInfo)((0, rebalance_methods_1.readPeriodicRebalanceRebalanceParamsFromStrategy)(strategyWithAddress.strategy.rebalanceRaw));
        }
        else if (rebalanceKind.kind === RebalanceType_1.Expander.kind) {
            rebalanceFields = (0, rebalance_methods_1.readExpanderRebalanceParamsFromStrategy)(strategyWithAddress.strategy.rebalanceRaw);
        }
        else if (rebalanceKind.kind === RebalanceType_1.Autodrift.kind) {
            rebalanceFields = (0, utils_1.rebalanceFieldsDictToInfo)((0, autodriftRebalance_1.readAutodriftRebalanceParamsFromStrategy)(strategyWithAddress.strategy.rebalanceRaw));
        }
        else {
            throw new Error(`Rebalance type ${rebalanceKind} is not supported`);
        }
        return rebalanceFields;
    }
    /**
     * Get the raw rebalancing params given the strategy type
     */
    async readRebalancingStateFromChain(strategy) {
        const strategyWithAddress = await this.getStrategyStateIfNotFetched(strategy);
        const rebalanceKind = (0, utils_1.numberToRebalanceType)(strategyWithAddress.strategy.rebalanceType);
        let rebalanceFields;
        if (rebalanceKind.kind === RebalanceType_1.Manual.kind) {
            rebalanceFields = [];
        }
        else if (rebalanceKind.kind === RebalanceType_1.PricePercentage.kind) {
            rebalanceFields = (0, rebalance_methods_1.readRawPricePercentageRebalanceStateFromStrategy)(strategyWithAddress.strategy.rebalanceRaw);
        }
        else if (rebalanceKind.kind === RebalanceType_1.PricePercentageWithReset.kind) {
            rebalanceFields = (0, rebalance_methods_1.readRawPricePercentageWithResetRebalanceStateFromStrategy)(strategyWithAddress.strategy.rebalanceRaw);
        }
        else if (rebalanceKind.kind === RebalanceType_1.Drift.kind) {
            rebalanceFields = (0, utils_1.rebalanceFieldsDictToInfo)((0, rebalance_methods_1.readRawDriftRebalanceStateFromStrategy)(strategyWithAddress.strategy.rebalanceRaw));
        }
        else if (rebalanceKind.kind === RebalanceType_1.TakeProfit.kind) {
            rebalanceFields = (0, utils_1.rebalanceFieldsDictToInfo)((0, rebalance_methods_1.readTakeProfitRebalanceStateFromStrategy)(strategyWithAddress.strategy.rebalanceRaw));
        }
        else if (rebalanceKind.kind === RebalanceType_1.PeriodicRebalance.kind) {
            rebalanceFields = (0, utils_1.rebalanceFieldsDictToInfo)((0, rebalance_methods_1.readPeriodicRebalanceRebalanceStateFromStrategy)(strategyWithAddress.strategy.rebalanceRaw));
        }
        else if (rebalanceKind.kind === RebalanceType_1.Expander.kind) {
            rebalanceFields = (0, utils_1.rebalanceFieldsDictToInfo)((0, rebalance_methods_1.readRawExpanderRebalanceStateFromStrategy)(strategyWithAddress.strategy.rebalanceRaw));
        }
        else if (rebalanceKind.kind === RebalanceType_1.Autodrift.kind) {
            rebalanceFields = (0, utils_1.rebalanceFieldsDictToInfo)((0, autodriftRebalance_1.readRawAutodriftRebalanceStateFromStrategy)(strategyWithAddress.strategy.rebalanceRaw));
        }
        else {
            throw new Error(`Rebalance type ${rebalanceKind} is not supported`);
        }
        return rebalanceFields;
    }
    /**
     * Get the current withdrawal caps for a strategy
     */
    async getStrategyCurrentWithdrawalCaps(strategy) {
        const strategyWithAddress = await this.getStrategyStateIfNotFetched(strategy);
        const tokenAWithdrawalCap = strategyWithAddress.strategy.withdrawalCapA;
        const tokenBWithdrawalCap = strategyWithAddress.strategy.withdrawalCapB;
        let tokenAWithdrawalCapTokens = decimal_js_1.default.max(new decimal_js_1.default(tokenAWithdrawalCap.configCapacity.toString()).sub(tokenAWithdrawalCap.currentTotal.toString()), utils_1.ZERO);
        let tokenBWithdrawalCapTokens = decimal_js_1.default.max(new decimal_js_1.default(tokenBWithdrawalCap.configCapacity.toString()).sub(tokenBWithdrawalCap.currentTotal.toString()), utils_1.ZERO);
        if (tokenAWithdrawalCap.configIntervalLengthSeconds.toNumber() == 0) {
            tokenAWithdrawalCapTokens = new decimal_js_1.default(Number.MAX_VALUE);
        }
        if (tokenBWithdrawalCap.configIntervalLengthSeconds.toNumber() == 0) {
            tokenBWithdrawalCapTokens = new decimal_js_1.default(Number.MAX_VALUE);
        }
        return {
            a: (0, utils_1.lamportsToNumberDecimal)(tokenAWithdrawalCapTokens, strategyWithAddress.strategy.tokenAMintDecimals.toNumber()),
            b: (0, utils_1.lamportsToNumberDecimal)(tokenBWithdrawalCapTokens, strategyWithAddress.strategy.tokenBMintDecimals.toNumber()),
        };
    }
    /**
     * Get the max USD value that can be deposited per ix for a strategy
     */
    async getStrategyDepositCapInUSDPerIx(strategy) {
        const strategyWithAddress = await this.getStrategyStateIfNotFetched(strategy);
        return (0, utils_1.lamportsToNumberDecimal)(new decimal_js_1.default(strategyWithAddress.strategy.depositCapUsdPerIxn.toString()), 6);
    }
    async getStrategyMaxDepositInUSD(strategy) {
        const strategyWithAddress = await this.getStrategyStateIfNotFetched(strategy);
        const depositCapInUSDPerIx = await this.getStrategyDepositCapInUSDPerIx(strategy);
        // return the min between deposit cap per ix and the cap left in the deposit
        const depositCapInTokens = (0, utils_1.lamportsToNumberDecimal)(new decimal_js_1.default(strategyWithAddress.strategy.depositCapUsd.toString()), 6);
        // read the tvl from API
        const url = `https://api.hubbleprotocol.io/strategies/${strategyWithAddress.address.toString()}/metrics?env=mainnet-beta`;
        const response = await fetch(url);
        const data = (await response.json());
        const tvl = new decimal_js_1.default(data.totalValueLocked);
        const spaceLeftInDeposit = decimal_js_1.default.max(depositCapInTokens.sub(tvl), utils_1.ZERO);
        return decimal_js_1.default.min(depositCapInUSDPerIx, spaceLeftInDeposit);
    }
    /**
     * Get the prices for rebalancing params (range and reset range, if strategy involves a reset range)
     */
    async readRebalancingParams(strategy) {
        const strategyWithAddress = await this.getStrategyStateIfNotFetched(strategy);
        const rebalanceKind = (0, utils_1.numberToRebalanceType)(strategyWithAddress.strategy.rebalanceType);
        if (rebalanceKind.kind === RebalanceType_1.Manual.kind) {
            const positionRange = await this.getStrategyRange(strategyWithAddress);
            return (0, rebalance_methods_1.getManualRebalanceFieldInfos)(positionRange.lowerPrice, positionRange.upperPrice);
        }
        else if (rebalanceKind.kind === RebalanceType_1.PricePercentage.kind) {
            const price = await this.getCurrentPrice(strategyWithAddress);
            return (0, rebalance_methods_1.deserializePricePercentageRebalanceFromOnchainParams)(price, strategyWithAddress.strategy.rebalanceRaw);
        }
        else if (rebalanceKind.kind === RebalanceType_1.PricePercentageWithReset.kind) {
            const price = await this.getCurrentPrice(strategyWithAddress);
            return (0, rebalance_methods_1.deserializePricePercentageWithResetRebalanceFromOnchainParams)(price, strategyWithAddress.strategy.rebalanceRaw);
        }
        else if (rebalanceKind.kind === RebalanceType_1.Drift.kind) {
            const dex = (0, utils_1.numberToDex)(strategyWithAddress.strategy.strategyDex.toNumber());
            const tokenADecimals = await (0, utils_1.getMintDecimals)(this._rpc, strategyWithAddress.strategy.tokenAMint);
            const tokenBDecimals = await (0, utils_1.getMintDecimals)(this._rpc, strategyWithAddress.strategy.tokenBMint);
            const tickSpacing = await this.getPoolTickSpacing(dex, strategyWithAddress.strategy.pool);
            return (0, rebalance_methods_1.deserializeDriftRebalanceFromOnchainParams)(dex, tickSpacing, tokenADecimals, tokenBDecimals, strategyWithAddress.strategy.rebalanceRaw);
        }
        else if (rebalanceKind.kind === RebalanceType_1.TakeProfit.kind) {
            const tokenADecimals = await (0, utils_1.getMintDecimals)(this._rpc, strategyWithAddress.strategy.tokenAMint);
            const tokenBDecimals = await (0, utils_1.getMintDecimals)(this._rpc, strategyWithAddress.strategy.tokenBMint);
            return (0, rebalance_methods_1.deserializeTakeProfitRebalanceFromOnchainParams)(tokenADecimals, tokenBDecimals, strategyWithAddress.strategy.rebalanceRaw);
        }
        else if (rebalanceKind.kind === RebalanceType_1.PeriodicRebalance.kind) {
            const price = await this.getCurrentPrice(strategyWithAddress);
            return (0, rebalance_methods_1.deserializePeriodicRebalanceFromOnchainParams)(price, strategyWithAddress.strategy.rebalanceRaw);
        }
        else if (rebalanceKind.kind === RebalanceType_1.Expander.kind) {
            const price = await this.getCurrentPrice(strategyWithAddress);
            return (0, rebalance_methods_1.readExpanderRebalanceFieldInfosFromStrategy)(price, strategyWithAddress.strategy.rebalanceRaw);
        }
        else if (rebalanceKind.kind === RebalanceType_1.Autodrift.kind) {
            const dex = (0, utils_1.numberToDex)(strategyWithAddress.strategy.strategyDex.toNumber());
            const tokenADecimals = await (0, utils_1.getMintDecimals)(this._rpc, strategyWithAddress.strategy.tokenAMint);
            const tokenBDecimals = await (0, utils_1.getMintDecimals)(this._rpc, strategyWithAddress.strategy.tokenBMint);
            const tickSpacing = await this.getPoolTickSpacing(dex, strategyWithAddress.strategy.pool);
            return (0, autodriftRebalance_1.deserializeAutodriftRebalanceFromOnchainParams)(dex, tokenADecimals, tokenBDecimals, tickSpacing, strategyWithAddress.strategy.rebalanceRaw);
        }
        else {
            throw new Error(`Rebalance type ${rebalanceKind} is not supported`);
        }
    }
    /**
     * Get the rebalancing params from chain, alongside the current details of the position, reset range, etc
     */
    async readRebalancingParamsWithState(strategy) {
        const strategyWithAddress = await this.getStrategyStateIfNotFetched(strategy);
        const rebalanceKind = (0, utils_1.numberToRebalanceType)(strategyWithAddress.strategy.rebalanceType);
        const dex = (0, utils_1.numberToDex)(strategyWithAddress.strategy.strategyDex.toNumber());
        const tokenADecimals = strategyWithAddress.strategy.tokenAMintDecimals.toNumber();
        const tokenBDecimals = strategyWithAddress.strategy.tokenBMintDecimals.toNumber();
        if (rebalanceKind.kind === RebalanceType_1.Manual.kind) {
            const positionRange = await this.getStrategyRange(strategyWithAddress);
            return (0, rebalance_methods_1.getManualRebalanceFieldInfos)(positionRange.lowerPrice, positionRange.upperPrice);
        }
        else if (rebalanceKind.kind === RebalanceType_1.PricePercentage.kind) {
            const price = await this.getCurrentPrice(strategyWithAddress);
            return (0, rebalance_methods_1.deserializePricePercentageRebalanceWithStateOverride)(dex, tokenADecimals, tokenBDecimals, price, strategyWithAddress.strategy.rebalanceRaw);
        }
        else if (rebalanceKind.kind === RebalanceType_1.PricePercentageWithReset.kind) {
            const price = await this.getCurrentPrice(strategyWithAddress);
            return (0, rebalance_methods_1.deserializePricePercentageWithResetRebalanceWithStateOverride)(dex, tokenADecimals, tokenBDecimals, price, strategyWithAddress.strategy.rebalanceRaw);
        }
        else if (rebalanceKind.kind === RebalanceType_1.Drift.kind) {
            const dex = (0, utils_1.numberToDex)(strategyWithAddress.strategy.strategyDex.toNumber());
            const tokenADecimals = await (0, utils_1.getMintDecimals)(this._rpc, strategyWithAddress.strategy.tokenAMint);
            const tokenBDecimals = await (0, utils_1.getMintDecimals)(this._rpc, strategyWithAddress.strategy.tokenBMint);
            const tickSpacing = await this.getPoolTickSpacing(dex, strategyWithAddress.strategy.pool);
            return (0, rebalance_methods_1.deserializeDriftRebalanceWithStateOverride)(dex, tickSpacing, tokenADecimals, tokenBDecimals, strategyWithAddress.strategy.rebalanceRaw);
        }
        else if (rebalanceKind.kind === RebalanceType_1.TakeProfit.kind) {
            const tokenADecimals = await (0, utils_1.getMintDecimals)(this._rpc, strategyWithAddress.strategy.tokenAMint);
            const tokenBDecimals = await (0, utils_1.getMintDecimals)(this._rpc, strategyWithAddress.strategy.tokenBMint);
            return (0, rebalance_methods_1.deserializeTakeProfitRebalanceFromOnchainParams)(tokenADecimals, tokenBDecimals, strategyWithAddress.strategy.rebalanceRaw);
        }
        else if (rebalanceKind.kind === RebalanceType_1.PeriodicRebalance.kind) {
            const price = await this.getCurrentPrice(strategyWithAddress);
            return (0, rebalance_methods_1.deserializePeriodicRebalanceFromOnchainParams)(price, strategyWithAddress.strategy.rebalanceRaw);
        }
        else if (rebalanceKind.kind === RebalanceType_1.Expander.kind) {
            const price = await this.getCurrentPrice(strategyWithAddress);
            return (0, rebalance_methods_1.deserializeExpanderRebalanceWithStateOverride)(dex, tokenADecimals, tokenBDecimals, price, strategyWithAddress.strategy.rebalanceRaw);
        }
        else if (rebalanceKind.kind === RebalanceType_1.Autodrift.kind) {
            const dex = (0, utils_1.numberToDex)(strategyWithAddress.strategy.strategyDex.toNumber());
            const tokenADecimals = await (0, utils_1.getMintDecimals)(this._rpc, strategyWithAddress.strategy.tokenAMint);
            const tokenBDecimals = await (0, utils_1.getMintDecimals)(this._rpc, strategyWithAddress.strategy.tokenBMint);
            const tickSpacing = await this.getPoolTickSpacing(dex, strategyWithAddress.strategy.pool);
            return (0, autodriftRebalance_1.deserializeAutodriftRebalanceWithStateOverride)(dex, tokenADecimals, tokenBDecimals, tickSpacing, strategyWithAddress.strategy.rebalanceRaw);
        }
        else {
            throw new Error(`Rebalance type ${rebalanceKind} is not supported`);
        }
    }
    /**
     * Get a list of updated rebalance field infos.
     * @param initialRebalanceFieldInfos the initial list of rebalance field infos
     * @param updatedFields the fields to be updated, with label and value
     * @returns list of RebalanceFieldInfo with updated values
     */
    getUpdatedRebalanceFieldInfos(initialRebalanceFieldInfos, updatedFields) {
        const newRebalanceFieldInfos = initialRebalanceFieldInfos.map((f) => {
            const updatedField = updatedFields.find((x) => x.label === f.label);
            if (updatedField) {
                return { ...f, value: updatedField.value };
            }
            else {
                return f;
            }
        });
        return newRebalanceFieldInfos;
    }
    getPriceRangePercentageBasedFromPrice(price, lowerPriceBpsDifference, upperPriceBpsDifference) {
        const fullBPSDecimal = new decimal_js_1.default(CreationParameters_1.FullBPS);
        const lowerPrice = price.mul(fullBPSDecimal.sub(lowerPriceBpsDifference)).div(fullBPSDecimal);
        const upperPrice = price.mul(fullBPSDecimal.add(upperPriceBpsDifference)).div(fullBPSDecimal);
        return [lowerPrice, upperPrice];
    }
    /**
     * Read the pool price for a specific dex and pool
     */
    async getPoolPrice(dex, pool, tokenADecimals, tokenBDecimals) {
        if (dex === 'ORCA') {
            return this.getOrcaPoolPrice(pool, tokenADecimals, tokenBDecimals);
        }
        else if (dex === 'RAYDIUM') {
            return this.getRaydiumPoolPrice(pool);
        }
        else if (dex === 'METEORA') {
            return this.getMeteoraPoolPrice(pool);
        }
        else {
            throw new Error(`Invalid dex ${dex}`);
        }
    }
    async getOrcaPoolPrice(pool, tokenADecimals, tokenBDecimals) {
        // if the decimals are provided read from API, otherwise use RPC
        if (tokenADecimals && tokenBDecimals) {
            const whirlpool = await accounts_2.Whirlpool.fetch(this._rpc, pool, this._orcaService.getWhirlpoolProgramId());
            if (!whirlpool) {
                throw Error(`Could not fetch Whirlpool data for ${pool.toString()}`);
            }
            return new decimal_js_1.default((0, whirlpools_core_1.sqrtPriceToPrice)(BigInt(whirlpool.sqrtPrice.toString()), tokenADecimals, tokenBDecimals));
        }
        else {
            const whirlpool = await this._orcaService.getOrcaWhirlpool(pool);
            if (!whirlpool) {
                throw Error(`Could not fetch Whirlpool data for ${pool.toString()}`);
            }
            return new decimal_js_1.default((0, whirlpools_core_1.sqrtPriceToPrice)(BigInt(whirlpool.sqrtPrice.toString()), whirlpool.tokenA.decimals, whirlpool.tokenB.decimals));
        }
    }
    async getRaydiumPoolPrice(pool) {
        const poolState = await accounts_3.PoolState.fetch(this._rpc, pool, this._raydiumService.getRaydiumProgramId());
        if (!poolState) {
            throw new Error(`Raydium poolState ${pool.toString()} is not found`);
        }
        const price = lib_1.SqrtPriceMath.sqrtPriceX64ToPrice(poolState.sqrtPriceX64, poolState.mintDecimals0, poolState.mintDecimals1);
        return price;
    }
    async getMeteoraPoolPrice(pool) {
        const poolState = await accounts_4.LbPair.fetch(this._rpc, pool, this._meteoraService.getMeteoraProgramId());
        if (!poolState) {
            throw new Error(`Meteora poolState ${pool.toString()} is not found`);
        }
        const decimalsX = await (0, utils_1.getMintDecimals)(this._rpc, poolState.tokenXMint);
        const decimalsY = await (0, utils_1.getMintDecimals)(this._rpc, poolState.tokenYMint);
        return (0, meteora_1.getPriceOfBinByBinIdWithDecimals)(poolState.activeId, poolState.binStep, decimalsX, decimalsY);
    }
    async getGenericPoolInfo(dex, pool) {
        let poolInfo;
        if (dex === 'ORCA') {
            poolInfo = await this._orcaService.getGenericPoolInfo(pool);
        }
        else if (dex === 'RAYDIUM') {
            poolInfo = await this._raydiumService.getGenericPoolInfo(pool);
        }
        else if (dex === 'METEORA') {
            poolInfo = await this._meteoraService.getGenericPoolInfo(pool);
        }
        else {
            throw new Error(`Invalid dex ${dex}`);
        }
        return poolInfo;
    }
    mintIsSupported = (collateralInfos, tokenMint) => {
        let found = false;
        collateralInfos.forEach((element) => {
            if (element.mint === tokenMint) {
                found = true;
            }
        });
        return found;
    };
    getCollateralInfoFromMint = (mint, collateralInfos) => {
        const collInfosForMint = collateralInfos.filter((x) => x.mint === mint);
        if (collInfosForMint.length === 0) {
            return undefined;
        }
        return collInfosForMint[0];
    };
    getCollateralIdFromMint = (mint, collateralInfos) => {
        for (let i = 0; i < collateralInfos.length; i++) {
            if (collateralInfos[i].mint === mint) {
                return i;
            }
        }
        return -1;
    };
    getMainLookupTablePks = async () => {
        if (this.getProgramID() === pubkeys_1.STAGING_KAMINO_PROGRAM_ID ||
            this._cluster === 'mainnet-beta' ||
            this._cluster === 'devnet') {
            return await this._rpc
                .getProgramAccounts(address_lookup_table_1.ADDRESS_LOOKUP_TABLE_PROGRAM_ADDRESS, {
                filters: [
                    { memcmp: { offset: 22n, bytes: pubkeys_1.LUT_OWNER_KEY.toString(), encoding: 'base58' } },
                ],
                dataSlice: { length: 0, offset: 0 },
            })
                .send()
                .then((res) => res.map((raw) => raw.pubkey));
        }
        return [];
    };
    getMainLookupTable = async () => {
        const pks = await this.getMainLookupTablePks();
        if (this.getProgramID() === pubkeys_1.STAGING_KAMINO_PROGRAM_ID ||
            this._cluster === 'mainnet-beta' ||
            this._cluster === 'devnet') {
            return (0, lookupTable_1.fetchMultipleLookupTableAccounts)(this._rpc, pks);
        }
        else {
            return undefined;
        }
    };
    getInitLookupTableIx = async (authority, slot) => {
        let recentSlot;
        if (slot) {
            recentSlot = slot;
        }
        else {
            recentSlot = await this._rpc.getSlot({ commitment: 'finalized' }).send();
        }
        const pda = await (0, address_lookup_table_1.findAddressLookupTablePda)({ authority: authority.address, recentSlot });
        const createLookupTableIx = (0, address_lookup_table_1.getCreateLookupTableInstruction)({
            authority: authority,
            payer: authority,
            address: pda,
            recentSlot: recentSlot,
        });
        return [createLookupTableIx, pda[0]];
    };
    getPopulateLookupTableIxs = async (authority, lookupTable, strategy) => {
        const { strategy: strategyState, address } = await this.getStrategyStateIfNotFetched(strategy);
        if (!strategyState) {
            throw Error(`Could not fetch strategy state with pubkey ${strategy.toString()}`);
        }
        const { treasuryFeeTokenAVault, treasuryFeeTokenBVault, treasuryFeeVaultAuthority } = await this.getTreasuryFeeVaultPDAs(strategyState.tokenAMint, strategyState.tokenBMint);
        const accountsToBeInserted = [
            address,
            strategyState.adminAuthority,
            strategyState.globalConfig,
            strategyState.baseVaultAuthority,
            strategyState.pool,
            strategyState.tokenAMint,
            strategyState.tokenBMint,
            strategyState.tokenAVault,
            strategyState.tokenBVault,
            strategyState.poolTokenVaultA,
            strategyState.poolTokenVaultB,
            strategyState.tokenAMint,
            strategyState.sharesMint,
            strategyState.sharesMintAuthority,
            treasuryFeeTokenAVault,
            treasuryFeeTokenBVault,
            treasuryFeeVaultAuthority,
        ];
        return this.getAddLookupTableEntriesIxs(authority, lookupTable, accountsToBeInserted);
    };
    getAddLookupTableEntriesIxs = (authority, lookupTable, entries) => {
        const chunkSize = 20;
        const txs = [];
        for (let i = 0; i < entries.length; i += chunkSize) {
            const chunk = entries.slice(i, i + chunkSize);
            txs.push((0, address_lookup_table_1.getExtendLookupTableInstruction)({
                authority,
                payer: authority,
                address: lookupTable,
                addresses: chunk,
            }));
        }
        return txs;
    };
    getLookupTable = async (tablePk) => {
        const lut = await (0, address_lookup_table_1.fetchMaybeAddressLookupTable)(this._rpc, tablePk);
        if (!lut.exists) {
            throw new Error(`Could not get lookup table ${tablePk}`);
        }
        return lut;
    };
    setupStrategyLookupTable = async (authority, strategy, slot) => {
        const [createLookupTableIx, lookupTable] = await this.getInitLookupTableIx(authority, slot);
        const populateLookupTableIxs = await this.getPopulateLookupTableIxs(authority, lookupTable, strategy);
        const strategyPk = typeof strategy === 'string' && (0, kit_1.isAddress)(strategy) ? strategy : strategy.address;
        const updateStrategyLookupTableIx = await (0, utils_1.getUpdateStrategyConfigIx)(authority, this._globalConfig, strategyPk, new StrategyConfigOption_1.UpdateLookupTable(), new decimal_js_1.default(0), this.getProgramID(), lookupTable);
        return {
            lookupTable,
            createLookupTableIx,
            populateLookupTableIxs,
            updateStrategyLookupTableIx,
        };
    };
    // todo(silviu): implement this
    // getEstimatedApyAndVolumeOnRange = async (
    //   dex: Dex,
    //   pool: Address,
    //   lowerPrice: Decimal,
    //   upperPrice: Decimal,
    //   _startDate: Date,
    //   _endDate: Date
    // ): Promise<GenericPositionRangeInfo> => {
    //   if (dex === 'ORCA') {
    //     return this.getEstimatedApyAndVolumeOnRangeOrca();
    //   } else if (dex === 'RAYDIUM') {
    //     return this.getEstimatedApyAndVolumeOnRangeRaydium();
    //   } else if (dex === 'METEORA') {
    //     return this.getEstimatedApyAndVolumeOnRangeMeteora();
    //   } else {
    //     throw new Error(`Dex ${dex} is not supported`);
    //   }
    // };
    getEstimatedApyAndVolumeOnRangeOrca = async () => {
        // todo
        return {
            estimatedApy: new decimal_js_1.default(0),
            estimatedVolume: new decimal_js_1.default(0),
        };
    };
    getEstimatedApyAndVolumeOnRangeRaydium = async () => {
        // todo
        return {
            estimatedApy: new decimal_js_1.default(0),
            estimatedVolume: new decimal_js_1.default(0),
        };
    };
    getEstimatedApyAndVolumeOnRangeMeteora = async () => {
        // todo
        return {
            estimatedApy: new decimal_js_1.default(0),
            estimatedVolume: new decimal_js_1.default(0),
        };
    };
    getManualPoolSimulatedValues = async (params) => {
        const { pool, startDate, endDate, priceLower, priceUpper } = params;
        return (0, PoolSimulationService_1.simulateManualPool)({ poolAddress: pool, priceUpper, priceLower, depositDate: startDate, endDate });
    };
    getPercentagePoolSimulatedValues = async (params) => {
        const { resetRangeWidthPercLower = 1, resetRangeWidthPercUpper = 1, ...rest } = params;
        return (0, PoolSimulationService_1.simulatePercentagePool)({ resetRangeWidthPercLower, resetRangeWidthPercUpper, ...rest });
    };
    /**
     * Get a list of transactions to rebalance a Kamino strategy.
     * @param admin pool admin
     * @param strategy strategy pubkey or object
     * @param newPosition new liquidity position account pubkey
     * @param priceLower new position's lower price of the range
     * @param priceUpper new position's upper price of the range
     * @returns list of transactions to rebalance (executive withdraw, collect fees/rewards, open new position, invest)
     */
    rebalance = async (admin, strategy, newPosition, priceLower, priceUpper) => {
        // todo: refactor this to return an object, not a list
        const strategyWithAddress = await this.getStrategyStateIfNotFetched(strategy);
        const ixs = [];
        // if there are no invested tokens we don't need to collect fees and rewards
        const stratTokenBalances = await this.getStrategyTokensBalances(strategyWithAddress.strategy);
        if (strategyWithAddress.strategy.strategyDex.toNumber() === (0, utils_1.dexToNumber)('ORCA') ||
            stratTokenBalances.invested.a.greaterThan(utils_1.ZERO) ||
            stratTokenBalances.invested.b.greaterThan(utils_1.ZERO)) {
            ixs.push(await this.collectFeesAndRewards(strategyWithAddress, admin));
        }
        ixs.push(await this.openPosition(admin, strategyWithAddress, newPosition, priceLower, priceUpper, new StrategyStatus_1.Rebalancing()));
        return ixs;
    };
    /**
     * Get a list of user's Kamino strategy positions
     * @param wallet user wallet address
     * @param strategyFilters
     * @returns list of kamino strategy positions
     */
    getUserPositions = async (wallet, strategyFilters = { strategyCreationStatus: 'LIVE' }) => {
        const userTokenAccounts = await this.getAllTokenAccounts(wallet);
        const liveStrategies = await this.getAllStrategiesWithFilters(strategyFilters);
        const positions = [];
        for (const tokenAccount of userTokenAccounts) {
            const accountData = tokenAccount.account.data;
            if ('parsed' in accountData) {
                // @ts-ignore
                const strategy = liveStrategies.find((x) => x.strategy.sharesMint === accountData.parsed.info.mint);
                if (strategy) {
                    positions.push({
                        shareMint: strategy.strategy.sharesMint,
                        strategy: strategy.address,
                        // @ts-ignore
                        sharesAmount: new decimal_js_1.default(accountData.parsed.info.tokenAmount.uiAmountString),
                        strategyDex: (0, utils_1.numberToDex)(strategy.strategy.strategyDex.toNumber()),
                    });
                }
            }
        }
        return positions;
    };
    /**
     * Get a list of user's Kamino strategy positions
     * @param wallet user wallet address
     * @param strategiesWithShareMintsMap
     * @param strategiesWithAddressMap
     * @returns list of kamino strategy positions
     */
    getUserPositionsByStrategiesMap = async (wallet, strategiesWithShareMintsMap, strategiesWithAddressMap) => {
        const tokenAccounts = await this._rpc
            .getTokenAccountsByOwner(wallet, { programId: token_1.TOKEN_PROGRAM_ADDRESS }, { encoding: 'jsonParsed' })
            .send();
        const mints = tokenAccounts.value.map((accountInfo) => {
            return accountInfo.account.data.parsed.info.mint;
        });
        const mintInfos = await (0, utils_1.batchFetch)(mints, async (chunk) => await (0, token_2022_1.fetchAllMint)(this.getConnection(), chunk));
        const kaminoStrategyAddresses = [];
        const kaminoAccountInfos = [];
        for (let i = 0; i < mints.length; i++) {
            const mint = mints[i];
            const mintInfo = mintInfos[i];
            const accountInfo = tokenAccounts.value[i];
            if (!mint || !mintInfo || !accountInfo)
                continue;
            const [expectedMintAuthority] = await (0, kit_1.getProgramDerivedAddress)({
                seeds: [Buffer.from('authority'), addressEncoder.encode(mint)],
                programAddress: this.getProgramID(),
            });
            if ((0, kit_1.isSome)(mintInfo.data.mintAuthority) && mintInfo.data.mintAuthority.value === expectedMintAuthority) {
                const shareMintAddress = tokenAccounts.value[i].account.data.parsed.info.mint;
                const addr = strategiesWithShareMintsMap.get(shareMintAddress)?.address;
                if (!addr)
                    continue;
                kaminoStrategyAddresses.push(addr);
                kaminoAccountInfos.push(accountInfo.account.data.parsed.info);
            }
        }
        let strategies = strategiesWithAddressMap
            ? Array.from(strategiesWithAddressMap.values())
            : [];
        const missingStrategies = kaminoStrategyAddresses.filter((x) => !strategiesWithAddressMap || !strategiesWithAddressMap.has(x));
        const missingStrategiesState = await (0, utils_1.batchFetch)(missingStrategies, (chunk) => this.getStrategies(chunk));
        strategies = strategies.concat(missingStrategiesState);
        const positions = [];
        for (const index of strategies.keys()) {
            const strategy = strategies[index];
            const accountData = kaminoAccountInfos[index];
            const address = kaminoStrategyAddresses[index];
            if (!strategy || !accountData) {
                continue;
            }
            positions.push({
                shareMint: strategy.sharesMint,
                strategy: address,
                sharesAmount: new decimal_js_1.default(accountData.tokenAmount.uiAmountString),
                strategyDex: (0, utils_1.numberToDex)(strategy.strategyDex.toNumber()),
            });
        }
        return positions;
    };
    /**
     * Get Kamino strategy vault APY/APR
     * @param strategy strategy pubkey or onchain state
     * @param orcaPools not required, but you can add orca whirlpools if you're caching them, and we don't refetch every time
     * @param raydiumPools not required, but you can add raydium pools if you're caching them, and we don't refetch every time
     */
    getStrategyAprApy = async (strategy, orcaPools, raydiumPools) => {
        const { strategy: strategyState } = await this.getStrategyStateIfNotFetched(strategy);
        const dex = Number(strategyState.strategyDex);
        const isOrca = (0, utils_1.dexToNumber)('ORCA') === dex;
        const isRaydium = (0, utils_1.dexToNumber)('RAYDIUM') === dex;
        const isMeteora = (0, utils_1.dexToNumber)('METEORA') === dex;
        if (strategyState.position === pubkeys_1.DEFAULT_PUBLIC_KEY) {
            return {
                totalApr: utils_1.ZERO,
                feeApr: utils_1.ZERO,
                totalApy: utils_1.ZERO,
                feeApy: utils_1.ZERO,
                priceUpper: utils_1.ZERO,
                priceLower: utils_1.ZERO,
                rewardsApr: [],
                rewardsApy: [],
                poolPrice: utils_1.ZERO,
                strategyOutOfRange: false,
            };
        }
        if (isOrca) {
            const prices = await this.getAllPrices();
            const collateralInfos = await this.getCollateralInfos();
            return this._orcaService.getStrategyWhirlpoolPoolAprApy(strategyState, collateralInfos, prices);
        }
        if (isRaydium) {
            return this._raydiumService.getStrategyWhirlpoolPoolAprApy(strategyState, raydiumPools);
        }
        if (isMeteora) {
            return this._meteoraService.getStrategyMeteoraPoolAprApy(strategyState);
        }
        throw Error(`Strategy dex ${dex} not supported`);
    };
    getStrategyPerformanceFees = async (strategy, globalConfig) => {
        const { strategy: strategyState } = await this.getStrategyStateIfNotFetched(strategy);
        const globalConfigState = globalConfig || (await this.getGlobalConfigState(strategyState.globalConfig));
        if (globalConfigState === null) {
            throw new Error(`Unable to fetch GlobalConfig with Pubkey ${strategyState.globalConfig}`);
        }
        const globalConfigMinPerformanceFee = new decimal_js_1.default(globalConfigState.minPerformanceFeeBps.toString());
        const strategyFeesFee = new decimal_js_1.default(strategyState.feesFee.toString());
        const strategyReward0Fee = new decimal_js_1.default(strategyState.reward0Fee.toString());
        const strategyReward1Fee = new decimal_js_1.default(strategyState.reward1Fee.toString());
        const strategyReward2Fee = new decimal_js_1.default(strategyState.reward2Fee.toString());
        return {
            feesFeeBPS: decimal_js_1.default.max(strategyFeesFee, globalConfigMinPerformanceFee),
            reward0FeeBPS: decimal_js_1.default.max(strategyReward0Fee, globalConfigMinPerformanceFee),
            reward1FeeBPS: decimal_js_1.default.max(strategyReward1Fee, globalConfigMinPerformanceFee),
            reward2FeeBPS: decimal_js_1.default.max(strategyReward2Fee, globalConfigMinPerformanceFee),
        };
    };
    getLiquidityDistributionRaydiumPool = (pool, keepOrder = true, lowestTick, highestTick) => {
        return this._raydiumService.getRaydiumPoolLiquidityDistribution(pool, keepOrder, lowestTick, highestTick);
    };
    getLiquidityDistributionMeteoraPool = (pool, keepOrder = true, lowestTick, highestTick) => {
        return this._meteoraService.getMeteoraLiquidityDistribution(pool, keepOrder, lowestTick, highestTick);
    };
    getLiquidityDistributionOrcaWhirlpool = (pool, keepOrder = true, lowestTick, highestTick) => {
        return this._orcaService.getWhirlpoolLiquidityDistribution(pool, keepOrder, lowestTick, highestTick);
    };
    getLiquidityDistribution = async (dex, pool, keepOrder = true, lowestTick, highestTick) => {
        if (dex === 'ORCA') {
            return this.getLiquidityDistributionOrcaWhirlpool(pool, keepOrder, lowestTick, highestTick);
        }
        else if (dex === 'RAYDIUM') {
            return this.getLiquidityDistributionRaydiumPool(pool, keepOrder, lowestTick, highestTick);
        }
        else if (dex === 'METEORA') {
            return this.getLiquidityDistributionMeteoraPool(pool, keepOrder, lowestTick, highestTick);
        }
        else {
            throw Error(`Dex ${dex} not supported`);
        }
    };
    getPositionsCountForPool = async (dex, pool) => {
        if (dex === 'ORCA') {
            return this._orcaService.getPositionsCountByPool(pool);
        }
        else if (dex === 'RAYDIUM') {
            return this._raydiumService.getPositionsCountByPool(pool);
        }
        else if (dex === 'METEORA') {
            return this._meteoraService.getPositionsCountByPool(pool);
        }
        else {
            throw Error(`Dex ${dex} not supported`);
        }
    };
    getStrategyTokensHoldings = async (strategy, mode = 'WITHDRAW') => {
        const { strategy: strategyState } = await this.getStrategyStateIfNotFetched(strategy);
        const holdings = await this.getStrategyTokensBalances(strategyState, mode);
        const totalA = holdings.available.a.add(holdings.invested.a);
        const totalB = holdings.available.b.add(holdings.invested.b);
        return { a: totalA, b: totalB };
    };
    /**
     * Get ratio of total_a_in_strategy/total_b_in_strategy; if the total_b_in_strategy is 0 throws;
     * @param strategy
     * @param amountA
     */
    getStrategyTokensRatio = async (strategy) => {
        const totalHoldings = await this.getStrategyTokensHoldings(strategy);
        return totalHoldings.a.div(totalHoldings.b);
    };
    calculateAmountsToBeDepositedWithSwap = async (strategy, tokenAAmountUserDeposit, tokenBAmountUserDeposit, profiler = utils_1.noopProfiledFunctionExecution, priceAInB) => {
        const strategyWithAddress = await this.getStrategyStateIfNotFetched(strategy);
        const strategyState = strategyWithAddress.strategy;
        if (!priceAInB) {
            priceAInB = await this.getCurrentPrice(strategyWithAddress);
        }
        const priceBInA = new decimal_js_1.default(1).div(priceAInB);
        const tokenADecimals = strategyState.tokenAMintDecimals.toNumber();
        const tokenBDecimals = strategyState.tokenBMintDecimals.toNumber();
        const tokenADecimalsDiff = tokenADecimals - tokenBDecimals;
        const tokenAAddDecimals = tokenADecimalsDiff > 0 ? 0 : Math.abs(tokenADecimalsDiff);
        const tokenBAddDecimals = tokenADecimalsDiff > 0 ? Math.abs(tokenADecimalsDiff) : 0;
        const aAmount = tokenAAmountUserDeposit;
        const bAmount = tokenBAmountUserDeposit;
        const [aAmounts, bAmounts] = await profiler(this.calculateAmountsRatioToBeDeposited(strategyWithAddress, undefined, profiler), 'C-calculateDepositRatio', []);
        const orcaAmountA = aAmounts.div(new decimal_js_1.default(10).pow(tokenADecimals));
        const orcaAmountB = bAmounts.div(new decimal_js_1.default(10).pow(tokenBDecimals));
        // multiply by tokens delta to make sure that both values uses the same about of decimals
        const totalUserDepositInA = aAmount
            .mul(10 ** tokenAAddDecimals)
            .add(bAmount.mul(10 ** tokenBAddDecimals).mul(priceBInA));
        // if the strategy is out of range we will deposit only one token so we will need to swap everything to that token
        if (orcaAmountA.eq(utils_1.ZERO)) {
            const requiredAAmountToDeposit = utils_1.ZERO;
            const requiredBAmountToDeposit = totalUserDepositInA.mul(priceAInB);
            const tokenAToSwapAmount = requiredAAmountToDeposit.sub(tokenAAmountUserDeposit);
            const tokenBToSwapAmount = requiredBAmountToDeposit.sub(tokenBAmountUserDeposit);
            const depositAmountsForSwap = {
                requiredAAmountToDeposit,
                requiredBAmountToDeposit,
                tokenAToSwapAmount,
                tokenBToSwapAmount,
            };
            return depositAmountsForSwap;
        }
        if (orcaAmountB.eq(utils_1.ZERO)) {
            const requiredAAmountToDeposit = totalUserDepositInA;
            const requiredBAmountToDeposit = utils_1.ZERO;
            const tokenAToSwapAmount = requiredAAmountToDeposit.sub(tokenAAmountUserDeposit);
            const tokenBToSwapAmount = requiredBAmountToDeposit.sub(tokenBAmountUserDeposit);
            const depositAmountsForSwap = {
                requiredAAmountToDeposit,
                requiredBAmountToDeposit,
                tokenAToSwapAmount,
                tokenBToSwapAmount,
            };
            return depositAmountsForSwap;
        }
        let ratio = orcaAmountA.div(orcaAmountB);
        ratio = ratio.div(priceBInA);
        const requiredAAmountToDeposit = totalUserDepositInA
            .mul(ratio)
            .div(ratio.add(1))
            .div(10 ** tokenAAddDecimals);
        const requiredBAmountToDeposit = totalUserDepositInA
            .sub(requiredAAmountToDeposit.mul(10 ** tokenAAddDecimals))
            .div(10 ** tokenBAddDecimals)
            .mul(priceAInB);
        const tokenAToSwapAmount = requiredAAmountToDeposit.sub(tokenAAmountUserDeposit);
        const tokenBToSwapAmount = requiredBAmountToDeposit.sub(tokenBAmountUserDeposit);
        const depositAmountsForSwap = {
            requiredAAmountToDeposit,
            requiredBAmountToDeposit,
            tokenAToSwapAmount,
            tokenBToSwapAmount,
        };
        return depositAmountsForSwap;
    };
    /**
     * @deprecated The method should not be used
     */
    calculateAmountsDistributionWithPriceRange = async (dex, pool, lowerPrice, upperPrice) => {
        const tokenAAmountToDeposit = new decimal_js_1.default(100.0);
        if (dex === 'RAYDIUM') {
            const poolState = await accounts_3.PoolState.fetch(this._rpc, pool, this._raydiumService.getRaydiumProgramId());
            if (!poolState) {
                throw new Error(`Raydium poolState ${pool.toString()} is not found`);
            }
            const decimalsA = poolState.mintDecimals0;
            const decimalsB = poolState.mintDecimals1;
            const { amountA, amountB } = lib_1.LiquidityMath.getAmountsFromLiquidity(poolState.sqrtPriceX64, lib_1.SqrtPriceMath.priceToSqrtPriceX64(lowerPrice, decimalsA, decimalsB), lib_1.SqrtPriceMath.priceToSqrtPriceX64(upperPrice, decimalsA, decimalsB), new bn_js_1.default(100_000_000), true);
            const amountADecimal = new decimal_js_1.default(amountA.toString());
            const amountBDecimal = new decimal_js_1.default(amountB.toString());
            return [(0, utils_1.lamportsToNumberDecimal)(amountADecimal, decimalsA), (0, utils_1.lamportsToNumberDecimal)(amountBDecimal, decimalsB)];
        }
        else if (dex === 'ORCA') {
            const whirlpoolState = await accounts_2.Whirlpool.fetch(this._rpc, pool, this._orcaService.getWhirlpoolProgramId());
            if (!whirlpoolState) {
                throw new Error(`Raydium poolState ${pool.toString()} is not found`);
            }
            const tokenMintA = whirlpoolState.tokenMintA;
            const tokenMintB = whirlpoolState.tokenMintB;
            const decimalsA = await (0, utils_1.getMintDecimals)(this._rpc, tokenMintA);
            const decimalsB = await (0, utils_1.getMintDecimals)(this._rpc, tokenMintB);
            const tickLowerIndex = (0, utils_1.getNearestValidTickIndexFromTickIndex)((0, whirlpools_core_1.priceToTickIndex)(lowerPrice.toNumber(), decimalsA, decimalsB), whirlpoolState.tickSpacing);
            const tickUpperIndex = (0, utils_1.getNearestValidTickIndexFromTickIndex)((0, whirlpools_core_1.priceToTickIndex)(upperPrice.toNumber(), decimalsA, decimalsB), whirlpoolState.tickSpacing);
            const param = {
                tokenA: BigInt((0, utils_1.collToLamportsDecimal)(tokenAAmountToDeposit, decimalsA).toString()),
            };
            const addLiqResult = (0, utils_1.getIncreaseLiquidityQuote)(param, whirlpoolState, tickLowerIndex, tickUpperIndex, utils_1.defaultSlippagePercentageBPS, undefined, undefined);
            return [
                (0, utils_1.lamportsToNumberDecimal)(new decimal_js_1.default(addLiqResult.tokenEstA.toString()), decimalsA),
                (0, utils_1.lamportsToNumberDecimal)(new decimal_js_1.default(addLiqResult.tokenEstB.toString()), decimalsB),
            ];
        }
        else if (dex === 'METEORA') {
            const poolState = await accounts_4.LbPair.fetch(this._rpc, pool, this._meteoraService.getMeteoraProgramId());
            if (!poolState) {
                throw new Error(`Meteora poolState ${pool.toString()} is not found`);
            }
            // const tokenMintA = poolState.tokenXMint;
            // const tokenMintB = poolState.tokenYMint;
            // const decimalsA = await getMintDecimals(this._connection, tokenMintA);
            // const decimalsB = await getMintDecimals(this._connection, tokenMintB);
            return [new decimal_js_1.default(0), new decimal_js_1.default(0)];
        }
        else {
            throw new Error('Invalid dex, use RAYDIUM or ORCA or METEORA');
        }
    };
    calculateAmountsToBeDeposited = async (strategy, tokenAAmount, tokenBAmount, profiledFunctionExecution = utils_1.noopProfiledFunctionExecution) => {
        const { strategy: strategyState } = await this.getStrategyStateIfNotFetched(strategy);
        if (strategyState.shareCalculationMethod === deposit_method_1.DOLLAR_BASED) {
            return this.calculateDepostAmountsDollarBased(strategy, tokenAAmount, tokenBAmount);
        }
        else if (strategyState.shareCalculationMethod === deposit_method_1.PROPORTION_BASED) {
            return this.calculateDepositAmountsProportional(strategy, tokenAAmount, tokenBAmount, profiledFunctionExecution);
        }
        else {
            throw new Error('Invalid share calculation method');
        }
    };
    /// Returns an amount of tokenA and an amount of tokenB that define the ratio of the amounts that can be deposited
    calculateAmountsRatioToBeDeposited = async (strategy, holdings, profiler = utils_1.noopProfiledFunctionExecution) => {
        const { strategy: strategyState } = await this.getStrategyStateIfNotFetched(strategy);
        if (strategyState.shareCalculationMethod === deposit_method_1.DOLLAR_BASED) {
            return this.calculateDepostAmountsDollarBased(strategy, new decimal_js_1.default(100), undefined);
        }
        else if (strategyState.shareCalculationMethod === deposit_method_1.PROPORTION_BASED) {
            let tokenHoldings = holdings;
            if (!tokenHoldings) {
                tokenHoldings = await profiler(this.getStrategyTokensHoldings(strategy), 'getStrategyTokensHoldings', []);
            }
            const { a, b } = tokenHoldings;
            return [a, b];
        }
        else {
            throw new Error('Invalid share calculation method');
        }
    };
    calculateDepositAmountsProportional = async (strategy, tokenAAmount, tokenBAmount, profiler = utils_1.noopProfiledFunctionExecution) => {
        if (!tokenAAmount && !tokenBAmount) {
            return [new decimal_js_1.default(0), new decimal_js_1.default(0)];
        }
        const totalHoldings = await profiler(this.getStrategyTokensHoldings(strategy), 'getStrategyTokensHoldings', []);
        // if we have no holdings, on the initial deposit we use the old method
        if (totalHoldings.a.eq(utils_1.ZERO) && totalHoldings.b.eq(utils_1.ZERO)) {
            return await this.calculateDepostAmountsDollarBased(strategy, tokenAAmount, tokenBAmount);
        }
        return await profiler(this.calculateDepositAmountsProportionalWithTotalTokens(totalHoldings, tokenAAmount, tokenBAmount), 'C-calculateDepositAmountsProportionalWithTotalTokens', []);
    };
    calculateDepositAmountsProportionalWithTotalTokens = async (totalTokens, tokenAAmount, tokenBAmount) => {
        if (totalTokens.a.eq(utils_1.ZERO)) {
            return [utils_1.ZERO, tokenBAmount ? tokenBAmount : new decimal_js_1.default(Number.MAX_VALUE)];
        }
        if (totalTokens.b.eq(utils_1.ZERO)) {
            return [tokenAAmount ? tokenAAmount : new decimal_js_1.default(Number.MAX_VALUE), utils_1.ZERO];
        }
        const tokensRatio = totalTokens.a.div(totalTokens.b);
        if (tokenAAmount) {
            const requiredBAmount = tokenAAmount.div(tokensRatio);
            if (!tokenBAmount || tokenBAmount.gt(requiredBAmount)) {
                return [tokenAAmount, requiredBAmount];
            }
            else {
                const requiredAAmount = tokenBAmount.mul(tokensRatio);
                return [requiredAAmount, tokenBAmount];
            }
        }
        else if (tokenBAmount) {
            const requiredAMount = tokenBAmount.mul(tokensRatio);
            return [requiredAMount, tokenBAmount];
        }
        else {
            throw new Error('Invalid params, one of tokenAAmount or tokenBAmount must be provided');
        }
    };
    calculateDepostAmountsDollarBased = async (strategy, tokenAAmount, tokenBAmount) => {
        const { strategy: strategyState } = await this.getStrategyStateIfNotFetched(strategy);
        const dex = Number(strategyState.strategyDex);
        const isOrca = (0, utils_1.dexToNumber)('ORCA') === dex;
        const isRaydium = (0, utils_1.dexToNumber)('RAYDIUM') === dex;
        const isMeteora = (0, utils_1.dexToNumber)('METEORA') === dex;
        if (isOrca) {
            const whirlpool = await accounts_2.Whirlpool.fetch(this._rpc, strategyState.pool, this._orcaService.getWhirlpoolProgramId());
            if (!whirlpool) {
                throw new Error(`Unable to get Orca whirlpool for pubkey ${strategyState.pool}`);
            }
            return this.calculateAmountsOrca({
                whirlpoolState: whirlpool,
                positionAddress: strategyState.position,
                tokenAAmount,
                tokenBAmount,
            });
        }
        else if (isRaydium) {
            return this.calculateAmountsRaydium({ strategyState, tokenAAmount, tokenBAmount });
        }
        else if (isMeteora) {
            return this.calculateAmountsMeteora({ strategyState, tokenAAmount, tokenBAmount });
        }
        else {
            throw new Error(`The strategy ${strategy.toString()} is not Orca or Raydium`);
        }
    };
    calculateAmountsOrca = async ({ whirlpoolState, positionAddress, tokenAAmount, tokenBAmount, }) => {
        if (!tokenAAmount && !tokenBAmount) {
            return [new decimal_js_1.default(0), new decimal_js_1.default(0)];
        }
        // Given A in ATA, calc how much A and B
        const defaultSlippagePercentageBPS = 10;
        const positionState = await accounts_2.Position.fetch(this._rpc, positionAddress, this._orcaService.getWhirlpoolProgramId());
        if (!positionState) {
            throw new Error(`Unable to get Orca position for pubkey ${positionAddress}`);
        }
        let computedAmounts = [new decimal_js_1.default(0), new decimal_js_1.default(0)];
        if (tokenAAmount) {
            const tokenAForQuote = BigInt(tokenAAmount.toString());
            const params = {
                tokenA: tokenAForQuote,
            };
            const estimatedGivenA = (0, utils_1.getIncreaseLiquidityQuote)(params, whirlpoolState, positionState.tickLowerIndex, positionState.tickUpperIndex, defaultSlippagePercentageBPS, undefined, // todo: use new Wirlpool state and read transfer fees
            undefined);
            computedAmounts = [
                new decimal_js_1.default(estimatedGivenA.tokenEstA.toString()),
                new decimal_js_1.default(estimatedGivenA.tokenEstB.toString()),
            ];
        }
        if (tokenBAmount && computedAmounts[1] > tokenBAmount) {
            const tokenBForQuote = BigInt(tokenBAmount.toString());
            const params = {
                tokenB: tokenBForQuote,
            };
            const estimatedGivenB = (0, utils_1.getIncreaseLiquidityQuote)(params, whirlpoolState, positionState.tickLowerIndex, positionState.tickUpperIndex, defaultSlippagePercentageBPS, undefined, // todo: use new Wirlpool state and read transfer fees
            undefined);
            computedAmounts = [
                new decimal_js_1.default(estimatedGivenB.tokenEstA.toString()),
                new decimal_js_1.default(estimatedGivenB.tokenEstB.toString()),
            ];
        }
        return computedAmounts;
    };
    calculateAmountsRaydium = async ({ strategyState, tokenAAmount, tokenBAmount, }) => {
        if (!tokenAAmount && !tokenBAmount) {
            return [new decimal_js_1.default(0), new decimal_js_1.default(0)];
        }
        const poolState = await accounts_3.PoolState.fetch(this._rpc, strategyState.pool, this._raydiumService.getRaydiumProgramId());
        const position = await accounts_3.PersonalPositionState.fetch(this._rpc, strategyState.position, this._raydiumService.getRaydiumProgramId());
        if (!position) {
            throw new Error(`position ${strategyState.position.toString()} is not found`);
        }
        if (!poolState) {
            throw new Error(`poolState ${strategyState.pool.toString()} is not found`);
        }
        if (tokenAAmount && tokenBAmount && tokenAAmount.gt(0) && tokenBAmount.gt(0)) {
            const liquidity = lib_1.LiquidityMath.getLiquidityFromTokenAmounts(poolState.sqrtPriceX64, lib_1.SqrtPriceMath.getSqrtPriceX64FromTick(position.tickLowerIndex), lib_1.SqrtPriceMath.getSqrtPriceX64FromTick(position.tickUpperIndex), new bn_js_1.default(tokenAAmount.toString()), new bn_js_1.default(tokenBAmount.toString()));
            const { amountA, amountB } = lib_1.LiquidityMath.getAmountsFromLiquidity(poolState.sqrtPriceX64, lib_1.SqrtPriceMath.getSqrtPriceX64FromTick(position.tickLowerIndex), lib_1.SqrtPriceMath.getSqrtPriceX64FromTick(position.tickUpperIndex), liquidity, true);
            return [new decimal_js_1.default(amountA.toString()), new decimal_js_1.default(amountB.toString())];
        }
        else {
            const primaryTokenAmount = tokenAAmount || tokenBAmount;
            const secondaryTokenAmount = tokenAAmount ? tokenBAmount : tokenAAmount;
            const { amountA, amountB } = lib_1.LiquidityMath.getAmountsFromLiquidity(poolState.sqrtPriceX64, lib_1.SqrtPriceMath.getSqrtPriceX64FromTick(position.tickLowerIndex), lib_1.SqrtPriceMath.getSqrtPriceX64FromTick(position.tickUpperIndex), 
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            new bn_js_1.default(primaryTokenAmount.plus(secondaryTokenAmount || 0).toString()), // safe to use ! here because we check in the beginning that at least one of the amounts are not undefined;
            true);
            const amountADecimal = new decimal_js_1.default(amountA.toString());
            const amountBDecimal = new decimal_js_1.default(amountB.toString());
            const ratio = amountADecimal.div(amountBDecimal);
            if (tokenAAmount === undefined || tokenAAmount.eq(utils_1.ZERO)) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                return [tokenBAmount.mul(ratio), tokenBAmount];
            }
            if (tokenBAmount === undefined || tokenBAmount.eq(utils_1.ZERO)) {
                return [tokenAAmount, tokenAAmount.div(ratio)];
            }
        }
        return [new decimal_js_1.default(0), new decimal_js_1.default(0)];
    };
    calculateAmountsMeteora = async ({ strategyState, tokenAAmount, tokenBAmount, }) => {
        if (!tokenAAmount && !tokenBAmount) {
            return [new decimal_js_1.default(0), new decimal_js_1.default(0)];
        }
        const poolState = await accounts_4.LbPair.fetch(this._rpc, strategyState.pool, this._meteoraService.getMeteoraProgramId());
        if (!poolState) {
            throw new Error(`poolState ${strategyState.pool.toString()} is not found`);
        }
        // TODO: this is just a simple approximation, but it's used only for the first deposit.
        if (tokenAAmount && tokenBAmount && tokenAAmount.gt(0) && tokenBAmount.gt(0)) {
            // Use everything that is given in case there are both tokens
            return [tokenAAmount, tokenBAmount];
        }
        else {
            const binArrayIndex = (0, meteora_1.binIdToBinArrayIndex)(new bn_js_1.default(poolState.activeId));
            const [binArrayPk] = await (0, meteora_1.deriveBinArray)(strategyState.pool, binArrayIndex, this._meteoraService.getMeteoraProgramId());
            const binArray = await accounts_4.BinArray.fetch(this._rpc, binArrayPk, this._meteoraService.getMeteoraProgramId());
            if (!binArray) {
                throw new Error(`bin array ${binArrayPk.toString()} is not found`);
            }
            const bin = (0, meteora_1.getBinFromBinArray)(poolState.activeId, binArray);
            let amountADecimal = new decimal_js_1.default(0);
            let amountBDecimal = new decimal_js_1.default(0);
            if (bin) {
                if (!bin.amountX.eq(new bn_js_1.default(0))) {
                    amountADecimal = new decimal_js_1.default(bin.amountX.toString());
                }
                if (!bin.amountY.eq(new bn_js_1.default(0))) {
                    amountBDecimal = new decimal_js_1.default(bin.amountY.toString());
                }
            }
            else {
                throw new Error(`bin ${poolState.activeId.toString()} is not found`);
            }
            if (amountADecimal.eq(utils_1.ZERO) && amountBDecimal.eq(utils_1.ZERO)) {
                const decimalsA = await (0, utils_1.getMintDecimals)(this._rpc, strategyState.tokenAMint);
                const decimalsB = await (0, utils_1.getMintDecimals)(this._rpc, strategyState.tokenBMint);
                const poolPrice = (0, meteora_1.getPriceOfBinByBinIdWithDecimals)(poolState.activeId, poolState.binStep, decimalsA, decimalsB);
                return [tokenAAmount || tokenBAmount.div(poolPrice), tokenBAmount || tokenAAmount.mul(poolPrice)];
            }
            if (amountBDecimal.eq(utils_1.ZERO)) {
                return [tokenAAmount, utils_1.ZERO];
            }
            if (amountADecimal.eq(utils_1.ZERO)) {
                return [utils_1.ZERO, tokenBAmount];
            }
            const ratio = amountADecimal.div(amountBDecimal);
            if (tokenAAmount === undefined || tokenAAmount.eq(utils_1.ZERO)) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const amountA = tokenBAmount.mul(ratio) || new decimal_js_1.default(0);
                return [amountA, tokenBAmount];
            }
            if (tokenBAmount === undefined || tokenBAmount.eq(utils_1.ZERO)) {
                const amountB = tokenAAmount.div(ratio) || new decimal_js_1.default(0);
                return [tokenAAmount, amountB];
            }
        }
        return [new decimal_js_1.default(0), new decimal_js_1.default(0)];
    };
    /**
     * @deprecated The method should not be used
     */
    getDepositRatioFromTokenA = async (strategy, amountA) => {
        const { strategy: strategyState } = await this.getStrategyStateIfNotFetched(strategy);
        const dex = Number(strategyState.strategyDex);
        const isOrca = (0, utils_1.dexToNumber)('ORCA') === dex;
        const isRaydium = (0, utils_1.dexToNumber)('RAYDIUM') === dex;
        const isMeteora = (0, utils_1.dexToNumber)('METEORA') === dex;
        if (isOrca) {
            return this.getDepositRatioFromAOrca(strategy, amountA);
        }
        if (isRaydium) {
            return this.getDepositRatioFromARaydium(strategy, amountA);
        }
        if (isMeteora) {
            return this.getDepositRatioFromAMeteora(strategy);
        }
        throw Error(`Strategy dex ${dex} not supported`);
    };
    /**
     * @deprecated The method should not be used
     */
    getDepositRatioFromTokenB = async (strategy, amountB) => {
        const { strategy: strategyState } = await this.getStrategyStateIfNotFetched(strategy);
        const dex = Number(strategyState.strategyDex);
        const isOrca = (0, utils_1.dexToNumber)('ORCA') === dex;
        const isRaydium = (0, utils_1.dexToNumber)('RAYDIUM') === dex;
        const isMeteora = (0, utils_1.dexToNumber)('METEORA') === dex;
        if (isOrca) {
            return this.getDepositRatioFromBOrca(strategy, amountB);
        }
        if (isRaydium) {
            return this.getDepositRatioFromBRaydium(strategy, amountB);
        }
        if (isMeteora) {
            return this.getDepositRatioFromBMeteora(strategy);
        }
        throw Error(`Strategy dex ${dex} not supported`);
    };
    /**
     * Get the on-chain state of the terms&conditions signature for the owner
     * @param owner
     */
    async getUserTermsSignatureState(owner) {
        const pdaSeed = [Buffer.from('signature'), addressEncoder.encode(owner)];
        const [signatureStateKey, _signatureStateBump] = await (0, kit_1.getProgramDerivedAddress)({
            seeds: pdaSeed,
            programAddress: this.getProgramID(),
        });
        return await accounts_1.TermsSignature.fetch(this._rpc, signatureStateKey, this.getProgramID());
    }
    /**
     * Get the instruction to store the on chain owner signature of terms&conditions
     * @param owner
     * @param signature
     */
    async getUserTermsSignatureIx(owner, signature) {
        const pdaSeed = [Buffer.from('signature'), addressEncoder.encode(owner.address)];
        const [signatureStateKey] = await (0, kit_1.getProgramDerivedAddress)({ seeds: pdaSeed, programAddress: this.getProgramID() });
        const args = {
            signature: Array.from(signature),
        };
        const accounts = {
            owner: owner,
            ownerSignatureState: signatureStateKey,
            systemProgram: system_1.SYSTEM_PROGRAM_ADDRESS,
            rent: sysvars_1.SYSVAR_RENT_ADDRESS,
        };
        return (0, instructions_2.signTerms)(args, accounts, undefined, this.getProgramID());
    }
    async getDepositRatioFromAOrca(strategy, amountA) {
        const { strategy: strategyState } = await this.getStrategyStateIfNotFetched(strategy);
        const whirlpool = await accounts_2.Whirlpool.fetch(this._rpc, strategyState.pool, this._orcaService.getWhirlpoolProgramId());
        if (!whirlpool) {
            throw Error(`Could not fetch whirlpool state with pubkey ${strategyState.pool.toString()}`);
        }
        const position = await accounts_2.Position.fetch(this._rpc, strategyState.position, this._orcaService.getWhirlpoolProgramId());
        if (!position) {
            throw new Error(`Whirlpool position ${strategyState.position} does not exist`);
        }
        const params = {
            tokenA: BigInt(amountA.toString()),
        };
        const quote = (0, utils_1.getIncreaseLiquidityQuote)(params, whirlpool, position.tickLowerIndex, position.tickUpperIndex, utils_1.defaultSlippagePercentageBPS, undefined, undefined);
        return { amountSlippageA: new bn_js_1.default(quote.tokenEstA.toString()), amountSlippageB: new bn_js_1.default(quote.tokenEstB.toString()) };
    }
    async getDepositRatioFromAMeteora(strategy) {
        const { strategy: strategyState } = await this.getStrategyStateIfNotFetched(strategy);
        const poolStatePromise = accounts_4.LbPair.fetch(this._rpc, strategyState.pool, this._meteoraService.getMeteoraProgramId());
        const positionPromise = accounts_4.PositionV2.fetch(this._rpc, strategyState.position, this._meteoraService.getMeteoraProgramId());
        const [poolState, _position] = await Promise.all([poolStatePromise, positionPromise]);
        if (!poolState) {
            throw Error(`Could not fetch lb pair state with pubkey ${strategyState.pool.toString()}`);
        }
        return { amountSlippageA: constants_1.ZERO_BN, amountSlippageB: constants_1.ZERO_BN };
    }
    async getDepositRatioFromBMeteora(strategy) {
        const { strategy: strategyState } = await this.getStrategyStateIfNotFetched(strategy);
        const [poolState, _position] = await Promise.all([
            accounts_4.LbPair.fetch(this._rpc, strategyState.pool, this._meteoraService.getMeteoraProgramId()),
            accounts_4.PositionV2.fetch(this._rpc, strategyState.position, this._meteoraService.getMeteoraProgramId()),
        ]);
        if (!poolState) {
            throw Error(`Could not fetch lb pair state with pubkey ${strategyState.pool.toString()}`);
        }
        return { amountSlippageA: constants_1.ZERO_BN, amountSlippageB: constants_1.ZERO_BN };
    }
    getDepositRatioFromBOrca = async (strategy, amountB) => {
        const { strategy: strategyState } = await this.getStrategyStateIfNotFetched(strategy);
        const whirlpool = await accounts_2.Whirlpool.fetch(this._rpc, strategyState.pool, this._orcaService.getWhirlpoolProgramId());
        if (!whirlpool) {
            throw Error(`Could not fetch whirlpool state with pubkey ${strategyState.pool.toString()}`);
        }
        const position = await accounts_2.Position.fetch(this._rpc, strategyState.position, this._orcaService.getWhirlpoolProgramId());
        if (!position) {
            throw new Error(`Whirlpool position ${strategyState.position} does not exist`);
        }
        const param = {
            tokenB: BigInt(amountB.toString()),
        };
        const quote = (0, utils_1.getIncreaseLiquidityQuote)(param, whirlpool, position.tickLowerIndex, position.tickUpperIndex, utils_1.defaultSlippagePercentageBPS, undefined, undefined);
        return { amountSlippageA: new bn_js_1.default(quote.tokenEstA.toString()), amountSlippageB: new bn_js_1.default(quote.tokenEstB.toString()) };
    };
    getDepositRatioFromARaydium = async (strategy, amountA) => {
        const { strategy: strategyState } = await this.getStrategyStateIfNotFetched(strategy);
        const poolState = await accounts_3.PoolState.fetch(this._rpc, strategyState.pool, this._raydiumService.getRaydiumProgramId());
        const positionState = await accounts_3.PersonalPositionState.fetch(this._rpc, strategyState.position, this._raydiumService.getRaydiumProgramId());
        if (!positionState) {
            throw new Error(`Raydium position ${strategyState.position.toString()} could not be found.`);
        }
        if (!poolState) {
            throw new Error(`Raydium pool ${strategyState.pool.toString()} could not be found.`);
        }
        const lowerSqrtPriceX64 = lib_1.SqrtPriceMath.getSqrtPriceX64FromTick(positionState.tickLowerIndex);
        const upperSqrtPriceX64 = lib_1.SqrtPriceMath.getSqrtPriceX64FromTick(positionState.tickUpperIndex);
        const liqudity = lib_1.LiquidityMath.getLiquidityFromTokenAmountA(lowerSqrtPriceX64, upperSqrtPriceX64, amountA, false);
        const amountsSlippage = lib_1.LiquidityMath.getAmountsFromLiquidityWithSlippage(poolState.sqrtPriceX64, lowerSqrtPriceX64, upperSqrtPriceX64, liqudity, true, false, 1);
        return amountsSlippage;
    };
    getDepositRatioFromBRaydium = async (strategy, amountB) => {
        const { strategy: strategyState } = await this.getStrategyStateIfNotFetched(strategy);
        const poolState = await accounts_3.PoolState.fetch(this._rpc, strategyState.pool, this._raydiumService.getRaydiumProgramId());
        const positionState = await accounts_3.PersonalPositionState.fetch(this._rpc, strategyState.position, this._raydiumService.getRaydiumProgramId());
        if (!positionState) {
            throw new Error(`Raydium position ${strategyState.position.toString()} could not be found.`);
        }
        if (!poolState) {
            throw new Error(`Raydium pool ${strategyState.pool.toString()} could not be found.`);
        }
        const lowerSqrtPriceX64 = lib_1.SqrtPriceMath.getSqrtPriceX64FromTick(positionState.tickLowerIndex);
        const upperSqrtPriceX64 = lib_1.SqrtPriceMath.getSqrtPriceX64FromTick(positionState.tickUpperIndex);
        const liqudity = lib_1.LiquidityMath.getLiquidityFromTokenAmountB(lowerSqrtPriceX64, upperSqrtPriceX64, amountB);
        const amountsSlippage = lib_1.LiquidityMath.getAmountsFromLiquidityWithSlippage(poolState.sqrtPriceX64, lowerSqrtPriceX64, upperSqrtPriceX64, liqudity, true, false, 1);
        return amountsSlippage;
    };
    getCollateralInfo = async (address) => {
        const collateralInfos = await accounts_1.CollateralInfos.fetch(this._rpc, address, this.getProgramID());
        if (collateralInfos === null) {
            throw new Error('Could not fetch CollateralInfos');
        }
        return collateralInfos.infos;
    };
    getGlobalConfigState = async (address) => {
        return await accounts_1.GlobalConfig.fetch(this._rpc, address, this.getProgramID());
    };
    getWhirlpoolStrategy = async (address) => {
        return await accounts_1.WhirlpoolStrategy.fetch(this._rpc, address, this.getProgramID());
    };
    getWhirlpoolStrategies = async (addresses) => {
        return await accounts_1.WhirlpoolStrategy.fetchMultiple(this._rpc, addresses, this.getProgramID());
    };
    getStrategyVaultBalances = async (strategy) => {
        const { strategy: strategyState } = await this.getStrategyStateIfNotFetched(strategy);
        const vaults = await Promise.all([
            this.getTokenAccountBalance(strategyState.tokenAVault),
            this.getTokenAccountBalance(strategyState.tokenBVault),
        ]);
        const aVault = vaults[0];
        const bVault = vaults[1];
        return { aVault, bVault };
    };
    getUpdateStrategyParamsIxs = async (strategyAdmin, strategy, rebalanceType, withdrawFeeBps, performanceFeeBps) => {
        const updateRebalanceTypeIx = await (0, utils_1.getUpdateStrategyConfigIx)(strategyAdmin, this._globalConfig, strategy, new StrategyConfigOption_1.UpdateRebalanceType(), rebalanceType, this.getProgramID());
        let updateWithdrawalFeeIx = null;
        if (withdrawFeeBps) {
            updateWithdrawalFeeIx = await (0, utils_1.getUpdateStrategyConfigIx)(strategyAdmin, this._globalConfig, strategy, new StrategyConfigOption_1.UpdateWithdrawFee(), withdrawFeeBps, this.getProgramID());
        }
        if (!performanceFeeBps) {
            performanceFeeBps = DefaultStrategyConfig_1.DefaultPerformanceFeeBps;
        }
        const updateFeesFeeIx = await (0, utils_1.getUpdateStrategyConfigIx)(strategyAdmin, this._globalConfig, strategy, new StrategyConfigOption_1.UpdateCollectFeesFee(), performanceFeeBps, this.getProgramID());
        const updateRewards0FeeIx = await (0, utils_1.getUpdateStrategyConfigIx)(strategyAdmin, this._globalConfig, strategy, new StrategyConfigOption_1.UpdateReward0Fee(), performanceFeeBps, this.getProgramID());
        const updateRewards1FeeIx = await (0, utils_1.getUpdateStrategyConfigIx)(strategyAdmin, this._globalConfig, strategy, new StrategyConfigOption_1.UpdateReward1Fee(), performanceFeeBps, this.getProgramID());
        const updateRewards2FeeIx = await (0, utils_1.getUpdateStrategyConfigIx)(strategyAdmin, this._globalConfig, strategy, new StrategyConfigOption_1.UpdateReward2Fee(), performanceFeeBps, this.getProgramID());
        const ixs = [updateRebalanceTypeIx, updateFeesFeeIx, updateRewards0FeeIx, updateRewards1FeeIx, updateRewards2FeeIx];
        if (updateWithdrawalFeeIx) {
            ixs.push(updateWithdrawalFeeIx);
        }
        return ixs;
    };
    getUpdateRewardsIxs = async (strategyOwner, strategy) => {
        const strategyWithAddress = await this.getStrategyStateIfNotFetched(strategy);
        const strategyState = strategyWithAddress.strategy;
        if (!strategyState) {
            throw Error(`Could not fetch strategy state with pubkey ${strategy.toString()}`);
        }
        const globalConfig = await this.getGlobalConfigState(strategyState.globalConfig);
        if (!globalConfig) {
            throw Error(`Could not fetch global config with pubkey ${strategyState.globalConfig.toString()}`);
        }
        const collateralInfos = await this.getCollateralInfo(globalConfig.tokenInfos);
        const result = [];
        if (strategyState.strategyDex.toNumber() === (0, utils_1.dexToNumber)('ORCA')) {
            const whirlpool = await accounts_2.Whirlpool.fetch(this._rpc, strategyState.pool, this._orcaService.getWhirlpoolProgramId());
            if (!whirlpool) {
                throw Error(`Could not fetch whirlpool state with pubkey ${strategyState.pool.toString()}`);
            }
            for (let i = 0; i < 3; i++) {
                if (whirlpool.rewardInfos[i].mint !== pubkeys_1.DEFAULT_PUBLIC_KEY) {
                    const collateralId = this.getCollateralIdFromMint(whirlpool.rewardInfos[i].mint, collateralInfos);
                    if (collateralId === -1) {
                        throw Error(`Could not find collateral id for mint ${whirlpool.rewardInfos[i].mint.toString()}`);
                    }
                    const rewardVault = await (0, kit_1.generateKeyPairSigner)();
                    const args = {
                        rewardIndex: i,
                        collateralToken: collateralId,
                    };
                    const tokenProgram = await this.getAccountOwner(whirlpool.rewardInfos[i].mint);
                    const accounts = {
                        payer: strategyOwner,
                        globalConfig: strategyState.globalConfig,
                        strategy: strategyWithAddress.address,
                        pool: strategyState.pool,
                        rewardMint: whirlpool.rewardInfos[i].mint,
                        rewardVault: rewardVault,
                        baseVaultAuthority: strategyState.baseVaultAuthority,
                        systemProgram: system_1.SYSTEM_PROGRAM_ADDRESS,
                        rent: sysvars_1.SYSVAR_RENT_ADDRESS,
                        tokenProgram,
                        tokenInfos: globalConfig.tokenInfos,
                    };
                    const ix = (0, instructions_2.updateRewardMapping)(args, accounts, undefined, this.getProgramID());
                    result.push([ix, rewardVault]);
                }
            }
            return result;
        }
        else if (strategyState.strategyDex.toNumber() === (0, utils_1.dexToNumber)('RAYDIUM')) {
            const poolState = await accounts_3.PoolState.fetch(this._rpc, strategyState.pool, this._raydiumService.getRaydiumProgramId());
            if (!poolState) {
                throw new Error(`Could not fetch whirlpool state with pubkey ${strategyState.pool.toString()}`);
            }
            for (let i = 0; i < 3; i++) {
                if (poolState.rewardInfos[i].tokenMint !== pubkeys_1.DEFAULT_PUBLIC_KEY) {
                    const collateralId = this.getCollateralIdFromMint(poolState.rewardInfos[i].tokenMint, collateralInfos);
                    if (collateralId === -1) {
                        throw Error(`Could not find collateral id for mint ${poolState.rewardInfos[i].tokenMint.toString()}`);
                    }
                    const rewardVault = await (0, kit_1.generateKeyPairSigner)();
                    const args = {
                        rewardIndex: i,
                        collateralToken: collateralId,
                    };
                    const tokenProgram = await this.getAccountOwner(poolState.rewardInfos[i].tokenMint);
                    const accounts = {
                        payer: strategyOwner,
                        globalConfig: strategyState.globalConfig,
                        strategy: strategyWithAddress.address,
                        pool: strategyState.pool,
                        rewardMint: poolState.rewardInfos[i].tokenMint,
                        rewardVault: rewardVault,
                        baseVaultAuthority: strategyState.baseVaultAuthority,
                        systemProgram: system_1.SYSTEM_PROGRAM_ADDRESS,
                        rent: sysvars_1.SYSVAR_RENT_ADDRESS,
                        tokenProgram,
                        tokenInfos: globalConfig.tokenInfos,
                    };
                    const ix = (0, instructions_2.updateRewardMapping)(args, accounts, undefined, this.getProgramID());
                    result.push([ix, rewardVault]);
                }
            }
            return result;
        }
        else if (strategyState.strategyDex.toNumber() === (0, utils_1.dexToNumber)('METEORA')) {
            const poolState = await accounts_4.LbPair.fetch(this._rpc, strategyState.pool, this._meteoraService.getMeteoraProgramId());
            if (!poolState) {
                throw new Error(`Could not fetch meteora state with pubkey ${strategyState.pool.toString()}`);
            }
            for (let i = 0; i < 2; i++) {
                if (poolState.rewardInfos[i].mint !== pubkeys_1.DEFAULT_PUBLIC_KEY) {
                    const collateralId = this.getCollateralIdFromMint(poolState.rewardInfos[i].mint, collateralInfos);
                    if (collateralId === -1) {
                        throw Error(`Could not find collateral id for mint ${poolState.rewardInfos[i].mint.toString()}`);
                    }
                    const rewardVault = await (0, kit_1.generateKeyPairSigner)();
                    const args = {
                        rewardIndex: i,
                        collateralToken: collateralId,
                    };
                    const tokenProgram = await this.getAccountOwner(poolState.rewardInfos[i].mint);
                    const accounts = {
                        payer: strategyOwner,
                        globalConfig: strategyState.globalConfig,
                        strategy: strategyWithAddress.address,
                        pool: strategyState.pool,
                        rewardMint: poolState.rewardInfos[i].mint,
                        rewardVault: rewardVault,
                        baseVaultAuthority: strategyState.baseVaultAuthority,
                        systemProgram: system_1.SYSTEM_PROGRAM_ADDRESS,
                        rent: sysvars_1.SYSVAR_RENT_ADDRESS,
                        tokenProgram,
                        tokenInfos: globalConfig.tokenInfos,
                    };
                    const ix = (0, instructions_2.updateRewardMapping)(args, accounts, undefined, this.getProgramID());
                    result.push([ix, rewardVault]);
                }
            }
            return result;
        }
        else {
            throw new Error(`Dex ${strategyState.strategyDex} not supported`);
        }
    };
    /**
     * Get the instruction to create an Orca Whirlpool tick, if it does not exist
     * @param payer
     * @param pool
     * @param price
     * @return tickPubkey, (tickInstruction | undefined)
     */
    initializeTickForOrcaPool = async (payer, pool, price) => {
        const { address: poolAddress, whirlpool: whilrpoolState } = await this.getWhirlpoolStateIfNotFetched(pool);
        const decimalsA = await (0, utils_1.getMintDecimals)(this._rpc, whilrpoolState.tokenMintA);
        const decimalsB = await (0, utils_1.getMintDecimals)(this._rpc, whilrpoolState.tokenMintB);
        const tickIndex = (0, whirlpools_core_1.getTickArrayStartTickIndex)((0, whirlpools_core_1.priceToTickIndex)(price.toNumber(), decimalsA, decimalsB), whilrpoolState.tickSpacing);
        const startTickIndex = (0, whirlpools_core_1.getTickArrayStartTickIndex)(tickIndex, whilrpoolState.tickSpacing);
        const [startTickIndexPk, _startTickIndexBump] = await (0, utils_1.getTickArray)(this._orcaService.getWhirlpoolProgramId(), poolAddress, startTickIndex);
        const tick = await accounts_2.TickArray.fetch(this._rpc, startTickIndexPk, this._orcaService.getWhirlpoolProgramId());
        // initialize tick if it doesn't exist
        if (!tick) {
            const initTickArrayArgs = {
                startTickIndex,
            };
            const initTickArrayAccounts = {
                whirlpool: poolAddress,
                funder: payer,
                tickArray: startTickIndexPk,
                systemProgram: system_1.SYSTEM_PROGRAM_ADDRESS,
            };
            return {
                tick: startTickIndexPk,
                initTickIx: (0, instructions_1.initializeTickArray)(initTickArrayArgs, initTickArrayAccounts),
            };
        }
        return {
            tick: startTickIndexPk,
            initTickIx: undefined,
        };
    };
    initializeTickForMeteoraPool = async (payer, pool, price) => {
        const { address: poolAddress, pool: poolState } = await this.getMeteoraStateIfNotFetched(pool);
        const decimalsA = await (0, utils_1.getMintDecimals)(this._rpc, poolState.tokenXMint);
        const decimalsB = await (0, utils_1.getMintDecimals)(this._rpc, poolState.tokenYMint);
        const binArray = (0, meteora_1.getBinIdFromPriceWithDecimals)(price, poolState.binStep, true, decimalsA, decimalsB);
        const binArrayIndex = (0, meteora_1.binIdToBinArrayIndex)(new bn_js_1.default(binArray));
        const [startTickIndexPk] = await (0, meteora_1.deriveBinArray)(poolAddress, binArrayIndex, this._meteoraService.getMeteoraProgramId());
        const tick = await accounts_2.TickArray.fetch(this._rpc, startTickIndexPk, this._meteoraService.getMeteoraProgramId());
        // initialize tick if it doesn't exist
        if (!tick) {
            const initTickArrayArgs = {
                index: new bn_js_1.default(binArrayIndex),
            };
            const initTickArrayAccounts = {
                funder: payer,
                binArray: startTickIndexPk,
                systemProgram: system_1.SYSTEM_PROGRAM_ADDRESS,
                lbPair: poolAddress,
            };
            return {
                tick: startTickIndexPk,
                initTickIx: (0, instructions_3.initializeBinArray)(initTickArrayArgs, initTickArrayAccounts),
            };
        }
        return {
            tick: startTickIndexPk,
            initTickIx: undefined,
        };
    };
    getDexProgramId(strategyState) {
        if (strategyState.strategyDex.toNumber() == (0, utils_1.dexToNumber)('ORCA')) {
            return this._orcaService.getWhirlpoolProgramId();
        }
        else if (strategyState.strategyDex.toNumber() == (0, utils_1.dexToNumber)('RAYDIUM')) {
            return this._raydiumService.getRaydiumProgramId();
        }
        else if (strategyState.strategyDex.toNumber() == (0, utils_1.dexToNumber)('METEORA')) {
            return this._meteoraService.getMeteoraProgramId();
        }
        else {
            throw Error(`Invalid DEX ${strategyState.strategyDex.toString()}`);
        }
    }
}
exports.Kamino = Kamino;
exports.default = Kamino;
//# sourceMappingURL=Kamino.js.map
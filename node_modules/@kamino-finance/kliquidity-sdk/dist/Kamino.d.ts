import { HubbleConfig, SolanaCluster } from '@hubbleprotocol/hubble-config';
import { Account, Address, Instruction, Option, Rpc, Slot, SolanaRpcApi, TransactionSigner } from '@solana/kit';
import { GlobalConfig, TermsSignature, WhirlpoolStrategy } from './@codegen/kliquidity/accounts';
import Decimal from 'decimal.js';
import { Position as OrcaPosition, Whirlpool } from './@codegen/whirlpools/accounts';
import { KaminoPosition, KaminoPrices, KaminoStrategyWithShareMint, ShareData, ShareDataWithAddress, StrategyHolder, StrategyPrices, StrategyWithPendingFees, TokenAmounts, TotalStrategyVaultTokens } from './models';
import { OraclePrices } from '@kamino-finance/scope-sdk/dist/@codegen/scope/accounts/OraclePrices';
import { DepositAmountsForSwap, Dex, GenericPoolInfo, GenericPositionRangeInfo, InitPoolTickIfNeeded, InitStrategyIxs, InputRebalanceFieldInfo, InstructionsWithLookupTables, LiquidityDistribution, LowerAndUpperTickPubkeys, MaybeTokensBalances, MetadataProgramAddressesOrca, MetadataProgramAddressesRaydium, PerformanceFees, PositionRange, PriceReferenceType, ProfiledFunctionExecution, RebalanceFieldInfo, StrategiesFilters, SwapperIxBuilder, TokensBalances, VaultParameters, WithdrawAllAndCloseIxns, WithdrawShares } from './utils';
import BN from 'bn.js';
import StrategyWithAddress from './models/StrategyWithAddress';
import { CollateralInfo, ExecutiveWithdrawActionKind, RebalanceTypeKind, ReferencePriceTypeKind, StrategyStatusKind } from './@codegen/kliquidity/types';
import { AmmConfig, PersonalPositionState, PoolState } from './@codegen/raydium/accounts';
import { Whirlpool as WhirlpoolAPIResponse, WhirlpoolAprApy } from './services';
import { Pool } from './services/RaydiumPoolsResponse';
import { RebalanceMethod } from './utils/CreationParameters';
import { SimulationPercentagePoolParameters } from './services/PoolSimulationService';
import WhirlpoolWithAddress from './models/WhirlpoolWithAddress';
import { PoolSimulationResponse } from './models/PoolSimulationResponseData';
import { MeteoraPool } from './services/MeteoraService';
import { LbPair, PositionV2 } from './@codegen/meteora/accounts';
import LbPairWithAddress from './models/LbPairWithAddress';
import { Token } from '@solana-program/token-2022';
import { AddressLookupTable } from '@solana-program/address-lookup-table';
import type { AccountInfoBase, AccountInfoWithJsonData, AccountInfoWithPubkey } from '@solana/rpc-types';
export declare const HUBBLE_SCOPE_FEED_ID: Address<"3NJYftD5sjVfxSnUdZ1wVML8f3aC6mp1CXCL6L7TnU8C">;
export declare const KAMINO_SCOPE_FEED_ID: Address<"3t4JZcueEzTbVP6kLxXrL3VpWx45jDer4eqysweBchNH">;
export declare class Kamino {
    private readonly _cluster;
    private readonly _rpc;
    readonly _config: HubbleConfig;
    private _globalConfig;
    private readonly _scope;
    private readonly _kliquidityProgramId;
    private readonly _orcaService;
    private readonly _raydiumService;
    private readonly _meteoraService;
    private readonly _jupBaseAPI;
    /**
     * Create a new instance of the Kamino SDK class.
     * @param cluster Name of the Solana cluster
     * @param rpc Connection to the Solana cluster
     * @param globalConfig override kamino global config
     * @param programId override kamino program id
     * @param whirlpoolProgramId override whirlpool program id
     * @param raydiumProgramId override raydium program id
     * @param meteoraProgramId
     * @param jupBaseAPI
     */
    constructor(cluster: SolanaCluster, rpc: Rpc<SolanaRpcApi>, globalConfig?: Address, programId?: Address, whirlpoolProgramId?: Address, raydiumProgramId?: Address, meteoraProgramId?: Address, jupBaseAPI?: string);
    getConnection: () => Rpc<import("@solana/kit").RequestAirdropApi & import("@solana/kit").GetAccountInfoApi & import("@solana/kit").GetBalanceApi & import("@solana/kit").GetBlockApi & import("@solana/kit").GetBlockCommitmentApi & import("@solana/kit").GetBlockHeightApi & import("@solana/kit").GetBlockProductionApi & import("@solana/kit").GetBlocksApi & import("@solana/kit").GetBlocksWithLimitApi & import("@solana/kit").GetBlockTimeApi & import("@solana/kit").GetClusterNodesApi & import("@solana/kit").GetEpochInfoApi & import("@solana/kit").GetEpochScheduleApi & import("@solana/kit").GetFeeForMessageApi & import("@solana/kit").GetFirstAvailableBlockApi & import("@solana/kit").GetGenesisHashApi & import("@solana/kit").GetHealthApi & import("@solana/kit").GetHighestSnapshotSlotApi & import("@solana/kit").GetIdentityApi & import("@solana/kit").GetInflationGovernorApi & import("@solana/kit").GetInflationRateApi & import("@solana/kit").GetInflationRewardApi & import("@solana/kit").GetLargestAccountsApi & import("@solana/kit").GetLatestBlockhashApi & import("@solana/kit").GetLeaderScheduleApi & import("@solana/kit").GetMaxRetransmitSlotApi & import("@solana/kit").GetMaxShredInsertSlotApi & import("@solana/kit").GetMinimumBalanceForRentExemptionApi & import("@solana/kit").GetMultipleAccountsApi & import("@solana/kit").GetProgramAccountsApi & import("@solana/kit").GetRecentPerformanceSamplesApi & import("@solana/kit").GetRecentPrioritizationFeesApi & import("@solana/kit").GetSignaturesForAddressApi & import("@solana/kit").GetSignatureStatusesApi & import("@solana/kit").GetSlotApi & import("@solana/kit").GetSlotLeaderApi & import("@solana/kit").GetSlotLeadersApi & import("@solana/kit").GetStakeMinimumDelegationApi & import("@solana/kit").GetSupplyApi & import("@solana/kit").GetTokenAccountBalanceApi & import("@solana/kit").GetTokenAccountsByDelegateApi & import("@solana/kit").GetTokenAccountsByOwnerApi & import("@solana/kit").GetTokenLargestAccountsApi & import("@solana/kit").GetTokenSupplyApi & import("@solana/kit").GetTransactionApi & import("@solana/kit").GetTransactionCountApi & import("@solana/kit").GetVersionApi & import("@solana/kit").GetVoteAccountsApi & import("@solana/kit").IsBlockhashValidApi & import("@solana/kit").MinimumLedgerSlotApi & import("@solana/kit").SendTransactionApi & import("@solana/kit").SimulateTransactionApi>;
    getProgramID: () => Address;
    setGlobalConfig: (globalConfig: Address) => void;
    getGlobalConfig: () => Address;
    getDepositableTokens: () => Promise<CollateralInfo[]>;
    getCollateralInfos: () => Promise<CollateralInfo[]>;
    getDisabledTokensPrices: (collateralInfos?: CollateralInfo[]) => Promise<Map<Address, Decimal>>;
    getSupportedDexes: () => Dex[];
    getFeeTiersForDex: (dex: Dex) => Decimal[];
    getRebalanceMethods: () => RebalanceMethod[];
    getEnabledRebalanceMethods: () => RebalanceMethod[];
    getPriceReferenceTypes: () => PriceReferenceType[];
    getDefaultRebalanceMethod: () => RebalanceMethod;
    getDefaultParametersForNewVault: () => Promise<VaultParameters>;
    /**
     * Retunrs what type of rebalance method the fields represent
     */
    getRebalanceTypeFromRebalanceFields: (rebalanceFields: RebalanceFieldInfo[]) => RebalanceTypeKind;
    /**
     * Retunrs the rebalance method the fields represent with more details (description, enabled, etc)
     */
    getRebalanceMethodFromRebalanceFields: (rebalanceFields: RebalanceFieldInfo[]) => RebalanceMethod;
    getReferencePriceTypeForStrategy: (strategy: Address | StrategyWithAddress) => Promise<PriceReferenceType>;
    getFieldsForRebalanceMethod: (rebalanceMethod: RebalanceMethod, dex: Dex, fieldOverrides: RebalanceFieldInfo[], tokenAMint: Address, tokenBMint: Address, tickSpacing: number, poolPrice?: Decimal) => Promise<RebalanceFieldInfo[]>;
    getFieldsForManualRebalanceMethod: (dex: Dex, fieldOverrides: RebalanceFieldInfo[], tokenAMint: Address, tokenBMint: Address, poolPrice?: Decimal) => Promise<RebalanceFieldInfo[]>;
    getFieldsForPricePercentageMethod: (dex: Dex, fieldOverrides: RebalanceFieldInfo[], tokenAMint: Address, tokenBMint: Address, poolPrice?: Decimal) => Promise<RebalanceFieldInfo[]>;
    getFieldsForPricePercentageWithResetMethod: (dex: Dex, fieldOverrides: RebalanceFieldInfo[], tokenAMint: Address, tokenBMint: Address, poolPrice?: Decimal) => Promise<RebalanceFieldInfo[]>;
    getFieldsForDriftRebalanceMethod: (dex: Dex, fieldOverrides: RebalanceFieldInfo[], tickSpacing: number, tokenAMint: Address, tokenBMint: Address, poolPrice?: Decimal) => Promise<RebalanceFieldInfo[]>;
    getFieldsForTakeProfitRebalanceMethod: (dex: Dex, fieldOverrides: RebalanceFieldInfo[], tokenAMint: Address, tokenBMint: Address, poolPrice?: Decimal) => Promise<RebalanceFieldInfo[]>;
    getFieldsForPeriodicRebalanceMethod: (dex: Dex, fieldOverrides: RebalanceFieldInfo[], tokenAMint: Address, tokenBMint: Address, poolPrice?: Decimal) => Promise<RebalanceFieldInfo[]>;
    getFieldsForExpanderRebalanceMethod: (dex: Dex, fieldOverrides: RebalanceFieldInfo[], tokenAMint: Address, tokenBMint: Address, poolPrice?: Decimal) => Promise<RebalanceFieldInfo[]>;
    getFieldsForAutodriftRebalanceMethod: (dex: Dex, fieldOverrides: RebalanceFieldInfo[], tokenAMint: Address, tokenBMint: Address, tickSpacing: number, poolPrice?: Decimal) => Promise<RebalanceFieldInfo[]>;
    /**
     * Get the price for a given pair of tokens in a given dex; The price comes from any pool having those tokens, not a specific one, so the price may not be exactly the same between different pools with the same tokens. For a specific pool price use getPoolPrice
     * @param strategy
     * @param amountA
     */
    getPriceForPair: (dex: Dex, poolTokenA: Address, poolTokenB: Address) => Promise<number>;
    getDefaultRebalanceFields: (dex: Dex, poolTokenA: Address, poolTokenB: Address, tickSpacing: number, rebalanceMethod: RebalanceMethod) => Promise<RebalanceFieldInfo[]>;
    /**
     * Return a the pubkey of the pool in a given dex, for given mints and fee tier; if that pool doesn't exist, return default pubkey
     */
    getPoolInitializedForDexPairTier: (dex: Dex, poolTokenA: Address, poolTokenB: Address, feeBPS: Decimal) => Promise<Address>;
    /**
     * Return generic information for all pools in a given dex, for given mints and fee tier
     */
    getExistentPoolsForPair(dex: Dex, tokenMintA: Address, tokenMintB: Address): Promise<GenericPoolInfo[]>;
    getOrcaPoolsForTokens: (poolTokenA: Address, poolTokenB: Address) => Promise<WhirlpoolAPIResponse[]>;
    getRaydiumPoolsForTokens: (poolTokenA: Address, poolTokenB: Address) => Promise<Pool[]>;
    getMeteoraPoolsForTokens: (poolTokenA: Address, poolTokenB: Address) => Promise<MeteoraPool[]>;
    /**
     * Return a list of all Kamino whirlpool strategies
     * @param strategies Limit results to these strategy addresses
     */
    getStrategies: (strategies?: Array<Address>) => Promise<Array<WhirlpoolStrategy | null>>;
    /**
     * Return a list of all Kamino whirlpool strategies with their addresses
     * @param strategies Limit results to these strategy addresses
     */
    getStrategiesWithAddresses: (strategies?: Array<Address>) => Promise<Array<StrategyWithAddress>>;
    getAllStrategiesWithFilters: (strategyFilters: StrategiesFilters) => Promise<Array<StrategyWithAddress>>;
    /**
     * Get a Kamino whirlpool strategy by its public key address
     * @param address
     */
    getStrategyByAddress: (address: Address) => Promise<WhirlpoolStrategy | null>;
    /**
     * Get a Kamino whirlpool strategy by its kToken mint address
     * @param kTokenMint - mint address of the kToken
     */
    getStrategyByKTokenMint: (kTokenMint: Address) => Promise<StrategyWithAddress | null>;
    /**
     * Get the strategy share data (price + balances) of the specified Kamino whirlpool strategy
     * @param strategy
     * @param scopePrices
     */
    getStrategyShareData: (strategy: Address | StrategyWithAddress, scopePrices?: OraclePrices) => Promise<ShareData>;
    /**
     * Get the token A and B per share for the specified Kamino whirlpool strategy
     * @param strategy
     */
    getTokenAAndBPerShare: (strategy: Address | StrategyWithAddress) => Promise<TokenAmounts>;
    /**
     * Batch fetch share data for all or a filtered list of strategies
     * @param strategyFilters strategy filters or a list of strategy public keys
     */
    getStrategiesShareData: (strategyFilters: StrategiesFilters | Address[], stratsWithAddresses?: StrategyWithAddress[], collateralInfos?: CollateralInfo[], disabledTokensPrices?: Map<Address, Decimal>) => Promise<Array<ShareDataWithAddress>>;
    private getBalance;
    private getRaydiumBalances;
    private getMeteoraBalances;
    private getRaydiumTokensBalances;
    private getMeteoraTokensBalances;
    private getOrcaBalances;
    private getOrcaTokensBalances;
    /**
     * Get the strategies share data (price + balances) of the Kamino whirlpool strategies that match the filters
     * @param strategyFilters
     */
    getStrategyShareDataForStrategies: (strategyFilters: StrategiesFilters) => Promise<Array<ShareDataWithAddress>>;
    /**
     * Get the strategy share price of the specified Kamino whirlpool strategy
     * @param strategy
     */
    getStrategySharePrice: (strategy: Address | StrategyWithAddress) => Promise<Decimal>;
    getTokenAccountBalance: (tokenAccount: Address) => Promise<Decimal>;
    /**
     * Get the balance of a token account or 0 if it doesn't exist
     * @param tokenAccount
     */
    getTokenAccountBalanceOrZero: (tokenAccount: Address) => Promise<Decimal>;
    private getStrategyBalances;
    private getStrategyTokensBalances;
    /**
     * Get amount of specified token in all Kamino live strategies
     * @param tokenMint token mint pubkey
     */
    getTotalTokensInStrategies: (tokenMint: Address | string) => Promise<TotalStrategyVaultTokens>;
    getAccountOwner: (pk: Address) => Promise<Address>;
    private getStrategyBalancesOrca;
    private getStrategyBalancesRaydium;
    private getStrategyBalancesMeteora;
    private getStrategyHoldingsUsd;
    getAllOraclePrices: (prices: Address[]) => Promise<[Address, OraclePrices][]>;
    /**
     * Get all Kamino token spot and twap prices
     * @param oraclePrices (optional) Scope Oracle prices
     * @param collateralInfos (optional) Kamino Collateral Infos
     */
    getAllPrices: (oraclePrices?: OraclePrices, collateralInfos?: CollateralInfo[], disabledTokensPrices?: Map<Address, Decimal>) => Promise<KaminoPrices>;
    private getOraclePricesAndCollateralInfos;
    /**
     * Get the prices of all tokens in the specified strategy, or null if the reward token does not exist
     * @param strategy
     * @param collateralInfos
     * @param scopePrices
     */
    getStrategyPrices: (strategy: WhirlpoolStrategy, collateralInfos: CollateralInfo[], scopePrices?: OraclePrices, disabledTokensPrices?: Map<Address, Decimal>) => Promise<StrategyPrices>;
    /**
     * Get all token accounts for the specified share mint
     */
    getShareTokenAccounts: (shareMint: Address) => Promise<AccountInfoWithPubkey<AccountInfoBase & AccountInfoWithJsonData>[]>;
    /**
     * Get all token accounts for the specified wallet
     */
    getAllTokenAccounts: (wallet: Address) => Promise<AccountInfoWithPubkey<AccountInfoBase & AccountInfoWithJsonData>[]>;
    /**
     * Get all token accounts that are holding a specific Kamino whirlpool strategy
     */
    getStrategyTokenAccounts: (strategy: Address | StrategyWithAddress) => Promise<Readonly<{
        account: Readonly<{
            executable: boolean;
            lamports: import("@solana/kit").Lamports;
            owner: Address;
            rentEpoch: bigint;
            space: bigint;
        }> & Readonly<{
            data: import("@solana/kit").Base64EncodedDataResponse | Readonly<{
                parsed: {
                    info?: object;
                    type: string;
                };
                program: string;
                space: bigint;
            }>;
        }>;
        pubkey: Address;
    }>[]>;
    /**
     * Get strategy range in which liquidity is deposited
     */
    getStrategyRange: (strategy: Address | StrategyWithAddress) => Promise<PositionRange>;
    getStrategyRangeOrca: (strategy: Address | StrategyWithAddress) => Promise<PositionRange>;
    getStrategyRangeRaydium: (strategy: Address | StrategyWithAddress) => Promise<PositionRange>;
    getStrategyRangeMeteora: (strategy: Address | StrategyWithAddress) => Promise<PositionRange>;
    getPositionRange: (dex: Dex, position: Address, decimalsA: number, decimalsB: number) => Promise<PositionRange>;
    getPositionRangeOrca: (positionPk: Address, decimalsA: number, decimalsB: number) => Promise<PositionRange>;
    getPositionRangeRaydium: (positionPk: Address, decimalsA: number, decimalsB: number) => Promise<PositionRange>;
    getPositionRangeMeteora: (positionPk: Address, decimalsA: number, decimalsB: number) => Promise<PositionRange>;
    /**
     * Get all strategy token holders
     * @param strategy
     */
    getStrategyHolders: (strategy: Address | StrategyWithAddress) => Promise<StrategyHolder[]>;
    /**
     * Get a list of Orca whirlpools from public keys
     * @param whirlpools
     */
    getWhirlpools: (whirlpools: Address[]) => Promise<Map<Address, Whirlpool | null>>;
    getAllWhirlpoolsFromAPI: (tokens?: Address[]) => Promise<WhirlpoolAPIResponse[]>;
    /**
     * Get a list of Orca positions from public keys
     * @param positions
     */
    getOrcaPositions: (positions: Address[]) => Promise<(OrcaPosition | null)[]>;
    /**
     * Get a list of Raydium positions from public keys
     * @param positions
     */
    getRaydiumPositions: (positions: Address[]) => Promise<(PersonalPositionState | null)[]>;
    getMeteoraPositions: (positions: Address[]) => Promise<(PositionV2 | null)[]>;
    /**
     * Get whirlpool from public key
     * @param whirlpool pubkey of the orca whirlpool
     */
    getWhirlpoolByAddress: (whirlpool: Address) => Promise<Whirlpool | null>;
    /**
     * Get a list of Raydium pools from public keys
     * @param pools
     */
    getRaydiumPools: (pools: Address[]) => Promise<Map<Address, PoolState | null>>;
    getMeteoraPools: (pools: Address[]) => Promise<Map<Address, LbPair | null>>;
    getRaydiumAmmConfig: (config: Address) => Promise<AmmConfig | null>;
    /**
     * Get Raydium pool from public key
     * @param pool pubkey of the orca whirlpool
     */
    getRaydiumPoolByAddress: (pool: Address) => Promise<PoolState | null>;
    getMeteoraPoolByAddress: (pool: Address) => Promise<LbPair | null>;
    getEventAuthorityPDA: (dex: BN) => Promise<Option<Address>>;
    /**
     * Return transaction instruction to withdraw shares from a strategy owner (wallet) and get back token A and token B
     * @param strategy strategy public key
     * @param sharesAmount amount of shares (decimal representation), NOT in lamports
     * @param owner shares owner (wallet with shares)
     * @returns transaction instruction
     */
    withdrawShares: (strategy: Address | StrategyWithAddress, sharesAmount: Decimal, owner: TransactionSigner, sharesAtaBalance?: Decimal) => Promise<WithdrawShares>;
    /**
     * Get transaction instructions that create associated token accounts if they don't exist (token A, B and share)
     * @param owner wallet owner (shareholder)
     * @param strategyState kamino strategy state
     * @param tokenAData token A data of the owner's wallet
     * @param tokenAAta associated token account for token B
     * @param tokenBData token B data of the owner's wallet
     * @param tokenBAta associated token account for token B
     * @param sharesMintData shares data of the owner's wallet
     * @param sharesAta associated token account for shares
     * @returns list of transaction instructions (empty if all accounts already exist)
     */
    getCreateAssociatedTokenAccountInstructionsIfNotExist: (owner: TransactionSigner, strategyState: StrategyWithAddress, tokenAData: Account<Token> | null, tokenAAta: Address, tokenBData: Account<Token> | null, tokenBAta: Address, sharesMintData: Account<Token> | null, sharesAta: Address) => Promise<Instruction[]>;
    /**
     * Check if strategy has already been fetched (is StrategyWithAddress type) and return that,
     * otherwise fetch it first from Address and return it
     * @param strategy
     * @private
     */
    private getStrategyStateIfNotFetched;
    private getWhirlpoolStateIfNotFetched;
    private getMeteoraStateIfNotFetched;
    /**
     * Get treasury fee vault program addresses from for token A and B mints
     * @param tokenAMint
     * @param tokenBMint
     * @private
     */
    private getTreasuryFeeVaultPDAs;
    /**
     * Get a transaction instruction to withdraw all strategy shares from a specific wallet into token A and B
     * @param strategy public key of the strategy
     * @param owner public key of the owner (shareholder)
     * @returns transaction instruction or null if no shares or no sharesMint ATA present in the wallet
     */
    withdrawAllShares: (strategy: Address | StrategyWithAddress, owner: TransactionSigner) => Promise<WithdrawShares | null>;
    /**
     * Get all the accounts needed by the deposit tx, without the swap.
     * @param strategy Kamino strategy public key or on-chain object
     * @param owner Owner (wallet, shareholder) public key
     * @returns list of pubkeys needed for the deposit transaction
     */
    getAllDepositAccounts: (strategy: Address | StrategyWithAddress, owner: Address) => Promise<Address[]>;
    /**
     * Get transaction instruction to deposit token A and B into a strategy.
     * @param strategy Kamino strategy public key or on-chain object
     * @param amountA Amount of token A to deposit into strategy
     * @param amountB Amount of token B to deposit into strategy
     * @param owner Owner (wallet, shareholder) public key
     * @returns transaction instruction for depositing tokens into a strategy
     */
    deposit: (strategy: Address | StrategyWithAddress, amountA: Decimal, amountB: Decimal, owner: TransactionSigner) => Promise<Instruction>;
    singleSidedDepositTokenA: (strategy: Address | StrategyWithAddress, amountToDeposit: Decimal, owner: TransactionSigner, slippageBps: Decimal, profiler?: ProfiledFunctionExecution, swapIxsBuilder?: SwapperIxBuilder, initialUserTokenAtaBalances?: TokensBalances, priceAInB?: Decimal, includeAtaIxns?: boolean, // if true it includes create and close wsol and token atas,
    onlyDirectRoutes?: boolean) => Promise<InstructionsWithLookupTables>;
    singleSidedDepositTokenB: (strategy: Address | StrategyWithAddress, amountToDeposit: Decimal, owner: TransactionSigner, slippageBps: Decimal, profiler?: ProfiledFunctionExecution, swapIxsBuilder?: SwapperIxBuilder, initialUserTokenAtaBalances?: TokensBalances, priceAInB?: Decimal, includeAtaIxns?: boolean, // if true it includes create and close wsol and token atas,
    onlyDirectRoutes?: boolean) => Promise<InstructionsWithLookupTables>;
    getInitialUserTokenBalances: (owner: Address, tokenAMint: Address, tokenBMint: Address, initialUserTokenBalances?: MaybeTokensBalances) => Promise<TokensBalances>;
    private getSingleSidedDepositIxs;
    static retryAsync(fn: () => Promise<any>, retriesLeft?: number, interval?: number): Promise<any>;
    /**
     * Get transaction instruction to deposit SOL into topup vault.
     * @param owner Owner (wallet, shareholder) public key
     * @param amountLamports Amount of SOL to deposit into topup vault
     * @returns transaction instruction for adding SOL to topup vault
     */
    upkeepTopupVault: (owner: TransactionSigner, amountLamports: Decimal) => Promise<Instruction>;
    /**
     * Get the topup vault balance in SOL.
     * @param owner Owner (wallet, shareholder) public key
     * @returns SOL amount in topup vault
     */
    topupVaultBalance: (owner: Address) => Promise<Decimal>;
    /**
     * Get transaction instruction to withdraw SOL from the topup vault.
     * @param owner Owner (wallet, shareholder) public key
     * @param amount Amount of SOL to withdraw from the topup vault
     * @returns transaction instruction for removing SOL from the topup vault
     */
    withdrawTopupVault: (owner: TransactionSigner, amount: Decimal) => Promise<Instruction>;
    getJupSwapIxsWithMaxAccounts: (input: DepositAmountsForSwap, tokenAMint: Address, tokenBMint: Address, owner: Address, slippageBps: Decimal, useOnlyLegacyTransaction: boolean, existingAccounts: Address[], maxAccounts: number, profiler?: ProfiledFunctionExecution, onlyDirectRoutes?: boolean) => Promise<[Instruction[], Address[]]>;
    getJupSwapIxsV6: (input: DepositAmountsForSwap, tokenAMint: Address, tokenBMint: Address, owner: Address, slippageBps: Decimal, useOnlyLegacyTransaction: boolean, existingAccounts: Address[], profiledFunctionExecution?: ProfiledFunctionExecution, onlyDirectRoutes?: boolean) => Promise<[Instruction[], Address[]]>;
    getCheckExpectedVaultsBalancesIx: (strategy: StrategyWithAddress, user: TransactionSigner, tokenAAta: Address, tokenBAta: Address, expectedTokensBalances?: MaybeTokensBalances) => Promise<Instruction>;
    /**
     * Get transaction instruction to create a new Kamino strategy.
     * Current limitations:
     *   - strategy can only be created by the owner (admin) of the global config, we will need to allow non-admins to bypass this check
     *   - after the strategy is created, only the owner (admin) can update the treasury fee vault with token A/B, we need to allow non-admins to be able to do (and require) this as well
     * @param strategy public key of the new strategy to create
     * @param pool public key of the CLMM pool (either Orca or Raydium)
     * @param owner public key of the strategy owner (admin authority)
     * @param dex decentralized exchange specifier
     * @returns transaction instruction for Kamino strategy creation
     */
    createStrategy: (strategy: Address, pool: Address, owner: TransactionSigner, dex: Dex) => Promise<Instruction>;
    /**
     * Get transaction instruction to close Kamino strategy, including its position if there is any
     * and strategy token accounts.
     * @param strategy public key of the strategy
     * @param admin signer to close the strategy
     * @returns instruction to close the strategy
     */
    withdrawAllAndCloseStrategy: (admin: TransactionSigner, strategy: Address | StrategyWithAddress) => Promise<WithdrawAllAndCloseIxns | null>;
    /**
     * Get transaction instruction to close Kamino strategy, including its position if there is any
     * and strategy token accounts.
     * @param admin signer to close the strategy
     * @param strategy public key of the strategy
     * @returns instruction to close the strategy
     */
    closeStrategy: (admin: TransactionSigner, strategy: Address | StrategyWithAddress) => Promise<import("@solana/kit").IInstruction>;
    getUserTopupVault: (user: Address) => Promise<Address>;
    /**
     * Find program adresses required for kamino strategy creation
     * @param strategy
     * @param tokenMintA
     * @param tokenMintB
     * @private
     * @returns object with program addresses for kamino strategy creation
     */
    private getStrategyProgramAddresses;
    /**
     * Get transaction instruction to create a new rent exempt strategy account
     * @param payer transaction payer (signer) public key
     * @param newStrategy public key of the new strategy
     * @returns transaction instruction to create the account
     */
    createStrategyAccount: (payer: TransactionSigner, newStrategy: TransactionSigner) => Promise<Instruction>;
    createAccountRentExempt: (payer: TransactionSigner, newAccount: TransactionSigner, size: bigint) => Promise<Instruction>;
    /**
     * Get transaction instruction to collect strategy fees from the treasury fee
     * vaults and rewards from the reward vaults.
     * @param strategy strategy public key or already fetched object
     * @param owner signer of the tx
     * @returns transaction instruction to collect strategy fees and rewards
     */
    collectFeesAndRewards: (strategy: Address | StrategyWithAddress, owner: TransactionSigner) => Promise<Instruction>;
    /**
     * Get orca position metadata program addresses
     * @param positionMint mint account of the position
     */
    getMetadataProgramAddressesOrca: (positionMint: Address) => Promise<MetadataProgramAddressesOrca>;
    getMetadataProgramAddressesRaydium: (positionMint: Address, pool: Address, tickLowerIndex: number, tickUpperIndex: number) => Promise<MetadataProgramAddressesRaydium>;
    getStartEndTickIndexProgramAddressesOrca: (whirlpool: Address, whirlpoolState: Whirlpool, tickLowerIndex: number, tickUpperIndex: number) => Promise<LowerAndUpperTickPubkeys>;
    private getStartEndTicketIndexProgramAddressesRaydium;
    private readMeteoraPosition;
    private getStartEndTicketIndexProgramAddressesMeteora;
    /**
     * Get a transaction to open liquidity position for a Kamino strategy
     * @param admin strategy admin authority
     * @param strategy strategy you want to open liquidity position for
     * @param positionMint position mint keypair
     * @param priceLower new position's lower price of the range
     * @param priceUpper new position's upper price of the range
     * @param status strategy status
     */
    openPosition: (admin: TransactionSigner, strategy: Address | StrategyWithAddress, positionMint: TransactionSigner, priceLower: Decimal, priceUpper: Decimal, status?: StrategyStatusKind) => Promise<Instruction>;
    /**
     * Get a transaction to open liquidity position for a Kamino strategy
     * @param strategy strategy you want to open liquidity position for
     * @param positionMint new liquidity position account pubkey
     * @param priceLower new position's lower price of the range
     * @param priceUpper new position's upper price of the range
     * @param status strategy status
     */
    openPositionOrca: (adminAuthority: TransactionSigner, strategy: Address, baseVaultAuthority: Address, pool: Address, positionMint: TransactionSigner, priceLower: Decimal, priceUpper: Decimal, tokenAVault: Address, tokenBVault: Address, tokenAMint: Address, tokenBMint: Address, tokenATokenProgram: Address, tokenBTokenProgram: Address, oldPositionOrBaseVaultAuthority: Address, oldPositionMintOrBaseVaultAuthority: Address, oldPositionTokenAccountOrBaseVaultAuthority: Address, oldTickArrayLowerOrBaseVaultAuthority: Address, oldTickArrayUpperOrBaseVaultAuthority: Address, status?: StrategyStatusKind) => Promise<Instruction>;
    /**
     * Get a transaction to open liquidity position for a Kamino strategy
     * @param strategy strategy you want to open liquidity position for
     * @param positionMint new liquidity position account pubkey
     * @param priceLower new position's lower price of the range
     * @param priceUpper new position's upper price of the range
     * @param status strategy status
     */
    openPositionRaydium: (adminAuthority: TransactionSigner, strategy: Address, baseVaultAuthority: Address, pool: Address, positionMint: TransactionSigner, priceLower: Decimal, priceUpper: Decimal, tokenAVault: Address, tokenBVault: Address, tokenAMint: Address, tokenBMint: Address, tokenATokenProgram: Address, tokenBTokenProgram: Address, oldTickArrayLowerOrBaseVaultAuthority: Address, oldTickArrayUpperOrBaseVaultAuthority: Address, oldPositionOrBaseVaultAuthority: Address, oldPositionMintOrBaseVaultAuthority: Address, oldPositionTokenAccountOrBaseVaultAuthority: Address, oldProtocolPositionOrBaseVaultAuthority: Address, eventAuthority: Option<Address>, status?: StrategyStatusKind, strategyRewardOVault?: Address, strategyReward1Vault?: Address, strategyReward2Vault?: Address) => Promise<Instruction>;
    /**
     * Get a transaction to open liquidity position for a Kamino strategy
     * @param strategy strategy you want to open liquidity position for
     * @param positionMint new liquidity position account pubkey
     * @param priceLower new position's lower price of the range
     * @param priceUpper new position's upper price of the range
     * @param status strategy status
     */
    openPositionMeteora: (adminAuthority: TransactionSigner, strategy: Address, baseVaultAuthority: Address, pool: Address, position: TransactionSigner, priceLower: Decimal, priceUpper: Decimal, tokenAVault: Address, tokenBVault: Address, tokenAMint: Address, tokenBMint: Address, tokenATokenProgram: Address, tokenBTokenProgram: Address, oldPositionOrBaseVaultAuthority: Address, oldPositionMintOrBaseVaultAuthority: Address, oldPositionTokenAccountOrBaseVaultAuthority: Address, oldTickArrayLowerOrBaseVaultAuthority: Address, oldTickArrayUpperOrBaseVaultAuthority: Address, eventAuthority: Option<Address>, status?: StrategyStatusKind) => Promise<Instruction>;
    /**
     * Get a transaction for executive withdrawal from a Kamino strategy.
     * @param strategy strategy pubkey or object
     * @param action withdrawal action
     * @returns transaction for executive withdrawal
     */
    executiveWithdraw: (admin: TransactionSigner, strategy: Address | StrategyWithAddress, action: ExecutiveWithdrawActionKind) => Promise<Instruction>;
    /**
     * Get a an instruction to update the reference price type of a strategy
     * @param admin transaction signer
     * @param strategy strategy pubkey or object
     * @param referencePriceType new reference price type
     */
    getUpdateReferencePriceTypeIx: (admin: TransactionSigner, strategy: Address | StrategyWithAddress, referencePriceType: ReferencePriceTypeKind) => Promise<Instruction>;
    /**
     * Get a transaction to invest funds from the Kamino vaults and put them into the DEX pool as liquidity.
     * @param strategy strategy pubkey or object
     * @param payer transaction payer
     */
    invest: (strategy: Address | StrategyWithAddress, payer: TransactionSigner) => Promise<Instruction>;
    /**
     * Get a list of instructions to collect the pending fees and invest them into the Kamino strategy's position.
     * @param strategy strategy pubkey or object
     * @param payer transaction payer
     */
    compound: (strategy: Address | StrategyWithAddress, payer: TransactionSigner) => Promise<Instruction[]>;
    /**
     * Get a the pending fees in lamports of a strategy.
     * @param strategy strategy pubkey or object
     */
    getPendingFees: (strategies: Address[]) => Promise<StrategyWithPendingFees[]>;
    getUpdateRebalancingParamsFromRebalanceFieldsIx: (strategyAdmin: TransactionSigner, strategy: Address | StrategyWithAddress, rebalanceFieldInfos: RebalanceFieldInfo[]) => Promise<Instruction>;
    processRebalanceParams: (dex: Dex, pool: Address | WhirlpoolWithAddress, rebalanceType: Decimal, rebalanceParams: Decimal[]) => Promise<Decimal[]>;
    getUpdateRebalancingParamsIxns: (strategyAdmin: TransactionSigner, strategy: Address | StrategyWithAddress, rebalanceParams: Decimal[], rebalanceType?: RebalanceTypeKind, tokenADecimals?: number, tokenBDecimals?: number) => Promise<Instruction>;
    getUpdateRebalancingParamsForUninitializedStratIx: (strategyAdmin: TransactionSigner, strategy: Address, rebalanceParams: Decimal[], rebalanceType: RebalanceTypeKind, tokenADecimals: number, tokenBDecimals: number) => Promise<Instruction>;
    buildStrategyRebalanceParams: (strategy: Address | StrategyWithAddress) => Promise<number[]>;
    /**
     * Get a list of instructions to initialize and set up a strategy
     * @param dex the dex to use (Orca or Raydium)
     * @param feeTierBps which fee tier for that specific pair should be used (in BPS)
     * @param tokenAMint the mint of TokenA in the pool
     * @param tokenBMint the mint of TokenB in the pool
     * @param depositCap the maximum amount in USD in lamports (6 decimals) that can be deposited into the strategy
     * @param depositCapPerIx the maximum amount in USD in lamports (6 decimals) that can be deposited into the strategy per instruction
     */
    getBuildStrategyIxns: (dex: Dex, feeTierBps: Decimal, strategy: Address, positionMint: TransactionSigner, strategyAdmin: TransactionSigner, rebalanceType: Decimal, rebalanceParams: Decimal[], tokenAMint: Address, tokenBMint: Address, depositCap?: Decimal, depositCapPerIx?: Decimal, withdrawFeeBps?: Decimal, depositFeeBps?: Decimal, performanceFeeBps?: Decimal) => Promise<InitStrategyIxs>;
    getNewPositionRange(strategy: Address | StrategyWithAddress, rebalanceKind: RebalanceTypeKind, rebalanceParams: Decimal[]): Promise<PositionRange>;
    private getRebalancePositionRange;
    getCurrentPrice(strategy: Address | StrategyWithAddress): Promise<Decimal>;
    getCurrentPriceFromPool(dex: Dex, pool: Address, tokenADecimals?: number, tokenBDecimals?: number): Promise<Decimal>;
    getPoolTickSpacing(dex: Dex, pool: Address): Promise<number>;
    getPriceRangePercentageBasedFromPool(dex: Dex, pool: Address, lowerPriceBpsDifference: Decimal, upperPriceBpsDifference: Decimal): Promise<[Decimal, Decimal]>;
    /**
     * Get the raw rebalancing params given the strategy type
     */
    readRebalancingParamsFromChain(strategy: Address | StrategyWithAddress): Promise<RebalanceFieldInfo[]>;
    /**
     * Get the raw rebalancing params given the strategy type
     */
    readRebalancingStateFromChain(strategy: Address | StrategyWithAddress): Promise<RebalanceFieldInfo[]>;
    /**
     * Get the current withdrawal caps for a strategy
     */
    getStrategyCurrentWithdrawalCaps(strategy: Address | StrategyWithAddress): Promise<TokenAmounts>;
    /**
     * Get the max USD value that can be deposited per ix for a strategy
     */
    getStrategyDepositCapInUSDPerIx(strategy: Address | StrategyWithAddress): Promise<Decimal>;
    getStrategyMaxDepositInUSD(strategy: Address | StrategyWithAddress): Promise<Decimal>;
    /**
     * Get the prices for rebalancing params (range and reset range, if strategy involves a reset range)
     */
    readRebalancingParams(strategy: Address | StrategyWithAddress): Promise<RebalanceFieldInfo[]>;
    /**
     * Get the rebalancing params from chain, alongside the current details of the position, reset range, etc
     */
    readRebalancingParamsWithState(strategy: Address | StrategyWithAddress): Promise<RebalanceFieldInfo[]>;
    /**
     * Get a list of updated rebalance field infos.
     * @param initialRebalanceFieldInfos the initial list of rebalance field infos
     * @param updatedFields the fields to be updated, with label and value
     * @returns list of RebalanceFieldInfo with updated values
     */
    getUpdatedRebalanceFieldInfos(initialRebalanceFieldInfos: RebalanceFieldInfo[], updatedFields: InputRebalanceFieldInfo[]): RebalanceFieldInfo[];
    getPriceRangePercentageBasedFromPrice(price: Decimal, lowerPriceBpsDifference: Decimal, upperPriceBpsDifference: Decimal): [Decimal, Decimal];
    /**
     * Read the pool price for a specific dex and pool
     */
    getPoolPrice(dex: Dex, pool: Address, tokenADecimals: number, tokenBDecimals: number): Promise<Decimal>;
    getOrcaPoolPrice(pool: Address, tokenADecimals?: number, tokenBDecimals?: number): Promise<Decimal>;
    getRaydiumPoolPrice(pool: Address): Promise<Decimal>;
    getMeteoraPoolPrice(pool: Address): Promise<Decimal>;
    getGenericPoolInfo(dex: Dex, pool: Address): Promise<GenericPoolInfo>;
    mintIsSupported: (collateralInfos: CollateralInfo[], tokenMint: Address) => boolean;
    getCollateralInfoFromMint: (mint: Address, collateralInfos: CollateralInfo[]) => CollateralInfo | undefined;
    getCollateralIdFromMint: (mint: Address, collateralInfos: CollateralInfo[]) => number;
    getMainLookupTablePks: () => Promise<Address[]>;
    getMainLookupTable: () => Promise<Account<AddressLookupTable>[] | undefined>;
    getInitLookupTableIx: (authority: TransactionSigner, slot?: Slot) => Promise<[Instruction, Address]>;
    getPopulateLookupTableIxs: (authority: TransactionSigner, lookupTable: Address, strategy: Address | StrategyWithAddress) => Promise<Instruction[]>;
    getAddLookupTableEntriesIxs: (authority: TransactionSigner, lookupTable: Address, entries: Address[]) => Instruction[];
    getLookupTable: (tablePk: Address) => Promise<Account<AddressLookupTable>>;
    setupStrategyLookupTable: (authority: TransactionSigner, strategy: Address | StrategyWithAddress, slot?: Slot) => Promise<{
        lookupTable: Address;
        createLookupTableIx: Instruction;
        populateLookupTableIxs: Instruction[];
        updateStrategyLookupTableIx: Instruction;
    }>;
    getEstimatedApyAndVolumeOnRangeOrca: () => Promise<GenericPositionRangeInfo>;
    getEstimatedApyAndVolumeOnRangeRaydium: () => Promise<GenericPositionRangeInfo>;
    getEstimatedApyAndVolumeOnRangeMeteora: () => Promise<GenericPositionRangeInfo>;
    getManualPoolSimulatedValues: (params: {
        pool: Address;
        priceLower: Decimal;
        priceUpper: Decimal;
        startDate: string;
        endDate: string;
    }) => Promise<PoolSimulationResponse>;
    getPercentagePoolSimulatedValues: (params: SimulationPercentagePoolParameters) => Promise<PoolSimulationResponse>;
    /**
     * Get a list of transactions to rebalance a Kamino strategy.
     * @param admin pool admin
     * @param strategy strategy pubkey or object
     * @param newPosition new liquidity position account pubkey
     * @param priceLower new position's lower price of the range
     * @param priceUpper new position's upper price of the range
     * @returns list of transactions to rebalance (executive withdraw, collect fees/rewards, open new position, invest)
     */
    rebalance: (admin: TransactionSigner, strategy: Address | StrategyWithAddress, newPosition: TransactionSigner, priceLower: Decimal, priceUpper: Decimal) => Promise<Instruction[]>;
    /**
     * Get a list of user's Kamino strategy positions
     * @param wallet user wallet address
     * @param strategyFilters
     * @returns list of kamino strategy positions
     */
    getUserPositions: (wallet: Address, strategyFilters?: StrategiesFilters) => Promise<KaminoPosition[]>;
    /**
     * Get a list of user's Kamino strategy positions
     * @param wallet user wallet address
     * @param strategiesWithShareMintsMap
     * @param strategiesWithAddressMap
     * @returns list of kamino strategy positions
     */
    getUserPositionsByStrategiesMap: (wallet: Address, strategiesWithShareMintsMap: Map<Address, KaminoStrategyWithShareMint>, strategiesWithAddressMap?: Map<Address, WhirlpoolStrategy>) => Promise<KaminoPosition[]>;
    /**
     * Get Kamino strategy vault APY/APR
     * @param strategy strategy pubkey or onchain state
     * @param orcaPools not required, but you can add orca whirlpools if you're caching them, and we don't refetch every time
     * @param raydiumPools not required, but you can add raydium pools if you're caching them, and we don't refetch every time
     */
    getStrategyAprApy: (strategy: Address | StrategyWithAddress, orcaPools?: WhirlpoolAPIResponse[], raydiumPools?: Pool[]) => Promise<WhirlpoolAprApy>;
    getStrategyPerformanceFees: (strategy: Address | StrategyWithAddress, globalConfig?: GlobalConfig) => Promise<PerformanceFees>;
    getLiquidityDistributionRaydiumPool: (pool: Address, keepOrder?: boolean, lowestTick?: number, highestTick?: number) => Promise<LiquidityDistribution>;
    getLiquidityDistributionMeteoraPool: (pool: Address, keepOrder?: boolean, lowestTick?: number, highestTick?: number) => Promise<LiquidityDistribution>;
    getLiquidityDistributionOrcaWhirlpool: (pool: Address, keepOrder?: boolean, lowestTick?: number, highestTick?: number) => Promise<LiquidityDistribution>;
    getLiquidityDistribution: (dex: Dex, pool: Address, keepOrder?: boolean, lowestTick?: number, highestTick?: number) => Promise<LiquidityDistribution>;
    getPositionsCountForPool: (dex: Dex, pool: Address) => Promise<number>;
    getStrategyTokensHoldings: (strategy: Address | StrategyWithAddress, mode?: "DEPOSIT" | "WITHDRAW") => Promise<TokenAmounts>;
    /**
     * Get ratio of total_a_in_strategy/total_b_in_strategy; if the total_b_in_strategy is 0 throws;
     * @param strategy
     * @param amountA
     */
    getStrategyTokensRatio: (strategy: Address | StrategyWithAddress) => Promise<Decimal>;
    calculateAmountsToBeDepositedWithSwap: (strategy: Address | StrategyWithAddress, tokenAAmountUserDeposit: Decimal, tokenBAmountUserDeposit: Decimal, profiler?: ProfiledFunctionExecution, priceAInB?: Decimal) => Promise<DepositAmountsForSwap>;
    /**
     * @deprecated The method should not be used
     */
    calculateAmountsDistributionWithPriceRange: (dex: Dex, pool: Address, lowerPrice: Decimal, upperPrice: Decimal) => Promise<[Decimal, Decimal]>;
    calculateAmountsToBeDeposited: (strategy: Address | StrategyWithAddress, tokenAAmount?: Decimal, tokenBAmount?: Decimal, profiledFunctionExecution?: ProfiledFunctionExecution) => Promise<[Decimal, Decimal]>;
    calculateAmountsRatioToBeDeposited: (strategy: Address | StrategyWithAddress, holdings?: TokenAmounts, profiler?: ProfiledFunctionExecution) => Promise<[Decimal, Decimal]>;
    calculateDepositAmountsProportional: (strategy: Address | StrategyWithAddress, tokenAAmount?: Decimal, tokenBAmount?: Decimal, profiler?: ProfiledFunctionExecution) => Promise<[Decimal, Decimal]>;
    private calculateDepositAmountsProportionalWithTotalTokens;
    calculateDepostAmountsDollarBased: (strategy: Address | StrategyWithAddress, tokenAAmount?: Decimal, tokenBAmount?: Decimal) => Promise<[Decimal, Decimal]>;
    calculateAmountsOrca: ({ whirlpoolState, positionAddress, tokenAAmount, tokenBAmount, }: {
        whirlpoolState: Whirlpool;
        positionAddress: Address;
        tokenAAmount?: Decimal;
        tokenBAmount?: Decimal;
    }) => Promise<[Decimal, Decimal]>;
    calculateAmountsRaydium: ({ strategyState, tokenAAmount, tokenBAmount, }: {
        strategyState: WhirlpoolStrategy;
        tokenAAmount?: Decimal;
        tokenBAmount?: Decimal;
    }) => Promise<[Decimal, Decimal]>;
    calculateAmountsMeteora: ({ strategyState, tokenAAmount, tokenBAmount, }: {
        strategyState: WhirlpoolStrategy;
        tokenAAmount?: Decimal;
        tokenBAmount?: Decimal;
    }) => Promise<[Decimal, Decimal]>;
    /**
     * @deprecated The method should not be used
     */
    getDepositRatioFromTokenA: (strategy: Address | StrategyWithAddress, amountA: BN) => Promise<{
        amountSlippageA: BN;
        amountSlippageB: BN;
    }>;
    /**
     * @deprecated The method should not be used
     */
    getDepositRatioFromTokenB: (strategy: Address | StrategyWithAddress, amountB: BN) => Promise<{
        amountSlippageA: BN;
        amountSlippageB: BN;
    }>;
    /**
     * Get the on-chain state of the terms&conditions signature for the owner
     * @param owner
     */
    getUserTermsSignatureState(owner: Address): Promise<TermsSignature | null>;
    /**
     * Get the instruction to store the on chain owner signature of terms&conditions
     * @param owner
     * @param signature
     */
    getUserTermsSignatureIx(owner: TransactionSigner, signature: Uint8Array): Promise<Instruction>;
    private getDepositRatioFromAOrca;
    private getDepositRatioFromAMeteora;
    private getDepositRatioFromBMeteora;
    private getDepositRatioFromBOrca;
    private getDepositRatioFromARaydium;
    private getDepositRatioFromBRaydium;
    getCollateralInfo: (address: Address) => Promise<CollateralInfo[]>;
    getGlobalConfigState: (address: Address) => Promise<GlobalConfig | null>;
    getWhirlpoolStrategy: (address: Address) => Promise<WhirlpoolStrategy | null>;
    getWhirlpoolStrategies: (addresses: Address[]) => Promise<Array<WhirlpoolStrategy | null>>;
    getStrategyVaultBalances: (strategy: Address | StrategyWithAddress) => Promise<{
        aVault: Decimal;
        bVault: Decimal;
    }>;
    getUpdateStrategyParamsIxs: (strategyAdmin: TransactionSigner, strategy: Address, rebalanceType: Decimal, withdrawFeeBps?: Decimal, performanceFeeBps?: Decimal) => Promise<Instruction[]>;
    getUpdateRewardsIxs: (strategyOwner: TransactionSigner, strategy: Address | StrategyWithAddress) => Promise<[Instruction, TransactionSigner][]>;
    /**
     * Get the instruction to create an Orca Whirlpool tick, if it does not exist
     * @param payer
     * @param pool
     * @param price
     * @return tickPubkey, (tickInstruction | undefined)
     */
    initializeTickForOrcaPool: (payer: TransactionSigner, pool: Address | WhirlpoolWithAddress, price: Decimal) => Promise<InitPoolTickIfNeeded>;
    initializeTickForMeteoraPool: (payer: TransactionSigner, pool: Address | LbPairWithAddress, price: Decimal) => Promise<InitPoolTickIfNeeded>;
    getDexProgramId(strategyState: WhirlpoolStrategy): Address;
}
export default Kamino;
//# sourceMappingURL=Kamino.d.ts.map
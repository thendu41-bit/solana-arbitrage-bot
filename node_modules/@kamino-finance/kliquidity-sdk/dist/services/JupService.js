"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JupService = exports.DEFAULT_JUP_SWAP_API = exports.DEFAULT_JUP_API_ENDPOINT = void 0;
exports.transformResponseIx = transformResponseIx;
exports.getAccountRole = getAccountRole;
const kit_1 = require("@solana/kit");
const axios_1 = __importDefault(require("axios"));
const decimal_js_1 = __importDefault(require("decimal.js"));
const api_1 = require("@jup-ag/api");
const USDC_MINT = (0, kit_1.address)('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v');
exports.DEFAULT_JUP_API_ENDPOINT = 'https://lite-api.jup.ag';
exports.DEFAULT_JUP_SWAP_API = 'https://lite-api.jup.ag/swap/v1';
const jupiterSwapApi = (0, api_1.createJupiterApiClient)({ basePath: exports.DEFAULT_JUP_SWAP_API });
class JupService {
    // the amounts has to be in lamports
    static getBestRouteV6 = async (userAddress, amount, inputMint, outputMint, slippageBps, asLegacyTransaction, maxAccounts, onlyDirectRoutes) => {
        try {
            // https://lite-api.jup.ag/swap/v1/quote?inputMint=7dHbWXmci3dT8UFYWYZweBLXgycu7Y3iL6trKn1Y7ARj&outputMint=mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So&amount=71101983&slippageBps=10&onlyDirectRoutes=false&asLegacyTransaction=false&maxAccounts=33
            const res = await this.getBestRouteQuoteV6(amount, inputMint, outputMint, slippageBps, asLegacyTransaction, maxAccounts, onlyDirectRoutes);
            const ixsResponse = await jupiterSwapApi.swapInstructionsPost({
                swapRequest: { quoteResponse: res, userPublicKey: userAddress, wrapAndUnwrapSol: false },
            });
            const swapIxs = {
                tokenLedgerInstruction: ixsResponse.tokenLedgerInstruction
                    ? transformResponseIx(ixsResponse.tokenLedgerInstruction)
                    : undefined,
                computeBudgetInstructions: ixsResponse.computeBudgetInstructions.map((ix) => transformResponseIx(ix)),
                setupInstructions: ixsResponse.setupInstructions.map((ix) => transformResponseIx(ix)),
                swapInstruction: transformResponseIx(ixsResponse.swapInstruction),
                cleanupInstruction: ixsResponse.cleanupInstruction
                    ? transformResponseIx(ixsResponse.cleanupInstruction)
                    : undefined,
                addressLookupTableAddresses: ixsResponse.addressLookupTableAddresses.map((a) => (0, kit_1.address)(a)),
            };
            return swapIxs;
        }
        catch (error) {
            console.log('getBestRouteV6 error', error);
            throw error;
        }
    };
    static getBestRouteQuoteV6 = async (amount, inputMint, outputMint, slippageBps, asLegacyTransaction, maxAccounts, onlyDirectRoutes, jupEndpoint) => {
        try {
            const params = {
                inputMint,
                outputMint,
                amount: amount.floor().toNumber(),
                slippageBps,
                onlyDirectRoutes: onlyDirectRoutes,
                asLegacyTransaction,
                maxAccounts,
            };
            const baseURL = jupEndpoint || exports.DEFAULT_JUP_API_ENDPOINT;
            const res = await axios_1.default.get(`${baseURL}/swap/v1/quote`, { params });
            return res.data;
        }
        catch (error) {
            console.log('getBestRouteQuoteV6 error', error);
            throw error;
        }
    };
    static getSwapIxsFromQuote = async (userAddress, quote, wrapUnwrapSOL = true, asLegacyTransaction) => {
        try {
            return await jupiterSwapApi.swapInstructionsPost({
                swapRequest: {
                    quoteResponse: quote,
                    userPublicKey: userAddress,
                    wrapAndUnwrapSol: wrapUnwrapSOL,
                    asLegacyTransaction: asLegacyTransaction,
                },
            });
        }
        catch (error) {
            console.log('getSwapTxFromQuote error', error);
            throw error;
        }
    };
    static getPrice = async (inputMint, outputMint, jupEndpoint) => {
        const params = { ids: inputMint.toString(), vsToken: outputMint.toString(), vsAmount: 1 };
        // BONK token
        if (outputMint.toString() === 'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263') {
            params.vsAmount = 100;
        }
        const baseURL = jupEndpoint || exports.DEFAULT_JUP_API_ENDPOINT;
        const res = await axios_1.default.get(`${baseURL}/price/v3`, { params });
        return res.data[inputMint.toString()].usdPrice;
    };
    static getPrices = async (inputMints, outputMint, jupEndpoint) => {
        const mintsCommaSeparated = inputMints.map((mint) => mint.toString()).join(',');
        const params = { ids: mintsCommaSeparated, vsToken: outputMint.toString(), vsAmount: 1 };
        // BONK token
        if (outputMint.toString() === 'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263') {
            params.vsAmount = 100;
        }
        const baseURL = jupEndpoint || exports.DEFAULT_JUP_API_ENDPOINT;
        const prices = new Map();
        try {
            const res = await axios_1.default.get(`${baseURL}/price/v3`, { params });
            for (const mint of inputMints) {
                try {
                    prices.set((0, kit_1.address)(mint), new decimal_js_1.default(res.data[mint.toString()].usdPrice));
                }
                catch (e) {
                    prices.set((0, kit_1.address)(mint), new decimal_js_1.default(0));
                }
            }
        }
        catch (e) {
            // ignore
        }
        return prices;
    };
    static getDollarPrices(inputMints, jupEndpoint) {
        return this.getPrices(inputMints, USDC_MINT, jupEndpoint);
    }
    static getDollarPrice = async (inputMint, jupEndpoint) => {
        return this.getPrice(inputMint, USDC_MINT, jupEndpoint);
    };
}
exports.JupService = JupService;
function transformResponseIx(ix) {
    return {
        data: ix.data ? Buffer.from(ix.data, 'base64') : undefined,
        programAddress: (0, kit_1.address)(ix.programId),
        accounts: ix.accounts.map((k) => ({
            address: (0, kit_1.address)(k.pubkey),
            role: getAccountRole({ isSigner: k.isSigner, isMut: k.isWritable }),
        })),
    };
}
function getAccountRole({ isSigner, isMut }) {
    if (isSigner && isMut) {
        return kit_1.AccountRole.WRITABLE_SIGNER;
    }
    if (isSigner && !isMut) {
        return kit_1.AccountRole.READONLY_SIGNER;
    }
    if (!isSigner && isMut) {
        return kit_1.AccountRole.WRITABLE;
    }
    return kit_1.AccountRole.READONLY;
}
//# sourceMappingURL=JupService.js.map
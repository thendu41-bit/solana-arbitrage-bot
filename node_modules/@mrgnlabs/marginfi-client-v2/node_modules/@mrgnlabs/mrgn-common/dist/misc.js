"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadKeypair = loadKeypair;
exports.getValueInsensitive = getValueInsensitive;
exports.sleep = sleep;
exports.chunks = chunks;
exports.setTimeoutPromise = setTimeoutPromise;
exports.chunkedGetRawMultipleAccountInfos = chunkedGetRawMultipleAccountInfos;
exports.chunkedGetRawMultipleAccountInfoOrderedWithNulls = chunkedGetRawMultipleAccountInfoOrderedWithNulls;
exports.chunkedGetRawMultipleAccountInfoOrdered = chunkedGetRawMultipleAccountInfoOrdered;
const web3_js_1 = require("@solana/web3.js");
/**
 * Load Keypair from the provided file.
 */
function loadKeypair(keypairPath) {
    const path = require("path");
    if (!keypairPath || keypairPath == "") {
        throw new Error("Keypair is required!");
    }
    if (keypairPath[0] === "~") {
        keypairPath = path.join(require("os").homedir(), keypairPath.slice(1));
    }
    const keyPath = path.normalize(keypairPath);
    return web3_js_1.Keypair.fromSecretKey(new Uint8Array(JSON.parse(require("fs").readFileSync(keyPath).toString())));
}
function getValueInsensitive(map, key) {
    const lowerCaseLabel = key.toLowerCase();
    for (let key in map) {
        if (key.toLowerCase() === lowerCaseLabel) {
            return map[key];
        }
    }
    throw new Error(`Token metadata not found for ${key}`);
}
/**
 * @internal
 */
function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
function chunks(array, size) {
    return Array.apply(0, new Array(Math.ceil(array.length / size))).map((_, index) => array.slice(index * size, (index + 1) * size));
}
function setTimeoutPromise(duration, message) {
    return new Promise((_, reject) => setTimeout(() => reject(new Error(message)), duration));
}
async function chunkedGetRawMultipleAccountInfos(connection, pks, batchChunkSize = 1000, maxAccountsChunkSize = 100) {
    const accountInfoMap = new Map();
    let contextSlot = 0;
    const batches = chunkArray(pks, batchChunkSize);
    for (let i = 0; i < batches.length; i++) {
        const batch = batches[i];
        const batchRequest = chunkArray(batch, maxAccountsChunkSize).map((pubkeys) => ({
            methodName: "getMultipleAccounts",
            args: connection._buildArgs([pubkeys], "confirmed", "base64"),
        }));
        let accountInfos = [];
        let retries = 0;
        const maxRetries = 3;
        while (retries < maxRetries && accountInfos.length === 0) {
            try {
                accountInfos = await connection
                    // @ts-ignore
                    ._rpcBatchRequest(batchRequest)
                    .then((batchResults) => {
                    contextSlot = Math.max(...batchResults.map((res) => res.result.context.slot));
                    const accounts = batchResults.reduce((acc, res) => {
                        acc.push(...res.result.value);
                        return acc;
                    }, []);
                    return accounts;
                });
            }
            catch (error) {
                retries++;
            }
        }
        if (accountInfos.length === 0) {
            throw new Error(`Failed to fetch account infos after ${maxRetries} retries`);
        }
        accountInfos.forEach((item, index) => {
            const publicKey = batch[index];
            if (item) {
                accountInfoMap.set(publicKey, {
                    ...item,
                    owner: new web3_js_1.PublicKey(item.owner),
                    data: Buffer.from(item.data[0], "base64"),
                });
            }
        });
    }
    return [contextSlot, accountInfoMap];
}
async function chunkedGetRawMultipleAccountInfoOrderedWithNulls(connection, pks, batchChunkSize = 1000, maxAccountsChunkSize = 100) {
    const allAccountInfos = [];
    const batches = chunkArray(pks, batchChunkSize);
    for (let i = 0; i < batches.length; i++) {
        const batch = batches[i];
        const batchRequest = chunkArray(batch, maxAccountsChunkSize).map((pubkeys) => ({
            methodName: "getMultipleAccounts",
            args: connection._buildArgs([pubkeys], "confirmed", "base64"),
        }));
        let accountInfos = [];
        let retries = 0;
        const maxRetries = 3;
        while (retries < maxRetries && accountInfos.length === 0) {
            try {
                accountInfos = await connection
                    // @ts-ignore
                    ._rpcBatchRequest(batchRequest)
                    .then((batchResults) => {
                    const accounts = batchResults.reduce((acc, res) => {
                        acc.push(...res.result.value);
                        return acc;
                    }, []);
                    return accounts;
                });
            }
            catch (error) {
                retries++;
            }
        }
        if (accountInfos.length === 0) {
            throw new Error(`Failed to fetch account infos after ${maxRetries} retries`);
        }
        accountInfos.forEach((item) => {
            if (item) {
                allAccountInfos.push({
                    ...item,
                    owner: new web3_js_1.PublicKey(item.owner),
                    data: Buffer.from(item.data[0], "base64"),
                });
            }
            else {
                allAccountInfos.push(null);
            }
        });
    }
    return allAccountInfos;
}
async function chunkedGetRawMultipleAccountInfoOrdered(connection, pks, batchChunkSize = 1000, maxAccountsChunkSize = 100) {
    const allAccountInfos = [];
    const batches = chunkArray(pks, batchChunkSize);
    for (let i = 0; i < batches.length; i++) {
        const batch = batches[i];
        const batchRequest = chunkArray(batch, maxAccountsChunkSize).map((pubkeys) => ({
            methodName: "getMultipleAccounts",
            args: connection._buildArgs([pubkeys], "confirmed", "base64"),
        }));
        let accountInfos = [];
        let retries = 0;
        const maxRetries = 3;
        while (retries < maxRetries && accountInfos.length === 0) {
            try {
                accountInfos = await connection
                    // @ts-ignore
                    ._rpcBatchRequest(batchRequest)
                    .then((batchResults) => {
                    const accounts = batchResults.reduce((acc, res) => {
                        acc.push(...res.result.value);
                        return acc;
                    }, []);
                    return accounts;
                });
            }
            catch (error) {
                retries++;
            }
        }
        if (accountInfos.length === 0) {
            throw new Error(`Failed to fetch account infos after ${maxRetries} retries`);
        }
        accountInfos.forEach((item) => {
            if (item) {
                allAccountInfos.push({
                    ...item,
                    owner: new web3_js_1.PublicKey(item.owner),
                    data: Buffer.from(item.data[0], "base64"),
                });
            }
        });
    }
    return allAccountInfos;
}
function chunkArray(array, chunkSize) {
    const chunks = [];
    for (let i = 0; i < array.length; i += chunkSize) {
        chunks.push(array.slice(i, i + chunkSize));
    }
    return chunks;
}

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NATIVE_MINT = exports.TOKEN_PROGRAM_ID = exports.ON_DEMAND_DEVNET_QUEUE_PDA = exports.ON_DEMAND_DEVNET_QUEUE = exports.ON_DEMAND_DEVNET_GUARDIAN_QUEUE = exports.ON_DEMAND_DEVNET_PID = exports.ON_DEMAND_MAINNET_QUEUE_PDA = exports.ON_DEMAND_MAINNET_QUEUE = exports.ON_DEMAND_MAINNET_GUARDIAN_QUEUE = exports.ON_DEMAND_MAINNET_PID = exports.loadLookupTables = void 0;
exports.createLoadLookupTables = createLoadLookupTables;
exports.isMainnetConnection = isMainnetConnection;
exports.isDevnetConnection = isDevnetConnection;
exports.getProgramId = getProgramId;
exports.getDefaultDevnetQueue = getDefaultDevnetQueue;
exports.getDefaultDevnetGuardianQueue = getDefaultDevnetGuardianQueue;
exports.getDefaultQueueAddress = getDefaultQueueAddress;
exports.getDefaultQueue = getDefaultQueue;
exports.getDefaultGuardianQueue = getDefaultGuardianQueue;
exports.getQueue = getQueue;
exports.fetchAllLutKeys = fetchAllLutKeys;
exports.storeFeed = storeFeed;
exports.getAssociatedTokenAddress = getAssociatedTokenAddress;
exports.getAssociatedTokenAddressSync = getAssociatedTokenAddressSync;
exports.getNodePayer = getNodePayer;
const oracle_js_1 = require("../accounts/oracle.js");
const queue_js_1 = require("../accounts/queue.js");
const AnchorUtils_js_1 = require("../anchor-utils/AnchorUtils.js");
const constants_js_1 = require("../constants.js");
const anchor_31_1 = require("@coral-xyz/anchor-31");
const common_1 = require("@switchboard-xyz/common");
const buffer_1 = require("buffer");
function createLoadLookupTables() {
    const promiseMap = new Map();
    function loadLookupTables(accounts) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const account of accounts) {
                const pubkey = account.pubkey.toString();
                if (pubkey && account.loadLookupTable) {
                    if (!promiseMap.has(pubkey)) {
                        promiseMap.set(pubkey, account.loadLookupTable());
                    }
                }
            }
            const out = [];
            for (const account of accounts) {
                const promise = promiseMap.get(account.pubkey.toString());
                if (promise)
                    out.push(promise);
            }
            return Promise.all(out).then(arr => {
                return arr.filter(x => Boolean(x));
            });
        });
    }
    return loadLookupTables;
}
exports.loadLookupTables = createLoadLookupTables();
/**
 * Mainnet program and queue addresses
 *
 * These are the official Switchboard On-Demand addresses for mainnet.
 * Most applications should use the default queue rather than deploying
 * their own.
 */
/** Switchboard On-Demand program ID on mainnet */
exports.ON_DEMAND_MAINNET_PID = new anchor_31_1.web3.PublicKey('SBondMDrcV3K4kxZR1HNVT7osZxAHVHgYXL5Ze1oMUv');
/** Guardian queue for mainnet (internal use) */
exports.ON_DEMAND_MAINNET_GUARDIAN_QUEUE = new anchor_31_1.web3.PublicKey('B7WgdyAgzK7yGoxfsBaNnY6d41bTybTzEh4ZuQosnvLK');
/** Default oracle queue on mainnet - use this for production */
exports.ON_DEMAND_MAINNET_QUEUE = new anchor_31_1.web3.PublicKey('A43DyUGA7s8eXPxqEjJY6EBu1KKbNgfxF8h17VAHn13w');
/** Queue PDA (Program Derived Address) for mainnet */
exports.ON_DEMAND_MAINNET_QUEUE_PDA = anchor_31_1.web3.PublicKey.findProgramAddressSync([buffer_1.Buffer.from('Queue'), exports.ON_DEMAND_MAINNET_QUEUE.toBuffer()], exports.ON_DEMAND_MAINNET_PID)[0];
/**
 * Devnet program and queue addresses
 *
 * These are the official Switchboard On-Demand addresses for devnet.
 * Use these for development and testing.
 */
/** Switchboard On-Demand program ID on devnet */
exports.ON_DEMAND_DEVNET_PID = new anchor_31_1.web3.PublicKey('Aio4gaXjXzJNVLtzwtNVmSqGKpANtXhybbkhtAC94ji2');
/** Guardian queue for devnet (internal use) */
exports.ON_DEMAND_DEVNET_GUARDIAN_QUEUE = new anchor_31_1.web3.PublicKey('BeZ4tU4HNe2fGQGUzJmNS2UU2TcZdMUUgnCH6RPg4Dpi');
/** Default oracle queue on devnet - use this for testing */
exports.ON_DEMAND_DEVNET_QUEUE = new anchor_31_1.web3.PublicKey('EYiAmGSdsQTuCw413V5BzaruWuCCSDgTPtBGvLkXHbe7');
/** Queue PDA for devnet (note: uses mainnet PID for compatibility) */
exports.ON_DEMAND_DEVNET_QUEUE_PDA = anchor_31_1.web3.PublicKey.findProgramAddressSync([buffer_1.Buffer.from('Queue'), exports.ON_DEMAND_DEVNET_QUEUE.toBuffer()], exports.ON_DEMAND_MAINNET_PID // SVM Devnet networks should be launched with SBond... as PID
)[0];
/**
 * Check if the connection is to the mainnet
 * @param connection - Connection: The connection
 * @returns - Promise<boolean> - Whether the connection is to the mainnet
 */
function isMainnetConnection(connection) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const genesisHash = yield connection.getGenesisHash();
            return genesisHash === '5eykt4UsFv8P8NJdTREpY1vzqKqZKvdpKuc147dw2N9d';
        }
        catch (_a) {
            return false;
        }
    });
}
/**
 * Check if the connection is to the devnet
 * @param connection - Connection: The connection
 * @returns - Promise<boolean> - Whether the connection is to the devnet
 */
function isDevnetConnection(connection) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const genesisHash = yield connection.getGenesisHash();
            return genesisHash === 'EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG';
        }
        catch (_a) {
            return false;
        }
    });
}
/**
 * Get the program ID for the Switchboard program based on the connection
 * @param connection - Connection: The connection
 * @returns - Promise<PublicKey> - The program ID
 */
function getProgramId(connection) {
    return __awaiter(this, void 0, void 0, function* () {
        const isDevnet = connection.rpcEndpoint.includes('devnet');
        return isDevnet ? exports.ON_DEMAND_DEVNET_PID : exports.ON_DEMAND_MAINNET_PID;
    });
}
/**
 * Get the default devnet queue for the Switchboard program
 * @param solanaRPCUrl - (optional) string: The Solana RPC URL
 * @returns - Promise<Queue> - The default devnet queue
 */
function getDefaultDevnetQueue() {
    return __awaiter(this, arguments, void 0, function* (solanaRPCUrl = 'https://api.devnet.solana.com') {
        return getQueue({
            solanaRPCUrl,
            queueAddress: exports.ON_DEMAND_DEVNET_QUEUE.toString(),
        });
    });
}
/**
 * Get the default devnet guardian queue for the Switchboard program
 * @param solanaRPCUrl - (optional) string: The Solana RPC URL
 * @returns - Promise<Queue> - The default devnet guardian queue
 */
function getDefaultDevnetGuardianQueue() {
    return __awaiter(this, arguments, void 0, function* (solanaRPCUrl = 'https://api.devnet.solana.com') {
        return getQueue({
            solanaRPCUrl,
            queueAddress: exports.ON_DEMAND_DEVNET_GUARDIAN_QUEUE.toString(),
        });
    });
}
/**
 * Get the default queue address for the Switchboard program on Solana.
 *
 * @param isMainnet - boolean: Whether the connection is to the mainnet
 * @returns - web3.PublicKey: The default queue address
 */
function getDefaultQueueAddress(isMainnet) {
    return isMainnet ? exports.ON_DEMAND_MAINNET_QUEUE : exports.ON_DEMAND_DEVNET_QUEUE;
}
/**
 * Gets the default Switchboard queue for the specified network
 *
 * Automatically detects whether you're on mainnet or devnet and returns
 * the appropriate default queue. This is the recommended way to get started
 * with Switchboard On-Demand.
 *
 * @param {string} solanaRPCUrl - Solana RPC endpoint URL (defaults to mainnet)
 * @returns {Promise<Queue>} The default queue instance
 *
 * @example
 * ```typescript
 * // Get default queue for current network
 * const queue = await getDefaultQueue();
 *
 * // Specify custom RPC
 * const queue = await getDefaultQueue('https://api.devnet.solana.com');
 * ```
 */
function getDefaultQueue() {
    return __awaiter(this, arguments, void 0, function* (solanaRPCUrl = anchor_31_1.web3.clusterApiUrl('mainnet-beta')) {
        const connection = new anchor_31_1.web3.Connection(solanaRPCUrl, 'confirmed');
        const isMainnet = yield isMainnetConnection(connection);
        const queueAddress = getDefaultQueueAddress(isMainnet);
        return getQueue({ solanaRPCUrl, queueAddress });
    });
}
/**
 * Get the default guardian queue for the Switchboard program
 * @param solanaRPCUrl - (optional) string: The Solana RPC URL
 * @returns - Promise<Queue> - The default guardian queue
 * @NOTE - SWITCHBOARD PID AND GUARDIAN QUEUE PUBKEY ARE WRONG
 */
function getDefaultGuardianQueue() {
    return __awaiter(this, arguments, void 0, function* (solanaRPCUrl = anchor_31_1.web3.clusterApiUrl('mainnet-beta')) {
        return getQueue({
            solanaRPCUrl,
            queueAddress: exports.ON_DEMAND_MAINNET_GUARDIAN_QUEUE.toString(),
        });
    });
}
/**
 * Get the queue for the Switchboard program
 * @param solanaRPCUrl - string: The Solana RPC URL
 * @param switchboardProgramId - string: The Switchboard program ID
 * @param queueAddress - string: The queue address
 * @returns - Promise<Queue> - The queue
 */
function getQueue(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const queue = new anchor_31_1.web3.PublicKey(params.queueAddress);
        const program = 'program' in params
            ? params.program
            : yield AnchorUtils_js_1.AnchorUtils.loadProgramFromConnection(new anchor_31_1.web3.Connection(params.solanaRPCUrl, 'confirmed'));
        return new queue_js_1.Queue(program, queue);
    });
}
/**
 * Get the unique LUT keys for the queue, all oracles in the queue, and all feeds
 * provided
 * @param queue - Queue: The queue
 * @param feeds - PullFeed[]: The feeds
 * @returns - Promise<PublicKey[]>: The unique LUT keys
 */
function fetchAllLutKeys(queue, feeds) {
    return __awaiter(this, void 0, void 0, function* () {
        const oracles = yield queue.fetchOracleKeys();
        const lutOwners = [];
        lutOwners.push(queue);
        feeds.forEach(feed => lutOwners.push(feed));
        oracles.forEach(oracle => lutOwners.push(new oracle_js_1.Oracle(queue.program, oracle)));
        const lutPromises = lutOwners.map(lutOwner => lutOwner.loadLookupTable());
        const luts = yield Promise.all(lutPromises);
        const keyset = new Set();
        luts.forEach(lut => lut.state.addresses.forEach(keyset.add));
        return Array.from(keyset).map(key => new anchor_31_1.web3.PublicKey(key));
    });
}
/**
 * @param queue Queue pubkey as base58 string
 * @param jobs Array of jobs to store (Oracle Jobs Object)
 * @param crossbarUrl
 * @returns
 */
function storeFeed(queue_1, jobs_1) {
    return __awaiter(this, arguments, void 0, function* (queue, jobs, crossbarUrl = common_1.CrossbarClient.default().crossbarUrl) {
        const crossbar = crossbarUrl.endsWith('/')
            ? crossbarUrl.slice(0, -1)
            : crossbarUrl;
        const x = new common_1.CrossbarClient(crossbar);
        return yield x.store(queue, jobs);
    });
}
function getAssociatedTokenAddress(mint_1, owner_1) {
    return __awaiter(this, arguments, void 0, function* (mint, owner, allowOwnerOffCurve = false, programId = constants_js_1.SPL_TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID) {
        if (!allowOwnerOffCurve && !anchor_31_1.web3.PublicKey.isOnCurve(owner.toBuffer())) {
            throw new Error('TokenOwnerOffCurveError');
        }
        const [address] = yield anchor_31_1.web3.PublicKey.findProgramAddress([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);
        return address;
    });
}
function getAssociatedTokenAddressSync(mint, owner, allowOwnerOffCurve = false, programId = constants_js_1.SPL_TOKEN_PROGRAM_ID, associatedTokenProgramId = constants_js_1.SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID) {
    if (!allowOwnerOffCurve && !anchor_31_1.web3.PublicKey.isOnCurve(owner.toBuffer())) {
        throw new Error('TokenOwnerOffCurveError');
    }
    const [address] = anchor_31_1.web3.PublicKey.findProgramAddressSync([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);
    return address;
}
function getNodePayer(program) {
    return program.provider.wallet.payer; // eslint-disable-line @typescript-eslint/no-explicit-any
}
// Re-export SPL Token constants
var constants_js_2 = require("../constants.js");
Object.defineProperty(exports, "TOKEN_PROGRAM_ID", { enumerable: true, get: function () { return constants_js_2.SPL_TOKEN_PROGRAM_ID; } });
var constants_js_3 = require("../constants.js");
Object.defineProperty(exports, "NATIVE_MINT", { enumerable: true, get: function () { return constants_js_3.SOL_NATIVE_MINT; } });
//# sourceMappingURL=index.js.map
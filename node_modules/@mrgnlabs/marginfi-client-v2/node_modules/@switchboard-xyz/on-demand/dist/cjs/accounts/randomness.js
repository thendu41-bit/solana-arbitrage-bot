"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Randomness = void 0;
const constants_js_1 = require("../constants.js");
const InstructionUtils_js_1 = require("../instruction-utils/InstructionUtils.js");
const gateway_js_1 = require("../oracle-interfaces/gateway.js");
const spl = __importStar(require("../utils/index.js"));
const lookupTable_js_1 = require("../utils/lookupTable.js");
const oracle_js_1 = require("./oracle.js");
const queue_js_1 = require("./queue.js");
const state_js_1 = require("./state.js");
const anchor_31_1 = require("@coral-xyz/anchor-31");
const bs58_1 = __importDefault(require("bs58"));
const buffer_1 = require("buffer");
function isNonSolana(queue) {
    return (queue.equals(spl.ON_DEMAND_MAINNET_QUEUE_PDA) ||
        queue.equals(spl.ON_DEMAND_DEVNET_QUEUE_PDA));
}
/**
 * Switchboard commit-reveal randomness.
 * This account type controls commit-reveal style randomness employing
 * Intel SGX enclaves as a randomness security mechanism.
 * For this flow, a user must commit to a future slot that would be unknown
 * to all parties at the time of commitment. The user must then reveal the
 * randomness by then sending the future slot hash to the oracle which can
 * then be signed by the secret key secured within the Trusted Execution Environment.
 *
 * In this manner, the only way for one to predict the randomness is to:
 * 1. Have access to the randomness oracle
 * 2. have control of the solana network slot leader at the time of commit
 * 3. Have an unpatched Intel SGX vulnerability/advisory that the Switchboard
 *   protocol failed to auto-prune.
 */
class Randomness {
    static getPayer(program, payer) {
        var _a;
        return (_a = payer !== null && payer !== void 0 ? payer : program.provider.publicKey) !== null && _a !== void 0 ? _a : anchor_31_1.web3.PublicKey.default;
    }
    /**
     * Constructs a `Randomness` instance.
     *
     * @param {Program} program - The Anchor program instance.
     * @param {web3.PublicKey} pubkey - The public key of the randomness account.
     */
    constructor(program, pubkey) {
        this.program = program;
        this.pubkey = pubkey;
    }
    /**
     * Loads the randomness data for this {@linkcode Randomness} account from on chain.
     *
     * @returns {Promise<any>} A promise that resolves to the randomness data.
     * @throws Will throw an error if the randomness account does not exist.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    loadData() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.program.account['randomnessAccountData'].fetch(this.pubkey);
        });
    }
    /**
     * Creates a new `Randomness` account.
     *
     * @param {Program} program - The Anchor program instance.
     * @param {web3.Keypair} kp - The keypair of the new `Randomness` account.
     * @param {web3.PublicKey} queue - The queue account to associate with the new `Randomness` account.
     * @param {web3.PublicKey} [payer_] - The payer for the transaction. If not provided, the default payer from the program provider is used.
     * @returns {Promise<[Randomness, web3.TransactionInstruction]>} A promise that resolves to a tuple containing the new `Randomness` account and the transaction instruction.
     */
    static create(program, kp, queue, payer_) {
        return __awaiter(this, void 0, void 0, function* () {
            const payer = Randomness.getPayer(program, payer_);
            const lutSigner = (0, lookupTable_js_1.getLutSigner)(program.programId, kp.publicKey);
            const recentSlot = yield program.provider.connection.getSlot('finalized');
            const lutKey = (0, lookupTable_js_1.getLutKey)(lutSigner, recentSlot);
            const ix = program.instruction.randomnessInit({
                recentSlot: new anchor_31_1.BN(recentSlot.toString()),
            }, {
                accounts: {
                    randomness: kp.publicKey,
                    queue,
                    authority: payer,
                    payer: payer,
                    rewardEscrow: spl.getAssociatedTokenAddressSync(constants_js_1.SOL_NATIVE_MINT, kp.publicKey),
                    systemProgram: anchor_31_1.web3.SystemProgram.programId,
                    tokenProgram: constants_js_1.SPL_TOKEN_PROGRAM_ID,
                    associatedTokenProgram: constants_js_1.SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,
                    wrappedSolMint: constants_js_1.SOL_NATIVE_MINT,
                    programState: state_js_1.State.keyFromSeed(program),
                    lutSigner: lutSigner,
                    lut: lutKey,
                    addressLookupTableProgram: anchor_31_1.web3.AddressLookupTableProgram.programId,
                },
            });
            return [new Randomness(program, kp.publicKey), ix];
        });
    }
    /**
     * Generate a randomness `commit` solana transaction instruction.
     * This will commit the randomness account to use currentSlot + 1 slothash
     * as the non-repeating randomness seed.
     *
     * @param {PublicKey} queue - The queue public key for the commit instruction.
     * @param {PublicKey} [authority_] - The optional authority public key.
     * @returns {Promise<TransactionInstruction>} A promise that resolves to the transaction instruction.
     */
    commitIx(queue, authority_, oracle_) {
        return __awaiter(this, void 0, void 0, function* () {
            const queueAccount = new queue_js_1.Queue(this.program, queue);
            let oracle;
            // If we're on a non-Solana SVM network - we'll need the oracle address as a PDA on the target chain
            if (oracle_) {
                oracle = oracle_;
            }
            else if (isNonSolana(queue)) {
                const isMainnet = queue.equals(spl.ON_DEMAND_MAINNET_QUEUE_PDA);
                const solanaQueue = yield spl.getQueue({
                    program: this.program,
                    queueAddress: spl.getDefaultQueueAddress(isMainnet),
                });
                const solanaOracle = yield solanaQueue.fetchFreshOracle();
                [oracle] = anchor_31_1.web3.PublicKey.findProgramAddressSync([buffer_1.Buffer.from('Oracle'), queue.toBuffer(), solanaOracle.toBuffer()], spl.ON_DEMAND_MAINNET_PID);
            }
            else {
                oracle = yield queueAccount.fetchFreshOracle();
            }
            const authority = authority_ !== null && authority_ !== void 0 ? authority_ : (yield this.loadData()).authority;
            const ix = this.program.instruction.randomnessCommit({}, {
                accounts: {
                    randomness: this.pubkey,
                    queue,
                    oracle,
                    recentSlothashes: constants_js_1.SPL_SYSVAR_SLOT_HASHES_ID,
                    authority,
                },
            });
            return ix;
        });
    }
    /**
     * Generate a randomness `reveal` solana transaction instruction.
     * This will reveal the randomness using the assigned oracle.
     *
     * @returns {Promise<web3.TransactionInstruction>} A promise that resolves to the transaction instruction.
     */
    revealIx(payer_) {
        return __awaiter(this, void 0, void 0, function* () {
            const payer = Randomness.getPayer(this.program, payer_);
            const data = yield this.loadData();
            let oracleData;
            // if non-Solana SVM network - we'll need to get the solana oracle address from the oracle PDA
            if (isNonSolana(data.queue)) {
                const solanaOracle = yield new oracle_js_1.Oracle(this.program, data.oracle).findSolanaOracleFromPDA();
                oracleData = solanaOracle.oracleData;
            }
            else {
                const oracle = new oracle_js_1.Oracle(this.program, data.oracle);
                oracleData = yield oracle.loadData();
            }
            const gatewayUrl = String.fromCharCode(...oracleData.gatewayUri).replace(/\0+$/, '');
            const gateway = new gateway_js_1.Gateway(this.program, gatewayUrl);
            const gatewayRevealResponse = yield gateway.fetchRandomnessReveal({
                randomnessAccount: this.pubkey,
                slothash: bs58_1.default.encode(data.seedSlothash),
                slot: data.seedSlot.toNumber(),
                rpc: this.program.provider.connection.rpcEndpoint,
            });
            const stats = anchor_31_1.web3.PublicKey.findProgramAddressSync([buffer_1.Buffer.from('OracleRandomnessStats'), data.oracle.toBuffer()], this.program.programId)[0];
            const ix = this.program.instruction.randomnessReveal({
                signature: buffer_1.Buffer.from(gatewayRevealResponse.signature, 'base64'),
                recoveryId: gatewayRevealResponse.recovery_id,
                value: gatewayRevealResponse.value,
            }, {
                accounts: {
                    randomness: this.pubkey,
                    oracle: data.oracle,
                    queue: data.queue,
                    stats,
                    authority: data.authority,
                    payer,
                    recentSlothashes: constants_js_1.SPL_SYSVAR_SLOT_HASHES_ID,
                    systemProgram: anchor_31_1.web3.SystemProgram.programId,
                    rewardEscrow: spl.getAssociatedTokenAddressSync(constants_js_1.SOL_NATIVE_MINT, this.pubkey),
                    tokenProgram: constants_js_1.SPL_TOKEN_PROGRAM_ID,
                    associatedTokenProgram: constants_js_1.SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,
                    wrappedSolMint: constants_js_1.SOL_NATIVE_MINT,
                    programState: state_js_1.State.keyFromSeed(this.program),
                },
            });
            return ix;
        });
    }
    /**
     * Commit and reveal randomness in a single transaction.
     *
     * @param {TransactionInstruction[]} callback - The callback to execute after the reveal in the same transaction.
     * @param {Keypair[]} signers - The signers to sign the transaction.
     * @param {PublicKey} queue - The queue public key.
     * @param {object} [configs] - The configuration options.
     * @param {number} [configs.computeUnitPrice] - The price per compute unit in microlamports.
     * @param {number} [configs.computeUnitLimit] - The compute unit limit.
     * @returns {Promise<void>} A promise that resolves when the transaction is confirmed.
     */
    commitAndReveal(callback, signers, queue, configs, debug) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            // In this function (because its 2 back to back transactions) we need to use the payer from the
            // provider as the authority for the commit transaction.
            const authority = spl.getNodePayer(this.program);
            const computeUnitPrice = (_a = configs === null || configs === void 0 ? void 0 : configs.computeUnitPrice) !== null && _a !== void 0 ? _a : 50000;
            const computeUnitLimit = (_b = configs === null || configs === void 0 ? void 0 : configs.computeUnitLimit) !== null && _b !== void 0 ? _b : 200000;
            const connection = this.program.provider.connection;
            for (;;) {
                const data = yield this.loadData();
                if (data.seedSlot.toNumber() !== 0) {
                    if (debug) {
                        console.log('Randomness slot already committed. Jumping to reveal.');
                    }
                    break;
                }
                const tx = yield InstructionUtils_js_1.InstructionUtils.asV0TxWithComputeIxs({
                    connection,
                    ixs: [
                        anchor_31_1.web3.ComputeBudgetProgram.setComputeUnitPrice({
                            microLamports: computeUnitPrice,
                        }),
                        yield this.commitIx(queue, data.authority),
                    ],
                });
                tx.sign([authority]);
                const sim = yield connection.simulateTransaction(tx, {
                    commitment: 'processed',
                });
                if (sim.value.err !== null) {
                    if (debug) {
                        console.log('Logs', sim.value.logs);
                    }
                    throw new Error(`Failed to simulate commit transaction: ${JSON.stringify(sim.value.err)}`);
                }
                const sig = yield connection.sendTransaction(tx, {
                    maxRetries: 2,
                    skipPreflight: true,
                });
                if (debug) {
                    console.log(`Commit transaction sent: ${sig}`);
                }
                try {
                    yield connection.confirmTransaction(sig);
                    if (debug) {
                        console.log(`Commit transaction confirmed: ${sig}`);
                    }
                    break;
                }
                catch (_c) {
                    if (debug) {
                        console.log('Failed to confirm commit transaction. Retrying...');
                    }
                    yield new Promise(f => setTimeout(f, 1000));
                    continue;
                }
            }
            yield new Promise(f => setTimeout(f, 1000));
            for (;;) {
                const data = yield this.loadData();
                if (data.revealSlot.toNumber() !== 0) {
                    break;
                }
                let revealIx = undefined;
                try {
                    revealIx = yield this.revealIx(authority.publicKey);
                }
                catch (e) {
                    if (debug) {
                        console.log(e);
                        console.log('Failed to grab reveal signature. Retrying...');
                    }
                    yield new Promise(f => setTimeout(f, 1000));
                    continue;
                }
                const tx = yield InstructionUtils_js_1.InstructionUtils.asV0TxWithComputeIxs({
                    connection: this.program.provider.connection,
                    ixs: [
                        anchor_31_1.web3.ComputeBudgetProgram.setComputeUnitPrice({
                            microLamports: computeUnitPrice,
                        }),
                        anchor_31_1.web3.ComputeBudgetProgram.setComputeUnitLimit({
                            units: computeUnitLimit,
                        }),
                        revealIx,
                        ...callback,
                    ],
                });
                tx.sign([authority, ...signers]);
                const sim = yield connection.simulateTransaction(tx, {
                    commitment: 'processed',
                });
                if (sim.value.err !== null) {
                    if (debug) {
                        console.log('Logs', sim.value.logs);
                    }
                    throw new Error(`Failed to simulate commit transaction: ${JSON.stringify(sim.value.err)}`);
                }
                const sig = yield connection.sendTransaction(tx, {
                    maxRetries: 2,
                    skipPreflight: true,
                });
                if (debug) {
                    console.log(`RevealAndCallback transaction sent: ${sig}`);
                }
                yield connection.confirmTransaction(sig);
                if (debug) {
                    console.log(`RevealAndCallback transaction confirmed: ${sig}`);
                }
            }
        });
    }
    /**
     * Creates a new `Randomness` account and prepares a commit transaction instruction.
     *
     * @param {Program} program - The Anchor program instance.
     * @param {web3.PublicKey} queue - The queue account to associate with the new `Randomness` account.
     * @returns {Promise<[Randomness, web3.Keypair, web3.TransactionInstruction[]]>} A promise that resolves to a tuple containing the new `Randomness` instance, the keypair, and an array of transaction instructions.
     */
    static createAndCommitIxs(program, queue, payer_) {
        return __awaiter(this, void 0, void 0, function* () {
            const payer = Randomness.getPayer(program, payer_);
            const accountKeypair = anchor_31_1.web3.Keypair.generate();
            const [account, creationIx] = yield Randomness.create(
            /* program= */ program, 
            /* kp= */ accountKeypair, 
            /* queue= */ queue, 
            /* payer= */ payer);
            const commitIx = yield account.commitIx(
            /* queue= */ queue, 
            /* authority= */ payer);
            // TODO: Why do we return the account keypair? The authority is already set to the payer right?
            return [account, accountKeypair, [creationIx, commitIx]];
        });
    }
    /**
     * Generate a randomness `close` solana transaction instruction.
     * This will close the randomness account and return the rent to the authority.
     *
     * @returns {Promise<web3.TransactionInstruction>} A promise that resolves to the transaction instruction.
     */
    closeIx() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.loadData();
            const lutSigner = (0, lookupTable_js_1.getLutSigner)(this.program.programId, this.pubkey);
            const lutKey = (0, lookupTable_js_1.getLutKey)(lutSigner, data.lutSlot);
            const ix = this.program.instruction.randomnessClose({}, {
                accounts: {
                    randomness: this.pubkey,
                    rewardEscrow: spl.getAssociatedTokenAddressSync(constants_js_1.SOL_NATIVE_MINT, this.pubkey),
                    authority: data.authority,
                    programState: state_js_1.State.keyFromSeed(this.program),
                    systemProgram: anchor_31_1.web3.SystemProgram.programId,
                    tokenProgram: constants_js_1.SPL_TOKEN_PROGRAM_ID,
                    wrappedSolMint: constants_js_1.SOL_NATIVE_MINT,
                    lut: lutKey,
                    lutSigner: lutSigner,
                    addressLookupTableProgram: anchor_31_1.web3.AddressLookupTableProgram.programId,
                },
            });
            return ix;
        });
    }
}
exports.Randomness = Randomness;
//# sourceMappingURL=randomness.js.map
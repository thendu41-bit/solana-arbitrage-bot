import { Amount, InstructionsWrapper, TransactionBroadcastType, TransactionOptions, ExtendedTransaction, ExtendedV0Transaction } from "@mrgnlabs/mrgn-common";
import { Address } from "@coral-xyz/anchor";
import { Commitment, PublicKey, Transaction, TransactionInstruction, Signer, AddressLookupTableAccount, VersionedTransaction, TransactionSignature } from "@solana/web3.js";
import BigNumber from "bignumber.js";
import { LoopTxProps, MakeBorrowIxOpts, MakeDepositIxOpts, MakeRepayIxOpts, MakeWithdrawIxOpts, MarginfiClient, MarginfiGroup, MarginfiIdlType, ProcessTransactionsClientOpts, RepayWithCollateralProps, FlashloanActionResult, LoopProps, TransactionBuilderResult, MarginfiAccountRaw, EmodeTag, EmodePair, ActionEmodeImpact } from "../..";
import { MarginfiAccount, MarginRequirementType } from "./pure";
import { Bank } from "../bank";
import { Balance } from "../balance";
export declare const MAX_TX_SIZE = 1232;
export declare const MAX_ACCOUNT_KEYS = 64;
export declare const BUNDLE_TX_SIZE = 81;
export declare const PRIORITY_TX_SIZE = 44;
export interface SimulationResult {
    banks: Map<string, Bank>;
    marginfiAccount: MarginfiAccountWrapper;
}
export interface FlashLoanArgs {
    ixs: TransactionInstruction[];
    signers?: Signer[];
    addressLookupTableAccounts?: AddressLookupTableAccount[];
    blockhash?: string;
}
declare class MarginfiAccountWrapper {
    readonly client: MarginfiClient;
    readonly address: PublicKey;
    private _marginfiAccount;
    /**
     * @internal
     */
    constructor(marginfiAccountPk: PublicKey, client: MarginfiClient, marginfiAccount: MarginfiAccount);
    static fetch(marginfiAccountPk: Address, client: MarginfiClient, commitment?: Commitment): Promise<MarginfiAccountWrapper>;
    static fromAccountParsed(marginfiAccountPk: Address, client: MarginfiClient, accountData: MarginfiAccountRaw): MarginfiAccountWrapper;
    static fromAccountDataRaw(marginfiAccountPk: PublicKey, client: MarginfiClient, marginfiAccountRawData: Buffer, idl: MarginfiIdlType): MarginfiAccountWrapper;
    get authority(): PublicKey;
    get group(): MarginfiGroup;
    get balances(): Balance[];
    get data(): MarginfiAccount;
    get pureAccount(): MarginfiAccount;
    /** @internal */
    private get _program();
    /** @internal */
    private get _config();
    get activeBalances(): Balance[];
    get isDisabled(): boolean;
    get isFlashLoanEnabled(): boolean;
    get isTransferAccountAuthorityEnabled(): boolean;
    getBalance(bankPk: PublicKey): Balance;
    simulateHealthCache(): Promise<MarginfiAccountWrapper>;
    canBeLiquidated(): boolean;
    computeHealthComponents(marginRequirement: MarginRequirementType): {
        assets: BigNumber;
        liabilities: BigNumber;
    };
    computeHealthComponentsLegacy(marginRequirement: MarginRequirementType): {
        assets: BigNumber;
        liabilities: BigNumber;
    };
    computeHealthComponentsWithoutBiasLegacy(marginRequirement: MarginRequirementType): {
        assets: BigNumber;
        liabilities: BigNumber;
    };
    computeFreeCollateral(opts?: {
        clamped?: boolean;
    }): BigNumber;
    computeAccountValue(): BigNumber;
    computeActiveEmodePairs(emodePairs: EmodePair[]): EmodePair[];
    computeEmodeImpacts(emodePairs: EmodePair[]): Record<string, ActionEmodeImpact>;
    computeMaxBorrowForBank(bankAddress: PublicKey, opts?: {
        volatilityFactor?: number;
        emodeWeights?: {
            assetWeightMaint: BigNumber;
            assetWeightInit: BigNumber;
            collateralTag: EmodeTag;
        };
    }): BigNumber;
    computeMaxWithdrawForBank(bankAddress: PublicKey, opts?: {
        volatilityFactor?: number;
    }): BigNumber;
    computeMaxLiquidatableAssetAmount(assetBankAddress: PublicKey, liabilityBankAddress: PublicKey): BigNumber;
    computeLiquidationPriceForBank(bankAddress: PublicKey): number | null;
    computeLiquidationPriceForBankAmount(bankAddress: PublicKey, isLending: boolean, amount: number): number | null;
    computeNetApy(): number;
    /** Todo move this into client */
    computeLoopingParams(principal: Amount, targetLeverage: number, depositBankAddress: PublicKey, borrowBankAddress: PublicKey, opts?: {
        assetWeightInit?: BigNumber;
        liabilityWeightInit?: BigNumber;
    }): {
        borrowAmount: BigNumber;
        totalDepositAmount: BigNumber;
    };
    makeComputeBudgetIx(): TransactionInstruction[];
    makeSetupIx(banks: PublicKey[]): Promise<TransactionInstruction[]>;
    /**
     * Moves a position from one marginfi account to another by withdrawing from source account and depositing to destination account.
     *
     * @param amount - The amount of tokens to move, can be a number or Amount object
     * @param bankAddress - The public key of the bank to move position from/to
     * @param destinationAccount - The marginfi account to move the position to
     * @param processOpts - Optional transaction processing configuration
     * @param txOpts - Optional transaction options
     * @returns Array of transaction signatures - includes signatures for any required oracle feed updates, withdraw transaction, and deposit transaction
     */
    movePosition(amount: Amount, bankAddress: PublicKey, destinationAccountPk: PublicKey, processOpts?: ProcessTransactionsClientOpts, txOpts?: TransactionOptions): Promise<TransactionSignature[]>;
    /**
     * Creates transactions for moving a position from one marginfi account to another.
     *
     * @param amount - The amount of tokens to move, can be a number or Amount object
     * @param bankAddress - The public key of the bank to move position from/to
     * @param destinationAccount - The marginfi account to move the position to
     * @returns Object containing feed crank transactions, withdraw transaction, and deposit transaction
     */
    makeMovePositionTx(amount: Amount, bankAddress: PublicKey, destinationAccountPk: PublicKey): Promise<TransactionBuilderResult>;
    /**
     * Repays a loan using collateral from another bank by:
     * 1. Withdrawing collateral from one bank
     * 2. Swapping it to the repayment asset
     * 3. Repaying the loan in another bank
     *
     * @param {RepayWithCollateralProps} props - Parameters for the repay with collateral transaction
     * @param {Amount} props.repayAmount - Amount to repay
     * @param {Amount} props.withdrawAmount - Amount of collateral to withdraw
     * @param {PublicKey} props.borrowBankAddress - Bank address where the loan is being repaid
     * @param {PublicKey} props.depositBankAddress - Bank address where collateral is being withdrawn from
     * @param {boolean} [props.withdrawAll=false] - Whether to withdraw all collateral from deposit bank
     * @param {boolean} [props.repayAll=false] - Whether to repay entire loan amount
     * @param {Object} props.swap - Swap configuration with instructions and lookup tables
     * @param {ProcessTransactionsClientOpts} [props.processOpts] - Optional transaction processing configuration
     * @param {TransactionOptions} [props.txOpts] - Optional transaction options
     * @returns {Promise<TransactionSignature[]>} Array of transaction signatures
     */
    repayWithCollatV2(props: RepayWithCollateralProps): Promise<TransactionSignature[]>;
    /**
     * Creates a transaction to repay a loan using collateral by:
     * 1. Withdrawing collateral from one bank
     * 2. Swapping it to the repayment asset
     * 3. Repaying the loan in another bank
     *
     * @param {RepayWithCollateralProps} params - Parameters for the repay with collateral transaction
     * @param {Amount} params.repayAmount - Amount to repay
     * @param {Amount} params.withdrawAmount - Amount of collateral to withdraw
     * @param {PublicKey} params.borrowBankAddress - Bank address where the loan is being repaid
     * @param {PublicKey} params.depositBankAddress - Bank address where collateral is being withdrawn from
     * @param {boolean} [params.withdrawAll=false] - Whether to withdraw all collateral from deposit bank
     * @param {boolean} [params.repayAll=false] - Whether to repay entire loan amount
     * @param {Object} params.swap - Swap configuration with instructions and lookup tables
     * @param {string} [params.blockhash] - Optional recent blockhash
     * @param {MakeWithdrawIxOpts} [params.withdrawOpts] - Optional withdraw configuration
     * @param {MakeRepayIxOpts} [params.repayOpts] - Optional repay configuration
     * @returns {Promise<RepayWithCollateralResult>} Result containing feed crank and flashloan transactions
     */
    makeRepayWithCollatTxV2({ repayAmount, withdrawAmount, borrowBankAddress, depositBankAddress, withdrawAll, repayAll, swap, blockhash: blockhashArg, }: RepayWithCollateralProps): Promise<FlashloanActionResult>;
    loopV2(props: LoopProps): Promise<TransactionSignature[]>;
    makeLoopTxV2({ depositAmount, inputDepositAmount, borrowAmount, depositBankAddress, borrowBankAddress, swap, blockhash: blockhashArg, setupBankAddresses, overrideInferAccounts, }: LoopTxProps): Promise<FlashloanActionResult>;
    /**
     * Creates instructions for closing a marginfi account.
     * The account must have no active positions or balances to be closed.
     * Closing an account will return any remaining SOL to the fee payer.
     *
     * @returns An InstructionsWrapper containing the close account instruction
     */
    makeCloseAccountIx(): Promise<InstructionsWrapper>;
    /**
     * Closes a marginfi account. The account must have no active positions or balances to be closed.
     * Closing an account will return any remaining SOL to the fee payer.
     *
     * @param processOpts - Optional transaction processing configuration
     * @param txOpts - Optional transaction options
     * @returns The transaction signature of the close account operation
     */
    closeAccount(processOpts?: ProcessTransactionsClientOpts, txOpts?: TransactionOptions): Promise<TransactionSignature>;
    /**
     * Creates a transaction for closing a marginfi account.
     * The account must have no active positions or balances to be closed.
     *
     * @returns A transaction configured to close the marginfi account
     */
    makeCloseAccountTx(): Promise<ExtendedTransaction>;
    /**
     * Creates instructions for depositing tokens into a marginfi bank account.
     *
     * @param amount - The amount of tokens to deposit, can be a number or Amount object
     * @param bankAddress - The public key of the bank to deposit into
     * @param depositOpts - Optional deposit configuration parameters
     * @returns An InstructionsWrapper containing the deposit instructions
     */
    makeDepositIx(amount: Amount, bankAddress: PublicKey, depositOpts?: MakeDepositIxOpts): Promise<InstructionsWrapper>;
    /**
     * Creates a transaction for depositing native stake into a marginfi staked asset bank account.
     * - Split stake account if required
     * - Authorize stake account to single spl pool pogram
     * - Deposit stake into pool for LST
     * - Deposit LST into marginfi bank
     *
     * @param amount - The amount of tokens to deposit, can be a number or Amount object
     * @param bankAddress - The public key of the bank to deposit into
     * @param stakeAccountPk - The public key of the stake account to delegate
     * @param validator - The public key of the validator to delegate to
     * @param depositOpts - Optional deposit configuration parameters
     * @returns A transaction object ready to be signed and sent
     */
    makeDepositStakedTx(amount: Amount, bankAddress: PublicKey, stakeAccountPk: PublicKey, validator: PublicKey, depositOpts?: MakeDepositIxOpts): Promise<ExtendedTransaction>;
    makeMergeStakeAccountsTx(stakeAccountSrc: PublicKey, stakeAccountDest: PublicKey): Promise<ExtendedTransaction>;
    /**
     * Deposits tokens into a marginfi bank account.
     *
     * @param amount - The amount of tokens to deposit, can be a number or Amount object
     * @param bankAddress - The public key of the bank to deposit into
     * @param depositOpts - Optional deposit configuration parameters
     * @param processOpts - Optional transaction processing configuration
     * @param txOpts - Optional transaction options
     * @returns The transaction signature of the deposit
     */
    deposit(amount: Amount, bankAddress: PublicKey, depositOpts?: MakeDepositIxOpts, processOpts?: ProcessTransactionsClientOpts, txOpts?: TransactionOptions): Promise<TransactionSignature>;
    /**
     * Creates a transaction for depositing tokens into a marginfi bank account.
     *
     * @param amount - The amount of tokens to deposit, can be a number or Amount object
     * @param bankAddress - The public key of the bank to deposit into
     * @param depositOpts - Optional deposit configuration parameters
     * @returns A transaction object ready to be signed and sent
     */
    makeDepositTx(amount: Amount, bankAddress: PublicKey, depositOpts?: MakeDepositIxOpts): Promise<ExtendedTransaction>;
    /**
     * Simulates a mrgnlend transaction to preview its effects.
     *
     * @param txs - Array of transactions to simulate, can be either VersionedTransaction or Transaction
     * @param bankAddress - The public key of the bank to inspect
     * @param additionalAccountsToInspect - Optional array of additional account public keys to inspect during simulation
     * @returns A SimulationResult containing the preview state of both the marginfi account and bank
     * @throws Will throw an error if simulation fails
     */
    simulateBorrowLendTransaction(txs: (VersionedTransaction | Transaction)[], banksToInspect: PublicKey[], healthSimOptions?: {
        enabled: boolean;
        mandatoryBanks: PublicKey[];
        excludedBanks: PublicKey[];
    }): Promise<SimulationResult>;
    /**
     * Creates a transaction instruction for repaying a loan.
     *
     * @param amount - The amount to repay, can be a number or Amount object
     * @param bankAddress - The public key of the bank to repay to
     * @param repayAll - Whether to repay the entire loan balance, defaults to false
     * @param repayOpts - Optional parameters for the repay instruction
     * @returns An InstructionsWrapper containing the deposit instructions
     * @throws Will throw an error if the repay mint is not found
     */
    makeRepayIx(amount: Amount, bankAddress: PublicKey, repayAll?: boolean, repayOpts?: MakeRepayIxOpts): Promise<InstructionsWrapper>;
    /**
     * Repays a loan in a marginfi bank account.
     *
     * @param amount - The amount to repay, can be a number or Amount object
     * @param bankAddress - The public key of the bank to repay to
     * @param repayAll - Whether to repay the entire loan balance, defaults to false
     * @param repayOpts - Optional parameters for the repay instruction
     * @param processOpts - Optional transaction processing configuration
     * @param txOpts - Optional transaction options
     * @returns The transaction signature of the repayment
     */
    repay(amount: Amount, bankAddress: PublicKey, repayAll?: boolean, repayOpts?: MakeRepayIxOpts, processOpts?: ProcessTransactionsClientOpts, txOpts?: TransactionOptions): Promise<TransactionSignature>;
    /**
     * Creates a transaction for repaying a loan in a marginfi bank account.
     *
     * @param amount - The amount to repay, can be a number or Amount object
     * @param bankAddress - The public key of the bank to repay to
     * @param repayAll - Whether to repay the entire loan balance, defaults to false
     * @param repayOpts - Optional parameters for the repay instruction
     * @returns A transaction object containing the repay instructions
     */
    makeRepayTx(amount: Amount, bankAddress: PublicKey, repayAll?: boolean, repayOpts?: MakeRepayIxOpts): Promise<ExtendedTransaction>;
    /**
     * Creates instructions for withdrawing tokens from a marginfi bank account.
     *
     * @param amount - The amount of tokens to withdraw, can be a number or Amount object
     * @param bankAddress - The public key of the bank to withdraw from
     * @param withdrawAll - Whether to withdraw the entire balance, defaults to false
     * @param withdrawOpts - Optional parameters for the withdraw instruction
     * @returns An InstructionsWrapper containing the withdraw instructions and signers
     * @throws Will throw an error if the withdraw mint is not found
     */
    makeWithdrawIx(amount: Amount, bankAddress: PublicKey, withdrawAll?: boolean, withdrawOpts?: MakeWithdrawIxOpts): Promise<InstructionsWrapper>;
    /**
     * Creates a transaction for withdrawing tokens from a marginfi bank account and staking them.
     * - Withdraw from marginfi bank
     * - Create stake account
     * - Approve mint authority to burn tokens
     * - Delegate stake account
     *
     * @param amount - The amount of tokens to withdraw, can be a number or Amount object
     * @param bankAddress - The public key of the bank to withdraw from
     * @param isWholePosition - Whether to withdraw the entire position, defaults to false
     * @returns A transaction object ready to be signed and sent
     */
    makeWithdrawStakedTx(amount: Amount, bankAddress: PublicKey, isWholePosition: boolean): Promise<TransactionBuilderResult>;
    /**
     * Creates a transaction for withdrawing all tokens from multiple marginfi banks.
     *
     * @param banks - Array of objects containing amount and bank address for each withdrawal
     * @param withdrawOpts - Optional parameters for the withdraw instructions
     * @returns A transaction object ready to be signed and sent
     */
    makeWithdrawAllTx(banks: {
        amount: Amount;
        bankAddress: PublicKey;
    }[], withdrawOpts?: MakeWithdrawIxOpts): Promise<ExtendedTransaction>;
    /**
     * Withdraws tokens from a marginfi bank account.
     *
     * @param amount - The amount of tokens to withdraw, can be a number or Amount object
     * @param bankAddress - The public key of the bank to withdraw from
     * @param withdrawAll - If true, withdraws entire balance from the bank
     * @param withdrawOpts - Optional withdraw configuration parameters
     * @param processOpts - Optional transaction processing configuration
     * @param txOpts - Optional transaction options
     * @returns Array of transaction signatures - includes signatures for any required oracle feed updates followed by the withdraw transaction
     */
    withdraw(amount: Amount, bankAddress: PublicKey, withdrawAll?: boolean, withdrawOpts?: MakeWithdrawIxOpts, processOpts?: ProcessTransactionsClientOpts, txOpts?: TransactionOptions): Promise<TransactionSignature[]>;
    /**
     * Creates a versioned transaction for withdrawing tokens from a marginfi bank account.
     *
     * @param amount - The amount of tokens to withdraw, can be a number or Amount object
     * @param bankAddress - The public key of the bank to withdraw from
     * @param withdrawAll - If true, withdraws entire balance from the bank
     * @param withdrawOpts - Optional withdraw configuration parameters
     * @returns Object containing feed crank transactions and the withdraw transaction
     */
    makeWithdrawTx(amount: Amount, bankAddress: PublicKey, withdrawAll?: boolean, withdrawOpts?: MakeWithdrawIxOpts): Promise<TransactionBuilderResult>;
    /**
     * Creates instructions for borrowing tokens from a marginfi bank account.
     *
     * @param amount - The amount of tokens to borrow, can be a number or Amount object
     * @param bankAddress - The public key of the bank to borrow from
     * @param borrowOpts - Optional borrow configuration parameters
     * @returns An InstructionsWrapper containing the borrow instructions
     */
    makeBorrowIx(amount: Amount, bankAddress: PublicKey, borrowOpts?: MakeBorrowIxOpts): Promise<InstructionsWrapper>;
    /**
     * Borrows tokens from a marginfi bank account.
     *
     * @param amount - The amount of tokens to borrow, can be a number or Amount object
     * @param bankAddress - The public key of the bank to borrow from
     * @param borrowOpts - Optional borrow configuration parameters
     * @param processOpts - Optional transaction processing configuration
     * @param txOpts - Optional transaction configuration parameters
     * @returns Array of transaction signatures from the borrow operation
     */
    borrow(amount: Amount, bankAddress: PublicKey, borrowOpts?: MakeBorrowIxOpts, processOpts?: ProcessTransactionsClientOpts, txOpts?: TransactionOptions): Promise<TransactionSignature[]>;
    /**
     * Creates a versioned transaction for borrowing tokens from a marginfi bank account.
     *
     * @param amount - The amount of tokens to borrow, can be a number or Amount object
     * @param bankAddress - The public key of the bank to borrow from
     * @param borrowOpts - Optional borrow configuration parameters
     * @returns Object containing feed crank transactions and the borrow transaction
     */
    makeBorrowTx(amount: Amount, bankAddress: PublicKey, borrowOpts?: MakeBorrowIxOpts): Promise<TransactionBuilderResult>;
    /**
     * Creates instructions for withdrawing emissions rewards from a marginfi bank account.
     *
     * @param bankAddress - The public key of the bank to withdraw emissions from
     * @returns An InstructionsWrapper containing the withdraw emissions instructions
     */
    makeWithdrawEmissionsIx(bankAddress: PublicKey): Promise<InstructionsWrapper>;
    /**
     * Creates a versioned transaction for withdrawing emissions rewards from multiple marginfi bank accounts.
     *
     * @param bankAddresses - Array of public keys for the banks to withdraw emissions from
     * @returns A versioned transaction containing the withdraw emissions instructions
     */
    makeWithdrawEmissionsTx(bankAddresses: PublicKey[]): Promise<ExtendedV0Transaction>;
    /**
     * Withdraws emissions rewards from multiple marginfi bank accounts.
     *
     * @param bankAddresses - Array of public keys for the banks to withdraw emissions from
     * @param processOpts - Optional processing options for the transaction
     * @param txOpts - Optional transaction options
     * @returns The transaction signature of the withdraw emissions transaction
     */
    withdrawEmissions(bankAddresses: PublicKey[], processOpts?: ProcessTransactionsClientOpts, txOpts?: TransactionOptions): Promise<TransactionSignature>;
    /**
     * Creates an instruction wrapper for liquidating a lending account position.
     *
     * @param liquidateeMarginfiAccount - The marginfi account to be liquidated
     * @param assetBankAddress - Public key of the bank containing the asset to receive in liquidation
     * @param assetQuantityUi - Amount of the asset to receive, in UI units
     * @param liabBankAddress - Public key of the bank containing the liability to repay
     * @returns An instruction wrapper containing the liquidation instructions
     */
    makeLendingAccountLiquidateIx(liquidateeMarginfiAccount: MarginfiAccount, assetBankAddress: PublicKey, assetQuantityUi: Amount, liabBankAddress: PublicKey): Promise<InstructionsWrapper>;
    /**
     * Liquidates a lending account position.
     *
     * @param liquidateeMarginfiAccount - The marginfi account to be liquidated
     * @param assetBankAddress - Public key of the bank containing the asset to receive in liquidation
     * @param assetQuantityUi - Amount of the asset to receive, in UI units
     * @param liabBankAddress - Public key of the bank containing the liability to repay
     * @param processOpts - Optional processing options for the transaction
     * @param txOpts - Optional transaction options
     * @returns The transaction signature of the liquidation transaction
     */
    lendingAccountLiquidate(liquidateeMarginfiAccount: MarginfiAccount, assetBankAddress: PublicKey, assetQuantityUi: Amount, liabBankAddress: PublicKey, processOpts?: ProcessTransactionsClientOpts, txOpts?: TransactionOptions): Promise<TransactionSignature>;
    /**
     * Creates an instruction to begin a flash loan operation.
     *
     * @param endIndex - The index where the flash loan instructions end in the transaction
     * @returns An InstructionsWrapper containing the begin flash loan instruction
     */
    makeBeginFlashLoanIx(endIndex: number): Promise<InstructionsWrapper>;
    /**
     * Creates an instruction to end a flash loan operation.
     *
     * @param projectedActiveBalances - Array of PublicKeys representing the projected active balance accounts after flash loan
     * @returns An InstructionsWrapper containing the end flash loan instruction
     */
    makeEndFlashLoanIx(projectedActiveBalances: PublicKey[]): Promise<InstructionsWrapper>;
    flashLoan(args: FlashLoanArgs, processOpts?: ProcessTransactionsClientOpts, txOpts?: TransactionOptions): Promise<TransactionSignature>;
    buildFlashLoanTx(args: FlashLoanArgs, lookupTables?: AddressLookupTableAccount[]): Promise<ExtendedV0Transaction>;
    makeAccountTransferToNewAccountIx(newMarginfiAccount: PublicKey, newAccountAuthority: PublicKey, globalFeeWallet: PublicKey): Promise<InstructionsWrapper>;
    makeAccountTransferToNewAccountTx(newMarginfiAccount: PublicKey, newAccountAuthority: PublicKey): Promise<Transaction>;
    makeUpdateFeedIx(newBanksPk: PublicKey[], txLandingBuffer?: number): Promise<{
        instructions: TransactionInstruction[];
        luts: AddressLookupTableAccount[];
    }>;
    makePulseHealthIx(mandatoryBanks?: PublicKey[], excludedBanks?: PublicKey[]): Promise<{
        instructions: TransactionInstruction[];
        keys: never[];
    }>;
    private static _fetchAccountData;
    static encode(decoded: MarginfiAccountRaw, idl: MarginfiIdlType): Promise<Buffer>;
    reload(): Promise<void>;
    private _updateFromAccountParsed;
    describe(): string;
    /**
     * @deprecated This method is deprecated. Please use simulateBorrowLendTransaction instead.
     */
    simulateDeposit(amount: Amount, bankAddress: PublicKey): Promise<SimulationResult>;
    /**
     * @deprecated This method is deprecated. Please use simulateBorrowLendTransaction instead.
     */
    simulateWithdraw(bankAddress: PublicKey, txs: VersionedTransaction[]): Promise<SimulationResult>;
    /**
     * @deprecated This method is deprecated. Please use simulateBorrowLendTransaction instead.
     */
    simulateBorrow(bankAddress: PublicKey, txs: VersionedTransaction[]): Promise<SimulationResult>;
    /**
     * @deprecated This method is deprecated. Please use simulateBorrowLendTransaction instead.
     */
    simulateRepay(amount: Amount, bankAddress: PublicKey, repayAll?: boolean): Promise<SimulationResult>;
}
/**
 * @deprecated This method is deprecated.
 */
export declare function makeTxPriorityIx(feePayer: PublicKey, feeUi?: number, broadcastType?: TransactionBroadcastType, computeUnitsLimit?: number): {
    bundleTipIx: TransactionInstruction | undefined;
    priorityFeeIx: TransactionInstruction;
};
export declare function makeBundleTipIx(feePayer: PublicKey, bundleTip?: number): TransactionInstruction;
export { MarginfiAccountWrapper };
//# sourceMappingURL=wrapper.d.ts.map
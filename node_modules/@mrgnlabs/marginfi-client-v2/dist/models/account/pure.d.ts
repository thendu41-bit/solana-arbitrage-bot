import { PublicKey, TransactionInstruction } from "@solana/web3.js";
import { Amount, BankMetadataMap, InstructionsWrapper, Program } from "@mrgnlabs/mrgn-common";
import BigNumber from "bignumber.js";
import { MarginfiProgram } from "../../types";
import { Bank } from "../bank";
import { Balance } from "../balance";
import { BankMap, MarginfiClient, MarginfiIdlType, OraclePriceMap, MintData, MarginfiAccountRaw, MarginfiAccountType, AccountFlags, EmodeTag, EmodePair, ActionEmodeImpact, OraclePrice, BankType, EmodeImpactStatus } from "../..";
import { HealthCache } from "../health-cache";
declare class MarginfiAccount implements MarginfiAccountType {
    readonly address: PublicKey;
    readonly group: PublicKey;
    readonly authority: PublicKey;
    readonly balances: Balance[];
    readonly accountFlags: AccountFlags[];
    readonly emissionsDestinationAccount: PublicKey;
    healthCache: HealthCache;
    constructor(address: PublicKey, group: PublicKey, authority: PublicKey, balances: Balance[], accountFlags: AccountFlags[], emissionsDestinationAccount: PublicKey, healthCache: HealthCache);
    static fetch(address: PublicKey, client: MarginfiClient): Promise<MarginfiAccount>;
    /**
     * @deprecated use decodeAccountRaw instead
     */
    static decode(encoded: Buffer, idl: MarginfiIdlType): MarginfiAccountRaw;
    static decodeAccountRaw(encoded: Buffer, idl: MarginfiIdlType): MarginfiAccountRaw;
    static fromAccountType(account: MarginfiAccountType): MarginfiAccount;
    static fromAccountParsed(marginfiAccountPk: PublicKey, accountData: MarginfiAccountRaw): MarginfiAccount;
    simulateHealthCache(program: Program<MarginfiIdlType>, bankMap: Map<string, Bank>, oraclePrices: Map<string, OraclePrice>, bankMetadataMap: BankMetadataMap): Promise<{
        marginfiAccount: MarginfiAccount;
        error?: import("../..").HealthCacheSimulationError;
    }>;
    static fromAccountDataRaw(marginfiAccountPk: PublicKey, rawData: Buffer, idl: MarginfiIdlType): MarginfiAccount;
    get activeBalances(): Balance[];
    getBalance(bankPk: PublicKey): Balance;
    get isDisabled(): boolean;
    get isFlashLoanEnabled(): boolean;
    get isTransferAccountAuthorityEnabled(): boolean;
    setHealthCache(value: HealthCache): void;
    computeFreeCollateral(opts?: {
        clamped?: boolean;
    }): BigNumber;
    computeFreeCollateralLegacy(banks: Map<string, BankType>, oraclePrices: Map<string, OraclePrice>, opts?: {
        clamped?: boolean;
    }): BigNumber;
    computeHealthComponents(marginReqType: MarginRequirementType): {
        assets: BigNumber;
        liabilities: BigNumber;
    };
    /**
     * @deprecated use computeHealthComponents instead
     */
    computeHealthComponentsLegacy(banks: Map<string, Bank>, oraclePrices: Map<string, OraclePrice>, marginReqType: MarginRequirementType, excludedBanks?: PublicKey[]): {
        assets: BigNumber;
        liabilities: BigNumber;
    };
    /**
     *  @deprecated use computeHealthComponents instead
     */
    computeHealthComponentsWithoutBiasLegacy(banks: Map<string, Bank>, oraclePrices: Map<string, OraclePrice>, marginReqType: MarginRequirementType): {
        assets: BigNumber;
        liabilities: BigNumber;
    };
    computeAccountValue(): BigNumber;
    computeNetApy(banks: Map<string, Bank>, oraclePrices: Map<string, OraclePrice>): number;
    /**
     * Calculate the maximum amount of asset that can be withdrawn from a bank given existing deposits of the asset
     * and the untied collateral of the margin account.
     *
     * fc = free collateral
     * ucb = untied collateral for bank
     *
     * q = (min(fc, ucb) / (price_lowest_bias * deposit_weight)) + (fc - min(fc, ucb)) / (price_highest_bias * liab_weight)
     *
     *
     *
     * NOTE FOR LIQUIDATORS
     * This function doesn't take into account the collateral received when liquidating an account.
     */
    computeMaxBorrowForBank(banks: Map<string, Bank>, oraclePrices: Map<string, OraclePrice>, bankAddress: PublicKey, opts?: {
        emodeImpactStatus?: EmodeImpactStatus;
        volatilityFactor?: number;
        emodeWeights?: {
            assetWeightMaint: BigNumber;
            assetWeightInit: BigNumber;
            collateralTag: EmodeTag;
        };
    }): BigNumber;
    /**
     * Calculate the maximum amount that can be withdrawn form a bank without borrowing.
     */
    computeMaxWithdrawForBank(banks: Map<string, Bank>, oraclePrices: Map<string, OraclePrice>, bankAddress: PublicKey, opts?: {
        volatilityFactor?: number;
    }): BigNumber;
    /**
     * Calculate the price at which the user position for the given bank will lead to liquidation, all other prices constant.
     */
    computeLiquidationPriceForBank(banks: Map<string, Bank>, oraclePrices: Map<string, OraclePrice>, bankAddress: PublicKey): number | null;
    /**
     * Calculate the price at which the user position for the given bank will lead to liquidation, all other prices constant.
     */
    computeLiquidationPriceForBankHealth(banks: Map<string, Bank>, oraclePrices: Map<string, OraclePrice>, bankAddress: PublicKey, opts?: {
        assetWeightMaint: BigNumber;
    }): number | null;
    /**
     * Calculate the price at which the user position for the given bank and amount will lead to liquidation, all other prices constant.
     */
    computeLiquidationPriceForBankAmount(banks: Map<string, Bank>, oraclePrices: Map<string, OraclePrice>, bankAddress: PublicKey, isLending: boolean, amount: number): number | null;
    computeMaxLiquidatableAssetAmount(banks: Map<string, Bank>, oraclePrices: Map<string, OraclePrice>, assetBankAddress: PublicKey, liabilityBankAddress: PublicKey): BigNumber;
    getHealthCheckAccounts(banks: Map<string, Bank>, mandatoryBanks?: PublicKey[], excludedBanks?: PublicKey[]): BankType[];
    /**
     * Determines which E-mode pairs are currently active for this account based on its balances
     *
     * @param emodePairs - All available E-mode pairs to check against the account's balances
     * @returns Array of active E-mode pairs for this account, or empty array if no E-mode is active
     */
    computeActiveEmodePairs(emodePairs: EmodePair[]): EmodePair[];
    /**
     * Calculates the impact of different actions on E-mode status for each bank
     *
     * For each bank, this method simulates the following actions and their effect on E-mode:
     * - Borrowing from the bank (for banks not currently borrowed from)
     * - Supplying to the bank (for supported collateral banks not currently supplied)
     * - Repaying all borrowing from the bank (for banks with active liabilities)
     * - Withdrawing all supply from the bank (for banks with active collateral)
     *
     * @param emodePairs - All available E-mode pairs to check against
     * @param banks - Array of bank PublicKeys to calculate impacts for
     * @returns Object mapping bank PublicKey strings to impact analysis for each possible action
     */
    computeEmodeImpacts(emodePairs: EmodePair[], banks: PublicKey[]): Record<string, ActionEmodeImpact>;
    makeDepositIx(program: MarginfiProgram, banks: Map<string, Bank>, mintDatas: Map<string, MintData>, amount: Amount, bankAddress: PublicKey, opts?: MakeDepositIxOpts): Promise<InstructionsWrapper>;
    makeRepayIx(program: MarginfiProgram, banks: Map<string, Bank>, mintDatas: Map<string, MintData>, amount: Amount, bankAddress: PublicKey, repayAll?: boolean, opts?: MakeRepayIxOpts): Promise<InstructionsWrapper>;
    makeWithdrawIx(program: MarginfiProgram, bankMap: Map<string, Bank>, mintDatas: Map<string, MintData>, bankMetadataMap: BankMetadataMap, amount: Amount, bankAddress: PublicKey, withdrawAll?: boolean, withdrawOpts?: MakeWithdrawIxOpts): Promise<InstructionsWrapper>;
    makeBorrowIx(program: MarginfiProgram, bankMap: Map<string, Bank>, mintDatas: Map<string, MintData>, bankMetadataMap: BankMetadataMap, amount: Amount, bankAddress: PublicKey, borrowOpts?: MakeBorrowIxOpts): Promise<InstructionsWrapper>;
    makeWithdrawEmissionsIx(program: MarginfiProgram, banks: Map<string, Bank>, mintDatas: Map<string, MintData>, bankAddress: PublicKey): Promise<InstructionsWrapper>;
    makeLendingAccountLiquidateIx(liquidateeMarginfiAccount: MarginfiAccount, program: MarginfiProgram, bankMap: Map<string, Bank>, mintDatas: Map<string, MintData>, bankMetadataMap: BankMetadataMap, assetBankAddress: PublicKey, assetQuantityUi: Amount, liabilityBankAddress: PublicKey): Promise<InstructionsWrapper>;
    makeBeginFlashLoanIx(program: MarginfiProgram, endIndex: number): Promise<InstructionsWrapper>;
    makeEndFlashLoanIx(program: MarginfiProgram, bankMap: Map<string, Bank>, projectedActiveBalances: PublicKey[]): Promise<InstructionsWrapper>;
    makeAccountTransferToNewAccountIx(program: MarginfiProgram, newMarginfiAccount: PublicKey, newAuthority: PublicKey, globalFeeWallet: PublicKey): Promise<InstructionsWrapper>;
    makeCloseAccountIx(program: MarginfiProgram): Promise<InstructionsWrapper>;
    makePulseHealthIx(program: MarginfiProgram, banks: Map<string, Bank>, mandatoryBanks: PublicKey[], excludedBanks: PublicKey[], bankMetadataMap: BankMetadataMap): Promise<{
        instructions: TransactionInstruction[];
        keys: never[];
    }>;
    projectActiveBalancesNoCpi(program: MarginfiProgram, instructions: TransactionInstruction[]): PublicKey[];
    wrapInstructionForWSol(ix: TransactionInstruction, amount?: Amount): TransactionInstruction[];
    describe(banks: BankMap, oraclePrices: OraclePriceMap): string;
}
declare enum MarginRequirementType {
    Initial = 0,
    Maintenance = 1,
    Equity = 2
}
export interface MakeDepositIxOpts {
    wrapAndUnwrapSol?: boolean;
    wSolBalanceUi?: number;
    overrideInferAccounts?: {
        group?: PublicKey;
        authority?: PublicKey;
        liquidityVault?: PublicKey;
    };
}
export interface MakeRepayIxOpts {
    wrapAndUnwrapSol?: boolean;
    wSolBalanceUi?: number;
    overrideInferAccounts?: {
        group?: PublicKey;
        authority?: PublicKey;
        liquidityVault?: PublicKey;
    };
}
export interface MakeWithdrawIxOpts {
    observationBanksOverride?: PublicKey[];
    wrapAndUnwrapSol?: boolean;
    createAtas?: boolean;
    overrideInferAccounts?: {
        group?: PublicKey;
        authority?: PublicKey;
    };
}
export interface MakeBorrowIxOpts {
    observationBanksOverride?: PublicKey[];
    wrapAndUnwrapSol?: boolean;
    createAtas?: boolean;
    overrideInferAccounts?: {
        group?: PublicKey;
        authority?: PublicKey;
    };
}
export declare function isWeightedPrice(reqType: MarginRequirementType): boolean;
export { MarginfiAccount, MarginRequirementType };
//# sourceMappingURL=pure.d.ts.map
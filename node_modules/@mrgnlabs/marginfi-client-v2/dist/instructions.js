"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bn_js_1 = __importDefault(require("bn.js"));
const mrgn_common_1 = require("@mrgnlabs/mrgn-common");
async function makeInitMarginfiAccountIx(mfProgram, accounts) {
    return mfProgram.methods.marginfiAccountInitialize().accounts(accounts).instruction();
}
async function makeDepositIx(mfProgram, accounts, args, remainingAccounts = []) {
    const { marginfiAccount, signerTokenAccount, bank, tokenProgram, ...optionalAccounts } = accounts;
    return mfProgram.methods
        .lendingAccountDeposit(args.amount, args.depositUpToLimit ?? null)
        .accounts({
        marginfiAccount,
        signerTokenAccount,
        bank,
        tokenProgram,
    })
        .accountsPartial(optionalAccounts)
        .remainingAccounts(remainingAccounts)
        .instruction();
}
async function makeRepayIx(mfProgram, accounts, args, remainingAccounts = []) {
    const { marginfiAccount, signerTokenAccount, bank, tokenProgram, ...optionalAccounts } = accounts;
    return mfProgram.methods
        .lendingAccountRepay(args.amount, args.repayAll ?? null)
        .accounts({
        marginfiAccount,
        signerTokenAccount,
        bank,
        tokenProgram,
    })
        .accountsPartial(optionalAccounts)
        .remainingAccounts(remainingAccounts)
        .instruction();
}
async function makeWithdrawIx(mfProgram, accounts, args, remainingAccounts = []) {
    const { marginfiAccount, bank, destinationTokenAccount, tokenProgram, ...optionalAccounts } = accounts;
    return mfProgram.methods
        .lendingAccountWithdraw(args.amount, args.withdrawAll ?? null)
        .accounts({
        marginfiAccount,
        destinationTokenAccount,
        bank,
        tokenProgram,
    })
        .accountsPartial(optionalAccounts)
        .remainingAccounts(remainingAccounts)
        .instruction();
}
async function makeBorrowIx(mfProgram, accounts, args, remainingAccounts = []) {
    const { marginfiAccount, bank, destinationTokenAccount, tokenProgram, ...optionalAccounts } = accounts;
    return mfProgram.methods
        .lendingAccountBorrow(args.amount)
        .accounts({
        marginfiAccount,
        destinationTokenAccount,
        bank,
        tokenProgram,
    })
        .accountsPartial(optionalAccounts)
        .remainingAccounts(remainingAccounts)
        .instruction();
}
function makeLendingAccountLiquidateIx(mfiProgram, accounts, args, remainingAccounts = []) {
    const { assetBank, liabBank, liquidatorMarginfiAccount, liquidateeMarginfiAccount, tokenProgram, ...optionalAccounts } = accounts;
    return mfiProgram.methods
        .lendingAccountLiquidate(args.assetAmount)
        .accounts({
        assetBank,
        liabBank,
        liquidatorMarginfiAccount,
        liquidateeMarginfiAccount,
        tokenProgram,
    })
        .accountsPartial(optionalAccounts)
        .remainingAccounts(remainingAccounts)
        .instruction();
}
function makelendingAccountWithdrawEmissionIx(mfiProgram, accounts) {
    const { marginfiAccount, destinationAccount, bank, tokenProgram, ...optionalAccounts } = accounts;
    return mfiProgram.methods
        .lendingAccountWithdrawEmissions()
        .accounts({
        marginfiAccount,
        destinationAccount,
        bank,
        tokenProgram,
    })
        .accountsPartial(optionalAccounts)
        .instruction();
}
function makePoolConfigureBankIx(mfiProgram, accounts, args) {
    const { bank, ...optionalAccounts } = accounts;
    return mfiProgram.methods
        .lendingPoolConfigureBank(args.bankConfigOpt)
        .accounts({
        bank,
    })
        .accountsPartial(optionalAccounts)
        .instruction();
}
function makeBeginFlashLoanIx(mfiProgram, accounts, args) {
    const { marginfiAccount, ...optionalAccounts } = accounts;
    return mfiProgram.methods
        .lendingAccountStartFlashloan(args.endIndex)
        .accounts({
        marginfiAccount,
    })
        .accountsPartial(optionalAccounts)
        .instruction();
}
function makeEndFlashLoanIx(mfiProgram, accounts, remainingAccounts = []) {
    const { marginfiAccount, ...optionalAccounts } = accounts;
    return mfiProgram.methods
        .lendingAccountEndFlashloan()
        .accounts({
        marginfiAccount,
    })
        .accountsPartial(optionalAccounts)
        .remainingAccounts(remainingAccounts)
        .instruction();
}
async function makeAccountTransferToNewAccountIx(mfProgram, accounts) {
    const { oldMarginfiAccount, newMarginfiAccount, newAuthority, globalFeeWallet, ...optionalAccounts } = accounts;
    return mfProgram.methods
        .transferToNewAccount()
        .accounts({
        oldMarginfiAccount,
        newMarginfiAccount,
        newAuthority,
        globalFeeWallet,
    })
        .accountsPartial(optionalAccounts)
        .instruction();
}
async function makeGroupInitIx(mfProgram, accounts, args) {
    return mfProgram.methods
        .marginfiGroupInitialize(args?.isArenaGroup ?? false)
        .accounts({
        marginfiGroup: accounts.marginfiGroup,
        admin: accounts.admin,
    })
        .instruction();
}
/**
 * Configure the oracle for a bank
 * @param mfProgram The marginfi program
 * @param accounts The accounts required for this instruction
 * @param args The oracle setup index and feed id
 * @param remainingAccounts The remaining accounts required for this instruction, should include the feed oracle key
 */
async function makeLendingPoolConfigureBankOracleIx(mfProgram, accounts, args, 
/**
 * The remaining accounts required for this instruction, should include the feed oracle key (non writable & signable)
 */
remainingAccounts = []) {
    const { bank, ...optionalAccounts } = accounts;
    return mfProgram.methods
        .lendingPoolConfigureBankOracle(args.setup, args.feedId)
        .accounts({
        bank,
    })
        .accountsPartial(optionalAccounts)
        .remainingAccounts(remainingAccounts)
        .instruction();
}
/**
 * Creates an instruction to add a permissionless staked bank to a lending pool.
 * @param mfProgram - The marginfi program instance
 * @param accounts - The accounts required for this instruction
 * @param remainingAccounts - The remaining accounts required for this instruction, including pythOracle, solPool and bankMint
 * @param args - Optional arguments for this instruction
 */
async function makePoolAddPermissionlessStakedBankIx(mfProgram, accounts, 
/**
 * The remaining accounts required for this instruction. Should include:
 * - pythOracle: The pyth oracle key (non writable & non signer)
 * - solPool: The sol pool key (non writable & non signer)
 * - bankMint: The bank mint key (non writable & non signer)
 */
remainingAccounts = [], args) {
    const { stakedSettings, feePayer, bankMint, solPool, stakePool, tokenProgram = mrgn_common_1.TOKEN_PROGRAM_ID, ...optionalAccounts } = accounts;
    return mfProgram.methods
        .lendingPoolAddBankPermissionless(args.seed ?? new bn_js_1.default(0))
        .accounts({
        stakedSettings,
        feePayer,
        bankMint,
        solPool,
        stakePool,
        tokenProgram,
    })
        .accountsPartial(optionalAccounts)
        .remainingAccounts(remainingAccounts)
        .instruction();
}
async function makePoolAddBankIx(mfProgram, accounts, args) {
    const { marginfiGroup, feePayer, bankMint, bank, tokenProgram, ...optionalAccounts } = accounts;
    return mfProgram.methods
        .lendingPoolAddBank({
        ...args.bankConfig,
        pad0: [0, 0, 0, 0, 0, 0, 0, 0],
    })
        .accounts({
        marginfiGroup,
        feePayer,
        bankMint,
        bank,
        tokenProgram,
    })
        .accountsPartial(optionalAccounts)
        .instruction();
}
async function makeCloseAccountIx(mfProgram, accounts) {
    const { marginfiAccount, feePayer, ...optionalAccounts } = accounts;
    return mfProgram.methods
        .marginfiAccountClose()
        .accounts({
        marginfiAccount,
        feePayer,
    })
        .accountsPartial(optionalAccounts)
        .instruction();
}
async function makeLendingAccountSortBalancesIx(mfProgram, accounts) {
    return mfProgram.methods
        .lendingAccountSortBalances()
        .accounts({
        marginfiAccount: accounts.marginfiAccount,
    })
        .instruction();
}
async function makePulseHealthIx(mfProgram, accounts, 
/**
 * The remaining accounts required for this instruction. Should include:
 * - For each balance the user has, pass bank and oracle: <bank1, oracle1, bank2, oracle2>
 */
remainingAccounts = []) {
    return mfProgram.methods
        .lendingAccountPulseHealth()
        .accounts({
        marginfiAccount: accounts.marginfiAccount,
    })
        .remainingAccounts(remainingAccounts)
        .instruction();
}
const instructions = {
    makeDepositIx,
    makeRepayIx,
    makeWithdrawIx,
    makeBorrowIx,
    makeInitMarginfiAccountIx,
    makeLendingAccountLiquidateIx,
    makelendingAccountWithdrawEmissionIx,
    makePoolAddBankIx,
    makePoolConfigureBankIx,
    makeBeginFlashLoanIx,
    makeEndFlashLoanIx,
    makeAccountTransferToNewAccountIx,
    makeGroupInitIx,
    makeCloseAccountIx,
    makePoolAddPermissionlessStakedBankIx,
    makeLendingPoolConfigureBankOracleIx,
    makePulseHealthIx,
    makeLendingAccountSortBalancesIx,
};
exports.default = instructions;

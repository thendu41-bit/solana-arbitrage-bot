"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConfigPda = exports.getTreasuryPda = void 0;
exports.freezeBankConfigIx = freezeBankConfigIx;
exports.addOracleToBanksIx = addOracleToBanksIx;
exports.getPriceFeedAccountForProgram = getPriceFeedAccountForProgram;
exports.crankPythOracleIx = crankPythOracleIx;
const web3_js_1 = require("@solana/web3.js");
const anchor_1 = require("@coral-xyz/anchor");
const mrgn_common_1 = require("@mrgnlabs/mrgn-common");
const pyth_crank_1 = require("../../vendor/pyth_crank");
const utils_1 = require("./utils");
const instructions_1 = __importDefault(require("../../instructions"));
async function freezeBankConfigIx(program, bankAddress, bankConfigOpt) {
    let bankConfigRaw;
    if (!bankConfigOpt) {
        // todo: make bankConfigOpt optional and create function to get bankConfigOptRaw from bank
    }
    bankConfigRaw = (0, utils_1.serializeBankConfigOpt)(bankConfigOpt);
    const ix = await instructions_1.default.makePoolConfigureBankIx(program, {
        bank: bankAddress,
    }, {
        bankConfigOpt: {
            // ...bankConfigRaw,
            assetWeightInit: null,
            assetWeightMaint: null,
            liabilityWeightInit: null,
            liabilityWeightMaint: null,
            depositLimit: null,
            borrowLimit: null,
            riskTier: null,
            assetTag: null,
            totalAssetValueInitLimit: null,
            interestRateConfig: null,
            operationalState: null,
            oracleMaxAge: null,
            permissionlessBadDebtSettlement: null,
            freezeSettings: true,
            oracleMaxConfidence: null,
        },
    });
    return {
        instructions: [ix],
        keys: [],
    };
}
async function addOracleToBanksIx({ program, bankAddress, feedId, oracleKey, setup, groupAddress, adminAddress, }) {
    const ix = await instructions_1.default.makeLendingPoolConfigureBankOracleIx(program, {
        bank: bankAddress,
        group: groupAddress,
        admin: adminAddress,
    }, {
        setup: (0, utils_1.serializeOracleSetupToIndex)(setup),
        feedId,
    }, oracleKey ? [{ isSigner: false, isWritable: false, pubkey: oracleKey }] : []);
    return {
        instructions: [ix],
        keys: [],
    };
}
/**
 * Derive the address of a price feed account
 * @param shardId The shard ID of the set of price feed accounts. This shard ID allows for multiple price feed accounts for the same price feed id to exist.
 * @param priceFeedId The price feed ID, as either a 32-byte buffer or hexadecimal string with or without a leading "0x" prefix.
 * @param pushOracleProgramId The program ID of the Pyth Push Oracle program. If not provided, the default deployment will be used.
 * @returns The address of the price feed account
 */
function getPriceFeedAccountForProgram(shardId, priceFeedId, pushOracleProgramId) {
    if (typeof priceFeedId == "string") {
        if (priceFeedId.startsWith("0x")) {
            priceFeedId = Buffer.from(priceFeedId.slice(2), "hex");
        }
        else {
            priceFeedId = Buffer.from(priceFeedId, "hex");
        }
    }
    if (priceFeedId.length != 32) {
        throw new Error("Feed ID should be 32 bytes long");
    }
    const shardBuffer = Buffer.alloc(2);
    shardBuffer.writeUint16LE(shardId, 0);
    return web3_js_1.PublicKey.findProgramAddressSync([shardBuffer, priceFeedId], pushOracleProgramId ?? pyth_crank_1.DEFAULT_PUSH_ORACLE_PROGRAM_ID)[0];
}
const getTreasuryPda = (treasuryId, receiverProgramId) => {
    return web3_js_1.PublicKey.findProgramAddressSync([Buffer.from("treasury"), Buffer.from([treasuryId])], receiverProgramId)[0];
};
exports.getTreasuryPda = getTreasuryPda;
const getConfigPda = (receiverProgramId) => {
    return web3_js_1.PublicKey.findProgramAddressSync([Buffer.from("config")], receiverProgramId)[0];
};
exports.getConfigPda = getConfigPda;
async function crankPythOracleIx(oracles, provider) {
    const feedIdsByShardId = {};
    const wormholeProgram = new anchor_1.Program(pyth_crank_1.PYTH_WORMHOLE_IDL, provider);
    const pushOracleProgram = new anchor_1.Program(pyth_crank_1.PYTH_PUSH_ORACLE_IDL, provider);
    const receiverProgram = new anchor_1.Program(pyth_crank_1.PYTH_SOLANA_RECEIVER_PROGRAM_IDL, provider);
    const addressLookupTableAccount = new web3_js_1.PublicKey("5DNCErWQFBdvCxWQXaC1mrEFsvL3ftrzZ2gVZWNybaSX");
    const lookupTableAccount = (await provider.connection.getAddressLookupTable(addressLookupTableAccount)).value;
    const buildURL = (endpoint) => {
        return new URL(`./v2/${endpoint}`, `https://hermes.pyth.network/`);
    };
    for (const oracle of oracles) {
        const { shardId, feedId } = oracle;
        if (!feedIdsByShardId[shardId]) {
            feedIdsByShardId[shardId] = [];
        }
        feedIdsByShardId[shardId].push(feedId);
    }
    const postInstructions = [];
    const priceFeedIdToPriceUpdateAccount = {};
    const closeInstructions = [];
    for (const [shardId, feedIds] of Object.entries(feedIdsByShardId)) {
        const url = buildURL("updates/price/latest");
        for (const id of feedIds) {
            url.searchParams.append("ids[]", id);
        }
        url.searchParams.append("encoding", "base64");
        const response = await fetch(url);
        const priceDataArray = (await response.json()).binary.data;
        const treasuryId = 0;
        for (const priceData of priceDataArray) {
            const accumulatorUpdateData = (0, pyth_crank_1.parseAccumulatorUpdateData)(Buffer.from(priceData, "base64"));
            const { postInstructions: postEncodedVaaInstructions, encodedVaaAddress: encodedVaa, closeInstructions: postEncodedVaacloseInstructions, } = await (0, pyth_crank_1.buildPostEncodedVaaInstructions)(wormholeProgram, accumulatorUpdateData.vaa);
            postInstructions.push(...postEncodedVaaInstructions);
            closeInstructions.push(...postEncodedVaacloseInstructions);
            for (const update of accumulatorUpdateData.updates) {
                const feedId = (0, pyth_crank_1.parsePriceFeedMessage)(update.message).feedId;
                postInstructions.push({
                    instruction: await pushOracleProgram.methods
                        .updatePriceFeed({
                        merklePriceUpdate: update,
                        treasuryId,
                    }, Number(shardId), Array.from(feedId))
                        .accounts({
                        pythSolanaReceiver: receiverProgram.programId,
                        encodedVaa,
                        priceFeedAccount: getPriceFeedAccountForProgram(Number(shardId), feedId, pushOracleProgram.programId),
                        treasury: (0, exports.getTreasuryPda)(treasuryId, receiverProgram.programId),
                        config: (0, exports.getConfigPda)(receiverProgram.programId),
                        systemProgram: mrgn_common_1.SYSTEM_PROGRAM_ID,
                    })
                        .instruction(),
                    signers: [],
                    computeUnits: pyth_crank_1.UPDATE_PRICE_FEED_COMPUTE_BUDGET,
                });
            }
        }
    }
    return {
        postInstructions: postInstructions,
        closeInstructions: closeInstructions,
        keys: [],
        lut: lookupTableAccount,
    };
}

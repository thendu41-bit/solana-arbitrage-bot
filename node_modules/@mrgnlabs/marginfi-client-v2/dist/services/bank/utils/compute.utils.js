"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeMaxLeverage = computeMaxLeverage;
exports.computeLoopingParams = computeLoopingParams;
exports.getTotalAssetQuantity = getTotalAssetQuantity;
exports.getTotalLiabilityQuantity = getTotalLiabilityQuantity;
exports.getAssetQuantity = getAssetQuantity;
exports.getLiabilityQuantity = getLiabilityQuantity;
exports.getAssetShares = getAssetShares;
exports.getLiabilityShares = getLiabilityShares;
exports.getAssetWeight = getAssetWeight;
exports.getLiabilityWeight = getLiabilityWeight;
exports.computeLiabilityUsdValue = computeLiabilityUsdValue;
exports.computeAssetUsdValue = computeAssetUsdValue;
exports.computeUsdValue = computeUsdValue;
exports.computeTvl = computeTvl;
exports.computeInterestRates = computeInterestRates;
exports.computeBaseInterestRate = computeBaseInterestRate;
exports.computeUtilizationRate = computeUtilizationRate;
exports.computeRemainingCapacity = computeRemainingCapacity;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const mrgn_common_1 = require("@mrgnlabs/mrgn-common");
const account_1 = require("../../../models/account");
const price_1 = require("../../price");
function computeMaxLeverage(depositBank, borrowBank, opts) {
    const assetWeightInit = opts?.assetWeightInit || depositBank.config.assetWeightInit;
    const liabilityWeightInit = opts?.liabilityWeightInit || borrowBank.config.liabilityWeightInit;
    const ltv = assetWeightInit.div(liabilityWeightInit).toNumber();
    const maxLeverage = 1 / (1 - ltv);
    return {
        maxLeverage,
        ltv,
    };
}
function computeLoopingParams(principal, targetLeverage, depositBank, borrowBank, depositOracleInfo, borrowOracleInfo, opts) {
    const initialCollateral = (0, mrgn_common_1.toBigNumber)(principal);
    const { maxLeverage } = computeMaxLeverage(depositBank, borrowBank, opts);
    if (targetLeverage < 1) {
        throw Error(`Target leverage ${targetLeverage} needs to be greater than 1`);
    }
    if (targetLeverage > maxLeverage) {
        throw Error(`Target leverage ${targetLeverage} exceeds max leverage for banks ${maxLeverage}`);
    }
    const totalDepositAmount = initialCollateral.times(new bignumber_js_1.default(targetLeverage));
    const additionalDepositAmount = totalDepositAmount.minus(initialCollateral);
    const borrowAmount = additionalDepositAmount
        .times(depositOracleInfo.priceWeighted.lowestPrice)
        .div(borrowOracleInfo.priceWeighted.highestPrice);
    return { borrowAmount, totalDepositAmount };
}
/** Small getters */
function getTotalAssetQuantity(bank) {
    return bank.totalAssetShares.times(bank.assetShareValue);
}
function getTotalLiabilityQuantity(bank) {
    return bank.totalLiabilityShares.times(bank.liabilityShareValue);
}
function getAssetQuantity(bank, assetShares) {
    return assetShares.times(bank.assetShareValue);
}
function getLiabilityQuantity(bank, liabilityShares) {
    return liabilityShares.times(bank.liabilityShareValue);
}
function getAssetShares(bank, assetQuantity) {
    return assetQuantity.times(bank.assetShareValue);
}
function getLiabilityShares(bank, liabilityQuantity) {
    return liabilityQuantity.times(bank.liabilityShareValue);
}
function getAssetWeight(bank, marginRequirementType, oraclePrice, opts) {
    const assetWeightInit = opts?.assetWeightInitOverride ?? bank.config.assetWeightInit;
    switch (marginRequirementType) {
        case account_1.MarginRequirementType.Initial:
            const isSoftLimitDisabled = bank.config.totalAssetValueInitLimit.isZero();
            if (opts?.ignoreSoftLimits || isSoftLimitDisabled)
                return assetWeightInit;
            const totalBankCollateralValue = computeAssetUsdValue(bank, oraclePrice, bank.totalAssetShares, account_1.MarginRequirementType.Equity, price_1.PriceBias.Lowest);
            if (totalBankCollateralValue.isGreaterThan(bank.config.totalAssetValueInitLimit)) {
                return bank.config.totalAssetValueInitLimit.div(totalBankCollateralValue).times(assetWeightInit);
            }
            else {
                return assetWeightInit;
            }
        case account_1.MarginRequirementType.Maintenance:
            return bank.config.assetWeightMaint;
        case account_1.MarginRequirementType.Equity:
            return new bignumber_js_1.default(1);
        default:
            throw new Error("Invalid margin requirement type");
    }
}
function getLiabilityWeight(config, marginRequirementType) {
    switch (marginRequirementType) {
        case account_1.MarginRequirementType.Initial:
            return config.liabilityWeightInit;
        case account_1.MarginRequirementType.Maintenance:
            return config.liabilityWeightMaint;
        case account_1.MarginRequirementType.Equity:
            return new bignumber_js_1.default(1);
        default:
            throw new Error("Invalid margin requirement type");
    }
}
/** Computes  */
function computeLiabilityUsdValue(bank, oraclePrice, liabilityShares, marginRequirementType, priceBias) {
    const liabilityQuantity = getLiabilityQuantity(bank, liabilityShares);
    const liabilityWeight = getLiabilityWeight(bank.config, marginRequirementType);
    const isWeighted = (0, account_1.isWeightedPrice)(marginRequirementType);
    return computeUsdValue(bank, oraclePrice, liabilityQuantity, priceBias, isWeighted, liabilityWeight);
}
function computeAssetUsdValue(bank, oraclePrice, assetShares, marginRequirementType, priceBias) {
    const assetQuantity = getAssetQuantity(bank, assetShares);
    const assetWeight = getAssetWeight(bank, marginRequirementType, oraclePrice);
    const isWeighted = (0, account_1.isWeightedPrice)(marginRequirementType);
    return computeUsdValue(bank, oraclePrice, assetQuantity, priceBias, isWeighted, assetWeight);
}
function computeUsdValue(bank, oraclePrice, quantity, priceBias, weightedPrice, weight, scaleToBase = true) {
    const price = (0, price_1.getPrice)(oraclePrice, priceBias, weightedPrice);
    return quantity
        .times(price)
        .times(weight ?? 1)
        .dividedBy(scaleToBase ? 10 ** bank.mintDecimals : 1);
}
function computeTvl(bank, oraclePrice) {
    return computeAssetUsdValue(bank, oraclePrice, bank.totalAssetShares, account_1.MarginRequirementType.Equity, price_1.PriceBias.None).minus(computeLiabilityUsdValue(bank, oraclePrice, bank.totalLiabilityShares, account_1.MarginRequirementType.Equity, price_1.PriceBias.None));
}
function computeInterestRates(bank) {
    const { insuranceFeeFixedApr, insuranceIrFee, protocolFixedFeeApr, protocolIrFee } = bank.config.interestRateConfig;
    const fixedFee = insuranceFeeFixedApr.plus(protocolFixedFeeApr);
    const rateFee = insuranceIrFee.plus(protocolIrFee);
    const baseInterestRate = computeBaseInterestRate(bank);
    const utilizationRate = computeUtilizationRate(bank);
    const lendingRate = baseInterestRate.times(utilizationRate);
    const borrowingRate = baseInterestRate.times(new bignumber_js_1.default(1).plus(rateFee)).plus(fixedFee);
    return { lendingRate, borrowingRate };
}
function computeBaseInterestRate(bank) {
    const { optimalUtilizationRate, plateauInterestRate, maxInterestRate } = bank.config.interestRateConfig;
    const utilizationRate = computeUtilizationRate(bank);
    if (utilizationRate.lte(optimalUtilizationRate)) {
        return utilizationRate.times(plateauInterestRate).div(optimalUtilizationRate);
    }
    else {
        return utilizationRate
            .minus(optimalUtilizationRate)
            .div(new bignumber_js_1.default(1).minus(optimalUtilizationRate))
            .times(maxInterestRate.minus(plateauInterestRate))
            .plus(plateauInterestRate);
    }
}
function computeUtilizationRate(bank) {
    const assets = getTotalAssetQuantity(bank);
    const liabilities = getTotalLiabilityQuantity(bank);
    if (assets.isZero())
        return new bignumber_js_1.default(0);
    return liabilities.div(assets);
}
const SECONDS_PER_DAY = 24 * 60 * 60;
const SECONDS_PER_YEAR = SECONDS_PER_DAY * 365.25;
function computeRemainingCapacity(bank) {
    const totalDeposits = getTotalAssetQuantity(bank);
    const remainingCapacity = bignumber_js_1.default.max(0, bank.config.depositLimit.minus(totalDeposits));
    const totalBorrows = getTotalLiabilityQuantity(bank);
    const remainingBorrowCapacity = bignumber_js_1.default.max(0, bank.config.borrowLimit.minus(totalBorrows));
    const durationSinceLastAccrual = Date.now() / 1000 - bank.lastUpdate;
    const { lendingRate, borrowingRate } = computeInterestRates(bank);
    const outstandingLendingInterest = lendingRate
        .times(durationSinceLastAccrual)
        .dividedBy(SECONDS_PER_YEAR)
        .times(totalDeposits);
    const outstandingBorrowInterest = borrowingRate
        .times(durationSinceLastAccrual)
        .dividedBy(SECONDS_PER_YEAR)
        .times(totalBorrows);
    const depositCapacity = remainingCapacity.minus(outstandingLendingInterest.times(2));
    const borrowCapacity = remainingBorrowCapacity.minus(outstandingBorrowInterest.times(2));
    return {
        depositCapacity,
        borrowCapacity,
    };
}

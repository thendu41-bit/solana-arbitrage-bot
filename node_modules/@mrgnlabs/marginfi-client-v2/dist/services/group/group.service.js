"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makePoolConfigureBankIx = makePoolConfigureBankIx;
exports.makeAddPermissionlessStakedBankIx = makeAddPermissionlessStakedBankIx;
exports.makePoolAddBankIx = makePoolAddBankIx;
const web3_js_1 = require("@solana/web3.js");
const bn_js_1 = __importDefault(require("bn.js"));
const mrgn_common_1 = require("@mrgnlabs/mrgn-common");
const single_spl_pool_1 = require("../../vendor/single-spl-pool");
const bank_1 = require("../bank");
const instructions_1 = __importDefault(require("../../instructions"));
async function makePoolConfigureBankIx(program, bank, args) {
    const ix = await instructions_1.default.makePoolConfigureBankIx(program, {
        bank: bank,
    }, { bankConfigOpt: args });
    return {
        instructions: [ix],
        keys: [],
    };
}
async function makeAddPermissionlessStakedBankIx(program, group, voteAccountAddress, feePayer, pythOracle // wSOL oracle
) {
    const [settingsKey] = web3_js_1.PublicKey.findProgramAddressSync([Buffer.from("staked_settings", "utf-8"), group.toBuffer()], program.programId);
    const poolAddress = (0, single_spl_pool_1.findPoolAddress)(voteAccountAddress);
    const solPool = (0, single_spl_pool_1.findPoolStakeAddress)(poolAddress);
    const lstMint = (0, single_spl_pool_1.findPoolMintAddress)(poolAddress);
    const onRampAddress = (0, single_spl_pool_1.findPoolOnRampAddress)(poolAddress);
    const keys = [
        { pubkey: poolAddress, isSigner: false, isWritable: false },
        { pubkey: onRampAddress, isSigner: false, isWritable: true },
        { pubkey: solPool, isSigner: false, isWritable: false },
        { pubkey: web3_js_1.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
        { pubkey: web3_js_1.SystemProgram.programId, isSigner: false, isWritable: false },
        { pubkey: web3_js_1.StakeProgram.programId, isSigner: false, isWritable: false },
    ];
    // TODO don't hard code the instruction index? (or why not, it's not gna change is it?)
    const data = Buffer.from(Uint8Array.of(6));
    const onrampIx = new web3_js_1.TransactionInstruction({
        keys,
        programId: mrgn_common_1.SINGLE_POOL_PROGRAM_ID,
        data,
    });
    const remainingKeys = [pythOracle, lstMint, solPool];
    const ix = await instructions_1.default.makePoolAddPermissionlessStakedBankIx(program, {
        stakedSettings: settingsKey,
        feePayer: feePayer,
        bankMint: lstMint,
        solPool,
        stakePool: poolAddress,
    }, remainingKeys.map((key) => ({ pubkey: key, isSigner: false, isWritable: false })), {
        seed: new bn_js_1.default(0),
    });
    return {
        instructions: [ix],
        keys: [],
    };
}
async function makePoolAddBankIx(program, group, bank, feePayer, bankMint, bankConfig, tokenProgram = mrgn_common_1.TOKEN_PROGRAM_ID, overrideOpt = {}) {
    let rawBankConfig = (0, bank_1.serializeBankConfigOpt)(bankConfig);
    // TODO verify this is correct
    const rawBankConfigCompact = {
        ...rawBankConfig,
        oracleMaxAge: bankConfig.oracleMaxAge,
        auto_padding_0: [0],
        auto_padding_1: [0],
    };
    const ix = await instructions_1.default.makePoolAddBankIx(program, {
        marginfiGroup: group,
        feePayer,
        bankMint,
        bank,
        tokenProgram,
        ...overrideOpt,
        // if two oracle keys: first is feed id, second is oracle key
    }, {
        bankConfig: rawBankConfigCompact,
    });
    return {
        instructions: [ix], //ix
        keys: [],
    };
}

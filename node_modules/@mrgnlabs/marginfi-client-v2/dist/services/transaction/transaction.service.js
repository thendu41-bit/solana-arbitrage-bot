"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.simulateTransactions = exports.DEFAULT_PROCESS_TX_STRATEGY = exports.DEFAULT_PROCESS_TX_OPTS = exports.MARGINFI_PROGRAM = void 0;
exports.processTransactions = processTransactions;
exports.confirmTransaction = confirmTransaction;
const web3_js_1 = require("@solana/web3.js");
const bs58_1 = __importDefault(require("bs58"));
const mrgn_common_1 = require("@mrgnlabs/mrgn-common");
const errors_1 = require("../../errors");
const helpers_1 = require("./helpers");
// TEMPORARY
exports.MARGINFI_PROGRAM = new web3_js_1.PublicKey("MFv2hWf31Z9kbCa1snEPYctwafyhdvnV7FZnsebVacA");
exports.DEFAULT_PROCESS_TX_OPTS = {
    broadcastType: "RPC",
    isSequentialTxs: true,
    isReadOnly: false,
};
exports.DEFAULT_PROCESS_TX_STRATEGY = {
    splitExecutionsStrategy: {
        singleTx: "RPC",
        multiTx: "RPC",
    },
    // if splitExecutionsStrategy is provided, the fallbackSequence will prioritize the first relevant broadcast method in the array
    fallbackSequence: [
        { method: "GRPC_BUNDLE", broadcastType: "BUNDLE" },
        { method: "API_BUNDLE", broadcastType: "BUNDLE" },
        { method: "RPC_BUNDLE", broadcastType: "RPC" },
        { method: "RPC_SEQUENTIAL", broadcastType: "RPC" },
    ],
};
/**
 * Processes a batch of Solana transactions by signing, simulating, and sending them to the network.
 *
 * @param {ProcessTransactionsProps} props - The properties required to process transactions.
 * @param {SolanaTransaction[]} props.transactions - The transactions to be processed.
 * @param {Connection} props.connection - The connection to the Solana network.
 * @param {Wallet} props.wallet - The wallet used to sign the transactions.
 * @param {ProcessTransactionOpts} [props.processOpts] - Optional processing options.
 * @param {TransactionOptions} [props.txOpts] - Optional transaction options.
 *
 * @returns {Promise<TransactionSignature[]>} - A promise that resolves to an array of transaction signatures.
 *
 * @throws {ProcessTransactionError} - Throws an error if transaction processing fails.
 */
async function processTransactions({ transactions, connection, wallet, processOpts: processOptsArgs, txOpts, }) {
    const processOpts = {
        ...exports.DEFAULT_PROCESS_TX_OPTS,
        ...processOptsArgs,
    };
    const commitment = connection.commitment ?? mrgn_common_1.DEFAULT_CONFIRM_OPTS.commitment;
    if (processOpts?.broadcastType === "BUNDLE" && processOpts?.bundleTipUi === 0) {
        throw new Error("A bundle tip is required for a bundled transactions");
    }
    let broadcastType;
    let finalFallbackMethod;
    const strategy = processOpts.dynamicStrategy ?? exports.DEFAULT_PROCESS_TX_STRATEGY;
    if (processOpts?.broadcastType === "DYNAMIC") {
        if (strategy.splitExecutionsStrategy) {
            if (transactions.length > 1) {
                broadcastType = strategy.splitExecutionsStrategy.multiTx;
            }
            else {
                broadcastType = strategy.splitExecutionsStrategy.singleTx;
            }
        }
        else {
            broadcastType = strategy.fallbackSequence[0].broadcastType;
        }
    }
    else {
        broadcastType = processOpts.broadcastType;
    }
    if (broadcastType === "RPC") {
        finalFallbackMethod = strategy.fallbackSequence.filter((method) => method.broadcastType === "RPC");
    }
    else {
        finalFallbackMethod = strategy.fallbackSequence.filter((method) => method.broadcastType === "BUNDLE");
    }
    let versionedTransactions = [];
    let minContextSlot;
    let blockhash;
    let lastValidBlockHeight;
    try {
        const getLatestBlockhashAndContext = await connection.getLatestBlockhashAndContext(commitment);
        minContextSlot = getLatestBlockhashAndContext.context.slot - 4;
        blockhash = getLatestBlockhashAndContext.value.blockhash;
        lastValidBlockHeight = getLatestBlockhashAndContext.value.lastValidBlockHeight;
    }
    catch (error) {
        console.error("Failed to get latest blockhash and context", error);
        if (error instanceof web3_js_1.SolanaJSONRPCError) {
            throw error;
        }
        throw new errors_1.ProcessTransactionError({
            message: "Failed to get latest blockhash and context.",
            type: errors_1.ProcessTransactionErrorType.TransactionBuildingError,
            failedTxs: transactions,
        });
    }
    let mergedOpts = {
        ...mrgn_common_1.DEFAULT_CONFIRM_OPTS,
        commitment,
        preflightCommitment: commitment,
        minContextSlot,
        ...txOpts,
    };
    let updatedTransactions = transactions;
    try {
        const simulationResult = await (0, exports.simulateTransactions)(processOpts, connection, transactions, mergedOpts, {
            feePayer: wallet.publicKey,
            blockhash,
        });
        const unitsConsumed = (0, helpers_1.isSimulatedTransactionResponse)(simulationResult)
            ? [simulationResult.unitsConsumed]
            : simulationResult.map((tx) => (tx.unitsConsumed ? Number(tx.unitsConsumed) : undefined));
        updatedTransactions = transactions.map((tx, idx) => (0, mrgn_common_1.addTransactionMetadata)(tx, {
            ...tx,
            unitsConsumed: unitsConsumed[idx],
        }));
    }
    catch {
        // only to estimate compute units, final simulation is done just before sending
    }
    const maxCapUi = processOpts.maxCapUi;
    console.log("------ Transaction Details 👇 ------");
    console.log(`📝 Executing ${transactions.length} transaction${transactions.length > 1 ? "s" : ""}`);
    console.log(`📡 Broadcast type: ${broadcastType}`);
    if (broadcastType === "BUNDLE") {
        console.log(`💸 Bundle tip: ${maxCapUi ? Math.min(processOpts.bundleTipUi ?? 0, maxCapUi) : processOpts.bundleTipUi} SOL`);
    }
    else {
        updatedTransactions.forEach((tx, idx) => {
            const cu = tx.unitsConsumed ? Math.min(tx.unitsConsumed + 50_000, 1_400_000) : (0, mrgn_common_1.getComputeBudgetUnits)(tx);
            const priorityFeeUi = maxCapUi
                ? Math.min(processOpts.priorityFeeMicro ? (0, mrgn_common_1.microLamportsToUi)(processOpts.priorityFeeMicro, cu) : 0, maxCapUi)
                : processOpts.priorityFeeMicro
                    ? (0, mrgn_common_1.microLamportsToUi)(processOpts.priorityFeeMicro, cu)
                    : 0;
            console.log(`💸 Priority fee for tx ${idx}: ${priorityFeeUi} SOL`);
        });
    }
    console.log("--------------------------------");
    versionedTransactions = (0, helpers_1.formatTransactions)(updatedTransactions, broadcastType, blockhash, {
        priorityFeeMicro: processOpts.priorityFeeMicro ?? 0,
        bundleTipUi: processOpts.bundleTipUi ?? 0,
        feePayer: wallet.publicKey,
        maxCapUi,
    }, processOpts.addArenaTxTag);
    let signatures = [];
    let bundleSignature;
    try {
        if (txOpts?.dryRun || processOpts?.isReadOnly) {
            return await dryRunTransaction(processOpts, connection, versionedTransactions);
        }
        else {
            let base58Txs = [];
            if (!!wallet.signAllTransactions) {
                versionedTransactions = await wallet.signAllTransactions(versionedTransactions);
                base58Txs = versionedTransactions.map((signedTx) => bs58_1.default.encode(signedTx.serialize()));
            }
            else {
                for (let i = 0; i < versionedTransactions.length; i++) {
                    const signedTx = await wallet.signTransaction(versionedTransactions[i]);
                    const base58Tx = bs58_1.default.encode(signedTx.serialize());
                    base58Txs.push(base58Tx);
                    versionedTransactions[i] = signedTx;
                }
            }
            // Updating after 'sign in wallet' step in toast
            // If the transactions are bundled, we need to advance the toast by the number of transactions.
            if (broadcastType === "BUNDLE") {
                const stepsToAdvance = versionedTransactions.length;
                processOpts.callback?.(undefined, true, undefined, stepsToAdvance);
            }
            else {
                processOpts.callback?.(undefined, true);
            }
            let simulateTxs = null;
            if (!mrgn_common_1.SKIP_SIMULATION) {
                simulateTxs = async () => await (0, exports.simulateTransactions)(processOpts, connection, versionedTransactions, mergedOpts);
            }
            const sendTxBundleGrpc = async (throwError) => await (0, helpers_1.sendTransactionAsGrpcBundle)(connection, base58Txs, throwError);
            const sendTxBundleApi = async (throwError, bundleId) => await (0, helpers_1.sendTransactionAsBundle)(connection, base58Txs, throwError, bundleId);
            const sendTxBundleRpc = async () => await (0, helpers_1.sendTransactionAsBundleRpc)({
                versionedTransactions,
                txOpts,
                connection,
                onCallback: processOpts.callback,
                blockStrategy: { blockhash, lastValidBlockHeight },
                confirmCommitment: mergedOpts.commitment,
                isSequentialTxs: processOpts.isSequentialTxs,
                throwError: true,
            });
            for (const [idx, method] of finalFallbackMethod.entries()) {
                const isLast = idx === finalFallbackMethod.length - 1;
                if (idx === 0 && simulateTxs && !mrgn_common_1.SKIP_SIMULATION) {
                    await simulateTxs();
                }
                let temporaryBundleSignature;
                let sig;
                let sigs;
                switch (method.method) {
                    case "GRPC_BUNDLE":
                        // always throw error, this is temporary as bundle already processed isn't catched well
                        sig = await sendTxBundleGrpc(true).catch((error) => {
                            if (error?.bundleId) {
                                temporaryBundleSignature = error.bundleId;
                            }
                            if (isLast)
                                throw error;
                            return undefined;
                        });
                        if (sig)
                            bundleSignature = sig;
                        break;
                    case "API_BUNDLE":
                        sig = await sendTxBundleApi(isLast, temporaryBundleSignature);
                        if (sig)
                            bundleSignature = sig;
                        break;
                    case "RPC_BUNDLE":
                        sigs = await sendTxBundleRpc();
                        if (sigs)
                            signatures = sigs;
                        break;
                    case "RPC_SEQUENTIAL":
                        console.log("implement");
                        break;
                }
                if (sig || sigs) {
                    break;
                }
            }
            if (bundleSignature || signatures.length > 0) {
                console.log("------ Transaction Success ✅ ------");
                if (bundleSignature) {
                    console.log("Bundle signature:", bundleSignature);
                }
                if (signatures.length > 0) {
                    console.log("Transaction signatures:", signatures.join(", "));
                }
                console.log("--------------------------------");
            }
            if (signatures.length !== 0) {
                return signatures;
            }
            else {
                if (!bundleSignature)
                    throw new Error("API bundle failed: unknown error");
                return [bundleSignature];
            }
        }
    }
    catch (error) {
        const failedTxs = transactions.splice(signatures.length);
        if (error instanceof web3_js_1.SolanaJSONRPCError) {
            throw error;
        }
        if (error instanceof errors_1.ProcessTransactionError) {
            throw errors_1.ProcessTransactionError.withFailedTransactions(error, failedTxs);
        }
        if (error instanceof helpers_1.SendBundleError) {
            // the bundle failed to land not much info we can gather from failing bundles
            throw new errors_1.ProcessTransactionError({
                message: error.message,
                type: errors_1.ProcessTransactionErrorType.TransactionSendingError,
                programId: exports.MARGINFI_PROGRAM.toBase58(),
                failedTxs: failedTxs,
            });
        }
        const parsedError = (0, errors_1.parseTransactionError)(error, processOpts?.programId ?? exports.MARGINFI_PROGRAM);
        if (error?.logs?.length > 0) {
            console.log("------ Logs 👇 ------");
            console.log(error.logs.join("\n"));
            if (parsedError) {
                console.log("Parsed:", parsedError);
                throw new errors_1.ProcessTransactionError({
                    message: parsedError.description,
                    type: errors_1.ProcessTransactionErrorType.TransactionSendingError,
                    logs: error.logs,
                    programId: parsedError.programId,
                });
            }
        }
        console.log("fallthrough error", error);
        throw new errors_1.ProcessTransactionError({
            message: parsedError?.description ?? "Something went wrong",
            type: errors_1.ProcessTransactionErrorType.FallthroughError,
            logs: error.logs,
            programId: parsedError.programId,
        });
    }
}
const simulateTransactions = async (processOpts, connection, solanaTransactions, confirmOpts, txOpts) => {
    const v0Txs = solanaTransactions.map((tx) => ((0, mrgn_common_1.isV0Tx)(tx) ? tx : (0, mrgn_common_1.legacyTxToV0Tx)(tx, txOpts)));
    try {
        if (v0Txs.length > 1) {
            const response = await (0, helpers_1.simulateBundle)(processOpts?.bundleSimRpcEndpoint ?? connection.rpcEndpoint, v0Txs);
            return response;
        }
        else {
            const response = await connection.simulateTransaction(v0Txs[0], {
                sigVerify: false,
                commitment: confirmOpts?.commitment,
                replaceRecentBlockhash: false,
                minContextSlot: confirmOpts?.minContextSlot,
            });
            if (response.value.err) {
                const error = response.value.err;
                const parsedError = (0, errors_1.parseTransactionError)(error, processOpts?.programId ?? exports.MARGINFI_PROGRAM);
                throw new errors_1.ProcessTransactionError({
                    message: parsedError.description ?? JSON.stringify(response.value.err),
                    type: errors_1.ProcessTransactionErrorType.SimulationError,
                    logs: response.value.logs ?? [],
                    programId: parsedError.programId,
                });
            }
            return response.value;
        }
    }
    catch (error) {
        if (error instanceof helpers_1.BundleSimulationError) {
            const parsedError = (0, errors_1.parseTransactionError)(error, processOpts?.programId ?? exports.MARGINFI_PROGRAM);
            throw new errors_1.ProcessTransactionError({
                message: parsedError.description,
                type: errors_1.ProcessTransactionErrorType.SimulationError,
                logs: error.logs,
                programId: parsedError.programId,
            });
        }
        throw error;
    }
};
exports.simulateTransactions = simulateTransactions;
const dryRunTransaction = async (processOpts, connection, versionedTransactions) => {
    try {
        const response = await (0, helpers_1.simulateBundle)(processOpts?.bundleSimRpcEndpoint ?? connection.rpcEndpoint, versionedTransactions);
        console.log("------ Units Consumed 👇 ------");
        for (const tx of response) {
            console.log(`✅ Success - ${tx.unitsConsumed} CU`);
        }
        console.log("------ Logs 👇 ------");
        for (const tx of response) {
            console.log(tx.logs);
        }
    }
    catch (error) {
        if (error instanceof helpers_1.BundleSimulationError) {
            console.log(`❌ Error: ${error.message}`);
            console.log("------ Logs 👇 ------");
            if (error.logs) {
                for (const log of error.logs) {
                    console.log(log);
                }
            }
        }
        throw error;
    }
    return [];
};
async function confirmTransaction(connection, signature, commitment = "confirmed") {
    const getStatus = async () => {
        const commitmentArray = ["processed", "confirmed", "finalized"];
        const index = commitmentArray.indexOf(commitment);
        if (index === -1)
            throw new Error("Invalid commitment");
        let attempts = 0;
        const maxAttempts = 8;
        while (attempts < maxAttempts) {
            attempts += 1;
            const status = await connection.getSignatureStatus(signature);
            if (status?.value?.err) {
                console.error("❌ Error:", status.value.err);
                throw status.value.err;
            }
            if (status?.value && status.value.confirmationStatus) {
                const confirmationStatusIndex = commitmentArray.indexOf(status.value.confirmationStatus);
                if (confirmationStatusIndex >= index) {
                    return status.value;
                }
            }
            console.log("🔄 Waiting for confirmation...");
            await (0, mrgn_common_1.sleep)(2000);
        }
        console.log("❌ Transaction failed to confirm in time.");
        throw new Error("Transaction failed to confirm in time.");
    };
    const result = await Promise.race([getStatus(), (0, mrgn_common_1.setTimeoutPromise)(20000, `Transaction failed to confirm in time.`)]);
    if (result instanceof Error) {
        throw result;
    }
    return result;
}

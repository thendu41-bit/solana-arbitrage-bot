"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendTransactionAsBundleRpc = sendTransactionAsBundleRpc;
const transaction_service_1 = require("../transaction.service");
const errors_1 = require("../../../errors");
async function sendTransactionAsBundleRpc({ versionedTransactions, txOpts, connection, onCallback, blockStrategy, confirmCommitment, isSequentialTxs, throwError = false, }) {
    let signatures = [];
    let hasValidationErrors = false;
    if (isSequentialTxs) {
        for (const [index, tx] of versionedTransactions.entries()) {
            let signature;
            try {
                signature = await connection.sendTransaction(tx, txOpts);
            }
            catch (error) {
                // Handle the specific "fallthrough error ea" and other sendTransaction errors
                const errorMessage = error instanceof Error ? error.message : String(error);
                if (errorMessage.includes("Expected the value to satisfy a union") ||
                    errorMessage.includes("satisfy a union")) {
                    console.warn("Transaction type validation error:", errorMessage);
                    // onCallback?.(index, true, "");
                    hasValidationErrors = true;
                    continue;
                }
                else {
                    onCallback?.(index, false, "");
                    throw error;
                }
            }
            if (signature) {
                try {
                    await (0, transaction_service_1.confirmTransaction)(connection, signature, confirmCommitment);
                    onCallback?.(index, true, signature);
                }
                catch (error) {
                    onCallback?.(index, false, signature);
                    throw error;
                }
                signatures.push(signature);
            }
        }
        // Throw user-friendly error if validation errors occurred
        if (hasValidationErrors) {
            onCallback?.(versionedTransactions.length, true, "The transaction may have landed on-chain but confirmation failed.");
            signatures.push("The transaction may have landed on-chain but confirmation failed.");
        }
    }
    else {
        signatures = await Promise.all(versionedTransactions.map(async (versionedTransaction, index) => {
            try {
                const signature = await connection.sendTransaction(versionedTransaction, txOpts);
                return signature;
            }
            catch (error) {
                // Handle the specific "fallthrough error ea" and other sendTransaction errors
                const errorMessage = error instanceof Error ? error.message : String(error);
                if (errorMessage.includes("Expected the value to satisfy a union") ||
                    errorMessage.includes("satisfy a union")) {
                    console.warn("Transaction type validation error:", errorMessage);
                    onCallback?.(index, false, "");
                    hasValidationErrors = true;
                    return ""; // Return empty signature to continue processing
                }
                // Re-throw other errors
                onCallback?.(index, false, "");
                throw error;
            }
        }));
        // Filter out empty signatures from failed transactions
        signatures = signatures.filter((sig) => sig !== "");
        // Throw user-friendly error if validation errors occurred
        if (hasValidationErrors) {
            throw new errors_1.ProcessTransactionError({
                message: "Transaction confirmation failed. The transaction may have landed on-chain but confirmation failed. Please check your wallet and try again.",
                type: errors_1.ProcessTransactionErrorType.TransactionTupleError,
            });
        }
        await Promise.all(signatures.map(async (signature, index) => {
            try {
                const result = await (0, transaction_service_1.confirmTransaction)(connection, signature, confirmCommitment);
                onCallback?.(index, true, signature);
                return result;
            }
            catch (error) {
                onCallback?.(index, false, signature);
                throw error;
            }
        }));
    }
    return signatures;
}

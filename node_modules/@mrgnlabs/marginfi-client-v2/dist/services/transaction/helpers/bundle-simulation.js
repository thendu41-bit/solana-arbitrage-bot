"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BundleSimulationError = void 0;
exports.isSimulatedTransactionResponse = isSimulatedTransactionResponse;
exports.simulateBundle = simulateBundle;
const web3_js_1 = require("@solana/web3.js");
class BundleSimulationError extends Error {
    constructor(message, logs, cause) {
        super(message);
        this.logs = logs;
        this.cause = cause;
        this.name = "BundleSimulationError";
    }
    static fromHttpError(status, statusText) {
        return new BundleSimulationError(`HTTP error ${status}: ${statusText}`);
    }
    static fromEncodingError(error, index) {
        return new BundleSimulationError(`Failed to encode transaction${index !== undefined ? ` at index ${index}` : "s"}`);
    }
}
exports.BundleSimulationError = BundleSimulationError;
function isSimulatedTransactionResponse(response) {
    return !Array.isArray(response) && "err" in response;
}
async function simulateBundle(rpcEndpoint, transactions, includeAccounts) {
    // Validate input
    if (!transactions.length) {
        throw new BundleSimulationError("No bundle provided for simulation");
    }
    try {
        // Prepare transaction data
        const encodedTransactions = encodeTransactions(transactions);
        const config = createBundleConfig(transactions, includeAccounts);
        // Execute simulation
        const result = await executeBundleSimulation(rpcEndpoint, encodedTransactions, config);
        return result;
    }
    catch (error) {
        // If it's already a SolanaJSONRPCError or BundleSimulationError, rethrow it
        if (error instanceof web3_js_1.SolanaJSONRPCError || error instanceof BundleSimulationError) {
            throw error;
        }
        else {
            throw new BundleSimulationError("Failed to execute bundle simulation", undefined, error);
        }
    }
}
function encodeTransactions(transactions) {
    try {
        return transactions.map((tx, index) => {
            try {
                const serialized = tx.serialize();
                return Buffer.from(serialized).toString("base64");
            }
            catch (error) {
                throw BundleSimulationError.fromEncodingError(error, index);
            }
        });
    }
    catch (error) {
        if (error instanceof BundleSimulationError)
            throw error;
        throw BundleSimulationError.fromEncodingError(error);
    }
}
function createBundleConfig(transactions, includeAccounts) {
    return {
        skipSigVerify: true,
        replaceRecentBlockhash: true,
        preExecutionAccountsConfigs: transactions.map(() => ({ addresses: [] })),
        postExecutionAccountsConfigs: transactions.map((_, index) => ({
            addresses: index === transactions.length - 1 && includeAccounts
                ? includeAccounts.map((account) => account.toBase58())
                : [],
        })),
    };
}
async function executeBundleSimulation(rpcEndpoint, encodedTransactions, config) {
    const response = await fetch(rpcEndpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
            jsonrpc: "2.0",
            id: 1,
            method: "simulateBundle",
            params: [{ encodedTransactions }, config],
        }),
    });
    if (!response.ok) {
        throw BundleSimulationError.fromHttpError(response.status, response.statusText);
    }
    const jsonResponse = (await response.json());
    if ("error" in jsonResponse) {
        throw jsonResponse.error;
    }
    const value = jsonResponse.result.value;
    if (value.summary !== "succeeded") {
        const logs = value.transactionResults.flatMap((tx) => tx.logs);
        throw new BundleSimulationError(JSON.stringify(value.summary.failed.error), logs);
    }
    return value.transactionResults;
}

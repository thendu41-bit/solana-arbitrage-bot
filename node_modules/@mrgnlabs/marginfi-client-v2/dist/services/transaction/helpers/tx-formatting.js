"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PRIORITY_TX_SIZE = exports.BUNDLE_TX_SIZE = exports.MAX_TX_SIZE = void 0;
exports.isFlashloan = isFlashloan;
exports.isSecp256k1 = isSecp256k1;
exports.formatTransactions = formatTransactions;
const web3_js_1 = require("@solana/web3.js");
const mrgn_common_1 = require("@mrgnlabs/mrgn-common");
const idl_1 = require("../../../idl");
const account_1 = require("../../../models/account");
const utils_1 = require("../../../utils");
// Temporary imports
exports.MAX_TX_SIZE = 1232;
exports.BUNDLE_TX_SIZE = 81;
exports.PRIORITY_TX_SIZE = 44;
function isFlashloan(tx) {
    if ((0, mrgn_common_1.isV0Tx)(tx)) {
        const addressLookupTableAccounts = tx.addressLookupTables ?? [];
        const message = (0, mrgn_common_1.decompileV0Transaction)(tx, addressLookupTableAccounts);
        const idl = { ...idl_1.MARGINFI_IDL, address: new web3_js_1.PublicKey(0) };
        const decoded = message.instructions.map((ix) => (0, mrgn_common_1.decodeInstruction)(idl, ix.data));
        return decoded.some((ix) => ix?.name.toLowerCase().includes("flashloan"));
    }
    //TODO: add legacy tx check
    return false;
}
function isSecp256k1(tx) {
    if ((0, mrgn_common_1.isV0Tx)(tx)) {
        const addressLookupTableAccounts = tx.addressLookupTables ?? [];
        const message = (0, mrgn_common_1.decompileV0Transaction)(tx, addressLookupTableAccounts);
        const decoded = message.instructions.some((ix) => ix.programId.equals(new web3_js_1.PublicKey("KeccakSecp256k11111111111111111111111111111")));
        return decoded;
    }
    //TODO: add legacy tx check
    return false;
}
function getFlashloanIndex(transactions) {
    for (const [index, transaction] of transactions.entries()) {
        if (isFlashloan(transaction)) {
            return index;
        }
    }
    return null;
}
function getSecp256k1Index(transactions) {
    for (const [index, transaction] of transactions.entries()) {
        if (isSecp256k1(transaction)) {
            return index;
        }
    }
    return null;
}
/**
 * Formats a list of Solana transactions into versioned transactions, applying
 * necessary settings such as fees and blockhash. Optionally adds transaction tags.
 *
 * @param {SolanaTransaction[]} transactionsArg - The array of Solana transactions to format.
 * @param {TransactionBroadcastType} broadcastType - The type of transaction broadcast to use.
 * @param {string} blockhash - The recent blockhash to set for the transactions.
 * @param {FeeSettings} feeSettings - The settings for transaction fees, including priority fee and bundle tip.
 * @param {boolean} [addTransactionTags] - Optional flag to add transaction tags.
 * @returns {VersionedTransaction[]} - The array of formatted versioned transactions.
 */
function formatTransactions(transactionsArg, broadcastType, blockhash, feeSettings, addTransactionTags) {
    let formattedTransactions = [];
    const { priorityFeeMicro, bundleTipUi, feePayer, maxCapUi } = feeSettings;
    const flashloanIndex = getFlashloanIndex(transactionsArg);
    const secp256k1Index = getSecp256k1Index(transactionsArg);
    transactionsArg.forEach((tx) => {
        if (!(0, mrgn_common_1.isV0Tx)(tx)) {
            tx.recentBlockhash = blockhash;
            tx.feePayer = feePayer;
        }
    });
    let transactions = addTransactionTags ? addTransactionTxTags(transactionsArg) : transactionsArg;
    const txSizes = transactions.map((tx) => (0, mrgn_common_1.getTxSize)(tx));
    const dummyPriorityFeeIx = (0, utils_1.makePriorityFeeMicroIx)(1);
    const priorityIxs = [];
    const cuLimitIxs = [];
    transactions.forEach((tx, idx) => {
        const cu = tx.unitsConsumed ? Math.min(tx.unitsConsumed + 50_000, 1_400_000) : (0, mrgn_common_1.getComputeBudgetUnits)(tx);
        const priorityFeeUi = maxCapUi
            ? Math.min((0, mrgn_common_1.microLamportsToUi)(priorityFeeMicro, cu), maxCapUi)
            : (0, mrgn_common_1.microLamportsToUi)(priorityFeeMicro, cu);
        let updatedFees = (0, mrgn_common_1.uiToMicroLamports)(priorityFeeUi, cu);
        // don't want to pay more than 0.1 SOL in fees
        if (priorityFeeUi > 0.1) {
            updatedFees = (0, mrgn_common_1.uiToMicroLamports)(0.1, cu);
        }
        priorityIxs.push(broadcastType === "BUNDLE" ? dummyPriorityFeeIx : (0, utils_1.makePriorityFeeMicroIx)(updatedFees));
        cuLimitIxs.push(cu ? web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({ units: cu }) : undefined);
    });
    const { bundleTipIx } = (0, account_1.makeTxPriorityIx)(feePayer, maxCapUi ? Math.min(bundleTipUi, maxCapUi) : bundleTipUi, broadcastType);
    let bundleTipIndex = broadcastType === "BUNDLE" ? -1 : null; // if index is -1 in the end, then add bundle tx
    const priorityFeeIndexes = [];
    for (let i = 0; i < txSizes.length; i++) {
        let baseTxSize = txSizes[i];
        if (flashloanIndex !== i) {
            if (bundleTipIndex === -1 && txSizes[i] + exports.BUNDLE_TX_SIZE < exports.MAX_TX_SIZE) {
                baseTxSize += exports.BUNDLE_TX_SIZE;
                bundleTipIndex = i;
            }
        }
        if (flashloanIndex === i || baseTxSize + exports.PRIORITY_TX_SIZE < exports.MAX_TX_SIZE) {
            priorityFeeIndexes.push(i);
        }
    }
    // no space for bundle tip, so add seperate tx
    if (bundleTipIndex === -1 && bundleTipIx) {
        const bundleTipMessage = new web3_js_1.TransactionMessage({
            instructions: [bundleTipIx],
            payerKey: feePayer,
            recentBlockhash: blockhash,
        });
        formattedTransactions.push(new web3_js_1.VersionedTransaction(bundleTipMessage.compileToV0Message()));
    }
    for (const [index, transaction] of transactions.entries()) {
        const hasFlashloan = flashloanIndex !== null; // check if there is a flashloan
        const isTxFlashloan = hasFlashloan && flashloanIndex === index; // check if the tx is the flashloan tx
        const isTxSecp256k1 = secp256k1Index === index;
        const signers = transaction.signers ?? [];
        const addressLookupTables = transaction.addressLookupTables ?? [];
        const requiredIxs = [
            ...(bundleTipIndex === index && bundleTipIx ? [bundleTipIx] : []),
            ...(priorityFeeIndexes.includes(index) ? [priorityIxs[index]] : []),
            ...(cuLimitIxs[index] ? [cuLimitIxs[index]] : []),
        ];
        let newTransaction;
        if ((0, mrgn_common_1.isV0Tx)(transaction)) {
            newTransaction = (0, mrgn_common_1.updateV0Tx)(transaction, {
                addressLookupTables,
                additionalIxs: requiredIxs,
                blockhash,
                replaceOnly: isTxFlashloan,
                indexOffset: isTxSecp256k1 ? 1 : undefined,
            });
        }
        else {
            newTransaction = (0, mrgn_common_1.legacyTxToV0Tx)(transaction, {
                addressLookupTables,
                additionalIxs: requiredIxs,
                blockhash,
                replaceOnly: isTxFlashloan,
                indexOffset: isTxSecp256k1 ? 1 : undefined,
            });
        }
        newTransaction.sign(signers);
        formattedTransactions.push(newTransaction);
    }
    return formattedTransactions;
}
function addTransactionTxTags(transactions) {
    const txWithTags = [];
    for (const [_, tx] of transactions.entries()) {
        let solanaTx = tx;
        const arenaKey = mrgn_common_1.TransactionArenaKeyMap[tx.type];
        if (arenaKey) {
            if ((0, mrgn_common_1.isV0Tx)(solanaTx)) {
                console.log("tx", solanaTx);
                const addressLookupTableAccounts = solanaTx.addressLookupTables ?? [];
                const message = (0, mrgn_common_1.decompileV0Transaction)(solanaTx, addressLookupTableAccounts);
                message.instructions[0].keys.push({
                    pubkey: arenaKey,
                    isSigner: false,
                    isWritable: false,
                });
                solanaTx = (0, mrgn_common_1.addTransactionMetadata)(new web3_js_1.VersionedTransaction(message.compileToV0Message(tx.addressLookupTables)), {
                    signers: solanaTx.signers,
                    addressLookupTables: solanaTx.addressLookupTables,
                    type: solanaTx.type,
                    unitsConsumed: solanaTx.unitsConsumed,
                });
            }
            else {
                solanaTx.instructions[0].keys.push({
                    pubkey: arenaKey,
                    isSigner: false,
                    isWritable: false,
                });
            }
        }
        txWithTags.push(solanaTx);
    }
    return txWithTags;
}

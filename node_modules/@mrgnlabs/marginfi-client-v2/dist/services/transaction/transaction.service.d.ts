import { VersionedTransaction, Transaction, TransactionSignature, Connection, ConfirmOptions, PublicKey, Commitment, SimulatedTransactionResponse } from "@solana/web3.js";
import { TransactionOptions, TransactionBroadcastType, Wallet, SolanaTransaction } from "@mrgnlabs/mrgn-common";
import { RpcSimulateBundleTransactionResult } from "./helpers";
export declare const MARGINFI_PROGRAM: PublicKey;
export declare const DEFAULT_PROCESS_TX_OPTS: {
    broadcastType: TransactionBroadcastType;
    isSequentialTxs: boolean;
    isReadOnly: boolean;
};
export interface ProcessTransactionOpts extends ProcessTransactionsClientOpts {
    isReadOnly?: boolean;
    programId?: PublicKey;
    bundleSimRpcEndpoint?: string;
    addArenaTxTag?: boolean;
}
export type PriorityFees = {
    bundleTipUi?: number;
    priorityFeeMicro?: number;
    maxCapUi?: number;
};
export type BroadcastMethodType = Extract<TransactionBroadcastType, "BUNDLE" | "RPC">;
export type SpecificBroadcastMethodType = "GRPC_BUNDLE" | "API_BUNDLE" | "RPC_BUNDLE" | "RPC_SEQUENTIAL";
export type SpecificBroadcastMethod = {
    method: SpecificBroadcastMethodType;
    broadcastType: BroadcastMethodType;
};
export type ProcessTransactionStrategy = {
    splitExecutionsStrategy?: {
        singleTx: BroadcastMethodType;
        multiTx: BroadcastMethodType;
    };
    fallbackSequence: SpecificBroadcastMethod[];
};
export declare const DEFAULT_PROCESS_TX_STRATEGY: ProcessTransactionStrategy;
export interface ProcessTransactionsClientOpts extends PriorityFees {
    broadcastType?: TransactionBroadcastType;
    dynamicStrategy?: ProcessTransactionStrategy;
    isSequentialTxs?: boolean;
    addArenaTxTag?: boolean;
    callback?: (index?: number, success?: boolean, signature?: string, stepsToAdvance?: number) => void;
}
type ProcessTransactionsProps = {
    transactions: SolanaTransaction[];
    connection: Connection;
    wallet: Wallet;
    txOpts?: TransactionOptions;
    processOpts?: ProcessTransactionOpts;
};
/**
 * Processes a batch of Solana transactions by signing, simulating, and sending them to the network.
 *
 * @param {ProcessTransactionsProps} props - The properties required to process transactions.
 * @param {SolanaTransaction[]} props.transactions - The transactions to be processed.
 * @param {Connection} props.connection - The connection to the Solana network.
 * @param {Wallet} props.wallet - The wallet used to sign the transactions.
 * @param {ProcessTransactionOpts} [props.processOpts] - Optional processing options.
 * @param {TransactionOptions} [props.txOpts] - Optional transaction options.
 *
 * @returns {Promise<TransactionSignature[]>} - A promise that resolves to an array of transaction signatures.
 *
 * @throws {ProcessTransactionError} - Throws an error if transaction processing fails.
 */
export declare function processTransactions({ transactions, connection, wallet, processOpts: processOptsArgs, txOpts, }: ProcessTransactionsProps): Promise<TransactionSignature[]>;
export declare const simulateTransactions: (processOpts: ProcessTransactionOpts, connection: Connection, solanaTransactions: VersionedTransaction[] | Transaction[] | SolanaTransaction[], confirmOpts?: ConfirmOptions, txOpts?: {
    feePayer: PublicKey;
    blockhash: string;
}) => Promise<SimulatedTransactionResponse | RpcSimulateBundleTransactionResult[]>;
export declare function confirmTransaction(connection: Connection, signature: string, commitment?: Commitment): Promise<import("@solana/web3.js").SignatureStatus>;
export {};
//# sourceMappingURL=transaction.service.d.ts.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchOracleData = exports.fetchSwbOracleData = exports.fetchPythOracleData = void 0;
const web3_js_1 = require("@solana/web3.js");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const utils_1 = require("../../../utils");
/**
 * Categorizes banks by their oracle setup type
 */
const categorizePythBanks = (banks) => {
    const pythMigratedBanks = banks.filter((bank) => (bank.data.config.oracleSetup && "pythLegacy" in bank.data.config.oracleSetup) ||
        (bank.data.config.oracleSetup &&
            "pythPushOracle" in bank.data.config.oracleSetup &&
            bank.data.config.configFlags === 1));
    const pythPushBanks = banks.filter((bank) => bank.data.config.oracleSetup &&
        "pythPushOracle" in bank.data.config.oracleSetup &&
        bank.data.config.configFlags !== 1);
    const pythStakedCollateralBanks = banks.filter((bank) => bank.data.config.oracleSetup && "stakedWithPythPush" in bank.data.config.oracleSetup);
    return { pythMigratedBanks, pythPushBanks, pythStakedCollateralBanks };
};
/**
 * Fetches Pyth feed map and staked collateral data via API endpoints
 */
const fetchPythDataViaAPI = async (pythPushBanks, voteAccMintTuples) => {
    const pythFeedMapPromise = pythPushBanks.length > 0
        ? fetch("/api/bankData/pythFeedMap?feedIds=" +
            pythPushBanks.map((bank) => bank.data.config.oracleKeys[0].toBase58()).join(","))
        : undefined;
    const encodedQuery = encodeURIComponent(JSON.stringify(voteAccMintTuples));
    const stakedCollatDataPromise = fetch(`/api/stakeData/stakedCollatData?voteAccMintTuple=${encodedQuery}`);
    const [pythFeedMapResponse, stakedCollatDataResponse] = await Promise.all([
        pythFeedMapPromise,
        stakedCollatDataPromise,
    ]);
    if (pythFeedMapResponse && !pythFeedMapResponse?.ok) {
        throw new Error("Failed to fetch pyth feed map");
    }
    if (!stakedCollatDataResponse.ok) {
        throw new Error("Failed to fetch staked collateral data");
    }
    const pythFeedMapJson = (await pythFeedMapResponse?.json()) ?? {};
    const stakedCollatDataJson = await stakedCollatDataResponse.json();
    // Build pythFeedMap
    const pythFeedMap = new Map();
    Object.entries(pythFeedMapJson).forEach(([feedId, { feedId: feedIdStr, shardId }]) => {
        pythFeedMap.set(feedId, { feedId: new web3_js_1.PublicKey(feedIdStr), shardId });
    });
    return { pythFeedMap, priceCoeffByBank: stakedCollatDataJson };
};
/**
 * Fetches Pyth feed map via direct connection (non-API)
 */
const fetchPythDataDirect = async (banks, connection) => {
    const pythFeedMap = await (0, utils_1.buildFeedIdMap)(banks.map((bank) => bank.data.config), connection);
    const priceCoeffByBank = {};
    return { pythFeedMap, priceCoeffByBank };
};
/**
 * Converts vote account coefficients to bank address coefficients
 */
const convertVoteAccCoeffsToBankCoeffs = (pythStakedCollateralBanks, bankMetadataMap, voteAccCoeffs) => {
    const priceCoeffByBank = {};
    pythStakedCollateralBanks.forEach((bank) => {
        const voteAccount = bankMetadataMap[bank.address.toBase58()]?.validatorVoteAccount;
        if (voteAccount && voteAccCoeffs[voteAccount] !== undefined) {
            priceCoeffByBank[bank.address.toBase58()] = voteAccCoeffs[voteAccount];
        }
    });
    return priceCoeffByBank;
};
/**
 * Extracts oracle keys for Pyth price fetching
 */
const extractPythOracleKeys = (pythLegacyBanks, pythPushBanks, pythFeedMap) => {
    const legacyKeys = pythLegacyBanks.map((bank) => bank.data.config.oracleKeys[0].toBase58());
    const pushKeys = pythPushBanks.map((bank) => {
        const feed = pythFeedMap.get(bank.data.config.oracleKeys[0].toBuffer().toString("hex"));
        if (!feed) {
            throw new Error("Feed not found");
        }
        return feed.feedId.toBase58();
    });
    return [...legacyKeys, ...pushKeys];
};
/**
 * Fetches oracle prices via API endpoint
 */
const fetchPythOraclePricesViaAPI = async (pythOracleKeys) => {
    const response = await fetch("/api/bankData/pythOracleData?pythOracleKeys=" + pythOracleKeys.join(","));
    if (!response.ok) {
        throw new Error("Failed to fetch pyth oracle data");
    }
    const responseBody = await response.json();
    return Object.fromEntries(Object.entries(responseBody).map(([key, oraclePrice]) => [
        key,
        {
            priceRealtime: {
                price: (0, bignumber_js_1.default)(oraclePrice.priceRealtime.price),
                confidence: (0, bignumber_js_1.default)(oraclePrice.priceRealtime.confidence),
                lowestPrice: (0, bignumber_js_1.default)(oraclePrice.priceRealtime.lowestPrice),
                highestPrice: (0, bignumber_js_1.default)(oraclePrice.priceRealtime.highestPrice),
            },
            priceWeighted: {
                price: (0, bignumber_js_1.default)(oraclePrice.priceWeighted.price),
                confidence: (0, bignumber_js_1.default)(oraclePrice.priceWeighted.confidence),
                lowestPrice: (0, bignumber_js_1.default)(oraclePrice.priceWeighted.lowestPrice),
                highestPrice: (0, bignumber_js_1.default)(oraclePrice.priceWeighted.highestPrice),
            },
            timestamp: oraclePrice.timestamp ? (0, bignumber_js_1.default)(oraclePrice.timestamp) : null,
            pythShardId: oraclePrice.pythShardId,
        },
    ]));
};
/**
 * Maps banks to their corresponding oracle prices
 */
const mapPythBanksToOraclePrices = (pythMigratedBanks, pythPushBanks, pythStakedCollateralBanks, pythFeedMap, oraclePrices, priceCoeffByBank) => {
    const bankOraclePriceMap = new Map();
    // Map legacy banks
    pythMigratedBanks.forEach((bank) => {
        const oracleKey = bank.data.config.oracleKeys[0].toBase58();
        const oraclePrice = oraclePrices[oracleKey];
        if (oraclePrice) {
            bankOraclePriceMap.set(bank.address.toBase58(), oraclePrice);
        }
    });
    // Map push oracle banks
    pythPushBanks.forEach((bank) => {
        const feed = pythFeedMap.get(bank.data.config.oracleKeys[0].toBuffer().toString("hex"));
        if (feed) {
            const oraclePrice = oraclePrices[feed.feedId.toBase58()];
            if (oraclePrice) {
                bankOraclePriceMap.set(bank.address.toBase58(), oraclePrice);
            }
        }
    });
    // Map staked collateral banks with price coefficient adjustment
    pythStakedCollateralBanks.forEach((bank) => {
        const priceCoeff = priceCoeffByBank[bank.address.toBase58()];
        const oracleKey = bank.data.config.oracleKeys[0].toBase58();
        if (oracleKey && priceCoeff !== undefined) {
            const oraclePrice = oraclePrices[oracleKey];
            if (oraclePrice) {
                bankOraclePriceMap.set(bank.address.toBase58(), {
                    timestamp: oraclePrice.timestamp,
                    priceRealtime: adjustPriceComponent(oraclePrice.priceRealtime, priceCoeff),
                    priceWeighted: adjustPriceComponent(oraclePrice.priceWeighted, priceCoeff),
                });
            }
        }
    });
    return bankOraclePriceMap;
};
const fetchPythOracleData = async (banks, bankMetadataMap, connection, opts) => {
    // Step 1: Categorize banks by oracle type
    const { pythMigratedBanks, pythPushBanks, pythStakedCollateralBanks } = categorizePythBanks(banks);
    // Step 2: Prepare vote account mint tuples for staked collateral
    const voteAccMintTuples = pythStakedCollateralBanks.map((bank) => [
        bankMetadataMap[bank.address.toBase58()]?.validatorVoteAccount ?? "",
        bank.data.mint?.toBase58() ?? "",
    ]);
    // Step 3: Fetch Pyth feed map and price coefficients
    let pythFeedMap;
    let priceCoeffByBank;
    if (opts?.useApiEndpoint || !connection) {
        const { pythFeedMap: feedMap, priceCoeffByBank: voteAccCoeffs } = await fetchPythDataViaAPI(pythPushBanks, voteAccMintTuples);
        pythFeedMap = feedMap;
        priceCoeffByBank = convertVoteAccCoeffsToBankCoeffs(pythStakedCollateralBanks, bankMetadataMap, voteAccCoeffs);
    }
    else {
        const result = await fetchPythDataDirect(banks, connection);
        pythFeedMap = result.pythFeedMap;
        priceCoeffByBank = result.priceCoeffByBank;
    }
    // Step 4: Extract oracle keys for price fetching
    const pythOracleKeys = extractPythOracleKeys(pythMigratedBanks, pythPushBanks, pythFeedMap);
    // Step 5: Fetch oracle prices
    let oraclePrices;
    if (opts?.useApiEndpoint) {
        oraclePrices = await fetchPythOraclePricesViaAPI(pythOracleKeys);
    }
    else {
        // Handle non-API endpoint case - placeholder for now
        oraclePrices = {};
    }
    // Step 6: Map banks to oracle prices
    const bankOraclePriceMap = mapPythBanksToOraclePrices(pythMigratedBanks, pythPushBanks, pythStakedCollateralBanks, pythFeedMap, oraclePrices, priceCoeffByBank);
    return {
        pythFeedMap,
        bankOraclePriceMap,
    };
};
exports.fetchPythOracleData = fetchPythOracleData;
const adjustPriceComponent = (priceComponent, priceCoeff) => ({
    price: priceComponent.price.multipliedBy(priceCoeff),
    confidence: priceComponent.confidence,
    lowestPrice: priceComponent.lowestPrice.multipliedBy(priceCoeff),
    highestPrice: priceComponent.highestPrice.multipliedBy(priceCoeff),
});
/**
 * =============================================================================
 * SWITCHBOARD ORACLE UTILS
 * =============================================================================
 *
 * Utility functions for fetching Switchboard oracle data
 */
const fetchSwbOracleData = async (banks, opts) => {
    // Step 1: Fetch Switchboard oracle map
    const switchboardBanks = banks.filter((bank) => bank.data.config.oracleSetup &&
        ("switchboardPull" in bank.data.config.oracleSetup || "switchboardV2" in bank.data.config.oracleSetup));
    let oracleKeyMap;
    if (opts?.useApiEndpoint) {
        const { oracleKeyMap: swbOracleKeyMap } = await fetchSwbDataViaAPI(switchboardBanks);
        oracleKeyMap = swbOracleKeyMap;
    }
    else {
        oracleKeyMap = {};
    }
    // Step 4: Extract oracle keys for price fetching
    const swbFeedIds = Object.values(oracleKeyMap).map((oracleKey) => oracleKey.feedId);
    // Step 5: Fetch oracle prices
    let oraclePrices;
    if (opts?.useApiEndpoint) {
        oraclePrices = await fetchSwbOraclePricesViaAPI(swbFeedIds);
    }
    else {
        // Handle non-API endpoint case - placeholder for now
        oraclePrices = {};
    }
    // Step 6: Map switchboardBanks to oracle prices
    const bankOraclePriceMap = mapSwbBanksToOraclePrices(switchboardBanks, oraclePrices, oracleKeyMap);
    return {
        bankOraclePriceMap,
    };
};
exports.fetchSwbOracleData = fetchSwbOracleData;
/**
 * Fetches Pyth feed map and staked collateral data via API endpoints
 */
const fetchSwbDataViaAPI = async (swbPullBanks) => {
    const swbOracleKeyMapResponse = await fetch("/api/bankData/swbOracleMap?oracleKeys=" +
        swbPullBanks.map((bank) => bank.data.config.oracleKeys[0].toBase58()).join(","));
    if (!swbOracleKeyMapResponse.ok) {
        throw new Error("Failed to fetch swb oracle key map");
    }
    const swbOracleKeyMapJson = await swbOracleKeyMapResponse.json();
    return { oracleKeyMap: swbOracleKeyMapJson };
};
const fetchSwbOraclePricesViaAPI = async (swbFeedIds) => {
    const response = await fetch("/api/bankData/swbOracleData?feedIds=" + swbFeedIds.join(","));
    if (!response.ok) {
        throw new Error("Failed to fetch swb oracle data");
    }
    const responseBody = await response.json();
    return Object.fromEntries(Object.entries(responseBody).map(([key, oraclePrice]) => [
        key,
        {
            priceRealtime: {
                price: (0, bignumber_js_1.default)(oraclePrice.priceRealtime.price),
                confidence: (0, bignumber_js_1.default)(oraclePrice.priceRealtime.confidence),
                lowestPrice: (0, bignumber_js_1.default)(oraclePrice.priceRealtime.lowestPrice),
                highestPrice: (0, bignumber_js_1.default)(oraclePrice.priceRealtime.highestPrice),
            },
            priceWeighted: {
                price: (0, bignumber_js_1.default)(oraclePrice.priceWeighted.price),
                confidence: (0, bignumber_js_1.default)(oraclePrice.priceWeighted.confidence),
                lowestPrice: (0, bignumber_js_1.default)(oraclePrice.priceWeighted.lowestPrice),
                highestPrice: (0, bignumber_js_1.default)(oraclePrice.priceWeighted.highestPrice),
            },
            timestamp: oraclePrice.timestamp ? (0, bignumber_js_1.default)(oraclePrice.timestamp) : null,
        },
    ]));
};
/**
 * Maps banks to their corresponding oracle prices
 */
const mapSwbBanksToOraclePrices = (banks, oraclePrices, oracleKeyMap) => {
    const bankOraclePriceMap = new Map();
    // Map legacy banks
    banks.forEach((bank) => {
        const oracleKey = bank.data.config.oracleKeys[0].toBase58();
        const oracleFeed = oracleKeyMap[oracleKey];
        const oraclePrice = oracleFeed?.feedId ? oraclePrices[oracleFeed.feedId] : null;
        if (oraclePrice) {
            bankOraclePriceMap.set(bank.address.toBase58(), oraclePrice);
        }
    });
    return bankOraclePriceMap;
};
/**
 * =============================================================================
 * ORACLE UTILS
 * =============================================================================
 *
 * Utility functions for fetching all oracle data
 */
const fetchOracleData = async (banks, bankMetadataMap, connection, opts) => {
    const [pythData, swbData] = await Promise.all([
        (0, exports.fetchPythOracleData)(banks, bankMetadataMap, connection, opts),
        (0, exports.fetchSwbOracleData)(banks, opts),
    ]);
    const bankOraclePriceMap = new Map();
    // Map pyth data
    pythData.bankOraclePriceMap.forEach((oraclePrice, bankAddress) => {
        bankOraclePriceMap.set(bankAddress, oraclePrice);
    });
    // Map swb data
    swbData.bankOraclePriceMap.forEach((oraclePrice, bankAddress) => {
        bankOraclePriceMap.set(bankAddress, oraclePrice);
    });
    // check if any bank is missing an oracle price
    banks.forEach((bank) => {
        if (!bankOraclePriceMap.has(bank.address.toBase58())) {
            // console.error(`Bank ${bank.address.toBase58()} is missing an oracle price`);
            bankOraclePriceMap.set(bank.address.toBase58(), {
                priceRealtime: {
                    price: (0, bignumber_js_1.default)(0),
                    confidence: (0, bignumber_js_1.default)(0),
                    lowestPrice: (0, bignumber_js_1.default)(0),
                    highestPrice: (0, bignumber_js_1.default)(0),
                },
                priceWeighted: {
                    price: (0, bignumber_js_1.default)(0),
                    confidence: (0, bignumber_js_1.default)(0),
                    lowestPrice: (0, bignumber_js_1.default)(0),
                    highestPrice: (0, bignumber_js_1.default)(0),
                },
                timestamp: (0, bignumber_js_1.default)(0),
            });
        }
    });
    return {
        bankOraclePriceMap,
        pythFeedMap: pythData.pythFeedMap,
    };
};
exports.fetchOracleData = fetchOracleData;

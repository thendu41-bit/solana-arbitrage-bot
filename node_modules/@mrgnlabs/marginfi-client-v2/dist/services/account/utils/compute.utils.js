"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeFreeCollateral = computeFreeCollateral;
exports.computeFreeCollateralLegacy = computeFreeCollateralLegacy;
exports.computeHealthComponents = computeHealthComponents;
exports.computeHealthComponentsLegacy = computeHealthComponentsLegacy;
exports.computeHealthComponentsWithoutBiasLegacy = computeHealthComponentsWithoutBiasLegacy;
exports.computeAccountValue = computeAccountValue;
exports.computeNetApy = computeNetApy;
exports.computeBalanceUsdValue = computeBalanceUsdValue;
exports.getBalanceUsdValueWithPriceBias = getBalanceUsdValueWithPriceBias;
exports.computeQuantity = computeQuantity;
exports.computeQuantityUi = computeQuantityUi;
exports.computeClaimedEmissions = computeClaimedEmissions;
exports.computeTotalOutstandingEmissions = computeTotalOutstandingEmissions;
exports.computeHealthCheckAccounts = computeHealthCheckAccounts;
exports.computeHealthAccountMetas = computeHealthAccountMetas;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const web3_js_1 = require("@solana/web3.js");
const mrgn_common_1 = require("@mrgnlabs/mrgn-common");
const account_1 = require("../../../models/account");
const vendor_1 = require("../../../vendor");
const bank_1 = require("../../bank");
const price_1 = require("../../price");
/**
 * Marginfi Account Computes
 * =========================
 */
function computeFreeCollateral(marginfiAccount, opts) {
    const _clamped = opts?.clamped ?? true;
    const { assets, liabilities } = computeHealthComponents(marginfiAccount, account_1.MarginRequirementType.Initial);
    const signedFreeCollateral = assets.minus(liabilities);
    return _clamped ? bignumber_js_1.default.max(0, signedFreeCollateral) : signedFreeCollateral;
}
function computeFreeCollateralLegacy(activeBalances, banks, oraclePrices, opts) {
    const _clamped = opts?.clamped ?? true;
    const { assets, liabilities } = computeHealthComponentsLegacy(activeBalances, banks, oraclePrices, account_1.MarginRequirementType.Initial, []);
    const signedFreeCollateral = assets.minus(liabilities);
    return _clamped ? bignumber_js_1.default.max(0, signedFreeCollateral) : signedFreeCollateral;
}
function computeHealthComponents(marginfiAccount, marginReqType) {
    // check if health cache failed
    switch (marginReqType) {
        case account_1.MarginRequirementType.Equity:
            return {
                assets: marginfiAccount.healthCache.assetValueEquity,
                liabilities: marginfiAccount.healthCache.liabilityValueEquity,
            };
        case account_1.MarginRequirementType.Initial:
            return {
                assets: marginfiAccount.healthCache.assetValue,
                liabilities: marginfiAccount.healthCache.liabilityValue,
            };
        case account_1.MarginRequirementType.Maintenance:
            return {
                assets: marginfiAccount.healthCache.assetValueMaint,
                liabilities: marginfiAccount.healthCache.liabilityValueMaint,
            };
    }
}
function computeHealthComponentsLegacy(activeBalances, banks, oraclePrices, marginReqType, excludedBanks = []) {
    const filteredBalances = activeBalances.filter((accountBalance) => !excludedBanks.find((b) => b.equals(accountBalance.bankPk)));
    const [assets, liabilities] = filteredBalances
        .map((accountBalance) => {
        const bank = banks.get(accountBalance.bankPk.toBase58());
        if (!bank) {
            console.warn(`Bank ${(0, mrgn_common_1.shortenAddress)(accountBalance.bankPk)} not found, excluding from health computation`);
            return [new bignumber_js_1.default(0), new bignumber_js_1.default(0)];
        }
        const priceInfo = oraclePrices.get(accountBalance.bankPk.toBase58());
        if (!priceInfo) {
            console.warn(`Price info for bank ${(0, mrgn_common_1.shortenAddress)(accountBalance.bankPk)} not found, excluding from health computation`);
            return [new bignumber_js_1.default(0), new bignumber_js_1.default(0)];
        }
        const { assets, liabilities } = getBalanceUsdValueWithPriceBias(accountBalance, bank, priceInfo, marginReqType);
        return [assets, liabilities];
    })
        .reduce(([asset, liability], [d, l]) => {
        return [asset.plus(d), liability.plus(l)];
    }, [new bignumber_js_1.default(0), new bignumber_js_1.default(0)]);
    return { assets, liabilities };
}
function computeHealthComponentsWithoutBiasLegacy(activeBalances, banks, oraclePrices, marginReqType) {
    const [assets, liabilities] = activeBalances
        .map((accountBalance) => {
        const bank = banks.get(accountBalance.bankPk.toBase58());
        if (!bank) {
            console.warn(`Bank ${(0, mrgn_common_1.shortenAddress)(accountBalance.bankPk)} not found, excluding from health computation`);
            return [new bignumber_js_1.default(0), new bignumber_js_1.default(0)];
        }
        const priceInfo = oraclePrices.get(accountBalance.bankPk.toBase58());
        if (!priceInfo) {
            console.warn(`Price info for bank ${(0, mrgn_common_1.shortenAddress)(accountBalance.bankPk)} not found, excluding from health computation`);
            return [new bignumber_js_1.default(0), new bignumber_js_1.default(0)];
        }
        const { assets, liabilities } = computeBalanceUsdValue(accountBalance, bank, priceInfo, marginReqType);
        return [assets, liabilities];
    })
        .reduce(([asset, liability], [d, l]) => {
        return [asset.plus(d), liability.plus(l)];
    }, [new bignumber_js_1.default(0), new bignumber_js_1.default(0)]);
    return { assets, liabilities };
}
function computeAccountValue(marginfiAccount) {
    const { assets, liabilities } = computeHealthComponents(marginfiAccount, account_1.MarginRequirementType.Equity);
    return assets.minus(liabilities);
}
function computeNetApy(marginfiAccount, activeBalances, banks, oraclePrices) {
    const { assets, liabilities } = computeHealthComponents(marginfiAccount, account_1.MarginRequirementType.Equity);
    const totalUsdValue = assets.minus(liabilities);
    const apr = activeBalances
        .reduce((weightedApr, balance) => {
        const bank = banks.get(balance.bankPk.toBase58());
        if (!bank) {
            console.warn(`Bank ${(0, mrgn_common_1.shortenAddress)(balance.bankPk)} not found, excluding from APY computation`);
            return weightedApr;
        }
        const priceInfo = oraclePrices.get(balance.bankPk.toBase58());
        if (!priceInfo) {
            console.warn(`Price info for bank ${(0, mrgn_common_1.shortenAddress)(balance.bankPk)} not found, excluding from APY computation`);
            return weightedApr;
        }
        return weightedApr
            .minus((0, bank_1.computeInterestRates)(bank)
            .borrowingRate.times(computeBalanceUsdValue(balance, bank, priceInfo, account_1.MarginRequirementType.Equity).liabilities)
            .div(totalUsdValue.isEqualTo(0) ? 1 : totalUsdValue))
            .plus((0, bank_1.computeInterestRates)(bank)
            .lendingRate.times(computeBalanceUsdValue(balance, bank, priceInfo, account_1.MarginRequirementType.Equity).assets)
            .div(totalUsdValue.isEqualTo(0) ? 1 : totalUsdValue));
    }, new bignumber_js_1.default(0))
        .toNumber();
    return (0, mrgn_common_1.aprToApy)(apr);
}
/**
 * Marginfi Balance Computes
 * =========================
 */
function computeBalanceUsdValue(balance, bank, oraclePrice, marginRequirementType) {
    const assetsValue = (0, bank_1.computeAssetUsdValue)(bank, oraclePrice, balance.assetShares, marginRequirementType, price_1.PriceBias.None);
    const liabilitiesValue = (0, bank_1.computeLiabilityUsdValue)(bank, oraclePrice, balance.liabilityShares, marginRequirementType, price_1.PriceBias.None);
    return { assets: assetsValue, liabilities: liabilitiesValue };
}
function getBalanceUsdValueWithPriceBias(balance, bank, oraclePrice, marginRequirementType) {
    const assetsValue = (0, bank_1.computeAssetUsdValue)(bank, oraclePrice, balance.assetShares, marginRequirementType, price_1.PriceBias.Lowest);
    const liabilitiesValue = (0, bank_1.computeLiabilityUsdValue)(bank, oraclePrice, balance.liabilityShares, marginRequirementType, price_1.PriceBias.Highest);
    return { assets: assetsValue, liabilities: liabilitiesValue };
}
function computeQuantity(balance, bank) {
    const assetsQuantity = (0, bank_1.getAssetQuantity)(bank, balance.assetShares);
    const liabilitiesQuantity = (0, bank_1.getLiabilityQuantity)(bank, balance.liabilityShares);
    return { assets: assetsQuantity, liabilities: liabilitiesQuantity };
}
function computeQuantityUi(balance, bank) {
    const assetsQuantity = new bignumber_js_1.default((0, mrgn_common_1.nativeToUi)((0, bank_1.getAssetQuantity)(bank, balance.assetShares), bank.mintDecimals));
    const liabilitiesQuantity = new bignumber_js_1.default((0, mrgn_common_1.nativeToUi)((0, bank_1.getLiabilityQuantity)(bank, balance.liabilityShares), bank.mintDecimals));
    return { assets: assetsQuantity, liabilities: liabilitiesQuantity };
}
function computeClaimedEmissions(balance, bank, currentTimestamp) {
    const lendingActive = bank.emissionsActiveLending;
    const borrowActive = bank.emissionsActiveBorrowing;
    const { assets, liabilities } = computeQuantity(balance, bank);
    let balanceAmount = null;
    if (lendingActive) {
        balanceAmount = assets;
    }
    else if (borrowActive) {
        balanceAmount = liabilities;
    }
    if (balanceAmount) {
        const lastUpdate = balance.lastUpdate;
        const period = new bignumber_js_1.default(currentTimestamp - lastUpdate);
        const emissionsRate = new bignumber_js_1.default(bank.emissionsRate);
        const emissions = period
            .times(balanceAmount)
            .times(emissionsRate)
            .div(31_536_000 * Math.pow(10, bank.mintDecimals));
        const emissionsReal = bignumber_js_1.default.min(emissions, new bignumber_js_1.default(bank.emissionsRemaining));
        return emissionsReal;
    }
    return new bignumber_js_1.default(0);
}
function computeTotalOutstandingEmissions(balance, bank) {
    const claimedEmissions = balance.emissionsOutstanding;
    const unclaimedEmissions = computeClaimedEmissions(balance, bank, Date.now() / 1000);
    return claimedEmissions.plus(unclaimedEmissions);
}
function computeHealthCheckAccounts(balances, banks, mandatoryBanks = [], excludedBanks = []) {
    const activeBalances = balances.filter((b) => b.active);
    const mandatoryBanksSet = new Set(mandatoryBanks.map((b) => b.toBase58()));
    const excludedBanksSet = new Set(excludedBanks.map((b) => b.toBase58()));
    const activeBanks = new Set(activeBalances.map((b) => b.bankPk.toBase58()));
    const banksToAdd = new Set([...mandatoryBanksSet].filter((x) => !activeBanks.has(x)));
    let slotsToKeep = banksToAdd.size;
    const projectedActiveBanks = balances
        .filter((balance) => {
        if (balance.active) {
            return !excludedBanksSet.has(balance.bankPk.toBase58());
        }
        else if (slotsToKeep > 0) {
            slotsToKeep--;
            return true;
        }
        else {
            return false;
        }
    })
        .map((balance) => {
        if (balance.active) {
            const bank = banks.get(balance.bankPk.toBase58());
            if (!bank)
                throw Error(`Bank ${balance.bankPk.toBase58()} not found`);
            return bank;
        }
        const newBankAddress = [...banksToAdd.values()][0];
        banksToAdd.delete(newBankAddress);
        const bank = banks.get(newBankAddress);
        if (!bank)
            throw Error(`Bank ${newBankAddress} not found`);
        return bank;
    });
    return projectedActiveBanks;
}
function computeHealthAccountMetas(banksToInclude, bankMetadataMap, enableSorting = true) {
    let wrapperFn = enableSorting ? mrgn_common_1.composeRemainingAccounts : (banksAndOracles) => banksAndOracles.flat();
    const accounts = wrapperFn(banksToInclude.map((bank) => {
        const keys = [bank.address, bank.oracleKey];
        // for staked collateral banks (assetTag === 2), include additional accounts
        if (bank.config.assetTag === 2) {
            const bankMetadata = bankMetadataMap?.[bank.address.toBase58()];
            if (!bankMetadata || !bankMetadata.validatorVoteAccount) {
                throw Error(`Bank metadata for ${bank.address.toBase58()} not found`);
            }
            const pool = (0, vendor_1.findPoolAddress)(new web3_js_1.PublicKey(bankMetadata.validatorVoteAccount));
            const solPool = (0, vendor_1.findPoolStakeAddress)(pool);
            const lstMint = (0, vendor_1.findPoolMintAddress)(pool);
            keys.push(lstMint, solPool);
        }
        return keys;
    }));
    return accounts;
}

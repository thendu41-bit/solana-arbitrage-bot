"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeAccountRaw = decodeAccountRaw;
exports.parseBalanceRaw = parseBalanceRaw;
exports.parseMarginfiAccountRaw = parseMarginfiAccountRaw;
exports.getActiveAccountFlags = getActiveAccountFlags;
exports.hasAccountFlag = hasAccountFlag;
exports.getActiveHealthCacheFlags = getActiveHealthCacheFlags;
exports.hasHealthCacheFlag = hasHealthCacheFlag;
exports.getHealthCacheStatusDescription = getHealthCacheStatusDescription;
exports.dtoToMarginfiAccount = dtoToMarginfiAccount;
exports.dtoToBalance = dtoToBalance;
exports.dtoToHealthCache = dtoToHealthCache;
const bn_js_1 = __importDefault(require("bn.js"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const anchor_1 = require("@coral-xyz/anchor");
const web3_js_1 = require("@solana/web3.js");
const mrgn_common_1 = require("@mrgnlabs/mrgn-common");
const types_1 = require("../types");
const balance_1 = require("../../../models/balance");
const health_cache_1 = require("../../../models/health-cache");
const types_2 = require("../../../types");
function decodeAccountRaw(encoded, idl) {
    const coder = new anchor_1.BorshCoder(idl);
    return coder.accounts.decode(types_2.AccountType.MarginfiAccount, encoded);
}
function parseBalanceRaw(balanceRaw) {
    const active = typeof balanceRaw.active === "number" ? balanceRaw.active === 1 : balanceRaw.active;
    const bankPk = balanceRaw.bankPk;
    const assetShares = (0, mrgn_common_1.wrappedI80F48toBigNumber)(balanceRaw.assetShares);
    const liabilityShares = (0, mrgn_common_1.wrappedI80F48toBigNumber)(balanceRaw.liabilityShares);
    const emissionsOutstanding = (0, mrgn_common_1.wrappedI80F48toBigNumber)(balanceRaw.emissionsOutstanding);
    const lastUpdate = balanceRaw.lastUpdate.toNumber();
    return {
        active,
        bankPk,
        assetShares,
        liabilityShares,
        emissionsOutstanding,
        lastUpdate,
    };
}
function parseMarginfiAccountRaw(marginfiAccountPk, accountData) {
    const address = marginfiAccountPk;
    const group = accountData.group;
    const authority = accountData.authority;
    const balances = accountData.lendingAccount.balances.map(balance_1.Balance.from);
    const accountFlags = getActiveAccountFlags(accountData.accountFlags);
    const emissionsDestinationAccount = accountData.emissionsDestinationAccount;
    const healthCache = health_cache_1.HealthCache.from(accountData.healthCache);
    return {
        address,
        group,
        authority,
        balances,
        accountFlags,
        emissionsDestinationAccount,
        healthCache,
    };
}
/**
 * Get all active account flags as an array of flag names
 */
function getActiveAccountFlags(flags) {
    const activeFlags = [];
    Object.keys(types_1.AccountFlags)
        .filter((key) => isNaN(Number(key))) // Only get the string keys (not the reverse mapping)
        .forEach((key) => {
        const flag = types_1.AccountFlags[key];
        if (typeof flag === "number" && hasAccountFlag(flags, flag)) {
            activeFlags.push(flag);
        }
    });
    return activeFlags;
}
/**
 * Check if an account flag is set
 */
function hasAccountFlag(flags, flag) {
    return !flags.and(new bn_js_1.default(flag)).isZero();
}
/**
 * Convert on-chain health cache flags (BN) to an array of HealthCacheFlags enum values
 *
 * According to the IDL, health cache flags are defined as:
 * - HEALTHY = 1 (bit 0) - If set, the account cannot be liquidated
 * - ENGINE_STATUS_OK = 2 (bit 1) - If set, the engine did not error during health calculation
 * - ORACLE_OK = 4 (bit 2) - If set, the engine did not encounter oracle issues
 */
function getActiveHealthCacheFlags(flags) {
    const activeFlags = [];
    // Check each flag bit
    if (hasHealthCacheFlag(flags, types_1.HealthCacheFlags.HEALTHY)) {
        activeFlags.push(types_1.HealthCacheFlags.HEALTHY);
    }
    if (hasHealthCacheFlag(flags, types_1.HealthCacheFlags.ENGINE_STATUS_OK)) {
        activeFlags.push(types_1.HealthCacheFlags.ENGINE_STATUS_OK);
    }
    if (hasHealthCacheFlag(flags, types_1.HealthCacheFlags.ORACLE_OK)) {
        activeFlags.push(types_1.HealthCacheFlags.ORACLE_OK);
    }
    return activeFlags;
}
/**
 * Check if a health cache flag is set
 */
function hasHealthCacheFlag(flags, flag) {
    return (flags & flag) !== 0;
}
/**
 * Convert numeric health cache flags to a human-readable status message
 */
function getHealthCacheStatusDescription(flags) {
    const activeFlags = getActiveHealthCacheFlags(flags);
    // Check for critical conditions first
    if (!activeFlags.includes(types_1.HealthCacheFlags.HEALTHY)) {
        return "UNHEALTHY: Account is eligible for liquidation";
    }
    if (!activeFlags.includes(types_1.HealthCacheFlags.ENGINE_STATUS_OK)) {
        return "ERROR: Risk engine encountered an error during health calculation";
    }
    if (!activeFlags.includes(types_1.HealthCacheFlags.ORACLE_OK)) {
        return "WARNING: Oracle price data may be stale or invalid";
    }
    // All good
    if (activeFlags.length === 3) {
        return "HEALTHY: Account is in good standing";
    }
    // Default case (shouldn't happen often)
    return `Status flags: ${activeFlags.join(", ")}`;
}
function dtoToMarginfiAccount(marginfiAccountDto) {
    return {
        address: new web3_js_1.PublicKey(marginfiAccountDto.address),
        group: new web3_js_1.PublicKey(marginfiAccountDto.group),
        authority: new web3_js_1.PublicKey(marginfiAccountDto.authority),
        balances: marginfiAccountDto.balances.map(dtoToBalance),
        accountFlags: marginfiAccountDto.accountFlags,
        emissionsDestinationAccount: new web3_js_1.PublicKey(marginfiAccountDto.emissionsDestinationAccount),
        healthCache: dtoToHealthCache(marginfiAccountDto.healthCache),
    };
}
function dtoToBalance(balanceDto) {
    return {
        active: balanceDto.active,
        bankPk: new web3_js_1.PublicKey(balanceDto.bankPk),
        assetShares: new bignumber_js_1.default(balanceDto.assetShares),
        liabilityShares: new bignumber_js_1.default(balanceDto.liabilityShares),
        emissionsOutstanding: new bignumber_js_1.default(balanceDto.emissionsOutstanding),
        lastUpdate: balanceDto.lastUpdate,
    };
}
function dtoToHealthCache(healthCacheDto) {
    return {
        assetValue: new bignumber_js_1.default(healthCacheDto.assetValue),
        liabilityValue: new bignumber_js_1.default(healthCacheDto.liabilityValue),
        assetValueMaint: new bignumber_js_1.default(healthCacheDto.assetValueMaint),
        liabilityValueMaint: new bignumber_js_1.default(healthCacheDto.liabilityValueMaint),
        assetValueEquity: new bignumber_js_1.default(healthCacheDto.assetValueEquity),
        liabilityValueEquity: new bignumber_js_1.default(healthCacheDto.liabilityValueEquity),
        timestamp: new bignumber_js_1.default(healthCacheDto.timestamp),
        flags: healthCacheDto.flags,
        prices: healthCacheDto.prices,
        simulationFailed: healthCacheDto.simulationFailed,
    };
}

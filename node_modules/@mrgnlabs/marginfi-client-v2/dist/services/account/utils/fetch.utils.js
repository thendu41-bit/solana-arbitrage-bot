"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchMarginfiAccountData = exports.fetchMarginfiAccountAddresses = void 0;
const account_1 = require("../../../models/account");
const account_service_1 = require("../account.service");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const fetchMarginfiAccountAddresses = async (program, authority, group) => {
    const marginfiAccounts = (await program.account.marginfiAccount.all([
        {
            memcmp: {
                bytes: group.toBase58(),
                offset: 8, // marginfiGroup is the first field in the account, so only offset is the discriminant
            },
        },
        {
            memcmp: {
                bytes: authority.toBase58(),
                offset: 8 + 32, // authority is the second field in the account after the authority, so offset by the discriminant and a pubkey
            },
        },
    ])).map((a) => a.publicKey);
    return marginfiAccounts;
};
exports.fetchMarginfiAccountAddresses = fetchMarginfiAccountAddresses;
const fetchMarginfiAccountData = async (program, marginfiAccountPk, bankMap, oraclePrices, bankMetadataMap, emodePairs) => {
    const marginfiAccountRaw = await program.account.marginfiAccount.fetch(marginfiAccountPk, "confirmed");
    const marginfiAccount = account_1.MarginfiAccount.fromAccountParsed(marginfiAccountPk, marginfiAccountRaw);
    const activeEmodePairs = marginfiAccount.computeActiveEmodePairs(emodePairs);
    // Adjust bank weights based on active emode pairs
    const adjustedBankMap = new Map();
    if (activeEmodePairs.length === 0) {
        // No active emode pairs, use original bank map
        bankMap.forEach((bank, key) => {
            adjustedBankMap.set(key, bank);
        });
    }
    else {
        // Find the best weights for each collateral bank across all active emode emodePairs
        const banks = [];
        bankMap.forEach((bank, key) => {
            banks.push(bank);
        });
        const { adjustedBanks } = adjustBankWeightsWithEmodePairs(banks, activeEmodePairs);
        adjustedBanks.forEach((b) => {
            const bankKey = b.address.toBase58();
            adjustedBankMap.set(bankKey, b);
        });
    }
    const marginfiAccountWithCache = await (0, account_service_1.simulateAccountHealthCacheWithFallback)({
        program,
        marginfiAccount,
        bankMap: adjustedBankMap,
        oraclePrices,
        bankMetadataMap,
        balances: marginfiAccount.balances,
    });
    return marginfiAccountWithCache;
};
exports.fetchMarginfiAccountData = fetchMarginfiAccountData;
function adjustBankWeightsWithEmodePairs(banks, emodePairs) {
    if (!emodePairs.length)
        return { adjustedBanks: banks, originalWeights: {} };
    const originalWeights = {};
    const lowestWeights = new Map();
    // For each emode pair, find the collateral banks and track their lowest possible weights
    emodePairs.forEach((emodePair) => {
        emodePair.collateralBanks.forEach((collateralBankPk) => {
            const bankPkStr = collateralBankPk.toString();
            // If we haven't seen this bank yet, initialize with current emode pair weights
            if (!lowestWeights.has(bankPkStr)) {
                lowestWeights.set(bankPkStr, {
                    assetWeightMaint: emodePair.assetWeightMaint,
                    assetWeightInit: emodePair.assetWeightInit,
                });
            }
            else {
                // If we've seen this bank before, use the lower weights
                const currentLowest = lowestWeights.get(bankPkStr);
                lowestWeights.set(bankPkStr, {
                    assetWeightMaint: bignumber_js_1.default.min(currentLowest.assetWeightMaint, emodePair.assetWeightMaint),
                    assetWeightInit: bignumber_js_1.default.min(currentLowest.assetWeightInit, emodePair.assetWeightInit),
                });
            }
        });
    });
    // Make a copy of the banks array to avoid modifying the original array reference
    // but keep the original Bank objects (with their methods intact)
    const adjustedBanks = [...banks];
    // Apply the lowest weights to each bank
    for (const bank of adjustedBanks) {
        const bankPkStr = bank.address.toString();
        const lowestWeight = lowestWeights.get(bankPkStr);
        if (lowestWeight) {
            // Store original weights before modifying
            originalWeights[bankPkStr] = {
                assetWeightMaint: bank.config.assetWeightMaint,
                assetWeightInit: bank.config.assetWeightInit,
            };
            // Apply new weights only if they're higher than current weights
            if (lowestWeight.assetWeightMaint.gt(bank.config.assetWeightMaint)) {
                // Use the emode weight directly since it's already a BigNumber
                bank.config.assetWeightMaint = lowestWeight.assetWeightMaint;
            }
            if (lowestWeight.assetWeightInit.gt(bank.config.assetWeightInit)) {
                // Use the emode weight directly since it's already a BigNumber
                bank.config.assetWeightInit = lowestWeight.assetWeightInit;
            }
        }
    }
    return { adjustedBanks, originalWeights };
}

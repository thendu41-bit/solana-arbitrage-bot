"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HealthCacheSimulationError = void 0;
exports.simulateAccountHealthCacheWithFallback = simulateAccountHealthCacheWithFallback;
exports.simulateAccountHealthCache = simulateAccountHealthCache;
exports.makePulseHealthIx = makePulseHealthIx;
exports.createUpdateFeedIx = createUpdateFeedIx;
exports.createMarginfiAccountTx = createMarginfiAccountTx;
exports.getActiveStaleBanks = getActiveStaleBanks;
const web3_js_1 = require("@solana/web3.js");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const bn_js_1 = __importDefault(require("bn.js"));
const mrgn_common_1 = require("@mrgnlabs/mrgn-common");
const utils_1 = require("./utils");
const instructions_1 = __importDefault(require("../../instructions"));
const account_1 = require("../../models/account");
const health_cache_1 = require("../../models/health-cache");
const utils_2 = require("../../utils");
const bank_1 = require("../bank");
const helpers_1 = require("../transaction/helpers");
const on_demand_1 = require("@switchboard-xyz/on-demand");
const common_1 = require("@switchboard-xyz/common");
const constants_1 = require("../../constants");
/**
 * Custom error class for health cache simulation failures
 */
class HealthCacheSimulationError extends Error {
    constructor(message, mrgnErr, internalErr) {
        super(message);
        this.name = "HealthCacheSimulationError";
        this.mrgnErr = mrgnErr;
        this.internalErr = internalErr;
        // Maintains proper stack trace for where our error was thrown (only available on V8)
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, HealthCacheSimulationError);
        }
    }
}
exports.HealthCacheSimulationError = HealthCacheSimulationError;
async function simulateAccountHealthCacheWithFallback(props) {
    let marginfiAccount = props.marginfiAccount;
    const activeBalances = props.balances.filter((b) => b.active);
    const { assets: assetValueEquity, liabilities: liabilityValueEquity } = (0, utils_1.computeHealthComponentsWithoutBiasLegacy)(activeBalances, props.bankMap, props.oraclePrices, account_1.MarginRequirementType.Equity);
    try {
        const simulatedAccount = await simulateAccountHealthCache({
            program: props.program,
            bankMap: props.bankMap,
            oraclePrices: props.oraclePrices,
            marginfiAccountPk: props.marginfiAccount.address,
            balances: props.balances,
            bankMetadataMap: props.bankMetadataMap,
            groupPk: props.marginfiAccount.group,
        });
        simulatedAccount.healthCache.assetValueEquity = (0, mrgn_common_1.bigNumberToWrappedI80F48)(assetValueEquity);
        simulatedAccount.healthCache.liabilityValueEquity = (0, mrgn_common_1.bigNumberToWrappedI80F48)(liabilityValueEquity);
        marginfiAccount = account_1.MarginfiAccount.fromAccountParsed(props.marginfiAccount.address, simulatedAccount);
    }
    catch (e) {
        console.log("e", e);
        const { assets: assetValueMaint, liabilities: liabilityValueMaint } = (0, utils_1.computeHealthComponentsLegacy)(activeBalances, props.bankMap, props.oraclePrices, account_1.MarginRequirementType.Maintenance);
        const { assets: assetValueInitial, liabilities: liabilityValueInitial } = (0, utils_1.computeHealthComponentsLegacy)(activeBalances, props.bankMap, props.oraclePrices, account_1.MarginRequirementType.Initial);
        marginfiAccount.setHealthCache(new health_cache_1.HealthCache(assetValueInitial, liabilityValueInitial, assetValueMaint, liabilityValueMaint, assetValueEquity, liabilityValueEquity, new bignumber_js_1.default(0), [], [], true));
        // Return the error if it's a HealthCacheSimulationError
        if (e instanceof HealthCacheSimulationError) {
            return { marginfiAccount, error: e };
        }
    }
    return { marginfiAccount };
}
async function simulateAccountHealthCache(props) {
    const { program, bankMap, oraclePrices, marginfiAccountPk, balances, bankMetadataMap, groupPk } = props;
    const activeBalances = balances.filter((b) => b.active);
    const { stalePythFeeds, staleSwbOracles } = getActiveStaleBanks(activeBalances, bankMap, [], oraclePrices, 30);
    const computeIx = web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({ units: 1_400_000 });
    const blockhash = (await program.provider.connection.getLatestBlockhash("confirmed")).blockhash;
    const fundAccountIx = web3_js_1.SystemProgram.transfer({
        fromPubkey: new web3_js_1.PublicKey("DD3AeAssFvjqTvRTrRAtpfjkBF8FpVKnFuwnMLN9haXD"), // marginfi SOL VAULT
        toPubkey: program.provider.publicKey,
        lamports: 100_000_000, // 0.1 SOL
    });
    const crankPythIxs = {
        postInstructions: [],
        closeInstructions: [],
        keys: [],
        lut: null,
    }; //await crankPythOracleIx(stalePythFeeds, program.provider);
    const crankSwbIxs = staleSwbOracles.length > 0
        ? await createUpdateFeedIx({
            swbPullOracles: staleSwbOracles.map((oracle) => oracle.oracleKey),
            provider: program.provider,
        })
        : { instructions: [], luts: [] };
    const healthPulseIxs = await makePulseHealthIx(program, marginfiAccountPk, bankMap, balances, activeBalances.map((b) => b.bankPk), [], bankMetadataMap);
    const pythLut = crankPythIxs.lut ? [crankPythIxs.lut] : [];
    const txs = [];
    const fundAccountMessageV0 = new web3_js_1.TransactionMessage({
        payerKey: program.provider.publicKey,
        recentBlockhash: blockhash,
        instructions: [fundAccountIx],
    }).compileToV0Message([]);
    const fundAccountTx = new web3_js_1.VersionedTransaction(fundAccountMessageV0);
    txs.push(fundAccountTx);
    const swbMessageV0 = new web3_js_1.TransactionMessage({
        payerKey: program.provider.publicKey,
        recentBlockhash: blockhash,
        instructions: [...crankSwbIxs.instructions],
    }).compileToV0Message([...crankSwbIxs.luts]);
    const swbTx = new web3_js_1.VersionedTransaction(swbMessageV0);
    txs.push(swbTx);
    let marginfiLutAddresses = groupPk ? constants_1.ADDRESS_LOOKUP_TABLE_FOR_GROUP[groupPk.toBase58()] : [];
    const marginfiLuts = (await Promise.all(marginfiLutAddresses.map((address) => program.provider.connection.getAddressLookupTable(address))))
        .map((lut) => lut.value)
        .filter((lut) => lut !== null);
    const healthMessageV0 = new web3_js_1.TransactionMessage({
        payerKey: program.provider.publicKey,
        recentBlockhash: blockhash,
        instructions: [computeIx, ...healthPulseIxs.instructions],
    }).compileToV0Message([...marginfiLuts]);
    const healthTx = new web3_js_1.VersionedTransaction(healthMessageV0);
    txs.push(healthTx);
    if (txs.length > 5) {
        console.error("Too many transactions", txs.length);
        throw new Error("Too many transactions");
    }
    const simulationResult = await (0, helpers_1.simulateBundle)(program.provider.connection.rpcEndpoint, txs, [marginfiAccountPk]);
    const postExecutionAccount = simulationResult.find((result) => result.postExecutionAccounts.length > 0);
    if (!postExecutionAccount) {
        throw new Error("Account not found");
    }
    const marginfiAccountPost = account_1.MarginfiAccount.decodeAccountRaw(Buffer.from(postExecutionAccount.postExecutionAccounts[0].data[0], "base64"), program.idl);
    if (marginfiAccountPost.healthCache.mrgnErr || marginfiAccountPost.healthCache.internalErr) {
        console.log("cranked swb oracles", staleSwbOracles.map((oracle) => oracle.oracleKey));
        console.log("MarginfiAccountPost healthCache internalErr", marginfiAccountPost.healthCache.internalErr);
        console.log("MarginfiAccountPost healthCache mrgnErr", marginfiAccountPost.healthCache.mrgnErr);
        if (marginfiAccountPost.healthCache.mrgnErr === 6009) {
            const assetValue = !(0, mrgn_common_1.wrappedI80F48toBigNumber)(marginfiAccountPost.healthCache.assetValue).isZero();
            const liabilityValue = !(0, mrgn_common_1.wrappedI80F48toBigNumber)(marginfiAccountPost.healthCache.liabilityValue).isZero();
            const assetValueEquity = !(0, mrgn_common_1.wrappedI80F48toBigNumber)(marginfiAccountPost.healthCache.assetValueEquity).isZero();
            const liabilityValueEquity = !(0, mrgn_common_1.wrappedI80F48toBigNumber)(marginfiAccountPost.healthCache.liabilityValueEquity).isZero();
            const assetValueMaint = !(0, mrgn_common_1.wrappedI80F48toBigNumber)(marginfiAccountPost.healthCache.assetValueMaint).isZero();
            const liabilityValueMaint = !(0, mrgn_common_1.wrappedI80F48toBigNumber)(marginfiAccountPost.healthCache.liabilityValueMaint).isZero();
            if (assetValue &&
                liabilityValue &&
                assetValueEquity &&
                liabilityValueEquity &&
                assetValueMaint &&
                liabilityValueMaint) {
                return marginfiAccountPost;
            }
        }
        console.error("Account health cache simulation failed", {
            mrgnErr: marginfiAccountPost.healthCache.mrgnErr,
            internalErr: marginfiAccountPost.healthCache.internalErr,
        });
        throw new HealthCacheSimulationError("Account health cache simulation failed", marginfiAccountPost.healthCache.mrgnErr, marginfiAccountPost.healthCache.internalErr);
    }
    return marginfiAccountPost;
}
async function makePulseHealthIx(program, marginfiAccountPk, banks, balances, mandatoryBanks, excludedBanks, bankMetadataMap) {
    const healthAccounts = (0, utils_1.computeHealthCheckAccounts)(balances, banks, mandatoryBanks, excludedBanks);
    const accountMetas = (0, utils_1.computeHealthAccountMetas)(healthAccounts, bankMetadataMap);
    const sortIx = await instructions_1.default.makeLendingAccountSortBalancesIx(program, {
        marginfiAccount: marginfiAccountPk,
    });
    const ix = await instructions_1.default.makePulseHealthIx(program, {
        marginfiAccount: marginfiAccountPk,
    }, accountMetas.map((account) => ({ pubkey: account, isSigner: false, isWritable: false })));
    return { instructions: [sortIx, ix], keys: [] };
}
async function createUpdateFeedIx(props) {
    const swbProgram = await on_demand_1.AnchorUtils.loadProgramFromConnection(props.provider.connection);
    const pullFeedInstances = props.swbPullOracles
        // filter 0 feeds
        .filter((pubkey) => !pubkey.equals(new web3_js_1.PublicKey("DMhGWtLAKE5d56WdyHQxqeFncwUeqMEnuC2RvvZfbuur")))
        .map((pubkey) => new on_demand_1.PullFeed(swbProgram, pubkey));
    const crossbarClient = new common_1.CrossbarClient(process.env.NEXT_PUBLIC_SWITCHBOARD_CROSSSBAR_API || "https://integrator-crossbar.prod.mrgn.app");
    const gateway = await pullFeedInstances[0].fetchGatewayUrl(crossbarClient);
    const [pullIx, luts] = await on_demand_1.PullFeed.fetchUpdateManyIx(swbProgram, {
        feeds: pullFeedInstances,
        gateway,
        numSignatures: 1,
        payer: props.provider.publicKey,
        crossbarClient,
    });
    return { instructions: pullIx, luts };
}
/**
 * This function creates a new Marginfi account transaction and returns a projected dummy account for simulation.
 * Note: This function is subject to future updates and improvements.
 */
async function createMarginfiAccountTx(props) {
    const authority = props.marginfiAccount?.authority ?? props.marginfiClient.provider.publicKey;
    const marginfiAccountKeypair = web3_js_1.Keypair.generate();
    // create a dummy account with 15 empty balances to be used in other transactions
    const dummyWrappedI80F48 = (0, mrgn_common_1.bigNumberToWrappedI80F48)(new bignumber_js_1.default(0));
    const dummyBalances = Array(15).fill({
        active: false,
        bankPk: new web3_js_1.PublicKey("11111111111111111111111111111111"),
        assetShares: dummyWrappedI80F48,
        liabilityShares: dummyWrappedI80F48,
        emissionsOutstanding: dummyWrappedI80F48,
        lastUpdate: new bn_js_1.default(0),
    });
    const rawAccount = {
        group: props.marginfiClient.group.address,
        authority: authority,
        lendingAccount: { balances: dummyBalances },
        healthCache: {
            assetValue: {
                value: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            },
            liabilityValue: {
                value: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            },
            timestamp: new bn_js_1.default(0),
            flags: 0,
            prices: [],
            assetValueMaint: (0, mrgn_common_1.bigNumberToWrappedI80F48)(new bignumber_js_1.default(0)),
            liabilityValueMaint: (0, mrgn_common_1.bigNumberToWrappedI80F48)(new bignumber_js_1.default(0)),
            assetValueEquity: (0, mrgn_common_1.bigNumberToWrappedI80F48)(new bignumber_js_1.default(0)),
            liabilityValueEquity: (0, mrgn_common_1.bigNumberToWrappedI80F48)(new bignumber_js_1.default(0)),
            errIndex: 0,
            internalErr: 0,
            internalBankruptcyErr: 0,
            internalLiqErr: 0,
            mrgnErr: 0,
        },
        emissionsDestinationAccount: new web3_js_1.PublicKey("11111111111111111111111111111111"),
        accountFlags: new bn_js_1.default([0, 0, 0]),
    };
    const account = account_1.MarginfiAccount.fromAccountParsed(marginfiAccountKeypair.publicKey, rawAccount);
    const wrappedAccount = new account_1.MarginfiAccountWrapper(marginfiAccountKeypair.publicKey, props.marginfiClient, account);
    return {
        account: wrappedAccount,
        tx: await props.marginfiClient.createMarginfiAccountTx({ accountKeypair: marginfiAccountKeypair }),
    };
}
function getActiveStaleBanks(balances, banks, additionalBanks, oraclePrices, maxAgeOffset = 0) {
    const activeBanks = balances
        .filter((balance) => balance.active)
        .map((balance) => banks.get(balance.bankPk.toBase58()))
        .filter((bank) => !!bank);
    const allBanks = [...activeBanks, ...additionalBanks];
    const staleBanks = allBanks.filter((bank) => {
        if (bank.config.oracleSetup === bank_1.OracleSetup.SwitchboardPull ||
            bank.config.oracleSetup === bank_1.OracleSetup.SwitchboardV2) {
            // always crank swb banks
            return true;
        }
        const oraclePrice = oraclePrices.get(bank.address.toBase58());
        const maxAge = bank.config.oracleMaxAge;
        const currentTime = Math.round(Date.now() / 1000);
        const oracleTime = Math.round(oraclePrice?.timestamp ? oraclePrice.timestamp.toNumber() : new Date().getTime());
        const adjustedMaxAge = Math.max(maxAge - maxAgeOffset, 0);
        const isStale = currentTime - oracleTime > adjustedMaxAge;
        return isStale;
    });
    if (staleBanks.length > 0) {
        const stalePythFeeds = [];
        const staleSwbOracles = [];
        const seenSwbOracles = new Set();
        const seenPythFeeds = new Set();
        staleBanks.forEach((bank) => {
            if (bank.config.oracleSetup === bank_1.OracleSetup.SwitchboardPull) {
                const key = bank.oracleKey.toBase58();
                if (!seenSwbOracles.has(key)) {
                    seenSwbOracles.add(key);
                    staleSwbOracles.push({ oracleKey: bank.oracleKey });
                }
            }
            else if (bank.config.oracleSetup === bank_1.OracleSetup.PythPushOracle ||
                bank.config.oracleSetup === bank_1.OracleSetup.StakedWithPythPush) {
                const oraclePrice = oraclePrices.get(bank.address.toBase58());
                const shardId = oraclePrice?.pythShardId ?? 0;
                const feedId = bank.config.oracleKeys[0];
                const feedKey = (0, utils_2.feedIdToString)(feedId);
                if (!seenPythFeeds.has(feedKey)) {
                    seenPythFeeds.add(feedKey);
                    stalePythFeeds.push({ feedId: feedKey, shardId });
                }
            }
        });
        return { stalePythFeeds, staleSwbOracles };
    }
    return { stalePythFeeds: [], staleSwbOracles: [] };
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MARGINFI_SPONSORED_SHARD_ID = exports.PYTH_SPONSORED_SHARD_ID = void 0;
exports.getBankVaultSeeds = getBankVaultSeeds;
exports.getBankVaultAuthority = getBankVaultAuthority;
exports.makeWrapSolIxs = makeWrapSolIxs;
exports.makeUnwrapSolIx = makeUnwrapSolIx;
exports.makeVersionedTransaction = makeVersionedTransaction;
exports.makePriorityFeeMicroIx = makePriorityFeeMicroIx;
exports.makePriorityFeeIx = makePriorityFeeIx;
exports.feedIdToString = feedIdToString;
exports.buildFeedIdMap = buildFeedIdMap;
exports.findOracleKey = findOracleKey;
exports.findPythPushOracleAddress = findPythPushOracleAddress;
const web3_js_1 = require("@solana/web3.js");
const constants_1 = require("./constants");
const types_1 = require("./types");
const mrgn_common_1 = require("@mrgnlabs/mrgn-common");
const bank_types_1 = require("./services/bank/types/bank.types");
const deserialize_utils_1 = require("./services/bank/utils/deserialize.utils");
const vendor_1 = require("./vendor");
function getBankVaultSeeds(type) {
    switch (type) {
        case types_1.BankVaultType.LiquidityVault:
            return constants_1.PDA_BANK_LIQUIDITY_VAULT_SEED;
        case types_1.BankVaultType.InsuranceVault:
            return constants_1.PDA_BANK_INSURANCE_VAULT_SEED;
        case types_1.BankVaultType.FeeVault:
            return constants_1.PDA_BANK_FEE_VAULT_SEED;
        default:
            throw Error(`Unknown vault type ${type}`);
    }
}
function getBankVaultAuthoritySeeds(type) {
    switch (type) {
        case types_1.BankVaultType.LiquidityVault:
            return constants_1.PDA_BANK_LIQUIDITY_VAULT_AUTH_SEED;
        case types_1.BankVaultType.InsuranceVault:
            return constants_1.PDA_BANK_INSURANCE_VAULT_AUTH_SEED;
        case types_1.BankVaultType.FeeVault:
            return constants_1.PDA_BANK_FEE_VAULT_AUTH_SEED;
        default:
            throw Error(`Unknown vault type ${type}`);
    }
}
/**
 * Compute authority PDA for a specific marginfi group bank vault
 */
function getBankVaultAuthority(bankVaultType, bankPk, programId) {
    return web3_js_1.PublicKey.findProgramAddressSync([getBankVaultAuthoritySeeds(bankVaultType), bankPk.toBuffer()], programId);
}
function makeWrapSolIxs(walletAddress, amount) {
    const address = (0, mrgn_common_1.getAssociatedTokenAddressSync)(mrgn_common_1.NATIVE_MINT, walletAddress, true);
    const ixs = [(0, mrgn_common_1.createAssociatedTokenAccountIdempotentInstruction)(walletAddress, address, walletAddress, mrgn_common_1.NATIVE_MINT)];
    if (amount.gt(0)) {
        const nativeAmount = (0, mrgn_common_1.uiToNative)(amount, 9).toNumber() + 10000;
        ixs.push(web3_js_1.SystemProgram.transfer({ fromPubkey: walletAddress, toPubkey: address, lamports: nativeAmount }), (0, mrgn_common_1.createSyncNativeInstruction)(address));
    }
    return ixs;
}
function makeUnwrapSolIx(walletAddress) {
    const address = (0, mrgn_common_1.getAssociatedTokenAddressSync)(mrgn_common_1.NATIVE_MINT, walletAddress, true); // We allow off curve addresses here to support Fuse.
    return (0, mrgn_common_1.createCloseAccountInstruction)(address, walletAddress, walletAddress);
}
async function makeVersionedTransaction(blockhash, transaction, payer, addressLookupTables) {
    const message = new web3_js_1.TransactionMessage({
        instructions: transaction.instructions,
        payerKey: payer,
        recentBlockhash: blockhash,
    });
    const versionedMessage = addressLookupTables
        ? message.compileToV0Message(addressLookupTables)
        : message.compileToLegacyMessage();
    return new web3_js_1.VersionedTransaction(versionedMessage);
}
/**
 * Creates a compute budget instruction to set the priority fee for a transaction.
 * The priority fee is specified in micro-lamports per compute unit.
 *
 * @param priorityFeeMicro - Priority fee in micro-lamports per compute unit. If not provided, defaults to 1.
 * @returns A compute budget instruction with the specified priority fee
 */
function makePriorityFeeMicroIx(priorityFeeMicro) {
    return web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
        microLamports: Math.floor(priorityFeeMicro ?? 1),
    });
}
/*
  deprecated use makePriorityFeeMicroIx instead
*/
function makePriorityFeeIx(priorityFeeUi, computeUnitsLimit) {
    const priorityFeeIx = [];
    const limit = computeUnitsLimit ?? 1_400_000;
    let microLamports = 1;
    if (priorityFeeUi) {
        // if priority fee is above 0.2 SOL discard it for safety reasons
        const isAbsurdPriorityFee = priorityFeeUi > 0.1;
        if (!isAbsurdPriorityFee) {
            const priorityFeeMicroLamports = priorityFeeUi * web3_js_1.LAMPORTS_PER_SOL * 1_000_000;
            microLamports = Math.round(priorityFeeMicroLamports / limit);
        }
    }
    priorityFeeIx.push(web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
        microLamports,
    }));
    return priorityFeeIx;
}
function feedIdToString(feedId) {
    return feedId.toBuffer().toString("hex");
}
async function buildFeedIdMap(bankConfigs, connection) {
    const feedIdMap = new Map();
    const feedIdsWithAddresses = bankConfigs
        .filter((bankConfig) => (0, deserialize_utils_1.parseOracleSetup)(bankConfig.oracleSetup) == bank_types_1.OracleSetup.PythPushOracle)
        .map((bankConfig) => {
        let feedId = bankConfig.oracleKeys[0].toBuffer();
        return {
            feedId,
            addresses: [
                findPythPushOracleAddress(feedId, constants_1.PYTH_PUSH_ORACLE_ID, exports.PYTH_SPONSORED_SHARD_ID),
                findPythPushOracleAddress(feedId, constants_1.PYTH_PUSH_ORACLE_ID, exports.MARGINFI_SPONSORED_SHARD_ID),
            ],
        };
    })
        .flat();
    const addressess = feedIdsWithAddresses.map((feedIdWithAddress) => feedIdWithAddress.addresses).flat();
    const accountInfos = [];
    const chunkSize = 25;
    for (let i = 0; i < addressess.length; i += chunkSize) {
        const chunk = addressess.slice(i, i + chunkSize);
        const accountInfosChunk = await connection.getMultipleAccountsInfo(chunk);
        accountInfos.push(...accountInfosChunk);
    }
    for (let i = 0; i < feedIdsWithAddresses.length; i++) {
        const oraclesStartIndex = i * 2;
        const pythSponsoredOracle = accountInfos[oraclesStartIndex];
        const mfiSponsoredOracle = accountInfos[oraclesStartIndex + 1];
        const feedId = feedIdsWithAddresses[i].feedId.toString("hex");
        if (mfiSponsoredOracle && pythSponsoredOracle) {
            let pythPriceAccount = (0, vendor_1.parsePriceInfo)(pythSponsoredOracle.data.slice(8));
            let pythPublishTime = pythPriceAccount.priceMessage.publishTime;
            let mfiPriceAccount = (0, vendor_1.parsePriceInfo)(mfiSponsoredOracle.data.slice(8));
            let mfiPublishTime = mfiPriceAccount.priceMessage.publishTime;
            if (pythPublishTime > mfiPublishTime) {
                feedIdMap.set(feedId, { feedId: feedIdsWithAddresses[i].addresses[0], shardId: exports.PYTH_SPONSORED_SHARD_ID });
            }
            else {
                feedIdMap.set(feedId, { feedId: feedIdsWithAddresses[i].addresses[1], shardId: exports.MARGINFI_SPONSORED_SHARD_ID });
            }
        }
        else if (pythSponsoredOracle) {
            feedIdMap.set(feedId, { feedId: feedIdsWithAddresses[i].addresses[0], shardId: exports.PYTH_SPONSORED_SHARD_ID });
        }
        else if (mfiSponsoredOracle) {
            feedIdMap.set(feedId, { feedId: feedIdsWithAddresses[i].addresses[1], shardId: exports.MARGINFI_SPONSORED_SHARD_ID });
        }
        else {
            throw new Error(`No oracle found for feedId: ${feedId}, either Pyth or MFI sponsored oracle must exist`);
        }
    }
    return feedIdMap;
}
function findOracleKey(bankConfig) {
    try {
        const oracleSetup = bankConfig.oracleSetup;
        const oracleKey = bankConfig.oracleKeys[0];
        return { oracleKey };
    }
    catch (error) {
        console.error("Error finding oracle key", error);
        console.log("oracleSetup", bankConfig.oracleSetup);
        return { oracleKey: bankConfig.oracleKeys[0] };
    }
}
exports.PYTH_SPONSORED_SHARD_ID = 0;
exports.MARGINFI_SPONSORED_SHARD_ID = 3301;
function findPythPushOracleAddress(feedId, programId, shardId) {
    const shardBytes = u16ToArrayBufferLE(shardId);
    return web3_js_1.PublicKey.findProgramAddressSync([shardBytes, feedId], programId)[0];
}
function u16ToArrayBufferLE(value) {
    // Create a buffer of 2 bytes
    const buffer = new ArrayBuffer(2);
    const dataView = new DataView(buffer);
    // Set the Uint16 value in little-endian order
    dataView.setUint16(0, value, true);
    // Return the buffer
    return new Uint8Array(buffer);
}

import { Address, AnchorProvider } from "@coral-xyz/anchor";
import { AddressLookupTableAccount, Commitment, ConfirmOptions, Connection, Keypair, PublicKey, Transaction, TransactionInstruction, TransactionSignature, VersionedTransaction } from "@solana/web3.js";
import { AccountType, Environment, MarginfiConfig, MarginfiProgram } from "../types";
import { BankMetadataMap, InstructionsWrapper, SolanaTransaction, TransactionOptions, Wallet } from "@mrgnlabs/mrgn-common";
import { MarginfiGroup } from "../models/group";
import { Bank, OraclePrice, BankConfigOpt } from "..";
import { MarginfiAccountWrapper } from "../models/account/wrapper";
import { PythPushFeedIdMap } from "../utils";
import { ProcessTransactionStrategy, ProcessTransactionsClientOpts } from "../services";
export type BankMap = Map<string, Bank>;
export type OraclePriceMap = Map<string, OraclePrice>;
export type MintDataMap = Map<string, MintData>;
export type MintData = {
    mint: PublicKey;
    tokenProgram: PublicKey;
    feeBps: number;
    emissionTokenProgram: PublicKey | null;
};
export type MarginfiClientOptions = {
    confirmOpts?: ConfirmOptions;
    readOnly?: boolean;
    preloadedBankAddresses?: PublicKey[];
    bundleSimRpcEndpoint?: string;
    processTransactionStrategy?: ProcessTransactionStrategy;
    bankMetadataMap?: BankMetadataMap;
    fetchGroupDataOverride?: (program: MarginfiProgram, groupAddress: PublicKey, commitment?: Commitment, bankAddresses?: PublicKey[], bankMetadataMap?: BankMetadataMap) => Promise<{
        marginfiGroup: MarginfiGroup;
        banks: Map<string, Bank>;
        priceInfos: Map<string, OraclePrice>;
        tokenDatas: Map<string, MintData>;
        feedIdMap: PythPushFeedIdMap;
    }>;
};
/**
 * Entrypoint to interact with the marginfi contract.
 */
declare class MarginfiClient {
    readonly config: MarginfiConfig;
    readonly program: MarginfiProgram;
    readonly wallet: Wallet;
    readonly isReadOnly: boolean;
    readonly bankMetadataMap?: BankMetadataMap | undefined;
    group: MarginfiGroup;
    banks: BankMap;
    oraclePrices: OraclePriceMap;
    mintDatas: MintDataMap;
    addressLookupTables: AddressLookupTableAccount[];
    lookupTablesAddresses: PublicKey[];
    feedIdMap: PythPushFeedIdMap;
    processTransactionStrategy?: ProcessTransactionStrategy;
    private preloadedBankAddresses?;
    private bundleSimRpcEndpoint;
    constructor(config: MarginfiConfig, program: MarginfiProgram, wallet: Wallet, isReadOnly: boolean, group: MarginfiGroup, banks: BankMap, priceInfos: OraclePriceMap, mintDatas: MintDataMap, feedIdMap: PythPushFeedIdMap, addressLookupTables?: AddressLookupTableAccount[], preloadedBankAddresses?: PublicKey[], bankMetadataMap?: BankMetadataMap | undefined, bundleSimRpcEndpoint?: string, processTransactionStrategy?: ProcessTransactionStrategy, lookupTablesAddresses?: PublicKey[]);
    /**
     * MarginfiClient factory
     *
     * Fetch account data according to the config and instantiate the corresponding MarginfiAccount.
     *
     * @param config marginfi config
     * @param wallet User wallet (used to pay fees and sign transactions)
     * @param connection Solana web.js Connection object
     * @returns MarginfiClient instance
     */
    static fetch(config: MarginfiConfig, wallet: Wallet, connection: Connection, clientOptions?: MarginfiClientOptions): Promise<MarginfiClient>;
    static fromEnv(overrides?: Partial<{
        env: Environment;
        connection: Connection;
        programId: Address;
        marginfiGroup: Address;
        wallet: Wallet;
    }>): Promise<MarginfiClient>;
    static fetchGroupData(program: MarginfiProgram, groupAddress: PublicKey, commitment?: Commitment, bankAddresses?: PublicKey[], bankMetadataMap?: BankMetadataMap): Promise<{
        marginfiGroup: MarginfiGroup;
        banks: Map<string, Bank>;
        priceInfos: Map<string, OraclePrice>;
        tokenDatas: Map<string, MintData>;
        feedIdMap: PythPushFeedIdMap;
    }>;
    reload(): Promise<void>;
    get groupAddress(): PublicKey;
    get provider(): AnchorProvider;
    get programId(): PublicKey;
    getAllMarginfiAccountPubkeys(): Promise<PublicKey[]>;
    /**
     * Fetches multiple marginfi accounts based on an array of public keys using the getMultipleAccounts RPC call.
     *
     * @param pubkeys - The public keys of the marginfi accounts to fetch.
     * @returns An array of MarginfiAccountWrapper instances.
     */
    getMultipleMarginfiAccounts(pubkeys: PublicKey[]): Promise<MarginfiAccountWrapper[]>;
    /**
     * Retrieves the addresses of all marginfi accounts in the underlying group.
     *
     * @returns Account addresses
     */
    getAllMarginfiAccountAddresses(): Promise<PublicKey[]>;
    /**
     * Retrieves all marginfi accounts under the specified authority.
     *
     * @returns MarginfiAccount instances
     */
    getMarginfiAccountsForAuthority(authority?: Address): Promise<MarginfiAccountWrapper[]>;
    /**
     * Retrieves the addresses of all accounts owned by the marginfi program.
     *
     * @returns Account addresses
     */
    getAllProgramAccountAddresses(type: AccountType): Promise<PublicKey[]>;
    getBankByPk(bankAddress: Address): Bank | null;
    getBankByMint(mint: Address): Bank | null;
    getBankByTokenSymbol(tokenSymbol: string): Bank | null;
    getOraclePriceByBank(bankAddress: Address): OraclePrice | null;
    /**
     * Create transaction instruction to create a new marginfi account under the authority of the user.
     *
     * @returns transaction instruction
     */
    makeCreateMarginfiAccountIx(marginfiAccountPk: PublicKey): Promise<InstructionsWrapper>;
    /**
     * Create a new marginfi account under the authority of the user.
     *
     * @param createOpts - Options for creating the account
     * @param createOpts.newAccountKey - Optional public key to use for the new account. If not provided, a new keypair will be generated.
     * @param processOpts - Options for processing the transaction
     * @param txOpts - Transaction options
     * @returns Object containing the transaction signature and the created MarginfiAccount instance
     */
    createMarginfiAccount(createOpts?: {
        newAccountKey?: PublicKey | undefined;
    }, processOpts?: ProcessTransactionsClientOpts, txOpts?: TransactionOptions): Promise<MarginfiAccountWrapper>;
    /**
     * Create a transaction to initialize a new marginfi account under the authority of the user.
     *
     * @param createOpts - Options for creating the account
     * @param createOpts.newAccountKey - Optional public key to use for the new account. If not provided, a new keypair will be generated.
     * @returns Transaction that can be used to create a new marginfi account
     */
    createMarginfiAccountTx(createOpts?: {
        accountKeypair?: Keypair;
    }): Promise<SolanaTransaction>;
    /**
     * Create transaction instruction to initialize a new group.
     *
     * @returns transaction instruction
     */
    makeCreateMarginfiGroupIx(marginfiGroup: PublicKey): Promise<InstructionsWrapper>;
    /**
     * Initiates a new permissionless marginfi bank under the authority of the user.
     *
     * @param {Object} params - The parameters for creating a permissionless bank.
     * @param {PublicKey} params.mint - The public key of the mint for the bank.
     * @param {BankConfigOpt} params.bankConfig - The configuration options for the bank.
     * @param {PublicKey} params.group - The public key of the group to which the bank belongs.
     * @param {PublicKey} params.admin - The public key of the admin who will have authority over the bank.
     * @param {Keypair} [params.seed] - An optional keypair used as a seed for generating the bank account.
     * @param {TransactionOptions} [params.txOpts] - Optional transaction options for processing.
     * @param {ProcessTransactionsClientOpts} [params.processOpts] - Optional processing options for transactions.
     * @returns {Promise<TransactionSignature>} A promise that resolves to the transaction signature as a string.
     */
    createPermissionlessBank({ mint, bankConfig, group, admin, seed, txOpts, processOpts, }: {
        mint: PublicKey;
        bankConfig: BankConfigOpt;
        group: PublicKey;
        admin: PublicKey;
        seed?: Keypair;
        processOpts?: ProcessTransactionsClientOpts;
        txOpts?: TransactionOptions;
    }): Promise<TransactionSignature>;
    /**
     * Initializes a new marginfi group with the specified parameters.
     *
     * @param seed - Optional keypair used for generating the group account.
     * @param additionalIxs - Optional array of additional transaction instructions to include.
     * @param txOpts - Optional transaction options for processing.
     * @param processOpts - Optional processing options for transactions.
     * @returns The public key of the newly created marginfi group.
     */
    createMarginfiGroup(seed?: Keypair, additionalIxs?: TransactionInstruction[], processOpts?: ProcessTransactionsClientOpts, txOpts?: TransactionOptions): Promise<PublicKey>;
    /**
     * Create a new bank under the authority of the user.
     *
     * @param bankMint - The public key of the token mint for the bank.
     * @param bankConfig - Configuration options for the bank.
     * @param seed - Optional keypair for the bank.
     * @param txOpts - Optional transaction options for processing.
     * @param processOpts - Optional processing options for transactions.
     * @returns The bank's public key and the transaction signature
     */
    createLendingPool(bankMint: PublicKey, bankConfig: BankConfigOpt, seed?: Keypair, processOpts?: ProcessTransactionsClientOpts, txOpts?: TransactionOptions): Promise<{
        bankAddress: PublicKey;
        signature: TransactionSignature;
    }>;
    /**
     * Processes multiple Solana transactions by signing and sending them to the network.
     *
     * @param {SolanaTransaction[]} transactions - An array of transactions to be processed.
     * @param {ProcessTransactionsClientOpts} [processOpts] - Optional processing options for transactions.
     * @param {TransactionOptions} [txOpts] - Optional transaction options for processing.
     *
     * @returns {Promise<TransactionSignature[]>} - A promise that resolves to an array of transaction signatures.
     *
     * @throws {ProcessTransactionError} - Throws an error if transaction processing fails.
     */
    processTransactions(transactions: SolanaTransaction[], processOpts?: ProcessTransactionsClientOpts, txOpts?: TransactionOptions): Promise<TransactionSignature[]>;
    /**
     * Processes a single Solana transaction by signing and sending it to the network.
     *
     * @param {SolanaTransaction} transaction - The transaction to be processed.
     * @param {TransactionOptions} [txOpts] - Optional transaction options.
     * @param {ProcessTransactionsClientOpts} [processOpts] - Optional processing options.
     *
     * @returns {Promise<TransactionSignature>} - A promise that resolves to the transaction signature.
     *
     * @throws {ProcessTransactionError} - Throws an error if transaction processing fails.
     */
    processTransaction(transaction: SolanaTransaction, processOpts?: ProcessTransactionsClientOpts, txOpts?: TransactionOptions): Promise<TransactionSignature>;
    simulateTransactions(transactions: (Transaction | VersionedTransaction)[], accountsToInspect: PublicKey[]): Promise<(Buffer | null)[]>;
}
export default MarginfiClient;
//# sourceMappingURL=client.d.ts.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const anchor_1 = require("@coral-xyz/anchor");
const web3_js_1 = require("@solana/web3.js");
const bs58_1 = __importDefault(require("bs58"));
const types_1 = require("../types");
const config_1 = require("../config");
const instructions_1 = __importDefault(require("../instructions"));
const account_1 = require("../models/account");
const mrgn_common_1 = require("@mrgnlabs/mrgn-common");
const group_1 = require("../models/group");
const __1 = require("..");
const wrapper_1 = require("../models/account/wrapper");
const errors_1 = require("../errors");
const utils_1 = require("../utils");
const services_1 = require("../services");
const helpers_1 = require("../services/transaction/helpers");
const vendor_1 = require("../vendor");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const idl_utils_1 = require("../idl/idl.utils");
/**
 * Entrypoint to interact with the marginfi contract.
 */
class MarginfiClient {
    // --------------------------------------------------------------------------
    // Factories
    // --------------------------------------------------------------------------
    constructor(config, program, wallet, isReadOnly, group, banks, priceInfos, mintDatas, feedIdMap, addressLookupTables, preloadedBankAddresses, bankMetadataMap, bundleSimRpcEndpoint, processTransactionStrategy, lookupTablesAddresses) {
        this.config = config;
        this.program = program;
        this.wallet = wallet;
        this.isReadOnly = isReadOnly;
        this.bankMetadataMap = bankMetadataMap;
        this.group = group;
        this.banks = banks;
        this.oraclePrices = priceInfos;
        this.mintDatas = mintDatas;
        this.addressLookupTables = addressLookupTables ?? [];
        this.preloadedBankAddresses = preloadedBankAddresses;
        this.feedIdMap = feedIdMap;
        this.bundleSimRpcEndpoint = bundleSimRpcEndpoint ?? program.provider.connection.rpcEndpoint;
        this.processTransactionStrategy = processTransactionStrategy;
        this.lookupTablesAddresses = lookupTablesAddresses ?? [];
    }
    /**
     * MarginfiClient factory
     *
     * Fetch account data according to the config and instantiate the corresponding MarginfiAccount.
     *
     * @param config marginfi config
     * @param wallet User wallet (used to pay fees and sign transactions)
     * @param connection Solana web.js Connection object
     * @returns MarginfiClient instance
     */
    static async fetch(config, wallet, connection, clientOptions) {
        const debug = require("debug")("mfi:client");
        debug("Loading Marginfi Client\n\tprogram: %s\n\tenv: %s\n\tgroup: %s\n\turl: %s", config.programId, config.environment, config.groupPk, connection.rpcEndpoint);
        const programIdl = (0, idl_utils_1.fetchLatestIdl)();
        const confirmOpts = clientOptions?.confirmOpts ?? {};
        const readOnly = clientOptions?.readOnly ?? false;
        const preloadedBankAddresses = clientOptions?.preloadedBankAddresses;
        const provider = new anchor_1.AnchorProvider(connection, wallet, {
            ...anchor_1.AnchorProvider.defaultOptions(),
            commitment: connection.commitment ?? anchor_1.AnchorProvider.defaultOptions().commitment,
            ...confirmOpts,
        });
        const idl = { ...programIdl, address: config.programId.toBase58() };
        const program = new anchor_1.Program(idl, provider);
        let bankMetadataMap = clientOptions?.bankMetadataMap;
        try {
            if (!bankMetadataMap) {
                bankMetadataMap = {
                    ...(await (0, mrgn_common_1.loadBankMetadatas)()),
                    ...(await (0, mrgn_common_1.loadStakedBankMetadatas)()),
                };
            }
        }
        catch (error) {
            console.error("Failed to load bank metadatas. Convenience getter by symbol will not be available", error);
        }
        const fetchGroupData = clientOptions?.fetchGroupDataOverride ?? MarginfiClient.fetchGroupData;
        const { marginfiGroup, banks, priceInfos, tokenDatas, feedIdMap } = await fetchGroupData(program, config.groupPk, connection.commitment, preloadedBankAddresses, bankMetadataMap);
        let addressLookupTableAddresses = __1.ADDRESS_LOOKUP_TABLE_FOR_GROUP[config.groupPk.toString()];
        if (!addressLookupTableAddresses) {
            try {
                const response = await fetch(`https://storage.googleapis.com/mrgn-public/mrgn-lut-cache.json`, {
                    headers: {
                        Accept: "application/json",
                    },
                    method: "GET",
                });
                if (response.status === 200) {
                    const parsedResponse = await response.json();
                    if (!parsedResponse)
                        throw new Error("JSON is mia");
                    const lookupTableString = parsedResponse[config.groupPk.toString()];
                    if (!parsedResponse)
                        throw new Error("Group not found");
                    addressLookupTableAddresses = [new web3_js_1.PublicKey(lookupTableString)];
                }
                else {
                    throw new Error("LUT not found");
                }
            }
            catch (error) {
                addressLookupTableAddresses = [];
            }
        }
        debug("Fetching address lookup tables for %s", addressLookupTableAddresses);
        const addressLookupTables = (await Promise.all(addressLookupTableAddresses.map((address) => connection.getAddressLookupTable(address))))
            .map((response) => response.value)
            .filter((table) => table !== null);
        return new MarginfiClient(config, program, wallet, readOnly, marginfiGroup, banks, priceInfos, tokenDatas, feedIdMap, addressLookupTables, preloadedBankAddresses, bankMetadataMap, clientOptions?.bundleSimRpcEndpoint, clientOptions?.processTransactionStrategy);
    }
    static async fromEnv(overrides) {
        const debug = require("debug")("mfi:client");
        const env = overrides?.env ?? process.env.MARGINFI_ENV;
        const connection = overrides?.connection ??
            new web3_js_1.Connection(process.env.MARGINFI_RPC_ENDPOINT, {
                commitment: mrgn_common_1.DEFAULT_COMMITMENT,
            });
        const programId = overrides?.programId ?? new web3_js_1.PublicKey(process.env.MARGINFI_PROGRAM);
        const groupPk = overrides?.marginfiGroup ??
            (process.env.MARGINFI_GROUP ? new web3_js_1.PublicKey(process.env.MARGINFI_GROUP) : web3_js_1.PublicKey.default);
        const wallet = overrides?.wallet ??
            new mrgn_common_1.NodeWallet(process.env.MARGINFI_WALLET_KEY
                ? web3_js_1.Keypair.fromSecretKey(new Uint8Array(JSON.parse(process.env.MARGINFI_WALLET_KEY)))
                : (0, mrgn_common_1.loadKeypair)(process.env.MARGINFI_WALLET));
        debug("Loading the marginfi client from env vars");
        debug("Env: %s\nProgram: %s\nGroup: %s\nSigner: %s", env, programId, groupPk, wallet.publicKey);
        const config = (0, config_1.getConfig)(env, {
            groupPk: (0, anchor_1.translateAddress)(groupPk),
            programId: (0, anchor_1.translateAddress)(programId),
        });
        return MarginfiClient.fetch(config, wallet, connection, {
            confirmOpts: {
                commitment: connection.commitment,
            },
        });
    }
    // NOTE: 2 RPC calls
    // Pass in bankAddresses to skip the gpa call
    static async fetchGroupData(program, groupAddress, commitment, bankAddresses, bankMetadataMap) {
        const debug = require("debug")("mfi:client");
        // Fetch & shape all accounts of Bank type (~ bank discovery)
        let bankDatasKeyed = [];
        if (bankAddresses && bankAddresses.length > 0) {
            debug("Using preloaded bank addresses, skipping gpa call", bankAddresses.length, "banks");
            let bankAccountsData = await program.account.bank.fetchMultiple(bankAddresses);
            for (let i = 0; i < bankAccountsData.length; i++) {
                if (bankAccountsData[i] !== null) {
                    bankDatasKeyed.push({
                        address: bankAddresses[i],
                        data: bankAccountsData[i],
                    });
                }
            }
        }
        else {
            let bankAccountsData = await program.account.bank.all([
                { memcmp: { offset: 8 + 32 + 1, bytes: groupAddress.toBase58() } },
            ]);
            bankDatasKeyed = bankAccountsData
                .filter((account) => account.account.config.assetTag !== 3)
                .map((account) => ({
                address: account.publicKey,
                data: account.account,
            }));
        }
        // const oracleKeys = bankDatasKeyed.map((b) => b.data.config.oracleKeys[0]);
        const mintKeys = bankDatasKeyed.map((b) => b.data.mint);
        const emissionMintKeys = bankDatasKeyed
            .map((b) => b.data.emissionsMint)
            .filter((pk) => !pk.equals(web3_js_1.PublicKey.default));
        const oracleKeys = bankDatasKeyed.map((b) => (0, utils_1.findOracleKey)(__1.BankConfig.fromAccountParsed(b.data.config)).oracleKey);
        // Batch-fetch the group account and all the oracle accounts as per the banks retrieved above
        const allAis = await (0, mrgn_common_1.chunkedGetRawMultipleAccountInfoOrdered)(program.provider.connection, [
            groupAddress.toBase58(),
            ...oracleKeys.map((pk) => pk.toBase58()),
            ...mintKeys.map((pk) => pk.toBase58()),
            ...emissionMintKeys.map((pk) => pk.toBase58()),
        ]); // NOTE: This will break if/when we start having more than 1 oracle key per bank
        const groupAi = allAis.shift();
        const oracleAis = allAis.splice(0, oracleKeys.length);
        const mintAis = allAis.splice(0, mintKeys.length);
        const emissionMintAis = allAis.splice(0);
        // Unpack raw data for group and oracles, and build the `Bank`s map
        if (!groupAi)
            throw new Error("Failed to fetch the on-chain group data");
        const marginfiGroup = group_1.MarginfiGroup.fromBuffer(groupAddress, groupAi.data, program.idl);
        const banks = new Map(bankDatasKeyed.map(({ address, data }) => {
            const bankMetadata = bankMetadataMap ? bankMetadataMap[address.toBase58()] : undefined;
            const bank = __1.Bank.fromAccountParsed(address, data, undefined, bankMetadata);
            return [address.toBase58(), bank];
        }));
        const tokenDatas = new Map(bankDatasKeyed.map(({ address: bankAddress, data: bankData }, index) => {
            const mintAddress = mintKeys[index];
            const mintDataRaw = mintAis[index];
            if (!mintDataRaw)
                throw new Error(`Failed to fetch mint account for bank ${bankAddress.toBase58()}`);
            let emissionTokenProgram = null;
            if (!bankData.emissionsMint.equals(web3_js_1.PublicKey.default)) {
                const emissionMintDataRawIndex = emissionMintKeys.findIndex((pk) => pk.equals(bankData.emissionsMint));
                emissionTokenProgram = emissionMintDataRawIndex >= 0 ? emissionMintAis[emissionMintDataRawIndex].owner : null;
            }
            // TODO: parse extension data to see if there is a fee
            return [
                bankAddress.toBase58(),
                { mint: mintAddress, tokenProgram: mintDataRaw.owner, feeBps: 0, emissionTokenProgram },
            ];
        }));
        const pythStakedCollateralBanks = [];
        const priceInfos = new Map(bankDatasKeyed.map(({ address: bankAddress, data: bankData }, index) => {
            const priceDataRaw = oracleAis[index];
            if (!priceDataRaw)
                throw new Error(`Failed to fetch price oracle account for bank ${bankAddress.toBase58()}`);
            const oracleSetup = (0, __1.parseOracleSetup)(bankData.config.oracleSetup);
            if (oracleSetup === __1.OracleSetup.StakedWithPythPush) {
                pythStakedCollateralBanks.push(bankAddress);
            }
            return [bankAddress.toBase58(), (0, __1.parsePriceInfo)(oracleSetup, priceDataRaw.data)];
        }));
        if (pythStakedCollateralBanks.length > 0 && bankMetadataMap) {
            const stakedCollatMap = {};
            const solPools = [];
            const mints = [];
            pythStakedCollateralBanks.forEach((bankAddress) => {
                const bankMetadata = bankMetadataMap[bankAddress.toBase58()];
                if (bankMetadata && bankMetadata.validatorVoteAccount) {
                    const [poolAddress] = web3_js_1.PublicKey.findProgramAddressSync([Buffer.from("pool"), new web3_js_1.PublicKey(bankMetadata.validatorVoteAccount).toBuffer()], mrgn_common_1.SINGLE_POOL_PROGRAM_ID);
                    const [stakePoolAddress] = web3_js_1.PublicKey.findProgramAddressSync([Buffer.from("stake"), poolAddress.toBuffer()], mrgn_common_1.SINGLE_POOL_PROGRAM_ID);
                    stakedCollatMap[bankAddress.toBase58()] = {
                        bankAddress,
                        mint: new web3_js_1.PublicKey(bankMetadata.tokenAddress),
                        stakePoolAddress,
                        poolAddress,
                    };
                    solPools.push(stakePoolAddress.toBase58());
                    mints.push(bankMetadata.tokenAddress);
                }
            });
            const dataAis = await (0, mrgn_common_1.chunkedGetRawMultipleAccountInfoOrdered)(program.provider.connection, [
                ...mints,
                ...solPools,
            ]);
            const stakePoolsAis = dataAis.slice(mints.length).map((ai) => (0, vendor_1.getStakeAccount)(ai.data));
            const lstMintsAis = dataAis.slice(0, mints.length).map((mintAi) => mrgn_common_1.MintLayout.decode(mintAi.data));
            const lstMintRecord = Object.fromEntries(mints.map((mint, i) => [mint, lstMintsAis[i]]));
            const solPoolsRecord = Object.fromEntries(solPools.map((poolKey, i) => [poolKey, stakePoolsAis[i]]));
            for (const index in stakedCollatMap) {
                const { bankAddress, mint, stakePoolAddress, poolAddress } = stakedCollatMap[index];
                const stakeAccount = solPoolsRecord[stakePoolAddress.toBase58()];
                const tokenSupply = lstMintRecord[mint.toBase58()].supply;
                const stakeActual = Number(stakeAccount.stake.delegation.stake);
                const oracle = priceInfos.get(bankAddress.toBase58());
                if (oracle) {
                    const adjustPrice = (price, stakeActual, tokenSupply) => {
                        return Number(tokenSupply) === 0
                            ? price
                            : new bignumber_js_1.default((price.toNumber() * (stakeActual - web3_js_1.LAMPORTS_PER_SOL)) / Number(tokenSupply));
                    };
                    const adjustPriceComponent = (priceComponent, stakeActual, tokenSupply) => ({
                        price: adjustPrice(priceComponent.price, stakeActual, tokenSupply),
                        confidence: priceComponent.confidence,
                        lowestPrice: adjustPrice(priceComponent.lowestPrice, stakeActual, tokenSupply),
                        highestPrice: adjustPrice(priceComponent.highestPrice, stakeActual, tokenSupply),
                    });
                    const oraclePrice = {
                        timestamp: oracle.timestamp,
                        priceRealtime: adjustPriceComponent(oracle.priceRealtime, stakeActual, tokenSupply),
                        priceWeighted: adjustPriceComponent(oracle.priceWeighted, stakeActual, tokenSupply),
                    };
                    priceInfos.set(bankAddress.toBase58(), oraclePrice);
                }
            }
        }
        debug("Fetched %s banks and %s price feeds", banks.size, priceInfos.size);
        return {
            marginfiGroup,
            banks,
            priceInfos,
            tokenDatas,
            feedIdMap: new Map(),
        };
    }
    async reload() {
        const { marginfiGroup, banks, priceInfos } = await MarginfiClient.fetchGroupData(this.program, this.config.groupPk, this.program.provider.connection.commitment, this.preloadedBankAddresses);
        this.group = marginfiGroup;
        this.banks = banks;
        this.oraclePrices = priceInfos;
    }
    // --------------------------------------------------------------------------
    // Attributes
    // --------------------------------------------------------------------------
    get groupAddress() {
        return this.config.groupPk;
    }
    get provider() {
        return this.program.provider;
    }
    get programId() {
        return this.program.programId;
    }
    async getAllMarginfiAccountPubkeys() {
        return (await this.provider.connection.getProgramAccounts(this.programId, {
            filters: [
                {
                    memcmp: {
                        bytes: this.config.groupPk.toBase58(),
                        offset: 8, // marginfiGroup is the first field in the account, so only offset is the discriminant
                    },
                },
            ],
            dataSlice: { offset: 0, length: 0 },
        })).map((a) => a.pubkey);
    }
    /**
     * Fetches multiple marginfi accounts based on an array of public keys using the getMultipleAccounts RPC call.
     *
     * @param pubkeys - The public keys of the marginfi accounts to fetch.
     * @returns An array of MarginfiAccountWrapper instances.
     */
    async getMultipleMarginfiAccounts(pubkeys) {
        require("debug")("mfi:client")("Fetching %s marginfi accounts", pubkeys);
        const accounts = await this.program.account.marginfiAccount.fetchMultiple(pubkeys);
        return accounts.map((account, index) => {
            if (!account) {
                throw new Error(`Account not found for pubkey: ${pubkeys[index].toBase58()}`);
            }
            return wrapper_1.MarginfiAccountWrapper.fromAccountParsed(pubkeys[index], this, account);
        });
    }
    /**
     * Retrieves the addresses of all marginfi accounts in the underlying group.
     *
     * @returns Account addresses
     */
    async getAllMarginfiAccountAddresses() {
        return (await this.program.provider.connection.getProgramAccounts(this.programId, {
            commitment: this.program.provider.connection.commitment,
            dataSlice: {
                offset: 0,
                length: 0,
            },
            filters: [
                {
                    memcmp: {
                        bytes: this.groupAddress.toBase58(),
                        offset: 8, // marginfiGroup is the second field in the account after the authority, so offset by the discriminant and a pubkey
                    },
                },
                {
                    memcmp: {
                        offset: 0,
                        bytes: bs58_1.default.encode(new anchor_1.BorshAccountsCoder(this.program.idl).accountDiscriminator(types_1.AccountType.MarginfiAccount)),
                    },
                },
            ],
        })).map((a) => a.pubkey);
    }
    /**
     * Retrieves all marginfi accounts under the specified authority.
     *
     * @returns MarginfiAccount instances
     */
    async getMarginfiAccountsForAuthority(authority) {
        const _authority = authority ? (0, anchor_1.translateAddress)(authority) : this.provider.wallet.publicKey;
        const marginfiAccounts = (await this.program.account.marginfiAccount.all([
            {
                memcmp: {
                    bytes: this.groupAddress.toBase58(),
                    offset: 8, // marginfiGroup is the first field in the account, so only offset is the discriminant
                },
            },
            {
                memcmp: {
                    bytes: _authority.toBase58(),
                    offset: 8 + 32, // authority is the second field in the account after the authority, so offset by the discriminant and a pubkey
                },
            },
        ])).map((a) => wrapper_1.MarginfiAccountWrapper.fromAccountParsed(a.publicKey, this, a.account));
        marginfiAccounts.sort((accountA, accountB) => {
            const assetsValueA = accountA.computeHealthComponents(account_1.MarginRequirementType.Equity).assets;
            const assetsValueB = accountB.computeHealthComponents(account_1.MarginRequirementType.Equity).assets;
            if (assetsValueA.eq(assetsValueB))
                return 0;
            return assetsValueA.gt(assetsValueB) ? -1 : 1;
        });
        return marginfiAccounts;
    }
    /**
     * Retrieves the addresses of all accounts owned by the marginfi program.
     *
     * @returns Account addresses
     */
    async getAllProgramAccountAddresses(type) {
        return (await this.program.provider.connection.getProgramAccounts(this.programId, {
            commitment: this.program.provider.connection.commitment,
            dataSlice: {
                offset: 0,
                length: 0,
            },
            filters: [
                {
                    memcmp: {
                        offset: 0,
                        bytes: bs58_1.default.encode(new anchor_1.BorshAccountsCoder(this.program.idl).accountDiscriminator(types_1.AccountType.MarginfiAccount)),
                    },
                },
            ],
        })).map((a) => a.pubkey);
    }
    getBankByPk(bankAddress) {
        let _bankAddress = (0, anchor_1.translateAddress)(bankAddress);
        return this.banks.get(_bankAddress.toString()) ?? null;
    }
    getBankByMint(mint) {
        const _mint = (0, anchor_1.translateAddress)(mint);
        return [...this.banks.values()].find((bank) => bank.mint.equals(_mint)) ?? null;
    }
    getBankByTokenSymbol(tokenSymbol) {
        if (tokenSymbol === undefined)
            return null;
        return [...this.banks.values()].find((bank) => bank.tokenSymbol === tokenSymbol) ?? null;
    }
    getOraclePriceByBank(bankAddress) {
        let _bankAddress = (0, anchor_1.translateAddress)(bankAddress);
        return this.oraclePrices.get(_bankAddress.toString()) ?? null;
    }
    // --------------------------------------------------------------------------
    // User actions
    // --------------------------------------------------------------------------
    /**
     * Create transaction instruction to create a new marginfi account under the authority of the user.
     *
     * @returns transaction instruction
     */
    async makeCreateMarginfiAccountIx(marginfiAccountPk) {
        const dbg = require("debug")("mfi:client");
        dbg("Generating marginfi account ix for %s", marginfiAccountPk);
        const initMarginfiAccountIx = await instructions_1.default.makeInitMarginfiAccountIx(this.program, {
            marginfiGroup: this.groupAddress,
            marginfiAccount: marginfiAccountPk,
            authority: this.provider.wallet.publicKey,
            feePayer: this.provider.wallet.publicKey,
        });
        const ixs = [initMarginfiAccountIx];
        return {
            instructions: ixs,
            keys: [],
        };
    }
    /**
     * Create a new marginfi account under the authority of the user.
     *
     * @param createOpts - Options for creating the account
     * @param createOpts.newAccountKey - Optional public key to use for the new account. If not provided, a new keypair will be generated.
     * @param processOpts - Options for processing the transaction
     * @param txOpts - Transaction options
     * @returns Object containing the transaction signature and the created MarginfiAccount instance
     */
    async createMarginfiAccount(createOpts, processOpts, txOpts) {
        const dbg = require("debug")("mfi:client");
        const accountKeypair = web3_js_1.Keypair.generate();
        const newAccountKey = createOpts?.newAccountKey ?? accountKeypair.publicKey;
        const solanaTx = await this.createMarginfiAccountTx({ accountKeypair });
        const sig = await this.processTransaction(solanaTx, processOpts, txOpts);
        dbg("Created Marginfi account %s", sig);
        return txOpts?.dryRun || createOpts?.newAccountKey
            ? Promise.resolve(undefined)
            : wrapper_1.MarginfiAccountWrapper.fetch(newAccountKey, this, txOpts?.commitment);
    }
    /**
     * Create a transaction to initialize a new marginfi account under the authority of the user.
     *
     * @param createOpts - Options for creating the account
     * @param createOpts.newAccountKey - Optional public key to use for the new account. If not provided, a new keypair will be generated.
     * @returns Transaction that can be used to create a new marginfi account
     */
    async createMarginfiAccountTx(createOpts) {
        const accountKeypair = createOpts?.accountKeypair ?? web3_js_1.Keypair.generate();
        const ixs = await this.makeCreateMarginfiAccountIx(accountKeypair.publicKey);
        const signers = [...ixs.keys];
        // If there was no newAccountKey provided, we need to sign with the ephemeraKeypair we generated.
        signers.push(accountKeypair);
        const tx = new web3_js_1.Transaction().add(...ixs.instructions);
        const solanaTx = (0, mrgn_common_1.addTransactionMetadata)(tx, {
            signers,
            addressLookupTables: this.addressLookupTables,
            type: mrgn_common_1.TransactionType.CREATE_ACCOUNT,
        });
        return solanaTx;
    }
    /**
     * Create transaction instruction to initialize a new group.
     *
     * @returns transaction instruction
     */
    async makeCreateMarginfiGroupIx(marginfiGroup) {
        const dbg = require("debug")("mfi:client");
        dbg("Generating group init ix");
        const initGroupIx = await instructions_1.default.makeGroupInitIx(this.program, {
            marginfiGroup: marginfiGroup,
            admin: this.provider.wallet.publicKey,
        });
        const ixs = [initGroupIx];
        return {
            instructions: ixs,
            keys: [],
        };
    }
    /**
     * Initiates a new permissionless marginfi bank under the authority of the user.
     *
     * @param {Object} params - The parameters for creating a permissionless bank.
     * @param {PublicKey} params.mint - The public key of the mint for the bank.
     * @param {BankConfigOpt} params.bankConfig - The configuration options for the bank.
     * @param {PublicKey} params.group - The public key of the group to which the bank belongs.
     * @param {PublicKey} params.admin - The public key of the admin who will have authority over the bank.
     * @param {Keypair} [params.seed] - An optional keypair used as a seed for generating the bank account.
     * @param {TransactionOptions} [params.txOpts] - Optional transaction options for processing.
     * @param {ProcessTransactionsClientOpts} [params.processOpts] - Optional processing options for transactions.
     * @returns {Promise<TransactionSignature>} A promise that resolves to the transaction signature as a string.
     */
    async createPermissionlessBank({ mint, bankConfig, group, admin, seed, txOpts, processOpts, }) {
        const dbg = require("debug")("mfi:client");
        const keypair = seed ?? web3_js_1.Keypair.generate();
        const bankIxs = await this.group.makePoolAddBankIx(this.program, keypair.publicKey, mint, bankConfig, admin);
        const signers = [...bankIxs.keys, keypair];
        const tx = new web3_js_1.Transaction().add(...bankIxs.instructions);
        const solanaTx = (0, mrgn_common_1.addTransactionMetadata)(tx, {
            signers,
            addressLookupTables: this.addressLookupTables,
            type: mrgn_common_1.TransactionType.CREATE_PERM_BANK,
        });
        const sig = await this.processTransaction(solanaTx, processOpts, txOpts);
        dbg("Created Marginfi group %s", sig);
        return sig;
    }
    /**
     * Initializes a new marginfi group with the specified parameters.
     *
     * @param seed - Optional keypair used for generating the group account.
     * @param additionalIxs - Optional array of additional transaction instructions to include.
     * @param txOpts - Optional transaction options for processing.
     * @param processOpts - Optional processing options for transactions.
     * @returns The public key of the newly created marginfi group.
     */
    async createMarginfiGroup(seed, additionalIxs, processOpts, txOpts) {
        const dbg = require("debug")("mfi:client");
        const accountKeypair = seed ?? web3_js_1.Keypair.generate();
        const ixs = await this.makeCreateMarginfiGroupIx(accountKeypair.publicKey);
        const signers = [...ixs.keys, accountKeypair];
        const tx = new web3_js_1.Transaction().add(...ixs.instructions, ...(additionalIxs ?? []));
        const solanaTx = (0, mrgn_common_1.addTransactionMetadata)(tx, {
            signers,
            addressLookupTables: this.addressLookupTables,
            type: mrgn_common_1.TransactionType.CREATE_GROUP,
        });
        const sig = await this.processTransaction(solanaTx, processOpts, txOpts);
        dbg("Created Marginfi group %s", sig);
        return Promise.resolve(accountKeypair.publicKey);
    }
    /**
     * Create a new bank under the authority of the user.
     *
     * @param bankMint - The public key of the token mint for the bank.
     * @param bankConfig - Configuration options for the bank.
     * @param seed - Optional keypair for the bank.
     * @param txOpts - Optional transaction options for processing.
     * @param processOpts - Optional processing options for transactions.
     * @returns The bank's public key and the transaction signature
     */
    async createLendingPool(bankMint, bankConfig, seed, processOpts, txOpts) {
        const dbg = require("debug")("mfi:client");
        const bankKeypair = seed ?? web3_js_1.Keypair.generate();
        const ixs = await this.group.makePoolAddBankIx(this.program, bankKeypair.publicKey, bankMint, bankConfig);
        const signers = [...ixs.keys, bankKeypair];
        const tx = new web3_js_1.Transaction().add(...ixs.instructions);
        const solanaTx = (0, mrgn_common_1.addTransactionMetadata)(tx, {
            signers,
            addressLookupTables: this.addressLookupTables,
            type: mrgn_common_1.TransactionType.CREATE_PERM_BANK,
        });
        const sig = await this.processTransaction(solanaTx, processOpts, txOpts);
        dbg("Created new lending pool %s", sig);
        return Promise.resolve({
            bankAddress: bankKeypair.publicKey,
            signature: sig,
        });
    }
    // --------------------------------------------------------------------------
    // Helpers
    // --------------------------------------------------------------------------
    /**
     * Processes multiple Solana transactions by signing and sending them to the network.
     *
     * @param {SolanaTransaction[]} transactions - An array of transactions to be processed.
     * @param {ProcessTransactionsClientOpts} [processOpts] - Optional processing options for transactions.
     * @param {TransactionOptions} [txOpts] - Optional transaction options for processing.
     *
     * @returns {Promise<TransactionSignature[]>} - A promise that resolves to an array of transaction signatures.
     *
     * @throws {ProcessTransactionError} - Throws an error if transaction processing fails.
     */
    async processTransactions(transactions, processOpts, txOpts) {
        const options = {
            ...processOpts,
            isReadOnly: this.isReadOnly,
            programId: this.program.programId,
            bundleSimRpcEndpoint: this.bundleSimRpcEndpoint,
            dynamicStrategy: processOpts?.dynamicStrategy ?? this.processTransactionStrategy,
        };
        console.log("processOpts", processOpts);
        console.log("processTransactions", options);
        return await (0, services_1.processTransactions)({
            transactions,
            connection: this.provider.connection,
            wallet: this.provider.wallet,
            processOpts: options,
            txOpts,
        });
    }
    /**
     * Processes a single Solana transaction by signing and sending it to the network.
     *
     * @param {SolanaTransaction} transaction - The transaction to be processed.
     * @param {TransactionOptions} [txOpts] - Optional transaction options.
     * @param {ProcessTransactionsClientOpts} [processOpts] - Optional processing options.
     *
     * @returns {Promise<TransactionSignature>} - A promise that resolves to the transaction signature.
     *
     * @throws {ProcessTransactionError} - Throws an error if transaction processing fails.
     */
    async processTransaction(transaction, processOpts, txOpts) {
        transaction.addressLookupTables = transaction.addressLookupTables || this.addressLookupTables;
        const options = {
            ...processOpts,
            isReadOnly: this.isReadOnly,
            programId: this.program.programId,
            bundleSimRpcEndpoint: this.bundleSimRpcEndpoint,
            dynamicStrategy: processOpts?.dynamicStrategy ?? this.processTransactionStrategy,
        };
        const [signature] = await (0, services_1.processTransactions)({
            transactions: [transaction],
            connection: this.provider.connection,
            wallet: this.provider.wallet,
            processOpts: options,
            txOpts,
        });
        return signature;
    }
    async simulateTransactions(transactions, accountsToInspect) {
        let versionedTransactions = [];
        const connection = new web3_js_1.Connection(this.provider.connection.rpcEndpoint, this.provider.opts);
        let blockhash;
        try {
            const getLatestBlockhashAndContext = await connection.getLatestBlockhashAndContext("confirmed");
            blockhash = getLatestBlockhashAndContext.value.blockhash;
            for (const transaction of transactions) {
                if ((0, mrgn_common_1.isV0Tx)(transaction)) {
                    versionedTransactions.push(transaction);
                }
                else {
                    const versionedMessage = new web3_js_1.TransactionMessage({
                        instructions: transaction.instructions,
                        payerKey: this.provider.publicKey,
                        recentBlockhash: blockhash,
                    });
                    versionedTransactions.push(new web3_js_1.VersionedTransaction(versionedMessage.compileToV0Message(this.addressLookupTables)));
                }
            }
        }
        catch (error) {
            throw new errors_1.ProcessTransactionError({
                message: error.message,
                type: errors_1.ProcessTransactionErrorType.TransactionBuildingError,
            });
        }
        let response;
        try {
            if (transactions.length === 1) {
                response = await connection.simulateTransaction(versionedTransactions[0], {
                    sigVerify: false,
                    accounts: { encoding: "base64", addresses: accountsToInspect.map((a) => a.toBase58()) },
                });
                if (response.value.err) {
                    const error = response.value.err;
                    const parsedError = (0, errors_1.parseTransactionError)(error, this.config.programId);
                    throw new errors_1.ProcessTransactionError({
                        message: parsedError.description ?? JSON.stringify(response.value.err),
                        type: errors_1.ProcessTransactionErrorType.SimulationError,
                        logs: response.value.logs ?? [],
                        programId: parsedError.programId,
                    });
                }
                return response.value.accounts?.map((a) => (a ? Buffer.from(a.data[0], "base64") : null)) ?? [];
            }
            else {
                const simulationResult = await (0, helpers_1.simulateBundle)(this.bundleSimRpcEndpoint, versionedTransactions, accountsToInspect);
                const value = simulationResult[simulationResult.length - 1];
                const accounts = value.postExecutionAccounts;
                return accounts?.map((a) => (a ? Buffer.from(a.data[0], "base64") : null)) ?? [];
            }
        }
        catch (error) {
            if (error instanceof errors_1.ProcessTransactionError)
                throw error;
            const parsedError = (0, errors_1.parseTransactionError)(error, this.config.programId);
            if (error instanceof helpers_1.BundleSimulationError) {
                throw new errors_1.ProcessTransactionError({
                    message: parsedError.description,
                    type: errors_1.ProcessTransactionErrorType.SimulationError,
                    logs: error.logs,
                    programId: parsedError.programId,
                });
            }
            if (error?.logs?.length > 0) {
                console.log("------ Logs 👇 ------");
                console.log(error.logs.join("\n"));
                if (parsedError) {
                    console.log("Parsed:", parsedError);
                    throw new errors_1.ProcessTransactionError({
                        message: parsedError.description,
                        type: errors_1.ProcessTransactionErrorType.SimulationError,
                        logs: error.logs,
                        programId: parsedError.programId,
                    });
                }
            }
            console.log("fallthrough error", error);
            throw new errors_1.ProcessTransactionError({
                message: parsedError?.description ?? "Something went wrong",
                type: errors_1.ProcessTransactionErrorType.FallthroughError,
                logs: error.logs,
                programId: parsedError.programId,
            });
        }
    }
}
exports.default = MarginfiClient;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.replenishPoolIx = exports.createPoolOnrampIx = exports.createAccountIx = exports.findPoolMintAddressByVoteAccount = exports.findPoolOnRampAddress = exports.findMplMetadataAddress = exports.findPoolMplAuthorityAddress = exports.findPoolMintAuthorityAddress = exports.findPoolStakeAuthorityAddress = exports.findPoolStakeAddress = exports.findPoolMintAddress = exports.findPoolAddress = exports.SinglePoolInstruction = void 0;
exports.initializeStakedPoolIxs = initializeStakedPoolIxs;
exports.initializeStakedPoolTx = initializeStakedPoolTx;
const web3_js_1 = require("@solana/web3.js");
const bn_js_1 = require("bn.js");
const mrgn_common_1 = require("@mrgnlabs/mrgn-common");
const web3_js_2 = require("@solana/web3.js");
// Instruction type enum
var SinglePoolInstructionType;
(function (SinglePoolInstructionType) {
    SinglePoolInstructionType[SinglePoolInstructionType["InitializePool"] = 0] = "InitializePool";
    SinglePoolInstructionType[SinglePoolInstructionType["ReplenishPool"] = 1] = "ReplenishPool";
    SinglePoolInstructionType[SinglePoolInstructionType["DepositStake"] = 2] = "DepositStake";
    SinglePoolInstructionType[SinglePoolInstructionType["WithdrawStake"] = 3] = "WithdrawStake";
    SinglePoolInstructionType[SinglePoolInstructionType["CreateTokenMetadata"] = 4] = "CreateTokenMetadata";
    SinglePoolInstructionType[SinglePoolInstructionType["UpdateTokenMetadata"] = 5] = "UpdateTokenMetadata";
    SinglePoolInstructionType[SinglePoolInstructionType["InitializeOnRamp"] = 6] = "InitializeOnRamp";
})(SinglePoolInstructionType || (SinglePoolInstructionType = {}));
const SinglePoolInstruction = {
    initializePool: (voteAccount) => {
        const pool = findPoolAddress(voteAccount);
        const stake = findPoolStakeAddress(pool);
        const mint = findPoolMintAddress(pool);
        const stakeAuthority = findPoolStakeAuthorityAddress(pool);
        const mintAuthority = findPoolMintAuthorityAddress(pool);
        return createTransactionInstruction(mrgn_common_1.SINGLE_POOL_PROGRAM_ID, [
            { pubkey: voteAccount, isSigner: false, isWritable: false },
            { pubkey: pool, isSigner: false, isWritable: true },
            { pubkey: stake, isSigner: false, isWritable: true },
            { pubkey: mint, isSigner: false, isWritable: true },
            { pubkey: stakeAuthority, isSigner: false, isWritable: false },
            { pubkey: mintAuthority, isSigner: false, isWritable: false },
            { pubkey: mrgn_common_1.SYSVAR_RENT_ID, isSigner: false, isWritable: false },
            { pubkey: mrgn_common_1.SYSVAR_CLOCK_ID, isSigner: false, isWritable: false },
            { pubkey: mrgn_common_1.SYSVAR_STAKE_HISTORY_ID, isSigner: false, isWritable: false },
            { pubkey: web3_js_1.STAKE_CONFIG_ID, isSigner: false, isWritable: false },
            { pubkey: mrgn_common_1.SYSTEM_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: mrgn_common_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: mrgn_common_1.STAKE_PROGRAM_ID, isSigner: false, isWritable: false },
        ], Buffer.from([SinglePoolInstructionType.InitializePool]));
    },
    initializeOnRamp: (pool) => {
        const onRamp = findPoolOnRampAddress(pool);
        const stakeAuthority = findPoolStakeAuthorityAddress(pool);
        return createTransactionInstruction(mrgn_common_1.SINGLE_POOL_PROGRAM_ID, [
            { pubkey: pool, isSigner: false, isWritable: false },
            { pubkey: onRamp, isSigner: false, isWritable: true },
            { pubkey: stakeAuthority, isSigner: false, isWritable: false },
            { pubkey: mrgn_common_1.SYSVAR_RENT_ID, isSigner: false, isWritable: false },
            { pubkey: mrgn_common_1.SYSTEM_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: mrgn_common_1.STAKE_PROGRAM_ID, isSigner: false, isWritable: false },
        ], Buffer.from([SinglePoolInstructionType.InitializeOnRamp]));
    },
    depositStake: async (pool, userStakeAccount, userTokenAccount, userLamportAccount) => {
        const stake = findPoolStakeAddress(pool);
        const mint = findPoolMintAddress(pool);
        const stakeAuthority = findPoolStakeAuthorityAddress(pool);
        const mintAuthority = findPoolMintAuthorityAddress(pool);
        return createTransactionInstruction(mrgn_common_1.SINGLE_POOL_PROGRAM_ID, [
            { pubkey: pool, isSigner: false, isWritable: false },
            { pubkey: stake, isSigner: false, isWritable: true },
            { pubkey: mint, isSigner: false, isWritable: true },
            { pubkey: stakeAuthority, isSigner: false, isWritable: false },
            { pubkey: mintAuthority, isSigner: false, isWritable: false },
            { pubkey: userStakeAccount, isSigner: false, isWritable: true },
            { pubkey: userTokenAccount, isSigner: false, isWritable: true },
            { pubkey: userLamportAccount, isSigner: false, isWritable: true },
            { pubkey: mrgn_common_1.SYSVAR_CLOCK_ID, isSigner: false, isWritable: false },
            { pubkey: mrgn_common_1.SYSVAR_STAKE_HISTORY_ID, isSigner: false, isWritable: false },
            { pubkey: mrgn_common_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: mrgn_common_1.STAKE_PROGRAM_ID, isSigner: false, isWritable: false },
        ], Buffer.from([SinglePoolInstructionType.DepositStake]));
    },
    withdrawStake: async (pool, userStakeAccount, userStakeAuthority, userTokenAccount, tokenAmount) => {
        const stake = findPoolStakeAddress(pool);
        const mint = findPoolMintAddress(pool);
        const stakeAuthority = findPoolStakeAuthorityAddress(pool);
        const mintAuthority = findPoolMintAuthorityAddress(pool);
        // Try using BigInt for more precise conversion
        const rawAmount = BigInt(tokenAmount.multipliedBy(1e9).toString());
        const data = Buffer.concat([
            Buffer.from([SinglePoolInstructionType.WithdrawStake]),
            userStakeAuthority.toBuffer(),
            Buffer.from(new bn_js_1.BN(rawAmount.toString()).toArray("le", 8)),
        ]);
        return createTransactionInstruction(mrgn_common_1.SINGLE_POOL_PROGRAM_ID, [
            { pubkey: pool, isSigner: false, isWritable: false },
            { pubkey: stake, isSigner: false, isWritable: true },
            { pubkey: mint, isSigner: false, isWritable: true },
            { pubkey: stakeAuthority, isSigner: false, isWritable: false },
            { pubkey: mintAuthority, isSigner: false, isWritable: false },
            { pubkey: userStakeAccount, isSigner: false, isWritable: true },
            { pubkey: userTokenAccount, isSigner: false, isWritable: true },
            { pubkey: mrgn_common_1.SYSVAR_CLOCK_ID, isSigner: false, isWritable: false },
            { pubkey: mrgn_common_1.TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: mrgn_common_1.STAKE_PROGRAM_ID, isSigner: false, isWritable: false },
        ], data);
    },
    createTokenMetadata: async (pool, payer) => {
        const mint = findPoolMintAddress(pool);
        const [mintAuthority, mplAuthority, mplMetadata] = await Promise.all([
            findPoolMintAuthorityAddress(pool),
            findPoolMplAuthorityAddress(pool),
            findMplMetadataAddress(mint),
        ]);
        return createTransactionInstruction(mrgn_common_1.SINGLE_POOL_PROGRAM_ID, [
            { pubkey: pool, isSigner: false, isWritable: false },
            { pubkey: mint, isSigner: false, isWritable: false },
            { pubkey: mintAuthority, isSigner: false, isWritable: false },
            { pubkey: mplAuthority, isSigner: false, isWritable: false },
            { pubkey: payer, isSigner: true, isWritable: true },
            { pubkey: mplMetadata, isSigner: false, isWritable: true },
            { pubkey: mrgn_common_1.MPL_METADATA_PROGRAM_ID, isSigner: false, isWritable: false },
            { pubkey: mrgn_common_1.SYSTEM_PROGRAM_ID, isSigner: false, isWritable: false },
        ], Buffer.from([SinglePoolInstructionType.CreateTokenMetadata]));
    },
    updateTokenMetadata: async (voteAccount, authorizedWithdrawer, tokenName, tokenSymbol, tokenUri = "") => {
        if (tokenName.length > 32) {
            throw new Error("maximum token name length is 32 characters");
        }
        if (tokenSymbol.length > 10) {
            throw new Error("maximum token symbol length is 10 characters");
        }
        if (tokenUri.length > 200) {
            throw new Error("maximum token uri length is 200 characters");
        }
        const pool = findPoolAddress(voteAccount);
        const [mint, mplAuthority] = await Promise.all([findPoolMintAddress(pool), findPoolMplAuthorityAddress(pool)]);
        const mplMetadata = await findMplMetadataAddress(mint);
        const data = Buffer.concat([
            Buffer.from([SinglePoolInstructionType.UpdateTokenMetadata]),
            Buffer.from(new Uint32Array([tokenName.length]).buffer),
            Buffer.from(tokenName),
            Buffer.from(new Uint32Array([tokenSymbol.length]).buffer),
            Buffer.from(tokenSymbol),
            Buffer.from(new Uint32Array([tokenUri.length]).buffer),
            Buffer.from(tokenUri),
        ]);
        return createTransactionInstruction(mrgn_common_1.SINGLE_POOL_PROGRAM_ID, [
            { pubkey: voteAccount, isSigner: false, isWritable: false },
            { pubkey: pool, isSigner: false, isWritable: false },
            { pubkey: mplAuthority, isSigner: false, isWritable: false },
            { pubkey: authorizedWithdrawer, isSigner: true, isWritable: false },
            { pubkey: mplMetadata, isSigner: false, isWritable: true },
            { pubkey: mrgn_common_1.MPL_METADATA_PROGRAM_ID, isSigner: false, isWritable: false },
        ], data);
    },
};
exports.SinglePoolInstruction = SinglePoolInstruction;
const createTransactionInstruction = (programId, keys, data) => {
    return {
        programId,
        keys,
        data,
    };
};
const findPda = (baseAddress, prefix, programId = mrgn_common_1.SINGLE_POOL_PROGRAM_ID) => {
    const [pda] = web3_js_1.PublicKey.findProgramAddressSync([Buffer.from(prefix), baseAddress.toBuffer()], programId);
    return pda;
};
const findPoolMintAddressByVoteAccount = (voteAccountAddress) => findPda(findPoolAddress(voteAccountAddress), "mint");
exports.findPoolMintAddressByVoteAccount = findPoolMintAddressByVoteAccount;
const findPoolAddress = (voteAccountAddress) => findPda(voteAccountAddress, "pool");
exports.findPoolAddress = findPoolAddress;
const findPoolMintAddress = (poolAddress) => findPda(poolAddress, "mint");
exports.findPoolMintAddress = findPoolMintAddress;
const findPoolStakeAddress = (poolAddress) => findPda(poolAddress, "stake");
exports.findPoolStakeAddress = findPoolStakeAddress;
const findPoolStakeAuthorityAddress = (poolAddress) => findPda(poolAddress, "stake_authority");
exports.findPoolStakeAuthorityAddress = findPoolStakeAuthorityAddress;
const findPoolMintAuthorityAddress = (poolAddress) => findPda(poolAddress, "mint_authority");
exports.findPoolMintAuthorityAddress = findPoolMintAuthorityAddress;
const findPoolMplAuthorityAddress = (poolAddress) => findPda(poolAddress, "mpl_authority");
exports.findPoolMplAuthorityAddress = findPoolMplAuthorityAddress;
const findPoolOnRampAddress = (poolAddress) => findPda(poolAddress, "onramp");
exports.findPoolOnRampAddress = findPoolOnRampAddress;
const findMplMetadataAddress = async (poolMintAddress) => {
    const [pda] = web3_js_1.PublicKey.findProgramAddressSync([Buffer.from("metadata"), mrgn_common_1.MPL_METADATA_PROGRAM_ID.toBuffer(), poolMintAddress.toBuffer()], mrgn_common_1.MPL_METADATA_PROGRAM_ID);
    return pda;
};
exports.findMplMetadataAddress = findMplMetadataAddress;
const SINGLE_POOL_ACCOUNT_SIZE = BigInt(33);
const STAKE_ACCOUNT_SIZE = BigInt(200);
const MINT_SIZE = BigInt(82);
async function initializeStakedPoolTx(connection, payer, voteAccountAddress) {
    const instructions = await initializeStakedPoolIxs(connection, payer, voteAccountAddress);
    const tx = new web3_js_1.Transaction().add(...instructions);
    return tx;
}
async function initializeStakedPoolIxs(connection, payer, voteAccountAddress) {
    const poolAddress = findPoolAddress(voteAccountAddress);
    const stakeAddress = findPoolStakeAddress(poolAddress);
    const mintAddress = findPoolMintAddress(poolAddress);
    const onRampAddress = findPoolOnRampAddress(poolAddress);
    // get min rent
    const [poolRent, stakeRent, mintRent, minimumDelegationObj] = await Promise.all([
        connection.getMinimumBalanceForRentExemption(Number(SINGLE_POOL_ACCOUNT_SIZE), "confirmed"),
        connection.getMinimumBalanceForRentExemption(Number(STAKE_ACCOUNT_SIZE), "confirmed"),
        connection.getMinimumBalanceForRentExemption(Number(MINT_SIZE), "confirmed"),
        connection.getStakeMinimumDelegation(),
    ]);
    const minimumDelegation = minimumDelegationObj.value;
    const instructions = [];
    // instructions
    instructions.push(web3_js_1.SystemProgram.transfer({ fromPubkey: payer, toPubkey: poolAddress, lamports: poolRent }));
    instructions.push(web3_js_1.SystemProgram.transfer({
        fromPubkey: payer,
        toPubkey: stakeAddress,
        lamports: stakeRent + minimumDelegation + web3_js_1.LAMPORTS_PER_SOL * 1,
    }));
    instructions.push(web3_js_1.SystemProgram.transfer({ fromPubkey: payer, toPubkey: onRampAddress, lamports: stakeRent }));
    instructions.push(web3_js_1.SystemProgram.transfer({ fromPubkey: payer, toPubkey: mintAddress, lamports: mintRent }));
    instructions.push(SinglePoolInstruction.initializePool(voteAccountAddress));
    instructions.push(SinglePoolInstruction.initializeOnRamp(poolAddress));
    instructions.push(await SinglePoolInstruction.createTokenMetadata(poolAddress, payer));
    return instructions;
}
const createAccountIx = (from, newAccount, lamports, space, programAddress) => {
    const data = Buffer.concat([
        Buffer.from([0]), // Assuming the first byte is an instruction type or similar
        Buffer.from(new bn_js_1.BN(lamports).toArray("le", 8)),
        Buffer.from(new bn_js_1.BN(space).toArray("le", 8)),
        programAddress.toBuffer(),
    ]);
    const accounts = [
        { pubkey: from, isSigner: true, isWritable: true },
        { pubkey: newAccount, isSigner: true, isWritable: true },
    ];
    return createTransactionInstruction(mrgn_common_1.SYSTEM_PROGRAM_ID, accounts, data);
};
exports.createAccountIx = createAccountIx;
const createPoolOnrampIx = (voteAccount) => {
    const poolAccount = findPoolAddress(voteAccount);
    const onRampAccount = findPoolOnRampAddress(poolAccount);
    const poolStakeAuthority = findPoolStakeAuthorityAddress(poolAccount);
    const keys = [
        { pubkey: poolAccount, isSigner: false, isWritable: false },
        { pubkey: onRampAccount, isSigner: false, isWritable: true },
        { pubkey: poolStakeAuthority, isSigner: false, isWritable: false },
        { pubkey: web3_js_2.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
        { pubkey: web3_js_1.SystemProgram.programId, isSigner: false, isWritable: false },
        { pubkey: web3_js_1.StakeProgram.programId, isSigner: false, isWritable: false },
    ];
    // TODO don't hard code the instruction index? (or why not, it's not gna change is it?)
    const data = Buffer.from(Uint8Array.of(6));
    return new web3_js_1.TransactionInstruction({
        keys,
        programId: mrgn_common_1.SINGLE_POOL_PROGRAM_ID,
        data,
    });
};
exports.createPoolOnrampIx = createPoolOnrampIx;
const replenishPoolIx = (voteAccount) => {
    const poolAccount = findPoolAddress(voteAccount);
    const stakePool = findPoolStakeAddress(poolAccount);
    const onRampPool = findPoolOnRampAddress(poolAccount);
    const authority = findPoolStakeAuthorityAddress(poolAccount);
    const keys = [
        { pubkey: voteAccount, isSigner: false, isWritable: false },
        { pubkey: poolAccount, isSigner: false, isWritable: false },
        { pubkey: stakePool, isSigner: false, isWritable: true },
        { pubkey: onRampPool, isSigner: false, isWritable: true },
        { pubkey: authority, isSigner: false, isWritable: false },
        { pubkey: web3_js_1.SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false },
        { pubkey: mrgn_common_1.SYSVAR_STAKE_HISTORY_ID, isSigner: false, isWritable: false },
        { pubkey: web3_js_1.STAKE_CONFIG_ID, isSigner: false, isWritable: false },
        { pubkey: web3_js_1.StakeProgram.programId, isSigner: false, isWritable: false },
    ];
    // TODO don't hard code the instruction index? (or why not, it's not gna change is it?)
    const data = Buffer.from(Uint8Array.of(1));
    return createTransactionInstruction(mrgn_common_1.SINGLE_POOL_PROGRAM_ID, keys, data);
};
exports.replenishPoolIx = replenishPoolIx;

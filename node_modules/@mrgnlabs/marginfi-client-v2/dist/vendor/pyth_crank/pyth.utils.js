"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGuardianSetPda = exports.VAA_SIGNATURE_SIZE = exports.DEFAULT_REDUCED_GUARDIAN_SET_SIZE = void 0;
exports.getGuardianSetIndex = getGuardianSetIndex;
exports.trimSignatures = trimSignatures;
exports.isAccumulatorUpdateData = isAccumulatorUpdateData;
exports.parseAccumulatorUpdateData = parseAccumulatorUpdateData;
exports.buildPostEncodedVaaInstructions = buildPostEncodedVaaInstructions;
exports.buildEncodedVaaCreateInstruction = buildEncodedVaaCreateInstruction;
exports.parsePriceFeedMessage = parsePriceFeedMessage;
const anchor_1 = require("@coral-xyz/anchor");
const pyth_consts_1 = require("./pyth.consts");
const web3_js_1 = require("@solana/web3.js");
function getGuardianSetIndex(vaa) {
    return vaa.readUInt32BE(1);
}
exports.DEFAULT_REDUCED_GUARDIAN_SET_SIZE = 5;
exports.VAA_SIGNATURE_SIZE = 66;
function trimSignatures(vaa, n = exports.DEFAULT_REDUCED_GUARDIAN_SET_SIZE) {
    const currentNumSignatures = vaa[5];
    if (n > currentNumSignatures) {
        throw new Error("Resulting VAA can't have more signatures than the original VAA");
    }
    const trimmedVaa = Buffer.concat([
        vaa.subarray(0, 6 + n * exports.VAA_SIGNATURE_SIZE),
        vaa.subarray(6 + currentNumSignatures * exports.VAA_SIGNATURE_SIZE),
    ]);
    trimmedVaa[5] = n;
    return trimmedVaa;
}
function isAccumulatorUpdateData(updateBytes) {
    return (updateBytes.toString("hex").slice(0, 8) === pyth_consts_1.ACCUMULATOR_MAGIC &&
        updateBytes[4] === pyth_consts_1.MAJOR_VERSION &&
        updateBytes[5] === pyth_consts_1.MINOR_VERSION);
}
function parseAccumulatorUpdateData(data) {
    if (!isAccumulatorUpdateData(data)) {
        throw new Error("Invalid accumulator message");
    }
    let cursor = 6;
    const trailingPayloadSize = data.readUint8(cursor);
    cursor += 1 + trailingPayloadSize;
    // const proofType = data.readUint8(cursor);
    cursor += 1;
    const vaaSize = data.readUint16BE(cursor);
    cursor += 2;
    const vaa = data.subarray(cursor, cursor + vaaSize);
    cursor += vaaSize;
    const numUpdates = data.readUInt8(cursor);
    const updates = [];
    cursor += 1;
    for (let i = 0; i < numUpdates; i++) {
        const messageSize = data.readUint16BE(cursor);
        cursor += 2;
        const message = data.subarray(cursor, cursor + messageSize);
        cursor += messageSize;
        const numProofs = data.readUInt8(cursor);
        cursor += 1;
        const proof = [];
        for (let j = 0; j < numProofs; j++) {
            proof.push(Array.from(data.subarray(cursor, cursor + pyth_consts_1.KECCAK160_HASH_SIZE)));
            cursor += pyth_consts_1.KECCAK160_HASH_SIZE;
        }
        updates.push({ message, proof });
    }
    if (cursor !== data.length) {
        throw new Error("Didn't reach the end of the message");
    }
    return { vaa, updates };
}
async function buildPostEncodedVaaInstructions(wormhole, vaa) {
    const groups = await generateVaaInstructionGroups(wormhole, vaa);
    // Pack instructions for optimal 2-transaction pattern:
    // TX1: init + first write
    // TX2: second write + verify
    return {
        encodedVaaAddress: groups.encodedVaaAddress,
        postInstructions: [
            ...groups.initInstructions,
            ...groups.writeFirstPartInstructions,
            ...groups.writeSecondPartAndVerifyInstructions,
        ],
        closeInstructions: groups.closeInstructions,
    };
}
async function generateVaaInstructionGroups(wormhole, vaa) {
    const encodedVaaKeypair = new web3_js_1.Keypair();
    // Create and init instructions
    const initInstructions = [
        await buildEncodedVaaCreateInstruction(wormhole, vaa, encodedVaaKeypair),
        {
            instruction: await wormhole.methods
                .initEncodedVaa()
                .accounts({
                encodedVaa: encodedVaaKeypair.publicKey,
            })
                .instruction(),
            signers: [],
            computeUnits: pyth_consts_1.INIT_ENCODED_VAA_COMPUTE_BUDGET,
        },
    ];
    // First write instruction
    const writeFirstPartInstructions = [
        {
            instruction: await wormhole.methods
                .writeEncodedVaa({
                index: 0,
                data: vaa.subarray(0, pyth_consts_1.VAA_SPLIT_INDEX),
            })
                .accounts({
                draftVaa: encodedVaaKeypair.publicKey,
            })
                .instruction(),
            signers: [],
            computeUnits: pyth_consts_1.WRITE_ENCODED_VAA_COMPUTE_BUDGET,
        },
    ];
    // Second write and verify instructions
    const writeSecondPartAndVerifyInstructions = [
        {
            instruction: await wormhole.methods
                .writeEncodedVaa({
                index: pyth_consts_1.VAA_SPLIT_INDEX,
                data: vaa.subarray(pyth_consts_1.VAA_SPLIT_INDEX),
            })
                .accounts({
                draftVaa: encodedVaaKeypair.publicKey,
            })
                .instruction(),
            signers: [],
            computeUnits: pyth_consts_1.WRITE_ENCODED_VAA_COMPUTE_BUDGET,
        },
        {
            instruction: await wormhole.methods
                .verifyEncodedVaaV1()
                .accounts({
                guardianSet: (0, exports.getGuardianSetPda)(getGuardianSetIndex(vaa), wormhole.programId),
                draftVaa: encodedVaaKeypair.publicKey,
            })
                .instruction(),
            signers: [],
            computeUnits: pyth_consts_1.VERIFY_ENCODED_VAA_COMPUTE_BUDGET,
        },
    ];
    // Close instructions
    const closeInstructions = [
        {
            instruction: await wormhole.methods
                .closeEncodedVaa()
                .accounts({ encodedVaa: encodedVaaKeypair.publicKey })
                .instruction(),
            signers: [],
            computeUnits: pyth_consts_1.CLOSE_ENCODED_VAA_COMPUTE_BUDGET,
        },
    ];
    return {
        initInstructions,
        writeFirstPartInstructions,
        writeSecondPartAndVerifyInstructions,
        closeInstructions,
        encodedVaaAddress: encodedVaaKeypair.publicKey,
    };
}
/**
 * Build an instruction to create an encoded VAA account.
 *
 * This is the first step to post a VAA to the Wormhole program.
 */
async function buildEncodedVaaCreateInstruction(wormhole, vaa, encodedVaaKeypair) {
    const encodedVaaSize = vaa.length + pyth_consts_1.VAA_START;
    return {
        instruction: await wormhole.account.encodedVaa.createInstruction(encodedVaaKeypair, encodedVaaSize),
        signers: [encodedVaaKeypair],
    };
}
/**
 * Returns the address of a guardian set account from the Wormhole program.
 */
const getGuardianSetPda = (guardianSetIndex, wormholeProgramId) => {
    const guardianSetIndexBuf = Buffer.alloc(4);
    guardianSetIndexBuf.writeUInt32BE(guardianSetIndex, 0);
    return web3_js_1.PublicKey.findProgramAddressSync([Buffer.from("GuardianSet"), guardianSetIndexBuf], wormholeProgramId)[0];
};
exports.getGuardianSetPda = getGuardianSetPda;
function parsePriceFeedMessage(message) {
    let cursor = 0;
    const variant = message.readUInt8(cursor);
    if (variant !== pyth_consts_1.PRICE_FEED_MESSAGE_VARIANT) {
        throw new Error("Not a price feed message");
    }
    cursor += 1;
    const feedId = message.subarray(cursor, cursor + 32);
    cursor += 32;
    const price = new anchor_1.BN(message.subarray(cursor, cursor + 8), "be");
    cursor += 8;
    const confidence = new anchor_1.BN(message.subarray(cursor, cursor + 8), "be");
    cursor += 8;
    const exponent = message.readInt32BE(cursor);
    cursor += 4;
    const publishTime = new anchor_1.BN(message.subarray(cursor, cursor + 8), "be");
    cursor += 8;
    const prevPublishTime = new anchor_1.BN(message.subarray(cursor, cursor + 8), "be");
    cursor += 8;
    const emaPrice = new anchor_1.BN(message.subarray(cursor, cursor + 8), "be");
    cursor += 8;
    const emaConf = new anchor_1.BN(message.subarray(cursor, cursor + 8), "be");
    cursor += 8;
    return {
        feedId,
        price,
        confidence,
        exponent,
        publishTime,
        prevPublishTime,
        emaPrice,
        emaConf,
    };
}

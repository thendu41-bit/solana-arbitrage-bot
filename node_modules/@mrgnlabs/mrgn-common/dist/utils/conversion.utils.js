"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.composeRemainingAccounts = void 0;
exports.wrappedI80F48toBigNumber = wrappedI80F48toBigNumber;
exports.bigNumberToWrappedI80F48 = bigNumberToWrappedI80F48;
exports.toNumber = toNumber;
exports.toBigNumber = toBigNumber;
exports.uiToNative = uiToNative;
exports.uiToNativeBigNumber = uiToNativeBigNumber;
exports.nativeToUi = nativeToUi;
exports.shortenAddress = shortenAddress;
exports.bpsToPercentile = bpsToPercentile;
const anchor_1 = require("@coral-xyz/anchor");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const decimal_js_1 = require("decimal.js");
const I80F48_FRACTIONAL_BYTES = 6;
const I80F48_TOTAL_BYTES = 16;
const I80F48_DIVISOR = new decimal_js_1.Decimal(2).pow(8 * I80F48_FRACTIONAL_BYTES);
function wrappedI80F48toBigNumber(wrapped) {
    let bytesLE = wrapped.value;
    if (bytesLE.length !== I80F48_TOTAL_BYTES) {
        throw new Error(`Expected a ${I80F48_TOTAL_BYTES}-byte buffer`);
    }
    let bytesBE = bytesLE.slice();
    bytesBE.reverse();
    let signChar = "";
    const msb = bytesBE[0];
    if (msb & 0x80) {
        signChar = "-";
        bytesBE = bytesBE.map((v) => ~v & 0xff);
    }
    let hex = signChar + "0x" + bytesBE.map((v) => v.toString(16).padStart(2, "0")).join("");
    let decoded = new decimal_js_1.Decimal(hex).dividedBy(I80F48_DIVISOR);
    return new bignumber_js_1.default(decoded.toString());
}
function bigNumberToWrappedI80F48(value) {
    let decimalValue = new decimal_js_1.Decimal(value.toString());
    const isNegative = decimalValue.isNegative();
    decimalValue = decimalValue.times(I80F48_DIVISOR);
    let wrappedValue = new anchor_1.BN(decimalValue.round().toFixed()).toArray();
    if (wrappedValue.length < I80F48_TOTAL_BYTES) {
        const padding = Array(I80F48_TOTAL_BYTES - wrappedValue.length).fill(0);
        wrappedValue.unshift(...padding);
    }
    if (isNegative) {
        wrappedValue[wrappedValue.length - 1] |= 0x80;
        wrappedValue = wrappedValue.map((v) => ~v & 0xff);
    }
    wrappedValue.reverse();
    return { value: wrappedValue };
}
/**
 * Converts a ui representation of a token amount into its native value as `BN`, given the specified mint decimal amount (default to 6 for USDC).
 */
function toNumber(amount) {
    let amt;
    if (typeof amount === "number") {
        amt = amount;
    }
    else if (typeof amount === "string") {
        amt = Number(amount);
    }
    else {
        amt = amount.toNumber();
    }
    return amt;
}
/**
 * Converts a ui representation of a token amount into its native value as `BN`, given the specified mint decimal amount (default to 6 for USDC).
 */
function toBigNumber(amount) {
    let amt;
    if (amount instanceof bignumber_js_1.default) {
        amt = amount;
    }
    else {
        amt = new bignumber_js_1.default(amount.toString());
    }
    return amt;
}
/**
 * Converts a UI representation of a token amount into its native value as `BN`, given the specified mint decimal amount (default to 6 for USDC).
 */
function uiToNative(amount, decimals) {
    let amt = toBigNumber(amount);
    return new anchor_1.BN(amt.times(10 ** decimals).toFixed(0, bignumber_js_1.default.ROUND_FLOOR));
}
function uiToNativeBigNumber(amount, decimals) {
    let amt = toBigNumber(amount);
    return amt.times(10 ** decimals);
}
/**
 * Converts a native representation of a token amount into its UI value as `number`, given the specified mint decimal amount.
 */
function nativeToUi(amount, decimals) {
    let amt = toBigNumber(amount);
    return amt.div(10 ** decimals).toNumber();
}
// shorten the checksummed version of the input address to have 4 characters at start and end
function shortenAddress(pubkey, chars = 4) {
    const pubkeyStr = pubkey.toString();
    return `${pubkeyStr.slice(0, chars)}...${pubkeyStr.slice(-chars)}`;
}
/**
 * Converts basis points (bps) to a decimal percentage value.
 */
function bpsToPercentile(bps) {
    return bps / 10000;
}
/**
 * Prepares transaction remaining accounts by processing bank-oracle groups:
 * 1. Sorts groups in descending order by bank public key (pushes inactive accounts to end)
 * 2. Flattens the structure into a single public key array
 *
 * Stable on most JS implementations (this shouldn't matter since we do not generally have duplicate
 * banks), in place, and uses the raw 32-byte value to sort in byte-wise lexicographical order (like
 * Rust's b.key.cmp(&a.key))
 *
 * @param banksAndOracles - Array where each element is a bank-oracle group: [bankPubkey,
 *                          oracle1Pubkey, oracle2Pubkey?, ...] Note: SystemProgram keys (111..111)
 *                          represent inactive accounts
 * @returns Flattened array of public keys with inactive accounts at the end, ready for transaction
 *          composition
 */
const composeRemainingAccounts = (banksAndOracles) => {
    banksAndOracles.sort((a, b) => {
        const A = a[0].toBytes();
        const B = b[0].toBytes();
        // find the first differing byte
        for (let i = 0; i < 32; i++) {
            if (A[i] !== B[i]) {
                // descending: bigger byte should come first
                return B[i] - A[i];
            }
        }
        return 0; // identical keys
    });
    // flatten out [bank, oracle…, oracle…] → [bank, oracle…, bank, oracle…, …]
    return banksAndOracles.flat();
};
exports.composeRemainingAccounts = composeRemainingAccounts;

import { Idl, Instruction } from "@coral-xyz/anchor";
import { AddressLookupTableAccount, PublicKey, Transaction, TransactionInstruction, TransactionMessage, VersionedTransaction } from "@solana/web3.js";
import { ExtendedTransactionProperties, SolanaTransaction } from "./transaction.types";
/**
 * Determines if a given transaction is a VersionedTransaction.
 * This function checks for the presence of a 'message' property to identify
 * if the transaction is of type VersionedTransaction.
 *
 * @param tx - The transaction object, which can be either a VersionedTransaction or a Transaction.
 * @returns A boolean indicating whether the transaction is a VersionedTransaction.
 */
export declare function isV0Tx(tx: Transaction | VersionedTransaction): tx is VersionedTransaction;
/**
 * Calculates the size of a Solana transaction in bytes.
 * This function considers the number of required signatures and other transaction components.
 *
 * @param tx - The transaction object, which can be either a VersionedTransaction or a Transaction.
 * @returns The size of the transaction in bytes.
 */
export declare function getTxSize(tx: VersionedTransaction | Transaction): number;
export declare function getAccountKeys(tx: VersionedTransaction | Transaction, lookupTableAccounts: AddressLookupTableAccount[]): number;
/**
 * Decodes a Solana transaction instruction using the provided Interface Definition Language (IDL).
 * This function utilizes the BorshInstructionCoder to interpret the encoded instruction data.
 *
 * @param idl - The Interface Definition Language object that defines the structure of the instruction.
 * @param encoded - The Buffer containing the encoded instruction data.
 * @returns The decoded instruction object.
 */
export declare function decodeInstruction(idl: Idl, encoded: Buffer): Instruction | null;
/**
 * Decompiles a VersionedTransaction into a TransactionMessage.
 *
 * @param tx - The VersionedTransaction to be decompiled.
 * @param lookupTableAccounts - An array of AddressLookupTableAccount used for decompiling the transaction message.
 * @returns A TransactionMessage object representing the decompiled transaction.
 */
export declare function decompileV0Transaction(tx: VersionedTransaction, lookupTableAccounts: AddressLookupTableAccount[]): TransactionMessage;
/**
 * Options for updating a transaction.
 * - `feePayer`: Optional public key of the fee payer. Defaults to the transaction's fee payer.
 * - `blockhash`: Optional blockhash for the transaction. Defaults to the transaction's recent blockhash.
 * - `addressLookupTables`: Optional array of address lookup table accounts for the transaction.
 * - `additionalIxs`: Optional array of additional transaction instructions to include.
 */
type UpdateTxOptions = {
    feePayer?: PublicKey;
    blockhash?: string;
    addressLookupTables?: AddressLookupTableAccount[];
    additionalIxs?: TransactionInstruction[];
    replaceOnly?: boolean;
    indexOffset?: number;
};
/**
 * Converts a legacy Solana transaction to a versioned transaction. *
 * @param transaction - The legacy transaction to be converted.
 * @param opts - Optional parameters for the conversion process.
 * @returns A VersionedTransaction object representing the converted transaction.
 * @throws Will throw an error if the fee payer or blockhash is not provided.
 */
export declare function legacyTxToV0Tx(transaction: Transaction, opts?: UpdateTxOptions): VersionedTransaction;
/**
 * Updates a VersionedTransaction with new options.
 *
 * This function allows you to modify a given VersionedTransaction by providing
 * additional transaction instructions, address lookup tables, a new fee payer,
 * and a new blockhash. It decompiles the existing transaction, applies the updates,
 * and recompiles it into a new VersionedTransaction.
 *
 * @param transaction - The VersionedTransaction to be updated.
 * @param opts - Optional parameters for updating the transaction.
 * @returns A new VersionedTransaction object with the applied updates.
 * @throws Will throw an error if the fee payer or blockhash is not provided.
 */
export declare function updateV0Tx(transaction: VersionedTransaction, opts?: UpdateTxOptions): VersionedTransaction;
/**
 * Checks if two transaction instructions are identical by comparing their data, program IDs, and account keys.
 *
 * @param ix1 - First transaction instruction to compare
 * @param ix2 - Second transaction instruction to compare
 * @returns True if instructions are identical, false otherwise
 */
export declare function compareInstructions(ix1: TransactionInstruction, ix2: TransactionInstruction): boolean;
export declare function replaceV0TxInstructions(additionalInstructions: TransactionInstruction[], instructions: TransactionInstruction[], replaceOnly?: boolean, indexOffset?: number): TransactionInstruction[];
export declare function replaceV0TxBlockhash(transaction: VersionedTransaction, blockhash: string): VersionedTransaction;
/**
 * Enhances a given transaction with additional metadata.
 *
 * @param transaction - The transaction to be enhanced, can be either VersionedTransaction or Transaction.
 * @param options - An object containing optional metadata:
 *   - signers: An array of Signer objects that are associated with the transaction.
 *   - addressLookupTables: An array of AddressLookupTableAccount objects for address resolution.
 *   - unitsConsumed: A number representing the compute units consumed by the transaction.
 *   - type: The type of the transaction, as defined by TransactionType.
 * @returns A SolanaTransaction object that includes the original transaction and the additional metadata.
 */
export declare function addTransactionMetadata<T extends Transaction | VersionedTransaction>(transaction: T, options: ExtendedTransactionProperties): T & ExtendedTransactionProperties;
/**
 * Decodes a ComputeBudget program instruction into a readable format.
 *
 * @param instruction - The ComputeBudget program instruction to decode
 * @returns An object containing the decoded instruction data with fields depending on the instruction type:
 *   - RequestUnits: { instructionType: string, units: number, additionalFee: number }
 *   - RequestHeapFrame: { instructionType: string, bytes: number }
 *   - SetComputeUnitLimit: { instructionType: string, units: number }
 *   - SetComputeUnitPrice: { instructionType: string, microLamports: string }
 *   - SetLoadedAccountsDataSizeLimit: { instructionType: string, accountDataSizeLimit: number }
 * @throws Error if the instruction data is invalid or the instruction type is unknown
 */
export declare function decodeComputeBudgetInstruction(instruction: TransactionInstruction): {
    instructionType: "RequestUnits";
    units: number;
    additionalFee: number;
    bytes?: undefined;
    microLamports?: undefined;
    accountDataSizeLimit?: undefined;
} | {
    instructionType: "RequestHeapFrame";
    bytes: number;
    units?: undefined;
    additionalFee?: undefined;
    microLamports?: undefined;
    accountDataSizeLimit?: undefined;
} | {
    instructionType: "SetComputeUnitLimit";
    units: number;
    additionalFee?: undefined;
    bytes?: undefined;
    microLamports?: undefined;
    accountDataSizeLimit?: undefined;
} | {
    instructionType: "SetComputeUnitPrice";
    microLamports: string;
    units?: undefined;
    additionalFee?: undefined;
    bytes?: undefined;
    accountDataSizeLimit?: undefined;
} | {
    instructionType: "SetLoadedAccountsDataSizeLimit";
    accountDataSizeLimit: number;
    units?: undefined;
    additionalFee?: undefined;
    bytes?: undefined;
    microLamports?: undefined;
};
export declare function getComputeBudgetUnits(tx: SolanaTransaction): number | undefined;
/**
 * Converts a priority fee from UI units (SOL) to micro-lamports per compute unit
 * @param ui - Priority fee amount in SOL
 * @param limitCU - Compute unit limit, defaults to 1.4M CU
 * @returns Priority fee in micro-lamports per compute unit
 */
export declare const uiToMicroLamports: (ui: number, limitCU?: number) => number;
/**
 * Converts a priority fee from micro-lamports per compute unit to UI units (SOL)
 * @param microLamports - Priority fee in micro-lamports per compute unit
 * @param limitCU - Compute unit limit, defaults to 1.4M CU
 * @returns Priority fee amount in SOL, truncated to 9 decimal places
 */
export declare const microLamportsToUi: (microLamports: number, limitCU?: number) => number;
/**
 * Splits your instructions into as many VersionedTransactions as needed
 * so that none exceed MAX_TX_SIZE.
 */
export declare function splitInstructionsToFitTransactions(mandatoryIxs: TransactionInstruction[], ixs: TransactionInstruction[], opts: {
    blockhash: string;
    payerKey: PublicKey;
    luts: AddressLookupTableAccount[];
}): VersionedTransaction[];
export {};
//# sourceMappingURL=transaction.utils.d.ts.map
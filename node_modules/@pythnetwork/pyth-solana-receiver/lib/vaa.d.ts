/// <reference types="node" />
import { Connection, Keypair, PublicKey } from "@solana/web3.js";
import { WormholeCoreBridgeSolana } from "./idl/wormhole_core_bridge_solana";
import { Program } from "@coral-xyz/anchor";
import { InstructionWithEphemeralSigners } from "@pythnetwork/solana-utils";
/**
 * Get the index of the guardian set that signed a VAA
 */
export declare function getGuardianSetIndex(vaa: Buffer): number;
/**
 * The default number of signatures to keep in a VAA when using `trimSignatures`.
 * This number was chosen as the maximum number of signatures so that the VAA's contents can be posted in a single Solana transaction.
 */
export declare const DEFAULT_REDUCED_GUARDIAN_SET_SIZE = 5;
/**
 * The size of a guardian signature in a VAA.
 *
 * It is 66 bytes long, the first byte is the guardian index and the next 65 bytes are the signature (including a recovery id).
 */
export declare const VAA_SIGNATURE_SIZE = 66;
/**
 * Trim the number of signatures of a VAA.
 *
 * @returns the same VAA as the input, but with `n` signatures instead of the original number of signatures.
 *
 * A Wormhole VAA typically has a number of signatures equal to two thirds of the number of guardians. However,
 * this function is useful to make VAAs smaller to post their contents in a single Solana transaction.
 */
export declare function trimSignatures(vaa: Buffer, n?: number): Buffer;
/**
 * The start of the VAA bytes in an encoded VAA account. Before this offset, the account contains a header.
 */
export declare const VAA_START = 46;
/**
 * Build an instruction to create an encoded VAA account.
 *
 * This is the first step to post a VAA to the Wormhole program.
 */
export declare function buildEncodedVaaCreateInstruction(wormhole: Program<WormholeCoreBridgeSolana>, vaa: Buffer, encodedVaaKeypair: Keypair): Promise<InstructionWithEphemeralSigners>;
/**
 * Writing the VAA to an encoded VAA account is done in 2 instructions.
 *
 * The first one writes the first `VAA_SPLIT_INDEX` bytes and the second one writes the rest.
 *
 * This number was chosen as the biggest number such that one can still call `createInstruction`, `initEncodedVaa` and `writeEncodedVaa` in a single Solana transaction.
 * This way, the packing of the instructions to post an encoded vaa is more efficient.
 */
export declare const VAA_SPLIT_INDEX = 755;
/**
 * Build a set of instructions to write a VAA to an encoded VAA account
 * This functions returns 2 instructions and splits the VAA in an opinionated way, so that the whole process of posting a VAA can be efficiently packed in the 2 transactions:
 *
 * TX 1 : `createInstruction` + `initEncodedVaa` + `writeEncodedVaa_1`
 *
 * TX 2 : `writeEncodedVaa_2` + `verifyEncodedVaaV1`
 */
export declare function buildWriteEncodedVaaWithSplitInstructions(wormhole: Program<WormholeCoreBridgeSolana>, vaa: Buffer, draftVaa: PublicKey): Promise<InstructionWithEphemeralSigners[]>;
/**
 * Find all the encoded VAA accounts that have a given write authority
 * @returns a list of the public keys of the encoded VAA accounts
 */
export declare function findEncodedVaaAccountsByWriteAuthority(connection: Connection, writeAuthority: PublicKey, wormholeProgramId: PublicKey): Promise<PublicKey[]>;
//# sourceMappingURL=vaa.d.ts.map
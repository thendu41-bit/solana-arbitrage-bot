"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findEncodedVaaAccountsByWriteAuthority = exports.buildWriteEncodedVaaWithSplitInstructions = exports.VAA_SPLIT_INDEX = exports.buildEncodedVaaCreateInstruction = exports.VAA_START = exports.trimSignatures = exports.VAA_SIGNATURE_SIZE = exports.DEFAULT_REDUCED_GUARDIAN_SET_SIZE = exports.getGuardianSetIndex = void 0;
const web3_js_1 = require("@solana/web3.js");
const compute_budget_1 = require("./compute_budget");
const sha256_1 = require("@noble/hashes/sha256");
const bytes_1 = require("@coral-xyz/anchor/dist/cjs/utils/bytes");
/**
 * Get the index of the guardian set that signed a VAA
 */
function getGuardianSetIndex(vaa) {
    return vaa.readUInt32BE(1);
}
exports.getGuardianSetIndex = getGuardianSetIndex;
/**
 * The default number of signatures to keep in a VAA when using `trimSignatures`.
 * This number was chosen as the maximum number of signatures so that the VAA's contents can be posted in a single Solana transaction.
 */
exports.DEFAULT_REDUCED_GUARDIAN_SET_SIZE = 5;
/**
 * The size of a guardian signature in a VAA.
 *
 * It is 66 bytes long, the first byte is the guardian index and the next 65 bytes are the signature (including a recovery id).
 */
exports.VAA_SIGNATURE_SIZE = 66;
/**
 * Trim the number of signatures of a VAA.
 *
 * @returns the same VAA as the input, but with `n` signatures instead of the original number of signatures.
 *
 * A Wormhole VAA typically has a number of signatures equal to two thirds of the number of guardians. However,
 * this function is useful to make VAAs smaller to post their contents in a single Solana transaction.
 */
function trimSignatures(vaa, n = exports.DEFAULT_REDUCED_GUARDIAN_SET_SIZE) {
    const currentNumSignatures = vaa[5];
    if (n > currentNumSignatures) {
        throw new Error("Resulting VAA can't have more signatures than the original VAA");
    }
    const trimmedVaa = Buffer.concat([
        vaa.subarray(0, 6 + n * exports.VAA_SIGNATURE_SIZE),
        vaa.subarray(6 + currentNumSignatures * exports.VAA_SIGNATURE_SIZE),
    ]);
    trimmedVaa[5] = n;
    return trimmedVaa;
}
exports.trimSignatures = trimSignatures;
/**
 * The start of the VAA bytes in an encoded VAA account. Before this offset, the account contains a header.
 */
exports.VAA_START = 46;
/**
 * Build an instruction to create an encoded VAA account.
 *
 * This is the first step to post a VAA to the Wormhole program.
 */
async function buildEncodedVaaCreateInstruction(wormhole, vaa, encodedVaaKeypair) {
    const encodedVaaSize = vaa.length + exports.VAA_START;
    return {
        instruction: await wormhole.account.encodedVaa.createInstruction(encodedVaaKeypair, encodedVaaSize),
        signers: [encodedVaaKeypair],
    };
}
exports.buildEncodedVaaCreateInstruction = buildEncodedVaaCreateInstruction;
/**
 * Writing the VAA to an encoded VAA account is done in 2 instructions.
 *
 * The first one writes the first `VAA_SPLIT_INDEX` bytes and the second one writes the rest.
 *
 * This number was chosen as the biggest number such that one can still call `createInstruction`, `initEncodedVaa` and `writeEncodedVaa` in a single Solana transaction.
 * This way, the packing of the instructions to post an encoded vaa is more efficient.
 */
exports.VAA_SPLIT_INDEX = 755;
/**
 * Build a set of instructions to write a VAA to an encoded VAA account
 * This functions returns 2 instructions and splits the VAA in an opinionated way, so that the whole process of posting a VAA can be efficiently packed in the 2 transactions:
 *
 * TX 1 : `createInstruction` + `initEncodedVaa` + `writeEncodedVaa_1`
 *
 * TX 2 : `writeEncodedVaa_2` + `verifyEncodedVaaV1`
 */
async function buildWriteEncodedVaaWithSplitInstructions(wormhole, vaa, draftVaa) {
    return [
        {
            instruction: await wormhole.methods
                .writeEncodedVaa({
                index: 0,
                data: vaa.subarray(0, exports.VAA_SPLIT_INDEX),
            })
                .accounts({
                draftVaa,
            })
                .instruction(),
            signers: [],
            computeUnits: compute_budget_1.WRITE_ENCODED_VAA_COMPUTE_BUDGET,
        },
        {
            instruction: await wormhole.methods
                .writeEncodedVaa({
                index: exports.VAA_SPLIT_INDEX,
                data: vaa.subarray(exports.VAA_SPLIT_INDEX),
            })
                .accounts({
                draftVaa,
            })
                .instruction(),
            signers: [],
            computeUnits: compute_budget_1.WRITE_ENCODED_VAA_COMPUTE_BUDGET,
        },
    ];
}
exports.buildWriteEncodedVaaWithSplitInstructions = buildWriteEncodedVaaWithSplitInstructions;
/**
 * Find all the encoded VAA accounts that have a given write authority
 * @returns a list of the public keys of the encoded VAA accounts
 */
async function findEncodedVaaAccountsByWriteAuthority(connection, writeAuthority, wormholeProgramId) {
    const result = await connection.getProgramAccounts(wormholeProgramId, {
        filters: [
            {
                memcmp: {
                    offset: 0,
                    bytes: bytes_1.bs58.encode(Buffer.from((0, sha256_1.sha256)("account:EncodedVaa").slice(0, 8))),
                },
            },
            {
                memcmp: {
                    offset: 8 + 1,
                    bytes: bytes_1.bs58.encode(writeAuthority.toBuffer()),
                },
            },
        ],
    });
    return result.map((account) => new web3_js_1.PublicKey(account.pubkey));
}
exports.findEncodedVaaAccountsByWriteAuthority = findEncodedVaaAccountsByWriteAuthority;

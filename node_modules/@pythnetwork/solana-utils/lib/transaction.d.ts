import { Wallet } from "@coral-xyz/anchor";
import { AddressLookupTableAccount, Connection, PublicKey, Signer, Transaction, TransactionInstruction, VersionedTransaction } from "@solana/web3.js";
/**
 * If the transaction doesn't contain a `setComputeUnitLimit` instruction, the default compute budget is 200,000 units per instruction.
 */
export declare const DEFAULT_COMPUTE_BUDGET_UNITS = 200000;
/**
 * The maximum size of a Solana transaction, leaving some room for the compute budget instructions.
 */
export declare const PACKET_DATA_SIZE_WITH_ROOM_FOR_COMPUTE_BUDGET: number;
/**
 * An instruction with some extra information that will be used to build transactions.
 */
export type InstructionWithEphemeralSigners = {
    /** The instruction */
    instruction: TransactionInstruction;
    /** The ephemeral signers that need to sign the transaction where this instruction will be */
    signers: Signer[];
    /** The compute units that this instruction requires, useful if greater than `DEFAULT_COMPUTE_BUDGET_UNITS`  */
    computeUnits?: number;
};
/**
 * The priority fee configuration for transactions
 */
export type PriorityFeeConfig = {
    /** This is the priority fee in micro lamports, it gets passed down to `setComputeUnitPrice`  */
    computeUnitPriceMicroLamports?: number;
    tightComputeBudget?: boolean;
    jitoTipLamports?: number;
    jitoBundleSize?: number;
};
/**
 * A default priority fee configuration. Using a priority fee is helpful even when you're not writing to hot accounts.
 */
export declare const DEFAULT_PRIORITY_FEE_CONFIG: PriorityFeeConfig;
/**
 * Get the size of a transaction that would contain the provided array of instructions
 * This is based on {@link https://solana.com/docs/core/transactions}.
 *
 * Each transaction has the following layout :
 *
 * - A compact array of all signatures
 * - A 3-bytes message header
 * - A compact array with all the account addresses
 * - A recent blockhash
 * - A compact array of instructions
 *
 * If the transaction is a `VersionedTransaction`, it also contains an extra byte at the beginning, indicating the version and an array of `MessageAddressTableLookup` at the end.
 * After this field there is an array of indexes into the address lookup table that represents the accounts from the address lookup table used in the transaction.
 *
 * Each instruction has the following layout :
 * - One byte indicating the index of the program in the account addresses array
 * - A compact array of indices into the account addresses array, indicating which accounts are used by the instruction
 * - A compact array of serialized instruction data
 */
export declare function getSizeOfTransaction(instructions: TransactionInstruction[], versionedTransaction?: boolean, addressLookupTable?: AddressLookupTableAccount): number;
/**
 * Get the size of n in bytes when serialized as a CompressedU16. Compact arrays use a CompactU16 to store the length of the array.
 */
export declare function getSizeOfCompressedU16(n: number): number;
/**
 * This class is helpful for batching instructions into transactions in an efficient way.
 * As you add instructions, it adds them to the current transaction until it's full, then it starts a new transaction.
 */
export declare class TransactionBuilder {
    readonly transactionInstructions: {
        instructions: TransactionInstruction[];
        signers: Signer[];
        computeUnits: number;
    }[];
    readonly payer: PublicKey;
    readonly connection: Connection;
    readonly addressLookupTable: AddressLookupTableAccount | undefined;
    /** Make a new `TransactionBuilder`. It requires a `payer` to populate the `payerKey` field and a connection to populate `recentBlockhash` in the versioned transactions. */
    constructor(payer: PublicKey, connection: Connection, addressLookupTable?: AddressLookupTableAccount);
    /**
     * Add an `InstructionWithEphemeralSigners` to the builder.
     */
    addInstruction(args: InstructionWithEphemeralSigners): void;
    /**
     * Add multiple `InstructionWithEphemeralSigners` to the builder.
     */
    addInstructions(instructions: InstructionWithEphemeralSigners[]): void;
    /**
     * Returns all the added instructions batched into versioned transactions, plus for each transaction the ephemeral signers that need to sign it
     */
    buildVersionedTransactions(args: PriorityFeeConfig): Promise<{
        tx: VersionedTransaction;
        signers: Signer[];
    }[]>;
    /**
     * Returns all the added instructions batched into transactions, plus for each transaction the ephemeral signers that need to sign it
     */
    buildLegacyTransactions(args: PriorityFeeConfig): {
        tx: Transaction;
        signers: Signer[];
    }[];
    /**
     * Returns a set of transactions that contain the provided instructions in the same order and with efficient batching
     */
    static batchIntoLegacyTransactions(instructions: TransactionInstruction[], priorityFeeConfig: PriorityFeeConfig): Transaction[];
    /**
     * Returns a set of versioned transactions that contain the provided instructions in the same order and with efficient batching
     */
    static batchIntoVersionedTransactions(payer: PublicKey, connection: Connection, instructions: InstructionWithEphemeralSigners[], priorityFeeConfig: PriorityFeeConfig, addressLookupTable?: AddressLookupTableAccount): Promise<{
        tx: VersionedTransaction;
        signers: Signer[];
    }[]>;
    /**
     * Add a priority fee to a legacy transaction
     */
    static addPriorityFee(transaction: Transaction, priorityFeeConfig: PriorityFeeConfig): void;
}
export declare const isVersionedTransaction: (tx: Transaction | VersionedTransaction) => tx is VersionedTransaction;
/**
 * Send a set of transactions to the network based on https://github.com/rpcpool/optimized-txs-examples
 */
export declare function sendTransactions(transactions: {
    tx: VersionedTransaction | Transaction;
    signers?: Signer[] | undefined;
}[], connection: Connection, wallet: Wallet, maxRetries?: number): Promise<string[]>;
//# sourceMappingURL=transaction.d.ts.map